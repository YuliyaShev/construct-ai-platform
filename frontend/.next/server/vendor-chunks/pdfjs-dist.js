"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pdfjs-dist";
exports.ids = ["vendor-chunks/pdfjs-dist"];
exports.modules = {

/***/ "(ssr)/./node_modules/pdfjs-dist/build/pdf.mjs":
/*!***********************************************!*\
  !*** ./node_modules/pdfjs-dist/build/pdf.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortException: () => (/* binding */ __webpack_exports__AbortException),\n/* harmony export */   AnnotationEditorLayer: () => (/* binding */ __webpack_exports__AnnotationEditorLayer),\n/* harmony export */   AnnotationEditorParamsType: () => (/* binding */ __webpack_exports__AnnotationEditorParamsType),\n/* harmony export */   AnnotationEditorType: () => (/* binding */ __webpack_exports__AnnotationEditorType),\n/* harmony export */   AnnotationEditorUIManager: () => (/* binding */ __webpack_exports__AnnotationEditorUIManager),\n/* harmony export */   AnnotationLayer: () => (/* binding */ __webpack_exports__AnnotationLayer),\n/* harmony export */   AnnotationMode: () => (/* binding */ __webpack_exports__AnnotationMode),\n/* harmony export */   ColorPicker: () => (/* binding */ __webpack_exports__ColorPicker),\n/* harmony export */   DOMSVGFactory: () => (/* binding */ __webpack_exports__DOMSVGFactory),\n/* harmony export */   DrawLayer: () => (/* binding */ __webpack_exports__DrawLayer),\n/* harmony export */   FeatureTest: () => (/* binding */ __webpack_exports__FeatureTest),\n/* harmony export */   GlobalWorkerOptions: () => (/* binding */ __webpack_exports__GlobalWorkerOptions),\n/* harmony export */   ImageKind: () => (/* binding */ __webpack_exports__ImageKind),\n/* harmony export */   InvalidPDFException: () => (/* binding */ __webpack_exports__InvalidPDFException),\n/* harmony export */   MissingPDFException: () => (/* binding */ __webpack_exports__MissingPDFException),\n/* harmony export */   OPS: () => (/* binding */ __webpack_exports__OPS),\n/* harmony export */   OutputScale: () => (/* binding */ __webpack_exports__OutputScale),\n/* harmony export */   PDFDataRangeTransport: () => (/* binding */ __webpack_exports__PDFDataRangeTransport),\n/* harmony export */   PDFDateString: () => (/* binding */ __webpack_exports__PDFDateString),\n/* harmony export */   PDFWorker: () => (/* binding */ __webpack_exports__PDFWorker),\n/* harmony export */   PasswordResponses: () => (/* binding */ __webpack_exports__PasswordResponses),\n/* harmony export */   PermissionFlag: () => (/* binding */ __webpack_exports__PermissionFlag),\n/* harmony export */   PixelsPerInch: () => (/* binding */ __webpack_exports__PixelsPerInch),\n/* harmony export */   RenderingCancelledException: () => (/* binding */ __webpack_exports__RenderingCancelledException),\n/* harmony export */   TextLayer: () => (/* binding */ __webpack_exports__TextLayer),\n/* harmony export */   TouchManager: () => (/* binding */ __webpack_exports__TouchManager),\n/* harmony export */   UnexpectedResponseException: () => (/* binding */ __webpack_exports__UnexpectedResponseException),\n/* harmony export */   Util: () => (/* binding */ __webpack_exports__Util),\n/* harmony export */   VerbosityLevel: () => (/* binding */ __webpack_exports__VerbosityLevel),\n/* harmony export */   XfaLayer: () => (/* binding */ __webpack_exports__XfaLayer),\n/* harmony export */   build: () => (/* binding */ __webpack_exports__build),\n/* harmony export */   createValidAbsoluteUrl: () => (/* binding */ __webpack_exports__createValidAbsoluteUrl),\n/* harmony export */   fetchData: () => (/* binding */ __webpack_exports__fetchData),\n/* harmony export */   getDocument: () => (/* binding */ __webpack_exports__getDocument),\n/* harmony export */   getFilenameFromUrl: () => (/* binding */ __webpack_exports__getFilenameFromUrl),\n/* harmony export */   getPdfFilenameFromUrl: () => (/* binding */ __webpack_exports__getPdfFilenameFromUrl),\n/* harmony export */   getXfaPageViewport: () => (/* binding */ __webpack_exports__getXfaPageViewport),\n/* harmony export */   isDataScheme: () => (/* binding */ __webpack_exports__isDataScheme),\n/* harmony export */   isPdfFile: () => (/* binding */ __webpack_exports__isPdfFile),\n/* harmony export */   noContextMenu: () => (/* binding */ __webpack_exports__noContextMenu),\n/* harmony export */   normalizeUnicode: () => (/* binding */ __webpack_exports__normalizeUnicode),\n/* harmony export */   setLayerDimensions: () => (/* binding */ __webpack_exports__setLayerDimensions),\n/* harmony export */   shadow: () => (/* binding */ __webpack_exports__shadow),\n/* harmony export */   stopEvent: () => (/* binding */ __webpack_exports__stopEvent),\n/* harmony export */   version: () => (/* binding */ __webpack_exports__version)\n/* harmony export */ });\n/**\n * @licstart The following is the entire license notice for the\n * JavaScript code in this page\n *\n * Copyright 2024 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * JavaScript code in this page\n */ /******/ // The require scope\n/******/ var __nested_webpack_require_838__ = {};\n/******/ /************************************************************************/ /******/ /* webpack/runtime/define property getters */ /******/ (()=>{\n    /******/ // define getter functions for harmony exports\n    /******/ __nested_webpack_require_838__.d = (exports, definition)=>{\n        /******/ for(var key in definition){\n            /******/ if (__nested_webpack_require_838__.o(definition, key) && !__nested_webpack_require_838__.o(exports, key)) {\n                /******/ Object.defineProperty(exports, key, {\n                    enumerable: true,\n                    get: definition[key]\n                });\n            /******/ }\n        /******/ }\n    /******/ };\n/******/ })();\n/******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (()=>{\n    /******/ __nested_webpack_require_838__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);\n/******/ })();\n/******/ /************************************************************************/ var __nested_webpack_exports__ = globalThis.pdfjsLib = {};\n// EXPORTS\n__nested_webpack_require_838__.d(__nested_webpack_exports__, {\n    AbortException: ()=>/* reexport */ AbortException,\n    AnnotationEditorLayer: ()=>/* reexport */ AnnotationEditorLayer,\n    AnnotationEditorParamsType: ()=>/* reexport */ AnnotationEditorParamsType,\n    AnnotationEditorType: ()=>/* reexport */ AnnotationEditorType,\n    AnnotationEditorUIManager: ()=>/* reexport */ AnnotationEditorUIManager,\n    AnnotationLayer: ()=>/* reexport */ AnnotationLayer,\n    AnnotationMode: ()=>/* reexport */ AnnotationMode,\n    ColorPicker: ()=>/* reexport */ ColorPicker,\n    DOMSVGFactory: ()=>/* reexport */ DOMSVGFactory,\n    DrawLayer: ()=>/* reexport */ DrawLayer,\n    FeatureTest: ()=>/* reexport */ util_FeatureTest,\n    GlobalWorkerOptions: ()=>/* reexport */ GlobalWorkerOptions,\n    ImageKind: ()=>/* reexport */ util_ImageKind,\n    InvalidPDFException: ()=>/* reexport */ InvalidPDFException,\n    MissingPDFException: ()=>/* reexport */ MissingPDFException,\n    OPS: ()=>/* reexport */ OPS,\n    OutputScale: ()=>/* reexport */ OutputScale,\n    PDFDataRangeTransport: ()=>/* reexport */ PDFDataRangeTransport,\n    PDFDateString: ()=>/* reexport */ PDFDateString,\n    PDFWorker: ()=>/* reexport */ PDFWorker,\n    PasswordResponses: ()=>/* reexport */ PasswordResponses,\n    PermissionFlag: ()=>/* reexport */ PermissionFlag,\n    PixelsPerInch: ()=>/* reexport */ PixelsPerInch,\n    RenderingCancelledException: ()=>/* reexport */ RenderingCancelledException,\n    TextLayer: ()=>/* reexport */ TextLayer,\n    TouchManager: ()=>/* reexport */ TouchManager,\n    UnexpectedResponseException: ()=>/* reexport */ UnexpectedResponseException,\n    Util: ()=>/* reexport */ Util,\n    VerbosityLevel: ()=>/* reexport */ VerbosityLevel,\n    XfaLayer: ()=>/* reexport */ XfaLayer,\n    build: ()=>/* reexport */ build,\n    createValidAbsoluteUrl: ()=>/* reexport */ createValidAbsoluteUrl,\n    fetchData: ()=>/* reexport */ fetchData,\n    getDocument: ()=>/* reexport */ getDocument,\n    getFilenameFromUrl: ()=>/* reexport */ getFilenameFromUrl,\n    getPdfFilenameFromUrl: ()=>/* reexport */ getPdfFilenameFromUrl,\n    getXfaPageViewport: ()=>/* reexport */ getXfaPageViewport,\n    isDataScheme: ()=>/* reexport */ isDataScheme,\n    isPdfFile: ()=>/* reexport */ isPdfFile,\n    noContextMenu: ()=>/* reexport */ noContextMenu,\n    normalizeUnicode: ()=>/* reexport */ normalizeUnicode,\n    setLayerDimensions: ()=>/* reexport */ setLayerDimensions,\n    shadow: ()=>/* reexport */ shadow,\n    stopEvent: ()=>/* reexport */ stopEvent,\n    version: ()=>/* reexport */ version\n});\n; // ./src/shared/util.js\nconst isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\nconst IDENTITY_MATRIX = [\n    1,\n    0,\n    0,\n    1,\n    0,\n    0\n];\nconst FONT_IDENTITY_MATRIX = [\n    0.001,\n    0,\n    0,\n    0.001,\n    0,\n    0\n];\nconst MAX_IMAGE_SIZE_TO_CACHE = 10e6;\nconst LINE_FACTOR = 1.35;\nconst LINE_DESCENT_FACTOR = 0.35;\nconst BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;\nconst RenderingIntentFlag = {\n    ANY: 0x01,\n    DISPLAY: 0x02,\n    PRINT: 0x04,\n    SAVE: 0x08,\n    ANNOTATIONS_FORMS: 0x10,\n    ANNOTATIONS_STORAGE: 0x20,\n    ANNOTATIONS_DISABLE: 0x40,\n    IS_EDITING: 0x80,\n    OPLIST: 0x100\n};\nconst AnnotationMode = {\n    DISABLE: 0,\n    ENABLE: 1,\n    ENABLE_FORMS: 2,\n    ENABLE_STORAGE: 3\n};\nconst AnnotationEditorPrefix = \"pdfjs_internal_editor_\";\nconst AnnotationEditorType = {\n    DISABLE: -1,\n    NONE: 0,\n    FREETEXT: 3,\n    HIGHLIGHT: 9,\n    STAMP: 13,\n    INK: 15\n};\nconst AnnotationEditorParamsType = {\n    RESIZE: 1,\n    CREATE: 2,\n    FREETEXT_SIZE: 11,\n    FREETEXT_COLOR: 12,\n    FREETEXT_OPACITY: 13,\n    INK_COLOR: 21,\n    INK_THICKNESS: 22,\n    INK_OPACITY: 23,\n    HIGHLIGHT_COLOR: 31,\n    HIGHLIGHT_DEFAULT_COLOR: 32,\n    HIGHLIGHT_THICKNESS: 33,\n    HIGHLIGHT_FREE: 34,\n    HIGHLIGHT_SHOW_ALL: 35,\n    DRAW_STEP: 41\n};\nconst PermissionFlag = {\n    PRINT: 0x04,\n    MODIFY_CONTENTS: 0x08,\n    COPY: 0x10,\n    MODIFY_ANNOTATIONS: 0x20,\n    FILL_INTERACTIVE_FORMS: 0x100,\n    COPY_FOR_ACCESSIBILITY: 0x200,\n    ASSEMBLE: 0x400,\n    PRINT_HIGH_QUALITY: 0x800\n};\nconst TextRenderingMode = {\n    FILL: 0,\n    STROKE: 1,\n    FILL_STROKE: 2,\n    INVISIBLE: 3,\n    FILL_ADD_TO_PATH: 4,\n    STROKE_ADD_TO_PATH: 5,\n    FILL_STROKE_ADD_TO_PATH: 6,\n    ADD_TO_PATH: 7,\n    FILL_STROKE_MASK: 3,\n    ADD_TO_PATH_FLAG: 4\n};\nconst util_ImageKind = {\n    GRAYSCALE_1BPP: 1,\n    RGB_24BPP: 2,\n    RGBA_32BPP: 3\n};\nconst AnnotationType = {\n    TEXT: 1,\n    LINK: 2,\n    FREETEXT: 3,\n    LINE: 4,\n    SQUARE: 5,\n    CIRCLE: 6,\n    POLYGON: 7,\n    POLYLINE: 8,\n    HIGHLIGHT: 9,\n    UNDERLINE: 10,\n    SQUIGGLY: 11,\n    STRIKEOUT: 12,\n    STAMP: 13,\n    CARET: 14,\n    INK: 15,\n    POPUP: 16,\n    FILEATTACHMENT: 17,\n    SOUND: 18,\n    MOVIE: 19,\n    WIDGET: 20,\n    SCREEN: 21,\n    PRINTERMARK: 22,\n    TRAPNET: 23,\n    WATERMARK: 24,\n    THREED: 25,\n    REDACT: 26\n};\nconst AnnotationReplyType = {\n    GROUP: \"Group\",\n    REPLY: \"R\"\n};\nconst AnnotationFlag = {\n    INVISIBLE: 0x01,\n    HIDDEN: 0x02,\n    PRINT: 0x04,\n    NOZOOM: 0x08,\n    NOROTATE: 0x10,\n    NOVIEW: 0x20,\n    READONLY: 0x40,\n    LOCKED: 0x80,\n    TOGGLENOVIEW: 0x100,\n    LOCKEDCONTENTS: 0x200\n};\nconst AnnotationFieldFlag = {\n    READONLY: 0x0000001,\n    REQUIRED: 0x0000002,\n    NOEXPORT: 0x0000004,\n    MULTILINE: 0x0001000,\n    PASSWORD: 0x0002000,\n    NOTOGGLETOOFF: 0x0004000,\n    RADIO: 0x0008000,\n    PUSHBUTTON: 0x0010000,\n    COMBO: 0x0020000,\n    EDIT: 0x0040000,\n    SORT: 0x0080000,\n    FILESELECT: 0x0100000,\n    MULTISELECT: 0x0200000,\n    DONOTSPELLCHECK: 0x0400000,\n    DONOTSCROLL: 0x0800000,\n    COMB: 0x1000000,\n    RICHTEXT: 0x2000000,\n    RADIOSINUNISON: 0x2000000,\n    COMMITONSELCHANGE: 0x4000000\n};\nconst AnnotationBorderStyleType = {\n    SOLID: 1,\n    DASHED: 2,\n    BEVELED: 3,\n    INSET: 4,\n    UNDERLINE: 5\n};\nconst AnnotationActionEventType = {\n    E: \"Mouse Enter\",\n    X: \"Mouse Exit\",\n    D: \"Mouse Down\",\n    U: \"Mouse Up\",\n    Fo: \"Focus\",\n    Bl: \"Blur\",\n    PO: \"PageOpen\",\n    PC: \"PageClose\",\n    PV: \"PageVisible\",\n    PI: \"PageInvisible\",\n    K: \"Keystroke\",\n    F: \"Format\",\n    V: \"Validate\",\n    C: \"Calculate\"\n};\nconst DocumentActionEventType = {\n    WC: \"WillClose\",\n    WS: \"WillSave\",\n    DS: \"DidSave\",\n    WP: \"WillPrint\",\n    DP: \"DidPrint\"\n};\nconst PageActionEventType = {\n    O: \"PageOpen\",\n    C: \"PageClose\"\n};\nconst VerbosityLevel = {\n    ERRORS: 0,\n    WARNINGS: 1,\n    INFOS: 5\n};\nconst OPS = {\n    dependency: 1,\n    setLineWidth: 2,\n    setLineCap: 3,\n    setLineJoin: 4,\n    setMiterLimit: 5,\n    setDash: 6,\n    setRenderingIntent: 7,\n    setFlatness: 8,\n    setGState: 9,\n    save: 10,\n    restore: 11,\n    transform: 12,\n    moveTo: 13,\n    lineTo: 14,\n    curveTo: 15,\n    curveTo2: 16,\n    curveTo3: 17,\n    closePath: 18,\n    rectangle: 19,\n    stroke: 20,\n    closeStroke: 21,\n    fill: 22,\n    eoFill: 23,\n    fillStroke: 24,\n    eoFillStroke: 25,\n    closeFillStroke: 26,\n    closeEOFillStroke: 27,\n    endPath: 28,\n    clip: 29,\n    eoClip: 30,\n    beginText: 31,\n    endText: 32,\n    setCharSpacing: 33,\n    setWordSpacing: 34,\n    setHScale: 35,\n    setLeading: 36,\n    setFont: 37,\n    setTextRenderingMode: 38,\n    setTextRise: 39,\n    moveText: 40,\n    setLeadingMoveText: 41,\n    setTextMatrix: 42,\n    nextLine: 43,\n    showText: 44,\n    showSpacedText: 45,\n    nextLineShowText: 46,\n    nextLineSetSpacingShowText: 47,\n    setCharWidth: 48,\n    setCharWidthAndBounds: 49,\n    setStrokeColorSpace: 50,\n    setFillColorSpace: 51,\n    setStrokeColor: 52,\n    setStrokeColorN: 53,\n    setFillColor: 54,\n    setFillColorN: 55,\n    setStrokeGray: 56,\n    setFillGray: 57,\n    setStrokeRGBColor: 58,\n    setFillRGBColor: 59,\n    setStrokeCMYKColor: 60,\n    setFillCMYKColor: 61,\n    shadingFill: 62,\n    beginInlineImage: 63,\n    beginImageData: 64,\n    endInlineImage: 65,\n    paintXObject: 66,\n    markPoint: 67,\n    markPointProps: 68,\n    beginMarkedContent: 69,\n    beginMarkedContentProps: 70,\n    endMarkedContent: 71,\n    beginCompat: 72,\n    endCompat: 73,\n    paintFormXObjectBegin: 74,\n    paintFormXObjectEnd: 75,\n    beginGroup: 76,\n    endGroup: 77,\n    beginAnnotation: 80,\n    endAnnotation: 81,\n    paintImageMaskXObject: 83,\n    paintImageMaskXObjectGroup: 84,\n    paintImageXObject: 85,\n    paintInlineImageXObject: 86,\n    paintInlineImageXObjectGroup: 87,\n    paintImageXObjectRepeat: 88,\n    paintImageMaskXObjectRepeat: 89,\n    paintSolidColorImageMask: 90,\n    constructPath: 91,\n    setStrokeTransparent: 92,\n    setFillTransparent: 93\n};\nconst PasswordResponses = {\n    NEED_PASSWORD: 1,\n    INCORRECT_PASSWORD: 2\n};\nlet verbosity = VerbosityLevel.WARNINGS;\nfunction setVerbosityLevel(level) {\n    if (Number.isInteger(level)) {\n        verbosity = level;\n    }\n}\nfunction getVerbosityLevel() {\n    return verbosity;\n}\nfunction info(msg) {\n    if (verbosity >= VerbosityLevel.INFOS) {\n        console.log(`Info: ${msg}`);\n    }\n}\nfunction warn(msg) {\n    if (verbosity >= VerbosityLevel.WARNINGS) {\n        console.log(`Warning: ${msg}`);\n    }\n}\nfunction unreachable(msg) {\n    throw new Error(msg);\n}\nfunction assert(cond, msg) {\n    if (!cond) {\n        unreachable(msg);\n    }\n}\nfunction _isValidProtocol(url) {\n    switch(url?.protocol){\n        case \"http:\":\n        case \"https:\":\n        case \"ftp:\":\n        case \"mailto:\":\n        case \"tel:\":\n            return true;\n        default:\n            return false;\n    }\n}\nfunction createValidAbsoluteUrl(url, baseUrl = null, options = null) {\n    if (!url) {\n        return null;\n    }\n    try {\n        if (options && typeof url === \"string\") {\n            if (options.addDefaultProtocol && url.startsWith(\"www.\")) {\n                const dots = url.match(/\\./g);\n                if (dots?.length >= 2) {\n                    url = `http://${url}`;\n                }\n            }\n            if (options.tryConvertEncoding) {\n                try {\n                    url = stringToUTF8String(url);\n                } catch  {}\n            }\n        }\n        const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);\n        if (_isValidProtocol(absoluteUrl)) {\n            return absoluteUrl;\n        }\n    } catch  {}\n    return null;\n}\nfunction shadow(obj, prop, value, nonSerializable = false) {\n    Object.defineProperty(obj, prop, {\n        value,\n        enumerable: !nonSerializable,\n        configurable: true,\n        writable: false\n    });\n    return value;\n}\nconst BaseException = function BaseExceptionClosure() {\n    function BaseException(message, name) {\n        this.message = message;\n        this.name = name;\n    }\n    BaseException.prototype = new Error();\n    BaseException.constructor = BaseException;\n    return BaseException;\n}();\nclass PasswordException extends BaseException {\n    constructor(msg, code){\n        super(msg, \"PasswordException\");\n        this.code = code;\n    }\n}\nclass UnknownErrorException extends BaseException {\n    constructor(msg, details){\n        super(msg, \"UnknownErrorException\");\n        this.details = details;\n    }\n}\nclass InvalidPDFException extends BaseException {\n    constructor(msg){\n        super(msg, \"InvalidPDFException\");\n    }\n}\nclass MissingPDFException extends BaseException {\n    constructor(msg){\n        super(msg, \"MissingPDFException\");\n    }\n}\nclass UnexpectedResponseException extends BaseException {\n    constructor(msg, status){\n        super(msg, \"UnexpectedResponseException\");\n        this.status = status;\n    }\n}\nclass FormatError extends BaseException {\n    constructor(msg){\n        super(msg, \"FormatError\");\n    }\n}\nclass AbortException extends BaseException {\n    constructor(msg){\n        super(msg, \"AbortException\");\n    }\n}\nfunction bytesToString(bytes) {\n    if (typeof bytes !== \"object\" || bytes?.length === undefined) {\n        unreachable(\"Invalid argument for bytesToString\");\n    }\n    const length = bytes.length;\n    const MAX_ARGUMENT_COUNT = 8192;\n    if (length < MAX_ARGUMENT_COUNT) {\n        return String.fromCharCode.apply(null, bytes);\n    }\n    const strBuf = [];\n    for(let i = 0; i < length; i += MAX_ARGUMENT_COUNT){\n        const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n        const chunk = bytes.subarray(i, chunkEnd);\n        strBuf.push(String.fromCharCode.apply(null, chunk));\n    }\n    return strBuf.join(\"\");\n}\nfunction stringToBytes(str) {\n    if (typeof str !== \"string\") {\n        unreachable(\"Invalid argument for stringToBytes\");\n    }\n    const length = str.length;\n    const bytes = new Uint8Array(length);\n    for(let i = 0; i < length; ++i){\n        bytes[i] = str.charCodeAt(i) & 0xff;\n    }\n    return bytes;\n}\nfunction string32(value) {\n    return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n}\nfunction objectSize(obj) {\n    return Object.keys(obj).length;\n}\nfunction objectFromMap(map) {\n    const obj = Object.create(null);\n    for (const [key, value] of map){\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction isLittleEndian() {\n    const buffer8 = new Uint8Array(4);\n    buffer8[0] = 1;\n    const view32 = new Uint32Array(buffer8.buffer, 0, 1);\n    return view32[0] === 1;\n}\nfunction isEvalSupported() {\n    try {\n        new Function(\"\");\n        return true;\n    } catch  {\n        return false;\n    }\n}\nclass util_FeatureTest {\n    static get isLittleEndian() {\n        return shadow(this, \"isLittleEndian\", isLittleEndian());\n    }\n    static get isEvalSupported() {\n        return shadow(this, \"isEvalSupported\", isEvalSupported());\n    }\n    static get isOffscreenCanvasSupported() {\n        return shadow(this, \"isOffscreenCanvasSupported\", typeof OffscreenCanvas !== \"undefined\");\n    }\n    static get isImageDecoderSupported() {\n        return shadow(this, \"isImageDecoderSupported\", typeof ImageDecoder !== \"undefined\");\n    }\n    static get platform() {\n        if (typeof navigator !== \"undefined\" && typeof navigator?.platform === \"string\") {\n            return shadow(this, \"platform\", {\n                isMac: navigator.platform.includes(\"Mac\"),\n                isWindows: navigator.platform.includes(\"Win\"),\n                isFirefox: typeof navigator?.userAgent === \"string\" && navigator.userAgent.includes(\"Firefox\")\n            });\n        }\n        return shadow(this, \"platform\", {\n            isMac: false,\n            isWindows: false,\n            isFirefox: false\n        });\n    }\n    static get isCSSRoundSupported() {\n        return shadow(this, \"isCSSRoundSupported\", globalThis.CSS?.supports?.(\"width: round(1.5px, 1px)\"));\n    }\n}\nconst hexNumbers = Array.from(Array(256).keys(), (n)=>n.toString(16).padStart(2, \"0\"));\nclass Util {\n    static makeHexColor(r, g, b) {\n        return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;\n    }\n    static scaleMinMax(transform, minMax) {\n        let temp;\n        if (transform[0]) {\n            if (transform[0] < 0) {\n                temp = minMax[0];\n                minMax[0] = minMax[2];\n                minMax[2] = temp;\n            }\n            minMax[0] *= transform[0];\n            minMax[2] *= transform[0];\n            if (transform[3] < 0) {\n                temp = minMax[1];\n                minMax[1] = minMax[3];\n                minMax[3] = temp;\n            }\n            minMax[1] *= transform[3];\n            minMax[3] *= transform[3];\n        } else {\n            temp = minMax[0];\n            minMax[0] = minMax[1];\n            minMax[1] = temp;\n            temp = minMax[2];\n            minMax[2] = minMax[3];\n            minMax[3] = temp;\n            if (transform[1] < 0) {\n                temp = minMax[1];\n                minMax[1] = minMax[3];\n                minMax[3] = temp;\n            }\n            minMax[1] *= transform[1];\n            minMax[3] *= transform[1];\n            if (transform[2] < 0) {\n                temp = minMax[0];\n                minMax[0] = minMax[2];\n                minMax[2] = temp;\n            }\n            minMax[0] *= transform[2];\n            minMax[2] *= transform[2];\n        }\n        minMax[0] += transform[4];\n        minMax[1] += transform[5];\n        minMax[2] += transform[4];\n        minMax[3] += transform[5];\n    }\n    static transform(m1, m2) {\n        return [\n            m1[0] * m2[0] + m1[2] * m2[1],\n            m1[1] * m2[0] + m1[3] * m2[1],\n            m1[0] * m2[2] + m1[2] * m2[3],\n            m1[1] * m2[2] + m1[3] * m2[3],\n            m1[0] * m2[4] + m1[2] * m2[5] + m1[4],\n            m1[1] * m2[4] + m1[3] * m2[5] + m1[5]\n        ];\n    }\n    static applyTransform(p, m) {\n        const xt = p[0] * m[0] + p[1] * m[2] + m[4];\n        const yt = p[0] * m[1] + p[1] * m[3] + m[5];\n        return [\n            xt,\n            yt\n        ];\n    }\n    static applyInverseTransform(p, m) {\n        const d = m[0] * m[3] - m[1] * m[2];\n        const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n        const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n        return [\n            xt,\n            yt\n        ];\n    }\n    static getAxialAlignedBoundingBox(r, m) {\n        const p1 = this.applyTransform(r, m);\n        const p2 = this.applyTransform(r.slice(2, 4), m);\n        const p3 = this.applyTransform([\n            r[0],\n            r[3]\n        ], m);\n        const p4 = this.applyTransform([\n            r[2],\n            r[1]\n        ], m);\n        return [\n            Math.min(p1[0], p2[0], p3[0], p4[0]),\n            Math.min(p1[1], p2[1], p3[1], p4[1]),\n            Math.max(p1[0], p2[0], p3[0], p4[0]),\n            Math.max(p1[1], p2[1], p3[1], p4[1])\n        ];\n    }\n    static inverseTransform(m) {\n        const d = m[0] * m[3] - m[1] * m[2];\n        return [\n            m[3] / d,\n            -m[1] / d,\n            -m[2] / d,\n            m[0] / d,\n            (m[2] * m[5] - m[4] * m[3]) / d,\n            (m[4] * m[1] - m[5] * m[0]) / d\n        ];\n    }\n    static singularValueDecompose2dScale(m) {\n        const transpose = [\n            m[0],\n            m[2],\n            m[1],\n            m[3]\n        ];\n        const a = m[0] * transpose[0] + m[1] * transpose[2];\n        const b = m[0] * transpose[1] + m[1] * transpose[3];\n        const c = m[2] * transpose[0] + m[3] * transpose[2];\n        const d = m[2] * transpose[1] + m[3] * transpose[3];\n        const first = (a + d) / 2;\n        const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;\n        const sx = first + second || 1;\n        const sy = first - second || 1;\n        return [\n            Math.sqrt(sx),\n            Math.sqrt(sy)\n        ];\n    }\n    static normalizeRect(rect) {\n        const r = rect.slice(0);\n        if (rect[0] > rect[2]) {\n            r[0] = rect[2];\n            r[2] = rect[0];\n        }\n        if (rect[1] > rect[3]) {\n            r[1] = rect[3];\n            r[3] = rect[1];\n        }\n        return r;\n    }\n    static intersect(rect1, rect2) {\n        const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));\n        const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));\n        if (xLow > xHigh) {\n            return null;\n        }\n        const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));\n        const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));\n        if (yLow > yHigh) {\n            return null;\n        }\n        return [\n            xLow,\n            yLow,\n            xHigh,\n            yHigh\n        ];\n    }\n    static #getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, t, minMax) {\n        if (t <= 0 || t >= 1) {\n            return;\n        }\n        const mt = 1 - t;\n        const tt = t * t;\n        const ttt = tt * t;\n        const x = mt * (mt * (mt * x0 + 3 * t * x1) + 3 * tt * x2) + ttt * x3;\n        const y = mt * (mt * (mt * y0 + 3 * t * y1) + 3 * tt * y2) + ttt * y3;\n        minMax[0] = Math.min(minMax[0], x);\n        minMax[1] = Math.min(minMax[1], y);\n        minMax[2] = Math.max(minMax[2], x);\n        minMax[3] = Math.max(minMax[3], y);\n    }\n    static #getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, a, b, c, minMax) {\n        if (Math.abs(a) < 1e-12) {\n            if (Math.abs(b) >= 1e-12) {\n                this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, -c / b, minMax);\n            }\n            return;\n        }\n        const delta = b ** 2 - 4 * c * a;\n        if (delta < 0) {\n            return;\n        }\n        const sqrtDelta = Math.sqrt(delta);\n        const a2 = 2 * a;\n        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b + sqrtDelta) / a2, minMax);\n        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b - sqrtDelta) / a2, minMax);\n    }\n    static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax) {\n        if (minMax) {\n            minMax[0] = Math.min(minMax[0], x0, x3);\n            minMax[1] = Math.min(minMax[1], y0, y3);\n            minMax[2] = Math.max(minMax[2], x0, x3);\n            minMax[3] = Math.max(minMax[3], y0, y3);\n        } else {\n            minMax = [\n                Math.min(x0, x3),\n                Math.min(y0, y3),\n                Math.max(x0, x3),\n                Math.max(y0, y3)\n            ];\n        }\n        this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-x0 + 3 * (x1 - x2) + x3), 6 * (x0 - 2 * x1 + x2), 3 * (x1 - x0), minMax);\n        this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-y0 + 3 * (y1 - y2) + y3), 6 * (y0 - 2 * y1 + y2), 3 * (y1 - y0), minMax);\n        return minMax;\n    }\n}\nconst PDFStringTranslateTable = /* unused pure expression or super */ null && 0;\nfunction stringToPDFString(str) {\n    if (str[0] >= \"\\xef\") {\n        let encoding;\n        if (str[0] === \"\\xfe\" && str[1] === \"\\xff\") {\n            encoding = \"utf-16be\";\n            if (str.length % 2 === 1) {\n                str = str.slice(0, -1);\n            }\n        } else if (str[0] === \"\\xff\" && str[1] === \"\\xfe\") {\n            encoding = \"utf-16le\";\n            if (str.length % 2 === 1) {\n                str = str.slice(0, -1);\n            }\n        } else if (str[0] === \"\\xef\" && str[1] === \"\\xbb\" && str[2] === \"\\xbf\") {\n            encoding = \"utf-8\";\n        }\n        if (encoding) {\n            try {\n                const decoder = new TextDecoder(encoding, {\n                    fatal: true\n                });\n                const buffer = stringToBytes(str);\n                const decoded = decoder.decode(buffer);\n                if (!decoded.includes(\"\\x1b\")) {\n                    return decoded;\n                }\n                return decoded.replaceAll(/\\x1b[^\\x1b]*(?:\\x1b|$)/g, \"\");\n            } catch (ex) {\n                warn(`stringToPDFString: \"${ex}\".`);\n            }\n        }\n    }\n    const strBuf = [];\n    for(let i = 0, ii = str.length; i < ii; i++){\n        const charCode = str.charCodeAt(i);\n        if (charCode === 0x1b) {\n            while(++i < ii && str.charCodeAt(i) !== 0x1b){}\n            continue;\n        }\n        const code = PDFStringTranslateTable[charCode];\n        strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n    }\n    return strBuf.join(\"\");\n}\nfunction stringToUTF8String(str) {\n    return decodeURIComponent(escape(str));\n}\nfunction utf8StringToString(str) {\n    return unescape(encodeURIComponent(str));\n}\nfunction isArrayEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    for(let i = 0, ii = arr1.length; i < ii; i++){\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getModificationDate(date = new Date()) {\n    const buffer = [\n        date.getUTCFullYear().toString(),\n        (date.getUTCMonth() + 1).toString().padStart(2, \"0\"),\n        date.getUTCDate().toString().padStart(2, \"0\"),\n        date.getUTCHours().toString().padStart(2, \"0\"),\n        date.getUTCMinutes().toString().padStart(2, \"0\"),\n        date.getUTCSeconds().toString().padStart(2, \"0\")\n    ];\n    return buffer.join(\"\");\n}\nlet NormalizeRegex = null;\nlet NormalizationMap = null;\nfunction normalizeUnicode(str) {\n    if (!NormalizeRegex) {\n        NormalizeRegex = /([\\u00a0\\u00b5\\u037e\\u0eb3\\u2000-\\u200a\\u202f\\u2126\\ufb00-\\ufb04\\ufb06\\ufb20-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufba1\\ufba4-\\ufba9\\ufbae-\\ufbb1\\ufbd3-\\ufbdc\\ufbde-\\ufbe7\\ufbea-\\ufbf8\\ufbfc-\\ufbfd\\ufc00-\\ufc5d\\ufc64-\\ufcf1\\ufcf5-\\ufd3d\\ufd88\\ufdf4\\ufdfa-\\ufdfb\\ufe71\\ufe77\\ufe79\\ufe7b\\ufe7d]+)|(\\ufb05+)/gu;\n        NormalizationMap = new Map([\n            [\n                \"ﬅ\",\n                \"ſt\"\n            ]\n        ]);\n    }\n    return str.replaceAll(NormalizeRegex, (_, p1, p2)=>p1 ? p1.normalize(\"NFKC\") : NormalizationMap.get(p2));\n}\nfunction getUuid() {\n    if (typeof crypto.randomUUID === \"function\") {\n        return crypto.randomUUID();\n    }\n    const buf = new Uint8Array(32);\n    crypto.getRandomValues(buf);\n    return bytesToString(buf);\n}\nconst AnnotationPrefix = \"pdfjs_internal_id_\";\nfunction toHexUtil(arr) {\n    if (Uint8Array.prototype.toHex) {\n        return arr.toHex();\n    }\n    return Array.from(arr, (num)=>hexNumbers[num]).join(\"\");\n}\nfunction toBase64Util(arr) {\n    if (Uint8Array.prototype.toBase64) {\n        return arr.toBase64();\n    }\n    return btoa(bytesToString(arr));\n}\nfunction fromBase64Util(str) {\n    if (Uint8Array.fromBase64) {\n        return Uint8Array.fromBase64(str);\n    }\n    return stringToBytes(atob(str));\n}\nif (typeof Promise.try !== \"function\") {\n    Promise.try = function(fn, ...args) {\n        return new Promise((resolve)=>{\n            resolve(fn(...args));\n        });\n    };\n}\n; // ./src/display/display_utils.js\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\nclass PixelsPerInch {\n    static{\n        this.CSS = 96.0;\n    }\n    static{\n        this.PDF = 72.0;\n    }\n    static{\n        this.PDF_TO_CSS_UNITS = this.CSS / this.PDF;\n    }\n}\nasync function fetchData(url, type = \"text\") {\n    if (isValidFetchUrl(url, document.baseURI)) {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(response.statusText);\n        }\n        switch(type){\n            case \"arraybuffer\":\n                return response.arrayBuffer();\n            case \"blob\":\n                return response.blob();\n            case \"json\":\n                return response.json();\n        }\n        return response.text();\n    }\n    return new Promise((resolve, reject)=>{\n        const request = new XMLHttpRequest();\n        request.open(\"GET\", url, true);\n        request.responseType = type;\n        request.onreadystatechange = ()=>{\n            if (request.readyState !== XMLHttpRequest.DONE) {\n                return;\n            }\n            if (request.status === 200 || request.status === 0) {\n                switch(type){\n                    case \"arraybuffer\":\n                    case \"blob\":\n                    case \"json\":\n                        resolve(request.response);\n                        return;\n                }\n                resolve(request.responseText);\n                return;\n            }\n            reject(new Error(request.statusText));\n        };\n        request.send(null);\n    });\n}\nclass PageViewport {\n    constructor({ viewBox, userUnit, scale, rotation, offsetX = 0, offsetY = 0, dontFlip = false }){\n        this.viewBox = viewBox;\n        this.userUnit = userUnit;\n        this.scale = scale;\n        this.rotation = rotation;\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        scale *= userUnit;\n        const centerX = (viewBox[2] + viewBox[0]) / 2;\n        const centerY = (viewBox[3] + viewBox[1]) / 2;\n        let rotateA, rotateB, rotateC, rotateD;\n        rotation %= 360;\n        if (rotation < 0) {\n            rotation += 360;\n        }\n        switch(rotation){\n            case 180:\n                rotateA = -1;\n                rotateB = 0;\n                rotateC = 0;\n                rotateD = 1;\n                break;\n            case 90:\n                rotateA = 0;\n                rotateB = 1;\n                rotateC = 1;\n                rotateD = 0;\n                break;\n            case 270:\n                rotateA = 0;\n                rotateB = -1;\n                rotateC = -1;\n                rotateD = 0;\n                break;\n            case 0:\n                rotateA = 1;\n                rotateB = 0;\n                rotateC = 0;\n                rotateD = -1;\n                break;\n            default:\n                throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n        }\n        if (dontFlip) {\n            rotateC = -rotateC;\n            rotateD = -rotateD;\n        }\n        let offsetCanvasX, offsetCanvasY;\n        let width, height;\n        if (rotateA === 0) {\n            offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n            offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n            width = (viewBox[3] - viewBox[1]) * scale;\n            height = (viewBox[2] - viewBox[0]) * scale;\n        } else {\n            offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n            offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n            width = (viewBox[2] - viewBox[0]) * scale;\n            height = (viewBox[3] - viewBox[1]) * scale;\n        }\n        this.transform = [\n            rotateA * scale,\n            rotateB * scale,\n            rotateC * scale,\n            rotateD * scale,\n            offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY,\n            offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY\n        ];\n        this.width = width;\n        this.height = height;\n    }\n    get rawDims() {\n        const { userUnit, viewBox } = this;\n        const dims = viewBox.map((x)=>x * userUnit);\n        return shadow(this, \"rawDims\", {\n            pageWidth: dims[2] - dims[0],\n            pageHeight: dims[3] - dims[1],\n            pageX: dims[0],\n            pageY: dims[1]\n        });\n    }\n    clone({ scale = this.scale, rotation = this.rotation, offsetX = this.offsetX, offsetY = this.offsetY, dontFlip = false } = {}) {\n        return new PageViewport({\n            viewBox: this.viewBox.slice(),\n            userUnit: this.userUnit,\n            scale,\n            rotation,\n            offsetX,\n            offsetY,\n            dontFlip\n        });\n    }\n    convertToViewportPoint(x, y) {\n        return Util.applyTransform([\n            x,\n            y\n        ], this.transform);\n    }\n    convertToViewportRectangle(rect) {\n        const topLeft = Util.applyTransform([\n            rect[0],\n            rect[1]\n        ], this.transform);\n        const bottomRight = Util.applyTransform([\n            rect[2],\n            rect[3]\n        ], this.transform);\n        return [\n            topLeft[0],\n            topLeft[1],\n            bottomRight[0],\n            bottomRight[1]\n        ];\n    }\n    convertToPdfPoint(x, y) {\n        return Util.applyInverseTransform([\n            x,\n            y\n        ], this.transform);\n    }\n}\nclass RenderingCancelledException extends BaseException {\n    constructor(msg, extraDelay = 0){\n        super(msg, \"RenderingCancelledException\");\n        this.extraDelay = extraDelay;\n    }\n}\nfunction isDataScheme(url) {\n    const ii = url.length;\n    let i = 0;\n    while(i < ii && url[i].trim() === \"\"){\n        i++;\n    }\n    return url.substring(i, i + 5).toLowerCase() === \"data:\";\n}\nfunction isPdfFile(filename) {\n    return typeof filename === \"string\" && /\\.pdf$/i.test(filename);\n}\nfunction getFilenameFromUrl(url) {\n    [url] = url.split(/[#?]/, 1);\n    return url.substring(url.lastIndexOf(\"/\") + 1);\n}\nfunction getPdfFilenameFromUrl(url, defaultFilename = \"document.pdf\") {\n    if (typeof url !== \"string\") {\n        return defaultFilename;\n    }\n    if (isDataScheme(url)) {\n        warn('getPdfFilenameFromUrl: ignore \"data:\"-URL for performance reasons.');\n        return defaultFilename;\n    }\n    const reURI = /^(?:(?:[^:]+:)?\\/\\/[^/]+)?([^?#]*)(\\?[^#]*)?(#.*)?$/;\n    const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n    const splitURI = reURI.exec(url);\n    let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);\n    if (suggestedFilename) {\n        suggestedFilename = suggestedFilename[0];\n        if (suggestedFilename.includes(\"%\")) {\n            try {\n                suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];\n            } catch  {}\n        }\n    }\n    return suggestedFilename || defaultFilename;\n}\nclass StatTimer {\n    time(name) {\n        if (name in this.started) {\n            warn(`Timer is already running for ${name}`);\n        }\n        this.started[name] = Date.now();\n    }\n    timeEnd(name) {\n        if (!(name in this.started)) {\n            warn(`Timer has not been started for ${name}`);\n        }\n        this.times.push({\n            name,\n            start: this.started[name],\n            end: Date.now()\n        });\n        delete this.started[name];\n    }\n    toString() {\n        const outBuf = [];\n        let longest = 0;\n        for (const { name } of this.times){\n            longest = Math.max(name.length, longest);\n        }\n        for (const { name, start, end } of this.times){\n            outBuf.push(`${name.padEnd(longest)} ${end - start}ms\\n`);\n        }\n        return outBuf.join(\"\");\n    }\n    constructor(){\n        this.started = Object.create(null);\n        this.times = [];\n    }\n}\nfunction isValidFetchUrl(url, baseUrl) {\n    try {\n        const { protocol } = baseUrl ? new URL(url, baseUrl) : new URL(url);\n        return protocol === \"http:\" || protocol === \"https:\";\n    } catch  {\n        return false;\n    }\n}\nfunction noContextMenu(e) {\n    e.preventDefault();\n}\nfunction stopEvent(e) {\n    e.preventDefault();\n    e.stopPropagation();\n}\nfunction deprecated(details) {\n    console.log(\"Deprecated API usage: \" + details);\n}\nclass PDFDateString {\n    static #regex;\n    static toDateObject(input) {\n        if (!input || typeof input !== \"string\") {\n            return null;\n        }\n        this.#regex ||= new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\n        const matches = this.#regex.exec(input);\n        if (!matches) {\n            return null;\n        }\n        const year = parseInt(matches[1], 10);\n        let month = parseInt(matches[2], 10);\n        month = month >= 1 && month <= 12 ? month - 1 : 0;\n        let day = parseInt(matches[3], 10);\n        day = day >= 1 && day <= 31 ? day : 1;\n        let hour = parseInt(matches[4], 10);\n        hour = hour >= 0 && hour <= 23 ? hour : 0;\n        let minute = parseInt(matches[5], 10);\n        minute = minute >= 0 && minute <= 59 ? minute : 0;\n        let second = parseInt(matches[6], 10);\n        second = second >= 0 && second <= 59 ? second : 0;\n        const universalTimeRelation = matches[7] || \"Z\";\n        let offsetHour = parseInt(matches[8], 10);\n        offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n        let offsetMinute = parseInt(matches[9], 10) || 0;\n        offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n        if (universalTimeRelation === \"-\") {\n            hour += offsetHour;\n            minute += offsetMinute;\n        } else if (universalTimeRelation === \"+\") {\n            hour -= offsetHour;\n            minute -= offsetMinute;\n        }\n        return new Date(Date.UTC(year, month, day, hour, minute, second));\n    }\n}\nfunction getXfaPageViewport(xfaPage, { scale = 1, rotation = 0 }) {\n    const { width, height } = xfaPage.attributes.style;\n    const viewBox = [\n        0,\n        0,\n        parseInt(width),\n        parseInt(height)\n    ];\n    return new PageViewport({\n        viewBox,\n        userUnit: 1,\n        scale,\n        rotation\n    });\n}\nfunction getRGB(color) {\n    if (color.startsWith(\"#\")) {\n        const colorRGB = parseInt(color.slice(1), 16);\n        return [\n            (colorRGB & 0xff0000) >> 16,\n            (colorRGB & 0x00ff00) >> 8,\n            colorRGB & 0x0000ff\n        ];\n    }\n    if (color.startsWith(\"rgb(\")) {\n        return color.slice(4, -1).split(\",\").map((x)=>parseInt(x));\n    }\n    if (color.startsWith(\"rgba(\")) {\n        return color.slice(5, -1).split(\",\").map((x)=>parseInt(x)).slice(0, 3);\n    }\n    warn(`Not a valid color format: \"${color}\"`);\n    return [\n        0,\n        0,\n        0\n    ];\n}\nfunction getColorValues(colors) {\n    const span = document.createElement(\"span\");\n    span.style.visibility = \"hidden\";\n    document.body.append(span);\n    for (const name of colors.keys()){\n        span.style.color = name;\n        const computedColor = window.getComputedStyle(span).color;\n        colors.set(name, getRGB(computedColor));\n    }\n    span.remove();\n}\nfunction getCurrentTransform(ctx) {\n    const { a, b, c, d, e, f } = ctx.getTransform();\n    return [\n        a,\n        b,\n        c,\n        d,\n        e,\n        f\n    ];\n}\nfunction getCurrentTransformInverse(ctx) {\n    const { a, b, c, d, e, f } = ctx.getTransform().invertSelf();\n    return [\n        a,\n        b,\n        c,\n        d,\n        e,\n        f\n    ];\n}\nfunction setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {\n    if (viewport instanceof PageViewport) {\n        const { pageWidth, pageHeight } = viewport.rawDims;\n        const { style } = div;\n        const useRound = util_FeatureTest.isCSSRoundSupported;\n        const w = `var(--scale-factor) * ${pageWidth}px`, h = `var(--scale-factor) * ${pageHeight}px`;\n        const widthStr = useRound ? `round(down, ${w}, var(--scale-round-x, 1px))` : `calc(${w})`, heightStr = useRound ? `round(down, ${h}, var(--scale-round-y, 1px))` : `calc(${h})`;\n        if (!mustFlip || viewport.rotation % 180 === 0) {\n            style.width = widthStr;\n            style.height = heightStr;\n        } else {\n            style.width = heightStr;\n            style.height = widthStr;\n        }\n    }\n    if (mustRotate) {\n        div.setAttribute(\"data-main-rotation\", viewport.rotation);\n    }\n}\nclass OutputScale {\n    constructor(){\n        const pixelRatio = window.devicePixelRatio || 1;\n        this.sx = pixelRatio;\n        this.sy = pixelRatio;\n    }\n    get scaled() {\n        return this.sx !== 1 || this.sy !== 1;\n    }\n    get symmetric() {\n        return this.sx === this.sy;\n    }\n}\n; // ./src/display/editor/toolbar.js\nclass EditorToolbar {\n    #toolbar;\n    #colorPicker;\n    #editor;\n    #buttons;\n    #altText;\n    static #l10nRemove = null;\n    constructor(editor){\n        this.#toolbar = null;\n        this.#colorPicker = null;\n        this.#buttons = null;\n        this.#altText = null;\n        this.#editor = editor;\n        EditorToolbar.#l10nRemove ||= Object.freeze({\n            freetext: \"pdfjs-editor-remove-freetext-button\",\n            highlight: \"pdfjs-editor-remove-highlight-button\",\n            ink: \"pdfjs-editor-remove-ink-button\",\n            stamp: \"pdfjs-editor-remove-stamp-button\"\n        });\n    }\n    render() {\n        const editToolbar = this.#toolbar = document.createElement(\"div\");\n        editToolbar.classList.add(\"editToolbar\", \"hidden\");\n        editToolbar.setAttribute(\"role\", \"toolbar\");\n        const signal = this.#editor._uiManager._signal;\n        editToolbar.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        editToolbar.addEventListener(\"pointerdown\", EditorToolbar.#pointerDown, {\n            signal\n        });\n        const buttons = this.#buttons = document.createElement(\"div\");\n        buttons.className = \"buttons\";\n        editToolbar.append(buttons);\n        const position = this.#editor.toolbarPosition;\n        if (position) {\n            const { style } = editToolbar;\n            const x = this.#editor._uiManager.direction === \"ltr\" ? 1 - position[0] : position[0];\n            style.insetInlineEnd = `${100 * x}%`;\n            style.top = `calc(${100 * position[1]}% + var(--editor-toolbar-vert-offset))`;\n        }\n        this.#addDeleteButton();\n        return editToolbar;\n    }\n    get div() {\n        return this.#toolbar;\n    }\n    static #pointerDown(e) {\n        e.stopPropagation();\n    }\n    #focusIn(e) {\n        this.#editor._focusEventsAllowed = false;\n        stopEvent(e);\n    }\n    #focusOut(e) {\n        this.#editor._focusEventsAllowed = true;\n        stopEvent(e);\n    }\n    #addListenersToElement(element) {\n        const signal = this.#editor._uiManager._signal;\n        element.addEventListener(\"focusin\", this.#focusIn.bind(this), {\n            capture: true,\n            signal\n        });\n        element.addEventListener(\"focusout\", this.#focusOut.bind(this), {\n            capture: true,\n            signal\n        });\n        element.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n    }\n    hide() {\n        this.#toolbar.classList.add(\"hidden\");\n        this.#colorPicker?.hideDropdown();\n    }\n    show() {\n        this.#toolbar.classList.remove(\"hidden\");\n        this.#altText?.shown();\n    }\n    #addDeleteButton() {\n        const { editorType, _uiManager } = this.#editor;\n        const button = document.createElement(\"button\");\n        button.className = \"delete\";\n        button.tabIndex = 0;\n        button.setAttribute(\"data-l10n-id\", EditorToolbar.#l10nRemove[editorType]);\n        this.#addListenersToElement(button);\n        button.addEventListener(\"click\", (e)=>{\n            _uiManager.delete();\n        }, {\n            signal: _uiManager._signal\n        });\n        this.#buttons.append(button);\n    }\n    get #divider() {\n        const divider = document.createElement(\"div\");\n        divider.className = \"divider\";\n        return divider;\n    }\n    async addAltText(altText) {\n        const button = await altText.render();\n        this.#addListenersToElement(button);\n        this.#buttons.prepend(button, this.#divider);\n        this.#altText = altText;\n    }\n    addColorPicker(colorPicker) {\n        this.#colorPicker = colorPicker;\n        const button = colorPicker.renderButton();\n        this.#addListenersToElement(button);\n        this.#buttons.prepend(button, this.#divider);\n    }\n    remove() {\n        this.#toolbar.remove();\n        this.#colorPicker?.destroy();\n        this.#colorPicker = null;\n    }\n}\nclass HighlightToolbar {\n    #buttons;\n    #toolbar;\n    #uiManager;\n    constructor(uiManager){\n        this.#buttons = null;\n        this.#toolbar = null;\n        this.#uiManager = uiManager;\n    }\n    #render() {\n        const editToolbar = this.#toolbar = document.createElement(\"div\");\n        editToolbar.className = \"editToolbar\";\n        editToolbar.setAttribute(\"role\", \"toolbar\");\n        editToolbar.addEventListener(\"contextmenu\", noContextMenu, {\n            signal: this.#uiManager._signal\n        });\n        const buttons = this.#buttons = document.createElement(\"div\");\n        buttons.className = \"buttons\";\n        editToolbar.append(buttons);\n        this.#addHighlightButton();\n        return editToolbar;\n    }\n    #getLastPoint(boxes, isLTR) {\n        let lastY = 0;\n        let lastX = 0;\n        for (const box of boxes){\n            const y = box.y + box.height;\n            if (y < lastY) {\n                continue;\n            }\n            const x = box.x + (isLTR ? box.width : 0);\n            if (y > lastY) {\n                lastX = x;\n                lastY = y;\n                continue;\n            }\n            if (isLTR) {\n                if (x > lastX) {\n                    lastX = x;\n                }\n            } else if (x < lastX) {\n                lastX = x;\n            }\n        }\n        return [\n            isLTR ? 1 - lastX : lastX,\n            lastY\n        ];\n    }\n    show(parent, boxes, isLTR) {\n        const [x, y] = this.#getLastPoint(boxes, isLTR);\n        const { style } = this.#toolbar ||= this.#render();\n        parent.append(this.#toolbar);\n        style.insetInlineEnd = `${100 * x}%`;\n        style.top = `calc(${100 * y}% + var(--editor-toolbar-vert-offset))`;\n    }\n    hide() {\n        this.#toolbar.remove();\n    }\n    #addHighlightButton() {\n        const button = document.createElement(\"button\");\n        button.className = \"highlightButton\";\n        button.tabIndex = 0;\n        button.setAttribute(\"data-l10n-id\", `pdfjs-highlight-floating-button1`);\n        const span = document.createElement(\"span\");\n        button.append(span);\n        span.className = \"visuallyHidden\";\n        span.setAttribute(\"data-l10n-id\", \"pdfjs-highlight-floating-button-label\");\n        const signal = this.#uiManager._signal;\n        button.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        button.addEventListener(\"click\", ()=>{\n            this.#uiManager.highlightSelection(\"floating_button\");\n        }, {\n            signal\n        });\n        this.#buttons.append(button);\n    }\n}\n; // ./src/display/editor/tools.js\nfunction bindEvents(obj, element, names) {\n    for (const name of names){\n        element.addEventListener(name, obj[name].bind(obj));\n    }\n}\nfunction opacityToHex(opacity) {\n    return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, \"0\");\n}\nclass IdManager {\n    #id;\n    get id() {\n        return `${AnnotationEditorPrefix}${this.#id++}`;\n    }\n    constructor(){\n        this.#id = 0;\n    }\n}\nclass ImageManager {\n    #baseId;\n    #id;\n    #cache;\n    static get _isSVGFittingCanvas() {\n        const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n        const canvas = new OffscreenCanvas(1, 3);\n        const ctx = canvas.getContext(\"2d\", {\n            willReadFrequently: true\n        });\n        const image = new Image();\n        image.src = svg;\n        const promise = image.decode().then(()=>{\n            ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);\n            return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;\n        });\n        return shadow(this, \"_isSVGFittingCanvas\", promise);\n    }\n    async #get(key, rawData) {\n        this.#cache ||= new Map();\n        let data = this.#cache.get(key);\n        if (data === null) {\n            return null;\n        }\n        if (data?.bitmap) {\n            data.refCounter += 1;\n            return data;\n        }\n        try {\n            data ||= {\n                bitmap: null,\n                id: `image_${this.#baseId}_${this.#id++}`,\n                refCounter: 0,\n                isSvg: false\n            };\n            let image;\n            if (typeof rawData === \"string\") {\n                data.url = rawData;\n                image = await fetchData(rawData, \"blob\");\n            } else if (rawData instanceof File) {\n                image = data.file = rawData;\n            } else if (rawData instanceof Blob) {\n                image = rawData;\n            }\n            if (image.type === \"image/svg+xml\") {\n                const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;\n                const fileReader = new FileReader();\n                const imageElement = new Image();\n                const imagePromise = new Promise((resolve, reject)=>{\n                    imageElement.onload = ()=>{\n                        data.bitmap = imageElement;\n                        data.isSvg = true;\n                        resolve();\n                    };\n                    fileReader.onload = async ()=>{\n                        const url = data.svgUrl = fileReader.result;\n                        imageElement.src = await mustRemoveAspectRatioPromise ? `${url}#svgView(preserveAspectRatio(none))` : url;\n                    };\n                    imageElement.onerror = fileReader.onerror = reject;\n                });\n                fileReader.readAsDataURL(image);\n                await imagePromise;\n            } else {\n                data.bitmap = await createImageBitmap(image);\n            }\n            data.refCounter = 1;\n        } catch (e) {\n            warn(e);\n            data = null;\n        }\n        this.#cache.set(key, data);\n        if (data) {\n            this.#cache.set(data.id, data);\n        }\n        return data;\n    }\n    async getFromFile(file) {\n        const { lastModified, name, size, type } = file;\n        return this.#get(`${lastModified}_${name}_${size}_${type}`, file);\n    }\n    async getFromUrl(url) {\n        return this.#get(url, url);\n    }\n    async getFromBlob(id, blobPromise) {\n        const blob = await blobPromise;\n        return this.#get(id, blob);\n    }\n    async getFromId(id) {\n        this.#cache ||= new Map();\n        const data = this.#cache.get(id);\n        if (!data) {\n            return null;\n        }\n        if (data.bitmap) {\n            data.refCounter += 1;\n            return data;\n        }\n        if (data.file) {\n            return this.getFromFile(data.file);\n        }\n        if (data.blobPromise) {\n            const { blobPromise } = data;\n            delete data.blobPromise;\n            return this.getFromBlob(data.id, blobPromise);\n        }\n        return this.getFromUrl(data.url);\n    }\n    getFromCanvas(id, canvas) {\n        this.#cache ||= new Map();\n        let data = this.#cache.get(id);\n        if (data?.bitmap) {\n            data.refCounter += 1;\n            return data;\n        }\n        const offscreen = new OffscreenCanvas(canvas.width, canvas.height);\n        const ctx = offscreen.getContext(\"2d\");\n        ctx.drawImage(canvas, 0, 0);\n        data = {\n            bitmap: offscreen.transferToImageBitmap(),\n            id: `image_${this.#baseId}_${this.#id++}`,\n            refCounter: 1,\n            isSvg: false\n        };\n        this.#cache.set(id, data);\n        this.#cache.set(data.id, data);\n        return data;\n    }\n    getSvgUrl(id) {\n        const data = this.#cache.get(id);\n        if (!data?.isSvg) {\n            return null;\n        }\n        return data.svgUrl;\n    }\n    deleteId(id) {\n        this.#cache ||= new Map();\n        const data = this.#cache.get(id);\n        if (!data) {\n            return;\n        }\n        data.refCounter -= 1;\n        if (data.refCounter !== 0) {\n            return;\n        }\n        const { bitmap } = data;\n        if (!data.url && !data.file) {\n            const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\n            const ctx = canvas.getContext(\"bitmaprenderer\");\n            ctx.transferFromImageBitmap(bitmap);\n            data.blobPromise = canvas.convertToBlob();\n        }\n        bitmap.close?.();\n        data.bitmap = null;\n    }\n    isValidId(id) {\n        return id.startsWith(`image_${this.#baseId}_`);\n    }\n    constructor(){\n        this.#baseId = getUuid();\n        this.#id = 0;\n        this.#cache = null;\n    }\n}\nclass CommandManager {\n    #commands;\n    #locked;\n    #maxSize;\n    #position;\n    constructor(maxSize = 128){\n        this.#commands = [];\n        this.#locked = false;\n        this.#position = -1;\n        this.#maxSize = maxSize;\n    }\n    add({ cmd, undo, post, mustExec, type = NaN, overwriteIfSameType = false, keepUndo = false }) {\n        if (mustExec) {\n            cmd();\n        }\n        if (this.#locked) {\n            return;\n        }\n        const save = {\n            cmd,\n            undo,\n            post,\n            type\n        };\n        if (this.#position === -1) {\n            if (this.#commands.length > 0) {\n                this.#commands.length = 0;\n            }\n            this.#position = 0;\n            this.#commands.push(save);\n            return;\n        }\n        if (overwriteIfSameType && this.#commands[this.#position].type === type) {\n            if (keepUndo) {\n                save.undo = this.#commands[this.#position].undo;\n            }\n            this.#commands[this.#position] = save;\n            return;\n        }\n        const next = this.#position + 1;\n        if (next === this.#maxSize) {\n            this.#commands.splice(0, 1);\n        } else {\n            this.#position = next;\n            if (next < this.#commands.length) {\n                this.#commands.splice(next);\n            }\n        }\n        this.#commands.push(save);\n    }\n    undo() {\n        if (this.#position === -1) {\n            return;\n        }\n        this.#locked = true;\n        const { undo, post } = this.#commands[this.#position];\n        undo();\n        post?.();\n        this.#locked = false;\n        this.#position -= 1;\n    }\n    redo() {\n        if (this.#position < this.#commands.length - 1) {\n            this.#position += 1;\n            this.#locked = true;\n            const { cmd, post } = this.#commands[this.#position];\n            cmd();\n            post?.();\n            this.#locked = false;\n        }\n    }\n    hasSomethingToUndo() {\n        return this.#position !== -1;\n    }\n    hasSomethingToRedo() {\n        return this.#position < this.#commands.length - 1;\n    }\n    cleanType(type) {\n        if (this.#position === -1) {\n            return;\n        }\n        for(let i = this.#position; i >= 0; i--){\n            if (this.#commands[i].type !== type) {\n                this.#commands.splice(i + 1, this.#position - i);\n                this.#position = i;\n                return;\n            }\n        }\n        this.#commands.length = 0;\n        this.#position = -1;\n    }\n    destroy() {\n        this.#commands = null;\n    }\n}\nclass KeyboardManager {\n    constructor(callbacks){\n        this.buffer = [];\n        this.callbacks = new Map();\n        this.allKeys = new Set();\n        const { isMac } = util_FeatureTest.platform;\n        for (const [keys, callback, options = {}] of callbacks){\n            for (const key of keys){\n                const isMacKey = key.startsWith(\"mac+\");\n                if (isMac && isMacKey) {\n                    this.callbacks.set(key.slice(4), {\n                        callback,\n                        options\n                    });\n                    this.allKeys.add(key.split(\"+\").at(-1));\n                } else if (!isMac && !isMacKey) {\n                    this.callbacks.set(key, {\n                        callback,\n                        options\n                    });\n                    this.allKeys.add(key.split(\"+\").at(-1));\n                }\n            }\n        }\n    }\n    #serialize(event) {\n        if (event.altKey) {\n            this.buffer.push(\"alt\");\n        }\n        if (event.ctrlKey) {\n            this.buffer.push(\"ctrl\");\n        }\n        if (event.metaKey) {\n            this.buffer.push(\"meta\");\n        }\n        if (event.shiftKey) {\n            this.buffer.push(\"shift\");\n        }\n        this.buffer.push(event.key);\n        const str = this.buffer.join(\"+\");\n        this.buffer.length = 0;\n        return str;\n    }\n    exec(self, event) {\n        if (!this.allKeys.has(event.key)) {\n            return;\n        }\n        const info = this.callbacks.get(this.#serialize(event));\n        if (!info) {\n            return;\n        }\n        const { callback, options: { bubbles = false, args = [], checker = null } } = info;\n        if (checker && !checker(self, event)) {\n            return;\n        }\n        callback.bind(self, ...args, event)();\n        if (!bubbles) {\n            stopEvent(event);\n        }\n    }\n}\nclass ColorManager {\n    static{\n        this._colorsMapping = new Map([\n            [\n                \"CanvasText\",\n                [\n                    0,\n                    0,\n                    0\n                ]\n            ],\n            [\n                \"Canvas\",\n                [\n                    255,\n                    255,\n                    255\n                ]\n            ]\n        ]);\n    }\n    get _colors() {\n        const colors = new Map([\n            [\n                \"CanvasText\",\n                null\n            ],\n            [\n                \"Canvas\",\n                null\n            ]\n        ]);\n        getColorValues(colors);\n        return shadow(this, \"_colors\", colors);\n    }\n    convert(color) {\n        const rgb = getRGB(color);\n        if (!window.matchMedia(\"(forced-colors: active)\").matches) {\n            return rgb;\n        }\n        for (const [name, RGB] of this._colors){\n            if (RGB.every((x, i)=>x === rgb[i])) {\n                return ColorManager._colorsMapping.get(name);\n            }\n        }\n        return rgb;\n    }\n    getHexCode(name) {\n        const rgb = this._colors.get(name);\n        if (!rgb) {\n            return name;\n        }\n        return Util.makeHexColor(...rgb);\n    }\n}\nclass AnnotationEditorUIManager {\n    #abortController;\n    #activeEditor;\n    #allEditors;\n    #allLayers;\n    #altTextManager;\n    #annotationStorage;\n    #changedExistingAnnotations;\n    #commandManager;\n    #copyPasteAC;\n    #currentDrawingSession;\n    #currentPageIndex;\n    #deletedAnnotationsElementIds;\n    #draggingEditors;\n    #editorTypes;\n    #editorsToRescale;\n    #enableHighlightFloatingButton;\n    #enableUpdatedAddImage;\n    #enableNewAltTextWhenAddingImage;\n    #filterFactory;\n    #focusMainContainerTimeoutId;\n    #focusManagerAC;\n    #highlightColors;\n    #highlightWhenShiftUp;\n    #highlightToolbar;\n    #idManager;\n    #isEnabled;\n    #isWaiting;\n    #keyboardManagerAC;\n    #lastActiveElement;\n    #mainHighlightColorPicker;\n    #mlManager;\n    #mode;\n    #selectedEditors;\n    #selectedTextNode;\n    #pageColors;\n    #showAllStates;\n    #previousStates;\n    #translation;\n    #translationTimeoutId;\n    #container;\n    #viewer;\n    #updateModeCapability;\n    static{\n        this.TRANSLATE_SMALL = 1;\n    }\n    static{\n        this.TRANSLATE_BIG = 10;\n    }\n    static get _keyboardManager() {\n        const proto = AnnotationEditorUIManager.prototype;\n        const arrowChecker = (self)=>self.#container.contains(document.activeElement) && document.activeElement.tagName !== \"BUTTON\" && self.hasSomethingToControl();\n        const textInputChecker = (_self, { target: el })=>{\n            if (el instanceof HTMLInputElement) {\n                const { type } = el;\n                return type !== \"text\" && type !== \"number\";\n            }\n            return true;\n        };\n        const small = this.TRANSLATE_SMALL;\n        const big = this.TRANSLATE_BIG;\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ctrl+a\",\n                    \"mac+meta+a\"\n                ],\n                proto.selectAll,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+z\",\n                    \"mac+meta+z\"\n                ],\n                proto.undo,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+y\",\n                    \"ctrl+shift+z\",\n                    \"mac+meta+shift+z\",\n                    \"ctrl+shift+Z\",\n                    \"mac+meta+shift+Z\"\n                ],\n                proto.redo,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"Backspace\",\n                    \"alt+Backspace\",\n                    \"ctrl+Backspace\",\n                    \"shift+Backspace\",\n                    \"mac+Backspace\",\n                    \"mac+alt+Backspace\",\n                    \"mac+ctrl+Backspace\",\n                    \"Delete\",\n                    \"ctrl+Delete\",\n                    \"shift+Delete\",\n                    \"mac+Delete\"\n                ],\n                proto.delete,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"Enter\",\n                    \"mac+Enter\"\n                ],\n                proto.addNewEditorFromKeyboard,\n                {\n                    checker: (self, { target: el })=>!(el instanceof HTMLButtonElement) && self.#container.contains(el) && !self.isEnterHandled\n                }\n            ],\n            [\n                [\n                    \" \",\n                    \"mac+ \"\n                ],\n                proto.addNewEditorFromKeyboard,\n                {\n                    checker: (self, { target: el })=>!(el instanceof HTMLButtonElement) && self.#container.contains(document.activeElement)\n                }\n            ],\n            [\n                [\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                proto.unselectAll\n            ],\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        -small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowLeft\",\n                    \"mac+shift+ArrowLeft\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        -big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowRight\",\n                    \"mac+shift+ArrowRight\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        -small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowUp\",\n                    \"mac+shift+ArrowUp\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        -big\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowDown\",\n                    \"mac+shift+ArrowDown\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        big\n                    ],\n                    checker: arrowChecker\n                }\n            ]\n        ]));\n    }\n    constructor(container, viewer, altTextManager, eventBus, pdfDocument, pageColors, highlightColors, enableHighlightFloatingButton, enableUpdatedAddImage, enableNewAltTextWhenAddingImage, mlManager, editorUndoBar, supportsPinchToZoom){\n        this.#abortController = new AbortController();\n        this.#activeEditor = null;\n        this.#allEditors = new Map();\n        this.#allLayers = new Map();\n        this.#altTextManager = null;\n        this.#annotationStorage = null;\n        this.#changedExistingAnnotations = null;\n        this.#commandManager = new CommandManager();\n        this.#copyPasteAC = null;\n        this.#currentDrawingSession = null;\n        this.#currentPageIndex = 0;\n        this.#deletedAnnotationsElementIds = new Set();\n        this.#draggingEditors = null;\n        this.#editorTypes = null;\n        this.#editorsToRescale = new Set();\n        this._editorUndoBar = null;\n        this.#enableHighlightFloatingButton = false;\n        this.#enableUpdatedAddImage = false;\n        this.#enableNewAltTextWhenAddingImage = false;\n        this.#filterFactory = null;\n        this.#focusMainContainerTimeoutId = null;\n        this.#focusManagerAC = null;\n        this.#highlightColors = null;\n        this.#highlightWhenShiftUp = false;\n        this.#highlightToolbar = null;\n        this.#idManager = new IdManager();\n        this.#isEnabled = false;\n        this.#isWaiting = false;\n        this.#keyboardManagerAC = null;\n        this.#lastActiveElement = null;\n        this.#mainHighlightColorPicker = null;\n        this.#mlManager = null;\n        this.#mode = AnnotationEditorType.NONE;\n        this.#selectedEditors = new Set();\n        this.#selectedTextNode = null;\n        this.#pageColors = null;\n        this.#showAllStates = null;\n        this.#previousStates = {\n            isEditing: false,\n            isEmpty: true,\n            hasSomethingToUndo: false,\n            hasSomethingToRedo: false,\n            hasSelectedEditor: false,\n            hasSelectedText: false\n        };\n        this.#translation = [\n            0,\n            0\n        ];\n        this.#translationTimeoutId = null;\n        this.#container = null;\n        this.#viewer = null;\n        this.#updateModeCapability = null;\n        const signal = this._signal = this.#abortController.signal;\n        this.#container = container;\n        this.#viewer = viewer;\n        this.#altTextManager = altTextManager;\n        this._eventBus = eventBus;\n        eventBus._on(\"editingaction\", this.onEditingAction.bind(this), {\n            signal\n        });\n        eventBus._on(\"pagechanging\", this.onPageChanging.bind(this), {\n            signal\n        });\n        eventBus._on(\"scalechanging\", this.onScaleChanging.bind(this), {\n            signal\n        });\n        eventBus._on(\"rotationchanging\", this.onRotationChanging.bind(this), {\n            signal\n        });\n        eventBus._on(\"setpreference\", this.onSetPreference.bind(this), {\n            signal\n        });\n        eventBus._on(\"switchannotationeditorparams\", (evt)=>this.updateParams(evt.type, evt.value), {\n            signal\n        });\n        this.#addSelectionListener();\n        this.#addDragAndDropListeners();\n        this.#addKeyboardManager();\n        this.#annotationStorage = pdfDocument.annotationStorage;\n        this.#filterFactory = pdfDocument.filterFactory;\n        this.#pageColors = pageColors;\n        this.#highlightColors = highlightColors || null;\n        this.#enableHighlightFloatingButton = enableHighlightFloatingButton;\n        this.#enableUpdatedAddImage = enableUpdatedAddImage;\n        this.#enableNewAltTextWhenAddingImage = enableNewAltTextWhenAddingImage;\n        this.#mlManager = mlManager || null;\n        this.viewParameters = {\n            realScale: PixelsPerInch.PDF_TO_CSS_UNITS,\n            rotation: 0\n        };\n        this.isShiftKeyDown = false;\n        this._editorUndoBar = editorUndoBar || null;\n        this._supportsPinchToZoom = supportsPinchToZoom !== false;\n    }\n    destroy() {\n        this.#updateModeCapability?.resolve();\n        this.#updateModeCapability = null;\n        this.#abortController?.abort();\n        this.#abortController = null;\n        this._signal = null;\n        for (const layer of this.#allLayers.values()){\n            layer.destroy();\n        }\n        this.#allLayers.clear();\n        this.#allEditors.clear();\n        this.#editorsToRescale.clear();\n        this.#activeEditor = null;\n        this.#selectedEditors.clear();\n        this.#commandManager.destroy();\n        this.#altTextManager?.destroy();\n        this.#highlightToolbar?.hide();\n        this.#highlightToolbar = null;\n        if (this.#focusMainContainerTimeoutId) {\n            clearTimeout(this.#focusMainContainerTimeoutId);\n            this.#focusMainContainerTimeoutId = null;\n        }\n        if (this.#translationTimeoutId) {\n            clearTimeout(this.#translationTimeoutId);\n            this.#translationTimeoutId = null;\n        }\n        this._editorUndoBar?.destroy();\n    }\n    combinedSignal(ac) {\n        return AbortSignal.any([\n            this._signal,\n            ac.signal\n        ]);\n    }\n    get mlManager() {\n        return this.#mlManager;\n    }\n    get useNewAltTextFlow() {\n        return this.#enableUpdatedAddImage;\n    }\n    get useNewAltTextWhenAddingImage() {\n        return this.#enableNewAltTextWhenAddingImage;\n    }\n    get hcmFilter() {\n        return shadow(this, \"hcmFilter\", this.#pageColors ? this.#filterFactory.addHCMFilter(this.#pageColors.foreground, this.#pageColors.background) : \"none\");\n    }\n    get direction() {\n        return shadow(this, \"direction\", getComputedStyle(this.#container).direction);\n    }\n    get highlightColors() {\n        return shadow(this, \"highlightColors\", this.#highlightColors ? new Map(this.#highlightColors.split(\",\").map((pair)=>pair.split(\"=\").map((x)=>x.trim()))) : null);\n    }\n    get highlightColorNames() {\n        return shadow(this, \"highlightColorNames\", this.highlightColors ? new Map(Array.from(this.highlightColors, (e)=>e.reverse())) : null);\n    }\n    setCurrentDrawingSession(layer) {\n        if (layer) {\n            this.unselectAll();\n            this.disableUserSelect(true);\n        } else {\n            this.disableUserSelect(false);\n        }\n        this.#currentDrawingSession = layer;\n    }\n    setMainHighlightColorPicker(colorPicker) {\n        this.#mainHighlightColorPicker = colorPicker;\n    }\n    editAltText(editor, firstTime = false) {\n        this.#altTextManager?.editAltText(this, editor, firstTime);\n    }\n    switchToMode(mode, callback) {\n        this._eventBus.on(\"annotationeditormodechanged\", callback, {\n            once: true,\n            signal: this._signal\n        });\n        this._eventBus.dispatch(\"showannotationeditorui\", {\n            source: this,\n            mode\n        });\n    }\n    setPreference(name, value) {\n        this._eventBus.dispatch(\"setpreference\", {\n            source: this,\n            name,\n            value\n        });\n    }\n    onSetPreference({ name, value }) {\n        switch(name){\n            case \"enableNewAltTextWhenAddingImage\":\n                this.#enableNewAltTextWhenAddingImage = value;\n                break;\n        }\n    }\n    onPageChanging({ pageNumber }) {\n        this.#currentPageIndex = pageNumber - 1;\n    }\n    focusMainContainer() {\n        this.#container.focus();\n    }\n    findParent(x, y) {\n        for (const layer of this.#allLayers.values()){\n            const { x: layerX, y: layerY, width, height } = layer.div.getBoundingClientRect();\n            if (x >= layerX && x <= layerX + width && y >= layerY && y <= layerY + height) {\n                return layer;\n            }\n        }\n        return null;\n    }\n    disableUserSelect(value = false) {\n        this.#viewer.classList.toggle(\"noUserSelect\", value);\n    }\n    addShouldRescale(editor) {\n        this.#editorsToRescale.add(editor);\n    }\n    removeShouldRescale(editor) {\n        this.#editorsToRescale.delete(editor);\n    }\n    onScaleChanging({ scale }) {\n        this.commitOrRemove();\n        this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;\n        for (const editor of this.#editorsToRescale){\n            editor.onScaleChanging();\n        }\n        this.#currentDrawingSession?.onScaleChanging();\n    }\n    onRotationChanging({ pagesRotation }) {\n        this.commitOrRemove();\n        this.viewParameters.rotation = pagesRotation;\n    }\n    #getAnchorElementForSelection({ anchorNode }) {\n        return anchorNode.nodeType === Node.TEXT_NODE ? anchorNode.parentElement : anchorNode;\n    }\n    #getLayerForTextLayer(textLayer) {\n        const { currentLayer } = this;\n        if (currentLayer.hasTextLayer(textLayer)) {\n            return currentLayer;\n        }\n        for (const layer of this.#allLayers.values()){\n            if (layer.hasTextLayer(textLayer)) {\n                return layer;\n            }\n        }\n        return null;\n    }\n    highlightSelection(methodOfCreation = \"\") {\n        const selection = document.getSelection();\n        if (!selection || selection.isCollapsed) {\n            return;\n        }\n        const { anchorNode, anchorOffset, focusNode, focusOffset } = selection;\n        const text = selection.toString();\n        const anchorElement = this.#getAnchorElementForSelection(selection);\n        const textLayer = anchorElement.closest(\".textLayer\");\n        const boxes = this.getSelectionBoxes(textLayer);\n        if (!boxes) {\n            return;\n        }\n        selection.empty();\n        const layer = this.#getLayerForTextLayer(textLayer);\n        const isNoneMode = this.#mode === AnnotationEditorType.NONE;\n        const callback = ()=>{\n            layer?.createAndAddNewEditor({\n                x: 0,\n                y: 0\n            }, false, {\n                methodOfCreation,\n                boxes,\n                anchorNode,\n                anchorOffset,\n                focusNode,\n                focusOffset,\n                text\n            });\n            if (isNoneMode) {\n                this.showAllEditors(\"highlight\", true, true);\n            }\n        };\n        if (isNoneMode) {\n            this.switchToMode(AnnotationEditorType.HIGHLIGHT, callback);\n            return;\n        }\n        callback();\n    }\n    #displayHighlightToolbar() {\n        const selection = document.getSelection();\n        if (!selection || selection.isCollapsed) {\n            return;\n        }\n        const anchorElement = this.#getAnchorElementForSelection(selection);\n        const textLayer = anchorElement.closest(\".textLayer\");\n        const boxes = this.getSelectionBoxes(textLayer);\n        if (!boxes) {\n            return;\n        }\n        this.#highlightToolbar ||= new HighlightToolbar(this);\n        this.#highlightToolbar.show(textLayer, boxes, this.direction === \"ltr\");\n    }\n    addToAnnotationStorage(editor) {\n        if (!editor.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor.id)) {\n            this.#annotationStorage.setValue(editor.id, editor);\n        }\n    }\n    #selectionChange() {\n        const selection = document.getSelection();\n        if (!selection || selection.isCollapsed) {\n            if (this.#selectedTextNode) {\n                this.#highlightToolbar?.hide();\n                this.#selectedTextNode = null;\n                this.#dispatchUpdateStates({\n                    hasSelectedText: false\n                });\n            }\n            return;\n        }\n        const { anchorNode } = selection;\n        if (anchorNode === this.#selectedTextNode) {\n            return;\n        }\n        const anchorElement = this.#getAnchorElementForSelection(selection);\n        const textLayer = anchorElement.closest(\".textLayer\");\n        if (!textLayer) {\n            if (this.#selectedTextNode) {\n                this.#highlightToolbar?.hide();\n                this.#selectedTextNode = null;\n                this.#dispatchUpdateStates({\n                    hasSelectedText: false\n                });\n            }\n            return;\n        }\n        this.#highlightToolbar?.hide();\n        this.#selectedTextNode = anchorNode;\n        this.#dispatchUpdateStates({\n            hasSelectedText: true\n        });\n        if (this.#mode !== AnnotationEditorType.HIGHLIGHT && this.#mode !== AnnotationEditorType.NONE) {\n            return;\n        }\n        if (this.#mode === AnnotationEditorType.HIGHLIGHT) {\n            this.showAllEditors(\"highlight\", true, true);\n        }\n        this.#highlightWhenShiftUp = this.isShiftKeyDown;\n        if (!this.isShiftKeyDown) {\n            const activeLayer = this.#mode === AnnotationEditorType.HIGHLIGHT ? this.#getLayerForTextLayer(textLayer) : null;\n            activeLayer?.toggleDrawing();\n            const ac = new AbortController();\n            const signal = this.combinedSignal(ac);\n            const pointerup = (e)=>{\n                if (e.type === \"pointerup\" && e.button !== 0) {\n                    return;\n                }\n                ac.abort();\n                activeLayer?.toggleDrawing(true);\n                if (e.type === \"pointerup\") {\n                    this.#onSelectEnd(\"main_toolbar\");\n                }\n            };\n            window.addEventListener(\"pointerup\", pointerup, {\n                signal\n            });\n            window.addEventListener(\"blur\", pointerup, {\n                signal\n            });\n        }\n    }\n    #onSelectEnd(methodOfCreation = \"\") {\n        if (this.#mode === AnnotationEditorType.HIGHLIGHT) {\n            this.highlightSelection(methodOfCreation);\n        } else if (this.#enableHighlightFloatingButton) {\n            this.#displayHighlightToolbar();\n        }\n    }\n    #addSelectionListener() {\n        document.addEventListener(\"selectionchange\", this.#selectionChange.bind(this), {\n            signal: this._signal\n        });\n    }\n    #addFocusManager() {\n        if (this.#focusManagerAC) {\n            return;\n        }\n        this.#focusManagerAC = new AbortController();\n        const signal = this.combinedSignal(this.#focusManagerAC);\n        window.addEventListener(\"focus\", this.focus.bind(this), {\n            signal\n        });\n        window.addEventListener(\"blur\", this.blur.bind(this), {\n            signal\n        });\n    }\n    #removeFocusManager() {\n        this.#focusManagerAC?.abort();\n        this.#focusManagerAC = null;\n    }\n    blur() {\n        this.isShiftKeyDown = false;\n        if (this.#highlightWhenShiftUp) {\n            this.#highlightWhenShiftUp = false;\n            this.#onSelectEnd(\"main_toolbar\");\n        }\n        if (!this.hasSelection) {\n            return;\n        }\n        const { activeElement } = document;\n        for (const editor of this.#selectedEditors){\n            if (editor.div.contains(activeElement)) {\n                this.#lastActiveElement = [\n                    editor,\n                    activeElement\n                ];\n                editor._focusEventsAllowed = false;\n                break;\n            }\n        }\n    }\n    focus() {\n        if (!this.#lastActiveElement) {\n            return;\n        }\n        const [lastEditor, lastActiveElement] = this.#lastActiveElement;\n        this.#lastActiveElement = null;\n        lastActiveElement.addEventListener(\"focusin\", ()=>{\n            lastEditor._focusEventsAllowed = true;\n        }, {\n            once: true,\n            signal: this._signal\n        });\n        lastActiveElement.focus();\n    }\n    #addKeyboardManager() {\n        if (this.#keyboardManagerAC) {\n            return;\n        }\n        this.#keyboardManagerAC = new AbortController();\n        const signal = this.combinedSignal(this.#keyboardManagerAC);\n        window.addEventListener(\"keydown\", this.keydown.bind(this), {\n            signal\n        });\n        window.addEventListener(\"keyup\", this.keyup.bind(this), {\n            signal\n        });\n    }\n    #removeKeyboardManager() {\n        this.#keyboardManagerAC?.abort();\n        this.#keyboardManagerAC = null;\n    }\n    #addCopyPasteListeners() {\n        if (this.#copyPasteAC) {\n            return;\n        }\n        this.#copyPasteAC = new AbortController();\n        const signal = this.combinedSignal(this.#copyPasteAC);\n        document.addEventListener(\"copy\", this.copy.bind(this), {\n            signal\n        });\n        document.addEventListener(\"cut\", this.cut.bind(this), {\n            signal\n        });\n        document.addEventListener(\"paste\", this.paste.bind(this), {\n            signal\n        });\n    }\n    #removeCopyPasteListeners() {\n        this.#copyPasteAC?.abort();\n        this.#copyPasteAC = null;\n    }\n    #addDragAndDropListeners() {\n        const signal = this._signal;\n        document.addEventListener(\"dragover\", this.dragOver.bind(this), {\n            signal\n        });\n        document.addEventListener(\"drop\", this.drop.bind(this), {\n            signal\n        });\n    }\n    addEditListeners() {\n        this.#addKeyboardManager();\n        this.#addCopyPasteListeners();\n    }\n    removeEditListeners() {\n        this.#removeKeyboardManager();\n        this.#removeCopyPasteListeners();\n    }\n    dragOver(event) {\n        for (const { type } of event.dataTransfer.items){\n            for (const editorType of this.#editorTypes){\n                if (editorType.isHandlingMimeForPasting(type)) {\n                    event.dataTransfer.dropEffect = \"copy\";\n                    event.preventDefault();\n                    return;\n                }\n            }\n        }\n    }\n    drop(event) {\n        for (const item of event.dataTransfer.items){\n            for (const editorType of this.#editorTypes){\n                if (editorType.isHandlingMimeForPasting(item.type)) {\n                    editorType.paste(item, this.currentLayer);\n                    event.preventDefault();\n                    return;\n                }\n            }\n        }\n    }\n    copy(event) {\n        event.preventDefault();\n        this.#activeEditor?.commitOrRemove();\n        if (!this.hasSelection) {\n            return;\n        }\n        const editors = [];\n        for (const editor of this.#selectedEditors){\n            const serialized = editor.serialize(true);\n            if (serialized) {\n                editors.push(serialized);\n            }\n        }\n        if (editors.length === 0) {\n            return;\n        }\n        event.clipboardData.setData(\"application/pdfjs\", JSON.stringify(editors));\n    }\n    cut(event) {\n        this.copy(event);\n        this.delete();\n    }\n    async paste(event) {\n        event.preventDefault();\n        const { clipboardData } = event;\n        for (const item of clipboardData.items){\n            for (const editorType of this.#editorTypes){\n                if (editorType.isHandlingMimeForPasting(item.type)) {\n                    editorType.paste(item, this.currentLayer);\n                    return;\n                }\n            }\n        }\n        let data = clipboardData.getData(\"application/pdfjs\");\n        if (!data) {\n            return;\n        }\n        try {\n            data = JSON.parse(data);\n        } catch (ex) {\n            warn(`paste: \"${ex.message}\".`);\n            return;\n        }\n        if (!Array.isArray(data)) {\n            return;\n        }\n        this.unselectAll();\n        const layer = this.currentLayer;\n        try {\n            const newEditors = [];\n            for (const editor of data){\n                const deserializedEditor = await layer.deserialize(editor);\n                if (!deserializedEditor) {\n                    return;\n                }\n                newEditors.push(deserializedEditor);\n            }\n            const cmd = ()=>{\n                for (const editor of newEditors){\n                    this.#addEditorToLayer(editor);\n                }\n                this.#selectEditors(newEditors);\n            };\n            const undo = ()=>{\n                for (const editor of newEditors){\n                    editor.remove();\n                }\n            };\n            this.addCommands({\n                cmd,\n                undo,\n                mustExec: true\n            });\n        } catch (ex) {\n            warn(`paste: \"${ex.message}\".`);\n        }\n    }\n    keydown(event) {\n        if (!this.isShiftKeyDown && event.key === \"Shift\") {\n            this.isShiftKeyDown = true;\n        }\n        if (this.#mode !== AnnotationEditorType.NONE && !this.isEditorHandlingKeyboard) {\n            AnnotationEditorUIManager._keyboardManager.exec(this, event);\n        }\n    }\n    keyup(event) {\n        if (this.isShiftKeyDown && event.key === \"Shift\") {\n            this.isShiftKeyDown = false;\n            if (this.#highlightWhenShiftUp) {\n                this.#highlightWhenShiftUp = false;\n                this.#onSelectEnd(\"main_toolbar\");\n            }\n        }\n    }\n    onEditingAction({ name }) {\n        switch(name){\n            case \"undo\":\n            case \"redo\":\n            case \"delete\":\n            case \"selectAll\":\n                this[name]();\n                break;\n            case \"highlightSelection\":\n                this.highlightSelection(\"context_menu\");\n                break;\n        }\n    }\n    #dispatchUpdateStates(details) {\n        const hasChanged = Object.entries(details).some(([key, value])=>this.#previousStates[key] !== value);\n        if (hasChanged) {\n            this._eventBus.dispatch(\"annotationeditorstateschanged\", {\n                source: this,\n                details: Object.assign(this.#previousStates, details)\n            });\n            if (this.#mode === AnnotationEditorType.HIGHLIGHT && details.hasSelectedEditor === false) {\n                this.#dispatchUpdateUI([\n                    [\n                        AnnotationEditorParamsType.HIGHLIGHT_FREE,\n                        true\n                    ]\n                ]);\n            }\n        }\n    }\n    #dispatchUpdateUI(details) {\n        this._eventBus.dispatch(\"annotationeditorparamschanged\", {\n            source: this,\n            details\n        });\n    }\n    setEditingState(isEditing) {\n        if (isEditing) {\n            this.#addFocusManager();\n            this.#addCopyPasteListeners();\n            this.#dispatchUpdateStates({\n                isEditing: this.#mode !== AnnotationEditorType.NONE,\n                isEmpty: this.#isEmpty(),\n                hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n                hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n                hasSelectedEditor: false\n            });\n        } else {\n            this.#removeFocusManager();\n            this.#removeCopyPasteListeners();\n            this.#dispatchUpdateStates({\n                isEditing: false\n            });\n            this.disableUserSelect(false);\n        }\n    }\n    registerEditorTypes(types) {\n        if (this.#editorTypes) {\n            return;\n        }\n        this.#editorTypes = types;\n        for (const editorType of this.#editorTypes){\n            this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n        }\n    }\n    getId() {\n        return this.#idManager.id;\n    }\n    get currentLayer() {\n        return this.#allLayers.get(this.#currentPageIndex);\n    }\n    getLayer(pageIndex) {\n        return this.#allLayers.get(pageIndex);\n    }\n    get currentPageIndex() {\n        return this.#currentPageIndex;\n    }\n    addLayer(layer) {\n        this.#allLayers.set(layer.pageIndex, layer);\n        if (this.#isEnabled) {\n            layer.enable();\n        } else {\n            layer.disable();\n        }\n    }\n    removeLayer(layer) {\n        this.#allLayers.delete(layer.pageIndex);\n    }\n    async updateMode(mode, editId = null, isFromKeyboard = false) {\n        if (this.#mode === mode) {\n            return;\n        }\n        if (this.#updateModeCapability) {\n            await this.#updateModeCapability.promise;\n            if (!this.#updateModeCapability) {\n                return;\n            }\n        }\n        this.#updateModeCapability = Promise.withResolvers();\n        this.#mode = mode;\n        if (mode === AnnotationEditorType.NONE) {\n            this.setEditingState(false);\n            this.#disableAll();\n            this._editorUndoBar?.hide();\n            this.#updateModeCapability.resolve();\n            return;\n        }\n        this.setEditingState(true);\n        await this.#enableAll();\n        this.unselectAll();\n        for (const layer of this.#allLayers.values()){\n            layer.updateMode(mode);\n        }\n        if (!editId) {\n            if (isFromKeyboard) {\n                this.addNewEditorFromKeyboard();\n            }\n            this.#updateModeCapability.resolve();\n            return;\n        }\n        for (const editor of this.#allEditors.values()){\n            if (editor.annotationElementId === editId) {\n                this.setSelected(editor);\n                editor.enterInEditMode();\n            } else {\n                editor.unselect();\n            }\n        }\n        this.#updateModeCapability.resolve();\n    }\n    addNewEditorFromKeyboard() {\n        if (this.currentLayer.canCreateNewEmptyEditor()) {\n            this.currentLayer.addNewEditor();\n        }\n    }\n    updateToolbar(mode) {\n        if (mode === this.#mode) {\n            return;\n        }\n        this._eventBus.dispatch(\"switchannotationeditormode\", {\n            source: this,\n            mode\n        });\n    }\n    updateParams(type, value) {\n        if (!this.#editorTypes) {\n            return;\n        }\n        switch(type){\n            case AnnotationEditorParamsType.CREATE:\n                this.currentLayer.addNewEditor();\n                return;\n            case AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR:\n                this.#mainHighlightColorPicker?.updateColor(value);\n                break;\n            case AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL:\n                this._eventBus.dispatch(\"reporttelemetry\", {\n                    source: this,\n                    details: {\n                        type: \"editing\",\n                        data: {\n                            type: \"highlight\",\n                            action: \"toggle_visibility\"\n                        }\n                    }\n                });\n                (this.#showAllStates ||= new Map()).set(type, value);\n                this.showAllEditors(\"highlight\", value);\n                break;\n        }\n        for (const editor of this.#selectedEditors){\n            editor.updateParams(type, value);\n        }\n        for (const editorType of this.#editorTypes){\n            editorType.updateDefaultParams(type, value);\n        }\n    }\n    showAllEditors(type, visible, updateButton = false) {\n        for (const editor of this.#allEditors.values()){\n            if (editor.editorType === type) {\n                editor.show(visible);\n            }\n        }\n        const state = this.#showAllStates?.get(AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL) ?? true;\n        if (state !== visible) {\n            this.#dispatchUpdateUI([\n                [\n                    AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL,\n                    visible\n                ]\n            ]);\n        }\n    }\n    enableWaiting(mustWait = false) {\n        if (this.#isWaiting === mustWait) {\n            return;\n        }\n        this.#isWaiting = mustWait;\n        for (const layer of this.#allLayers.values()){\n            if (mustWait) {\n                layer.disableClick();\n            } else {\n                layer.enableClick();\n            }\n            layer.div.classList.toggle(\"waiting\", mustWait);\n        }\n    }\n    async #enableAll() {\n        if (!this.#isEnabled) {\n            this.#isEnabled = true;\n            const promises = [];\n            for (const layer of this.#allLayers.values()){\n                promises.push(layer.enable());\n            }\n            await Promise.all(promises);\n            for (const editor of this.#allEditors.values()){\n                editor.enable();\n            }\n        }\n    }\n    #disableAll() {\n        this.unselectAll();\n        if (this.#isEnabled) {\n            this.#isEnabled = false;\n            for (const layer of this.#allLayers.values()){\n                layer.disable();\n            }\n            for (const editor of this.#allEditors.values()){\n                editor.disable();\n            }\n        }\n    }\n    getEditors(pageIndex) {\n        const editors = [];\n        for (const editor of this.#allEditors.values()){\n            if (editor.pageIndex === pageIndex) {\n                editors.push(editor);\n            }\n        }\n        return editors;\n    }\n    getEditor(id) {\n        return this.#allEditors.get(id);\n    }\n    addEditor(editor) {\n        this.#allEditors.set(editor.id, editor);\n    }\n    removeEditor(editor) {\n        if (editor.div.contains(document.activeElement)) {\n            if (this.#focusMainContainerTimeoutId) {\n                clearTimeout(this.#focusMainContainerTimeoutId);\n            }\n            this.#focusMainContainerTimeoutId = setTimeout(()=>{\n                this.focusMainContainer();\n                this.#focusMainContainerTimeoutId = null;\n            }, 0);\n        }\n        this.#allEditors.delete(editor.id);\n        this.unselect(editor);\n        if (!editor.annotationElementId || !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)) {\n            this.#annotationStorage?.remove(editor.id);\n        }\n    }\n    addDeletedAnnotationElement(editor) {\n        this.#deletedAnnotationsElementIds.add(editor.annotationElementId);\n        this.addChangedExistingAnnotation(editor);\n        editor.deleted = true;\n    }\n    isDeletedAnnotationElement(annotationElementId) {\n        return this.#deletedAnnotationsElementIds.has(annotationElementId);\n    }\n    removeDeletedAnnotationElement(editor) {\n        this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);\n        this.removeChangedExistingAnnotation(editor);\n        editor.deleted = false;\n    }\n    #addEditorToLayer(editor) {\n        const layer = this.#allLayers.get(editor.pageIndex);\n        if (layer) {\n            layer.addOrRebuild(editor);\n        } else {\n            this.addEditor(editor);\n            this.addToAnnotationStorage(editor);\n        }\n    }\n    setActiveEditor(editor) {\n        if (this.#activeEditor === editor) {\n            return;\n        }\n        this.#activeEditor = editor;\n        if (editor) {\n            this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        }\n    }\n    get #lastSelectedEditor() {\n        let ed = null;\n        for (ed of this.#selectedEditors){}\n        return ed;\n    }\n    updateUI(editor) {\n        if (this.#lastSelectedEditor === editor) {\n            this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        }\n    }\n    updateUIForDefaultProperties(editorType) {\n        this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n    }\n    toggleSelected(editor) {\n        if (this.#selectedEditors.has(editor)) {\n            this.#selectedEditors.delete(editor);\n            editor.unselect();\n            this.#dispatchUpdateStates({\n                hasSelectedEditor: this.hasSelection\n            });\n            return;\n        }\n        this.#selectedEditors.add(editor);\n        editor.select();\n        this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: true\n        });\n    }\n    setSelected(editor) {\n        this.#currentDrawingSession?.commitOrRemove();\n        for (const ed of this.#selectedEditors){\n            if (ed !== editor) {\n                ed.unselect();\n            }\n        }\n        this.#selectedEditors.clear();\n        this.#selectedEditors.add(editor);\n        editor.select();\n        this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: true\n        });\n    }\n    isSelected(editor) {\n        return this.#selectedEditors.has(editor);\n    }\n    get firstSelectedEditor() {\n        return this.#selectedEditors.values().next().value;\n    }\n    unselect(editor) {\n        editor.unselect();\n        this.#selectedEditors.delete(editor);\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: this.hasSelection\n        });\n    }\n    get hasSelection() {\n        return this.#selectedEditors.size !== 0;\n    }\n    get isEnterHandled() {\n        return this.#selectedEditors.size === 1 && this.firstSelectedEditor.isEnterHandled;\n    }\n    undo() {\n        this.#commandManager.undo();\n        this.#dispatchUpdateStates({\n            hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n            hasSomethingToRedo: true,\n            isEmpty: this.#isEmpty()\n        });\n        this._editorUndoBar?.hide();\n    }\n    redo() {\n        this.#commandManager.redo();\n        this.#dispatchUpdateStates({\n            hasSomethingToUndo: true,\n            hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n            isEmpty: this.#isEmpty()\n        });\n    }\n    addCommands(params) {\n        this.#commandManager.add(params);\n        this.#dispatchUpdateStates({\n            hasSomethingToUndo: true,\n            hasSomethingToRedo: false,\n            isEmpty: this.#isEmpty()\n        });\n    }\n    cleanUndoStack(type) {\n        this.#commandManager.cleanType(type);\n    }\n    #isEmpty() {\n        if (this.#allEditors.size === 0) {\n            return true;\n        }\n        if (this.#allEditors.size === 1) {\n            for (const editor of this.#allEditors.values()){\n                return editor.isEmpty();\n            }\n        }\n        return false;\n    }\n    delete() {\n        this.commitOrRemove();\n        const drawingEditor = this.currentLayer?.endDrawingSession(true);\n        if (!this.hasSelection && !drawingEditor) {\n            return;\n        }\n        const editors = drawingEditor ? [\n            drawingEditor\n        ] : [\n            ...this.#selectedEditors\n        ];\n        const cmd = ()=>{\n            this._editorUndoBar?.show(undo, editors.length === 1 ? editors[0].editorType : editors.length);\n            for (const editor of editors){\n                editor.remove();\n            }\n        };\n        const undo = ()=>{\n            for (const editor of editors){\n                this.#addEditorToLayer(editor);\n            }\n        };\n        this.addCommands({\n            cmd,\n            undo,\n            mustExec: true\n        });\n    }\n    commitOrRemove() {\n        this.#activeEditor?.commitOrRemove();\n    }\n    hasSomethingToControl() {\n        return this.#activeEditor || this.hasSelection;\n    }\n    #selectEditors(editors) {\n        for (const editor of this.#selectedEditors){\n            editor.unselect();\n        }\n        this.#selectedEditors.clear();\n        for (const editor of editors){\n            if (editor.isEmpty()) {\n                continue;\n            }\n            this.#selectedEditors.add(editor);\n            editor.select();\n        }\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: this.hasSelection\n        });\n    }\n    selectAll() {\n        for (const editor of this.#selectedEditors){\n            editor.commit();\n        }\n        this.#selectEditors(this.#allEditors.values());\n    }\n    unselectAll() {\n        if (this.#activeEditor) {\n            this.#activeEditor.commitOrRemove();\n            if (this.#mode !== AnnotationEditorType.NONE) {\n                return;\n            }\n        }\n        if (this.#currentDrawingSession?.commitOrRemove()) {\n            return;\n        }\n        if (!this.hasSelection) {\n            return;\n        }\n        for (const editor of this.#selectedEditors){\n            editor.unselect();\n        }\n        this.#selectedEditors.clear();\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: false\n        });\n    }\n    translateSelectedEditors(x, y, noCommit = false) {\n        if (!noCommit) {\n            this.commitOrRemove();\n        }\n        if (!this.hasSelection) {\n            return;\n        }\n        this.#translation[0] += x;\n        this.#translation[1] += y;\n        const [totalX, totalY] = this.#translation;\n        const editors = [\n            ...this.#selectedEditors\n        ];\n        const TIME_TO_WAIT = 1000;\n        if (this.#translationTimeoutId) {\n            clearTimeout(this.#translationTimeoutId);\n        }\n        this.#translationTimeoutId = setTimeout(()=>{\n            this.#translationTimeoutId = null;\n            this.#translation[0] = this.#translation[1] = 0;\n            this.addCommands({\n                cmd: ()=>{\n                    for (const editor of editors){\n                        if (this.#allEditors.has(editor.id)) {\n                            editor.translateInPage(totalX, totalY);\n                        }\n                    }\n                },\n                undo: ()=>{\n                    for (const editor of editors){\n                        if (this.#allEditors.has(editor.id)) {\n                            editor.translateInPage(-totalX, -totalY);\n                        }\n                    }\n                },\n                mustExec: false\n            });\n        }, TIME_TO_WAIT);\n        for (const editor of editors){\n            editor.translateInPage(x, y);\n        }\n    }\n    setUpDragSession() {\n        if (!this.hasSelection) {\n            return;\n        }\n        this.disableUserSelect(true);\n        this.#draggingEditors = new Map();\n        for (const editor of this.#selectedEditors){\n            this.#draggingEditors.set(editor, {\n                savedX: editor.x,\n                savedY: editor.y,\n                savedPageIndex: editor.pageIndex,\n                newX: 0,\n                newY: 0,\n                newPageIndex: -1\n            });\n        }\n    }\n    endDragSession() {\n        if (!this.#draggingEditors) {\n            return false;\n        }\n        this.disableUserSelect(false);\n        const map = this.#draggingEditors;\n        this.#draggingEditors = null;\n        let mustBeAddedInUndoStack = false;\n        for (const [{ x, y, pageIndex }, value] of map){\n            value.newX = x;\n            value.newY = y;\n            value.newPageIndex = pageIndex;\n            mustBeAddedInUndoStack ||= x !== value.savedX || y !== value.savedY || pageIndex !== value.savedPageIndex;\n        }\n        if (!mustBeAddedInUndoStack) {\n            return false;\n        }\n        const move = (editor, x, y, pageIndex)=>{\n            if (this.#allEditors.has(editor.id)) {\n                const parent = this.#allLayers.get(pageIndex);\n                if (parent) {\n                    editor._setParentAndPosition(parent, x, y);\n                } else {\n                    editor.pageIndex = pageIndex;\n                    editor.x = x;\n                    editor.y = y;\n                }\n            }\n        };\n        this.addCommands({\n            cmd: ()=>{\n                for (const [editor, { newX, newY, newPageIndex }] of map){\n                    move(editor, newX, newY, newPageIndex);\n                }\n            },\n            undo: ()=>{\n                for (const [editor, { savedX, savedY, savedPageIndex }] of map){\n                    move(editor, savedX, savedY, savedPageIndex);\n                }\n            },\n            mustExec: true\n        });\n        return true;\n    }\n    dragSelectedEditors(tx, ty) {\n        if (!this.#draggingEditors) {\n            return;\n        }\n        for (const editor of this.#draggingEditors.keys()){\n            editor.drag(tx, ty);\n        }\n    }\n    rebuild(editor) {\n        if (editor.parent === null) {\n            const parent = this.getLayer(editor.pageIndex);\n            if (parent) {\n                parent.changeParent(editor);\n                parent.addOrRebuild(editor);\n            } else {\n                this.addEditor(editor);\n                this.addToAnnotationStorage(editor);\n                editor.rebuild();\n            }\n        } else {\n            editor.parent.addOrRebuild(editor);\n        }\n    }\n    get isEditorHandlingKeyboard() {\n        return this.getActive()?.shouldGetKeyboardEvents() || this.#selectedEditors.size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();\n    }\n    isActive(editor) {\n        return this.#activeEditor === editor;\n    }\n    getActive() {\n        return this.#activeEditor;\n    }\n    getMode() {\n        return this.#mode;\n    }\n    get imageManager() {\n        return shadow(this, \"imageManager\", new ImageManager());\n    }\n    getSelectionBoxes(textLayer) {\n        if (!textLayer) {\n            return null;\n        }\n        const selection = document.getSelection();\n        for(let i = 0, ii = selection.rangeCount; i < ii; i++){\n            if (!textLayer.contains(selection.getRangeAt(i).commonAncestorContainer)) {\n                return null;\n            }\n        }\n        const { x: layerX, y: layerY, width: parentWidth, height: parentHeight } = textLayer.getBoundingClientRect();\n        let rotator;\n        switch(textLayer.getAttribute(\"data-main-rotation\")){\n            case \"90\":\n                rotator = (x, y, w, h)=>({\n                        x: (y - layerY) / parentHeight,\n                        y: 1 - (x + w - layerX) / parentWidth,\n                        width: h / parentHeight,\n                        height: w / parentWidth\n                    });\n                break;\n            case \"180\":\n                rotator = (x, y, w, h)=>({\n                        x: 1 - (x + w - layerX) / parentWidth,\n                        y: 1 - (y + h - layerY) / parentHeight,\n                        width: w / parentWidth,\n                        height: h / parentHeight\n                    });\n                break;\n            case \"270\":\n                rotator = (x, y, w, h)=>({\n                        x: 1 - (y + h - layerY) / parentHeight,\n                        y: (x - layerX) / parentWidth,\n                        width: h / parentHeight,\n                        height: w / parentWidth\n                    });\n                break;\n            default:\n                rotator = (x, y, w, h)=>({\n                        x: (x - layerX) / parentWidth,\n                        y: (y - layerY) / parentHeight,\n                        width: w / parentWidth,\n                        height: h / parentHeight\n                    });\n                break;\n        }\n        const boxes = [];\n        for(let i = 0, ii = selection.rangeCount; i < ii; i++){\n            const range = selection.getRangeAt(i);\n            if (range.collapsed) {\n                continue;\n            }\n            for (const { x, y, width, height } of range.getClientRects()){\n                if (width === 0 || height === 0) {\n                    continue;\n                }\n                boxes.push(rotator(x, y, width, height));\n            }\n        }\n        return boxes.length === 0 ? null : boxes;\n    }\n    addChangedExistingAnnotation({ annotationElementId, id }) {\n        (this.#changedExistingAnnotations ||= new Map()).set(annotationElementId, id);\n    }\n    removeChangedExistingAnnotation({ annotationElementId }) {\n        this.#changedExistingAnnotations?.delete(annotationElementId);\n    }\n    renderAnnotationElement(annotation) {\n        const editorId = this.#changedExistingAnnotations?.get(annotation.data.id);\n        if (!editorId) {\n            return;\n        }\n        const editor = this.#annotationStorage.getRawValue(editorId);\n        if (!editor) {\n            return;\n        }\n        if (this.#mode === AnnotationEditorType.NONE && !editor.hasBeenModified) {\n            return;\n        }\n        editor.renderAnnotationElement(annotation);\n    }\n}\n; // ./src/display/editor/alt_text.js\nclass AltText {\n    #altText;\n    #altTextDecorative;\n    #altTextButton;\n    #altTextButtonLabel;\n    #altTextTooltip;\n    #altTextTooltipTimeout;\n    #altTextWasFromKeyBoard;\n    #badge;\n    #editor;\n    #guessedText;\n    #textWithDisclaimer;\n    #useNewAltTextFlow;\n    static #l10nNewButton = null;\n    static{\n        this._l10n = null;\n    }\n    constructor(editor){\n        this.#altText = null;\n        this.#altTextDecorative = false;\n        this.#altTextButton = null;\n        this.#altTextButtonLabel = null;\n        this.#altTextTooltip = null;\n        this.#altTextTooltipTimeout = null;\n        this.#altTextWasFromKeyBoard = false;\n        this.#badge = null;\n        this.#editor = null;\n        this.#guessedText = null;\n        this.#textWithDisclaimer = null;\n        this.#useNewAltTextFlow = false;\n        this.#editor = editor;\n        this.#useNewAltTextFlow = editor._uiManager.useNewAltTextFlow;\n        AltText.#l10nNewButton ||= Object.freeze({\n            added: \"pdfjs-editor-new-alt-text-added-button\",\n            \"added-label\": \"pdfjs-editor-new-alt-text-added-button-label\",\n            missing: \"pdfjs-editor-new-alt-text-missing-button\",\n            \"missing-label\": \"pdfjs-editor-new-alt-text-missing-button-label\",\n            review: \"pdfjs-editor-new-alt-text-to-review-button\",\n            \"review-label\": \"pdfjs-editor-new-alt-text-to-review-button-label\"\n        });\n    }\n    static initialize(l10n) {\n        AltText._l10n ??= l10n;\n    }\n    async render() {\n        const altText = this.#altTextButton = document.createElement(\"button\");\n        altText.className = \"altText\";\n        altText.tabIndex = \"0\";\n        const label = this.#altTextButtonLabel = document.createElement(\"span\");\n        altText.append(label);\n        if (this.#useNewAltTextFlow) {\n            altText.classList.add(\"new\");\n            altText.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton.missing);\n            label.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[\"missing-label\"]);\n        } else {\n            altText.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-button\");\n            label.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-button-label\");\n        }\n        const signal = this.#editor._uiManager._signal;\n        altText.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        altText.addEventListener(\"pointerdown\", (event)=>event.stopPropagation(), {\n            signal\n        });\n        const onClick = (event)=>{\n            event.preventDefault();\n            this.#editor._uiManager.editAltText(this.#editor);\n            if (this.#useNewAltTextFlow) {\n                this.#editor._reportTelemetry({\n                    action: \"pdfjs.image.alt_text.image_status_label_clicked\",\n                    data: {\n                        label: this.#label\n                    }\n                });\n            }\n        };\n        altText.addEventListener(\"click\", onClick, {\n            capture: true,\n            signal\n        });\n        altText.addEventListener(\"keydown\", (event)=>{\n            if (event.target === altText && event.key === \"Enter\") {\n                this.#altTextWasFromKeyBoard = true;\n                onClick(event);\n            }\n        }, {\n            signal\n        });\n        await this.#setState();\n        return altText;\n    }\n    get #label() {\n        return this.#altText && \"added\" || this.#altText === null && this.guessedText && \"review\" || \"missing\";\n    }\n    finish() {\n        if (!this.#altTextButton) {\n            return;\n        }\n        this.#altTextButton.focus({\n            focusVisible: this.#altTextWasFromKeyBoard\n        });\n        this.#altTextWasFromKeyBoard = false;\n    }\n    isEmpty() {\n        if (this.#useNewAltTextFlow) {\n            return this.#altText === null;\n        }\n        return !this.#altText && !this.#altTextDecorative;\n    }\n    hasData() {\n        if (this.#useNewAltTextFlow) {\n            return this.#altText !== null || !!this.#guessedText;\n        }\n        return this.isEmpty();\n    }\n    get guessedText() {\n        return this.#guessedText;\n    }\n    async setGuessedText(guessedText) {\n        if (this.#altText !== null) {\n            return;\n        }\n        this.#guessedText = guessedText;\n        this.#textWithDisclaimer = await AltText._l10n.get(\"pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer\", {\n            generatedAltText: guessedText\n        });\n        this.#setState();\n    }\n    toggleAltTextBadge(visibility = false) {\n        if (!this.#useNewAltTextFlow || this.#altText) {\n            this.#badge?.remove();\n            this.#badge = null;\n            return;\n        }\n        if (!this.#badge) {\n            const badge = this.#badge = document.createElement(\"div\");\n            badge.className = \"noAltTextBadge\";\n            this.#editor.div.append(badge);\n        }\n        this.#badge.classList.toggle(\"hidden\", !visibility);\n    }\n    serialize(isForCopying) {\n        let altText = this.#altText;\n        if (!isForCopying && this.#guessedText === altText) {\n            altText = this.#textWithDisclaimer;\n        }\n        return {\n            altText,\n            decorative: this.#altTextDecorative,\n            guessedText: this.#guessedText,\n            textWithDisclaimer: this.#textWithDisclaimer\n        };\n    }\n    get data() {\n        return {\n            altText: this.#altText,\n            decorative: this.#altTextDecorative\n        };\n    }\n    set data({ altText, decorative, guessedText, textWithDisclaimer, cancel = false }) {\n        if (guessedText) {\n            this.#guessedText = guessedText;\n            this.#textWithDisclaimer = textWithDisclaimer;\n        }\n        if (this.#altText === altText && this.#altTextDecorative === decorative) {\n            return;\n        }\n        if (!cancel) {\n            this.#altText = altText;\n            this.#altTextDecorative = decorative;\n        }\n        this.#setState();\n    }\n    toggle(enabled = false) {\n        if (!this.#altTextButton) {\n            return;\n        }\n        if (!enabled && this.#altTextTooltipTimeout) {\n            clearTimeout(this.#altTextTooltipTimeout);\n            this.#altTextTooltipTimeout = null;\n        }\n        this.#altTextButton.disabled = !enabled;\n    }\n    shown() {\n        this.#editor._reportTelemetry({\n            action: \"pdfjs.image.alt_text.image_status_label_displayed\",\n            data: {\n                label: this.#label\n            }\n        });\n    }\n    destroy() {\n        this.#altTextButton?.remove();\n        this.#altTextButton = null;\n        this.#altTextButtonLabel = null;\n        this.#altTextTooltip = null;\n        this.#badge?.remove();\n        this.#badge = null;\n    }\n    async #setState() {\n        const button = this.#altTextButton;\n        if (!button) {\n            return;\n        }\n        if (this.#useNewAltTextFlow) {\n            button.classList.toggle(\"done\", !!this.#altText);\n            button.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[this.#label]);\n            this.#altTextButtonLabel?.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[`${this.#label}-label`]);\n            if (!this.#altText) {\n                this.#altTextTooltip?.remove();\n                return;\n            }\n        } else {\n            if (!this.#altText && !this.#altTextDecorative) {\n                button.classList.remove(\"done\");\n                this.#altTextTooltip?.remove();\n                return;\n            }\n            button.classList.add(\"done\");\n            button.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-edit-button\");\n        }\n        let tooltip = this.#altTextTooltip;\n        if (!tooltip) {\n            this.#altTextTooltip = tooltip = document.createElement(\"span\");\n            tooltip.className = \"tooltip\";\n            tooltip.setAttribute(\"role\", \"tooltip\");\n            tooltip.id = `alt-text-tooltip-${this.#editor.id}`;\n            const DELAY_TO_SHOW_TOOLTIP = 100;\n            const signal = this.#editor._uiManager._signal;\n            signal.addEventListener(\"abort\", ()=>{\n                clearTimeout(this.#altTextTooltipTimeout);\n                this.#altTextTooltipTimeout = null;\n            }, {\n                once: true\n            });\n            button.addEventListener(\"mouseenter\", ()=>{\n                this.#altTextTooltipTimeout = setTimeout(()=>{\n                    this.#altTextTooltipTimeout = null;\n                    this.#altTextTooltip.classList.add(\"show\");\n                    this.#editor._reportTelemetry({\n                        action: \"alt_text_tooltip\"\n                    });\n                }, DELAY_TO_SHOW_TOOLTIP);\n            }, {\n                signal\n            });\n            button.addEventListener(\"mouseleave\", ()=>{\n                if (this.#altTextTooltipTimeout) {\n                    clearTimeout(this.#altTextTooltipTimeout);\n                    this.#altTextTooltipTimeout = null;\n                }\n                this.#altTextTooltip?.classList.remove(\"show\");\n            }, {\n                signal\n            });\n        }\n        if (this.#altTextDecorative) {\n            tooltip.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-decorative-tooltip\");\n        } else {\n            tooltip.removeAttribute(\"data-l10n-id\");\n            tooltip.textContent = this.#altText;\n        }\n        if (!tooltip.parentNode) {\n            button.append(tooltip);\n        }\n        const element = this.#editor.getImageForAltText();\n        element?.setAttribute(\"aria-describedby\", tooltip.id);\n    }\n}\n; // ./src/display/touch_manager.js\nclass TouchManager {\n    #container;\n    #isPinching;\n    #isPinchingStopped;\n    #isPinchingDisabled;\n    #onPinchStart;\n    #onPinching;\n    #onPinchEnd;\n    #signal;\n    #touchInfo;\n    #touchManagerAC;\n    #touchMoveAC;\n    constructor({ container, isPinchingDisabled = null, isPinchingStopped = null, onPinchStart = null, onPinching = null, onPinchEnd = null, signal }){\n        this.#isPinching = false;\n        this.#isPinchingStopped = null;\n        this.#touchInfo = null;\n        this.#touchMoveAC = null;\n        this.#container = container;\n        this.#isPinchingStopped = isPinchingStopped;\n        this.#isPinchingDisabled = isPinchingDisabled;\n        this.#onPinchStart = onPinchStart;\n        this.#onPinching = onPinching;\n        this.#onPinchEnd = onPinchEnd;\n        this.#touchManagerAC = new AbortController();\n        this.#signal = AbortSignal.any([\n            signal,\n            this.#touchManagerAC.signal\n        ]);\n        container.addEventListener(\"touchstart\", this.#onTouchStart.bind(this), {\n            passive: false,\n            signal: this.#signal\n        });\n    }\n    get MIN_TOUCH_DISTANCE_TO_PINCH() {\n        return shadow(this, \"MIN_TOUCH_DISTANCE_TO_PINCH\", 35 / (window.devicePixelRatio || 1));\n    }\n    #onTouchStart(evt) {\n        if (this.#isPinchingDisabled?.() || evt.touches.length < 2) {\n            return;\n        }\n        if (!this.#touchMoveAC) {\n            this.#touchMoveAC = new AbortController();\n            const signal = AbortSignal.any([\n                this.#signal,\n                this.#touchMoveAC.signal\n            ]);\n            const container = this.#container;\n            const opt = {\n                signal,\n                passive: false\n            };\n            container.addEventListener(\"touchmove\", this.#onTouchMove.bind(this), opt);\n            container.addEventListener(\"touchend\", this.#onTouchEnd.bind(this), opt);\n            container.addEventListener(\"touchcancel\", this.#onTouchEnd.bind(this), opt);\n            this.#onPinchStart?.();\n        }\n        stopEvent(evt);\n        if (evt.touches.length !== 2 || this.#isPinchingStopped?.()) {\n            this.#touchInfo = null;\n            return;\n        }\n        let [touch0, touch1] = evt.touches;\n        if (touch0.identifier > touch1.identifier) {\n            [touch0, touch1] = [\n                touch1,\n                touch0\n            ];\n        }\n        this.#touchInfo = {\n            touch0X: touch0.screenX,\n            touch0Y: touch0.screenY,\n            touch1X: touch1.screenX,\n            touch1Y: touch1.screenY\n        };\n    }\n    #onTouchMove(evt) {\n        if (!this.#touchInfo || evt.touches.length !== 2) {\n            return;\n        }\n        let [touch0, touch1] = evt.touches;\n        if (touch0.identifier > touch1.identifier) {\n            [touch0, touch1] = [\n                touch1,\n                touch0\n            ];\n        }\n        const { screenX: screen0X, screenY: screen0Y } = touch0;\n        const { screenX: screen1X, screenY: screen1Y } = touch1;\n        const touchInfo = this.#touchInfo;\n        const { touch0X: pTouch0X, touch0Y: pTouch0Y, touch1X: pTouch1X, touch1Y: pTouch1Y } = touchInfo;\n        const prevGapX = pTouch1X - pTouch0X;\n        const prevGapY = pTouch1Y - pTouch0Y;\n        const currGapX = screen1X - screen0X;\n        const currGapY = screen1Y - screen0Y;\n        const distance = Math.hypot(currGapX, currGapY) || 1;\n        const pDistance = Math.hypot(prevGapX, prevGapY) || 1;\n        if (!this.#isPinching && Math.abs(pDistance - distance) <= TouchManager.MIN_TOUCH_DISTANCE_TO_PINCH) {\n            return;\n        }\n        touchInfo.touch0X = screen0X;\n        touchInfo.touch0Y = screen0Y;\n        touchInfo.touch1X = screen1X;\n        touchInfo.touch1Y = screen1Y;\n        evt.preventDefault();\n        if (!this.#isPinching) {\n            this.#isPinching = true;\n            return;\n        }\n        const origin = [\n            (screen0X + screen1X) / 2,\n            (screen0Y + screen1Y) / 2\n        ];\n        this.#onPinching?.(origin, pDistance, distance);\n    }\n    #onTouchEnd(evt) {\n        this.#touchMoveAC.abort();\n        this.#touchMoveAC = null;\n        this.#onPinchEnd?.();\n        if (!this.#touchInfo) {\n            return;\n        }\n        evt.preventDefault();\n        this.#touchInfo = null;\n        this.#isPinching = false;\n    }\n    destroy() {\n        this.#touchManagerAC?.abort();\n        this.#touchManagerAC = null;\n    }\n}\n; // ./src/display/editor/editor.js\nclass AnnotationEditor {\n    #accessibilityData;\n    #allResizerDivs;\n    #altText;\n    #disabled;\n    #dragPointerId;\n    #dragPointerType;\n    #keepAspectRatio;\n    #resizersDiv;\n    #lastPointerCoords;\n    #savedDimensions;\n    #focusAC;\n    #focusedResizerName;\n    #hasBeenClicked;\n    #initialRect;\n    #isEditing;\n    #isInEditMode;\n    #isResizerEnabledForKeyboard;\n    #moveInDOMTimeout;\n    #prevDragX;\n    #prevDragY;\n    #telemetryTimeouts;\n    #touchManager;\n    static{\n        this._l10n = null;\n    }\n    static{\n        this._l10nResizer = null;\n    }\n    #isDraggable;\n    #zIndex;\n    static{\n        this._borderLineWidth = -1;\n    }\n    static{\n        this._colorManager = new ColorManager();\n    }\n    static{\n        this._zIndex = 1;\n    }\n    static{\n        this._telemetryTimeout = 1000;\n    }\n    static get _resizerKeyboardManager() {\n        const resize = AnnotationEditor.prototype._resizeWithKeyboard;\n        const small = AnnotationEditorUIManager.TRANSLATE_SMALL;\n        const big = AnnotationEditorUIManager.TRANSLATE_BIG;\n        return shadow(this, \"_resizerKeyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                resize,\n                {\n                    args: [\n                        -small,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowLeft\",\n                    \"mac+shift+ArrowLeft\"\n                ],\n                resize,\n                {\n                    args: [\n                        -big,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                resize,\n                {\n                    args: [\n                        small,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowRight\",\n                    \"mac+shift+ArrowRight\"\n                ],\n                resize,\n                {\n                    args: [\n                        big,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        -small\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowUp\",\n                    \"mac+shift+ArrowUp\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        -big\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        small\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowDown\",\n                    \"mac+shift+ArrowDown\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        big\n                    ]\n                }\n            ],\n            [\n                [\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                AnnotationEditor.prototype._stopResizingWithKeyboard\n            ]\n        ]));\n    }\n    constructor(parameters){\n        this.#accessibilityData = null;\n        this.#allResizerDivs = null;\n        this.#altText = null;\n        this.#disabled = false;\n        this.#dragPointerId = null;\n        this.#dragPointerType = \"\";\n        this.#keepAspectRatio = false;\n        this.#resizersDiv = null;\n        this.#lastPointerCoords = null;\n        this.#savedDimensions = null;\n        this.#focusAC = null;\n        this.#focusedResizerName = \"\";\n        this.#hasBeenClicked = false;\n        this.#initialRect = null;\n        this.#isEditing = false;\n        this.#isInEditMode = false;\n        this.#isResizerEnabledForKeyboard = false;\n        this.#moveInDOMTimeout = null;\n        this.#prevDragX = 0;\n        this.#prevDragY = 0;\n        this.#telemetryTimeouts = null;\n        this.#touchManager = null;\n        this._editToolbar = null;\n        this._initialOptions = Object.create(null);\n        this._initialData = null;\n        this._isVisible = true;\n        this._uiManager = null;\n        this._focusEventsAllowed = true;\n        this.#isDraggable = false;\n        this.#zIndex = AnnotationEditor._zIndex++;\n        this.parent = parameters.parent;\n        this.id = parameters.id;\n        this.width = this.height = null;\n        this.pageIndex = parameters.parent.pageIndex;\n        this.name = parameters.name;\n        this.div = null;\n        this._uiManager = parameters.uiManager;\n        this.annotationElementId = null;\n        this._willKeepAspectRatio = false;\n        this._initialOptions.isCentered = parameters.isCentered;\n        this._structTreeParentId = null;\n        const { rotation, rawDims: { pageWidth, pageHeight, pageX, pageY } } = this.parent.viewport;\n        this.rotation = rotation;\n        this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;\n        this.pageDimensions = [\n            pageWidth,\n            pageHeight\n        ];\n        this.pageTranslation = [\n            pageX,\n            pageY\n        ];\n        const [width, height] = this.parentDimensions;\n        this.x = parameters.x / width;\n        this.y = parameters.y / height;\n        this.isAttachedToDOM = false;\n        this.deleted = false;\n    }\n    get editorType() {\n        return Object.getPrototypeOf(this).constructor._type;\n    }\n    static get isDrawer() {\n        return false;\n    }\n    static get _defaultLineColor() {\n        return shadow(this, \"_defaultLineColor\", this._colorManager.getHexCode(\"CanvasText\"));\n    }\n    static deleteAnnotationElement(editor) {\n        const fakeEditor = new FakeEditor({\n            id: editor.parent.getNextId(),\n            parent: editor.parent,\n            uiManager: editor._uiManager\n        });\n        fakeEditor.annotationElementId = editor.annotationElementId;\n        fakeEditor.deleted = true;\n        fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);\n    }\n    static initialize(l10n, _uiManager) {\n        AnnotationEditor._l10n ??= l10n;\n        AnnotationEditor._l10nResizer ||= Object.freeze({\n            topLeft: \"pdfjs-editor-resizer-top-left\",\n            topMiddle: \"pdfjs-editor-resizer-top-middle\",\n            topRight: \"pdfjs-editor-resizer-top-right\",\n            middleRight: \"pdfjs-editor-resizer-middle-right\",\n            bottomRight: \"pdfjs-editor-resizer-bottom-right\",\n            bottomMiddle: \"pdfjs-editor-resizer-bottom-middle\",\n            bottomLeft: \"pdfjs-editor-resizer-bottom-left\",\n            middleLeft: \"pdfjs-editor-resizer-middle-left\"\n        });\n        if (AnnotationEditor._borderLineWidth !== -1) {\n            return;\n        }\n        const style = getComputedStyle(document.documentElement);\n        AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue(\"--outline-width\")) || 0;\n    }\n    static updateDefaultParams(_type, _value) {}\n    static get defaultPropertiesToUpdate() {\n        return [];\n    }\n    static isHandlingMimeForPasting(mime) {\n        return false;\n    }\n    static paste(item, parent) {\n        unreachable(\"Not implemented\");\n    }\n    get propertiesToUpdate() {\n        return [];\n    }\n    get _isDraggable() {\n        return this.#isDraggable;\n    }\n    set _isDraggable(value) {\n        this.#isDraggable = value;\n        this.div?.classList.toggle(\"draggable\", value);\n    }\n    get isEnterHandled() {\n        return true;\n    }\n    center() {\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        switch(this.parentRotation){\n            case 90:\n                this.x -= this.height * pageHeight / (pageWidth * 2);\n                this.y += this.width * pageWidth / (pageHeight * 2);\n                break;\n            case 180:\n                this.x += this.width / 2;\n                this.y += this.height / 2;\n                break;\n            case 270:\n                this.x += this.height * pageHeight / (pageWidth * 2);\n                this.y -= this.width * pageWidth / (pageHeight * 2);\n                break;\n            default:\n                this.x -= this.width / 2;\n                this.y -= this.height / 2;\n                break;\n        }\n        this.fixAndSetPosition();\n    }\n    addCommands(params) {\n        this._uiManager.addCommands(params);\n    }\n    get currentLayer() {\n        return this._uiManager.currentLayer;\n    }\n    setInBackground() {\n        this.div.style.zIndex = 0;\n    }\n    setInForeground() {\n        this.div.style.zIndex = this.#zIndex;\n    }\n    setParent(parent) {\n        if (parent !== null) {\n            this.pageIndex = parent.pageIndex;\n            this.pageDimensions = parent.pageDimensions;\n        } else {\n            this.#stopResizing();\n        }\n        this.parent = parent;\n    }\n    focusin(event) {\n        if (!this._focusEventsAllowed) {\n            return;\n        }\n        if (!this.#hasBeenClicked) {\n            this.parent.setSelected(this);\n        } else {\n            this.#hasBeenClicked = false;\n        }\n    }\n    focusout(event) {\n        if (!this._focusEventsAllowed) {\n            return;\n        }\n        if (!this.isAttachedToDOM) {\n            return;\n        }\n        const target = event.relatedTarget;\n        if (target?.closest(`#${this.id}`)) {\n            return;\n        }\n        event.preventDefault();\n        if (!this.parent?.isMultipleSelection) {\n            this.commitOrRemove();\n        }\n    }\n    commitOrRemove() {\n        if (this.isEmpty()) {\n            this.remove();\n        } else {\n            this.commit();\n        }\n    }\n    commit() {\n        this.addToAnnotationStorage();\n    }\n    addToAnnotationStorage() {\n        this._uiManager.addToAnnotationStorage(this);\n    }\n    setAt(x, y, tx, ty) {\n        const [width, height] = this.parentDimensions;\n        [tx, ty] = this.screenToPageTranslation(tx, ty);\n        this.x = (x + tx) / width;\n        this.y = (y + ty) / height;\n        this.fixAndSetPosition();\n    }\n    #translate([width, height], x, y) {\n        [x, y] = this.screenToPageTranslation(x, y);\n        this.x += x / width;\n        this.y += y / height;\n        this._onTranslating(this.x, this.y);\n        this.fixAndSetPosition();\n    }\n    translate(x, y) {\n        this.#translate(this.parentDimensions, x, y);\n    }\n    translateInPage(x, y) {\n        this.#initialRect ||= [\n            this.x,\n            this.y,\n            this.width,\n            this.height\n        ];\n        this.#translate(this.pageDimensions, x, y);\n        this.div.scrollIntoView({\n            block: \"nearest\"\n        });\n    }\n    drag(tx, ty) {\n        this.#initialRect ||= [\n            this.x,\n            this.y,\n            this.width,\n            this.height\n        ];\n        const { div, parentDimensions: [parentWidth, parentHeight] } = this;\n        this.x += tx / parentWidth;\n        this.y += ty / parentHeight;\n        if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {\n            const { x, y } = this.div.getBoundingClientRect();\n            if (this.parent.findNewParent(this, x, y)) {\n                this.x -= Math.floor(this.x);\n                this.y -= Math.floor(this.y);\n            }\n        }\n        let { x, y } = this;\n        const [bx, by] = this.getBaseTranslation();\n        x += bx;\n        y += by;\n        const { style } = div;\n        style.left = `${(100 * x).toFixed(2)}%`;\n        style.top = `${(100 * y).toFixed(2)}%`;\n        this._onTranslating(x, y);\n        div.scrollIntoView({\n            block: \"nearest\"\n        });\n    }\n    _onTranslating(x, y) {}\n    _onTranslated(x, y) {}\n    get _hasBeenMoved() {\n        return !!this.#initialRect && (this.#initialRect[0] !== this.x || this.#initialRect[1] !== this.y);\n    }\n    get _hasBeenResized() {\n        return !!this.#initialRect && (this.#initialRect[2] !== this.width || this.#initialRect[3] !== this.height);\n    }\n    getBaseTranslation() {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const { _borderLineWidth } = AnnotationEditor;\n        const x = _borderLineWidth / parentWidth;\n        const y = _borderLineWidth / parentHeight;\n        switch(this.rotation){\n            case 90:\n                return [\n                    -x,\n                    y\n                ];\n            case 180:\n                return [\n                    x,\n                    y\n                ];\n            case 270:\n                return [\n                    x,\n                    -y\n                ];\n            default:\n                return [\n                    -x,\n                    -y\n                ];\n        }\n    }\n    get _mustFixPosition() {\n        return true;\n    }\n    fixAndSetPosition(rotation = this.rotation) {\n        const { div: { style }, pageDimensions: [pageWidth, pageHeight] } = this;\n        let { x, y, width, height } = this;\n        width *= pageWidth;\n        height *= pageHeight;\n        x *= pageWidth;\n        y *= pageHeight;\n        if (this._mustFixPosition) {\n            switch(rotation){\n                case 0:\n                    x = Math.max(0, Math.min(pageWidth - width, x));\n                    y = Math.max(0, Math.min(pageHeight - height, y));\n                    break;\n                case 90:\n                    x = Math.max(0, Math.min(pageWidth - height, x));\n                    y = Math.min(pageHeight, Math.max(width, y));\n                    break;\n                case 180:\n                    x = Math.min(pageWidth, Math.max(width, x));\n                    y = Math.min(pageHeight, Math.max(height, y));\n                    break;\n                case 270:\n                    x = Math.min(pageWidth, Math.max(height, x));\n                    y = Math.max(0, Math.min(pageHeight - width, y));\n                    break;\n            }\n        }\n        this.x = x /= pageWidth;\n        this.y = y /= pageHeight;\n        const [bx, by] = this.getBaseTranslation();\n        x += bx;\n        y += by;\n        style.left = `${(100 * x).toFixed(2)}%`;\n        style.top = `${(100 * y).toFixed(2)}%`;\n        this.moveInDOM();\n    }\n    static #rotatePoint(x, y, angle) {\n        switch(angle){\n            case 90:\n                return [\n                    y,\n                    -x\n                ];\n            case 180:\n                return [\n                    -x,\n                    -y\n                ];\n            case 270:\n                return [\n                    -y,\n                    x\n                ];\n            default:\n                return [\n                    x,\n                    y\n                ];\n        }\n    }\n    screenToPageTranslation(x, y) {\n        return AnnotationEditor.#rotatePoint(x, y, this.parentRotation);\n    }\n    pageTranslationToScreen(x, y) {\n        return AnnotationEditor.#rotatePoint(x, y, 360 - this.parentRotation);\n    }\n    #getRotationMatrix(rotation) {\n        switch(rotation){\n            case 90:\n                {\n                    const [pageWidth, pageHeight] = this.pageDimensions;\n                    return [\n                        0,\n                        -pageWidth / pageHeight,\n                        pageHeight / pageWidth,\n                        0\n                    ];\n                }\n            case 180:\n                return [\n                    -1,\n                    0,\n                    0,\n                    -1\n                ];\n            case 270:\n                {\n                    const [pageWidth, pageHeight] = this.pageDimensions;\n                    return [\n                        0,\n                        pageWidth / pageHeight,\n                        -pageHeight / pageWidth,\n                        0\n                    ];\n                }\n            default:\n                return [\n                    1,\n                    0,\n                    0,\n                    1\n                ];\n        }\n    }\n    get parentScale() {\n        return this._uiManager.viewParameters.realScale;\n    }\n    get parentRotation() {\n        return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;\n    }\n    get parentDimensions() {\n        const { parentScale, pageDimensions: [pageWidth, pageHeight] } = this;\n        return [\n            pageWidth * parentScale,\n            pageHeight * parentScale\n        ];\n    }\n    setDims(width, height) {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const { style } = this.div;\n        style.width = `${(100 * width / parentWidth).toFixed(2)}%`;\n        if (!this.#keepAspectRatio) {\n            style.height = `${(100 * height / parentHeight).toFixed(2)}%`;\n        }\n    }\n    fixDims() {\n        const { style } = this.div;\n        const { height, width } = style;\n        const widthPercent = width.endsWith(\"%\");\n        const heightPercent = !this.#keepAspectRatio && height.endsWith(\"%\");\n        if (widthPercent && heightPercent) {\n            return;\n        }\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        if (!widthPercent) {\n            style.width = `${(100 * parseFloat(width) / parentWidth).toFixed(2)}%`;\n        }\n        if (!this.#keepAspectRatio && !heightPercent) {\n            style.height = `${(100 * parseFloat(height) / parentHeight).toFixed(2)}%`;\n        }\n    }\n    getInitialTranslation() {\n        return [\n            0,\n            0\n        ];\n    }\n    #createResizers() {\n        if (this.#resizersDiv) {\n            return;\n        }\n        this.#resizersDiv = document.createElement(\"div\");\n        this.#resizersDiv.classList.add(\"resizers\");\n        const classes = this._willKeepAspectRatio ? [\n            \"topLeft\",\n            \"topRight\",\n            \"bottomRight\",\n            \"bottomLeft\"\n        ] : [\n            \"topLeft\",\n            \"topMiddle\",\n            \"topRight\",\n            \"middleRight\",\n            \"bottomRight\",\n            \"bottomMiddle\",\n            \"bottomLeft\",\n            \"middleLeft\"\n        ];\n        const signal = this._uiManager._signal;\n        for (const name of classes){\n            const div = document.createElement(\"div\");\n            this.#resizersDiv.append(div);\n            div.classList.add(\"resizer\", name);\n            div.setAttribute(\"data-resizer-name\", name);\n            div.addEventListener(\"pointerdown\", this.#resizerPointerdown.bind(this, name), {\n                signal\n            });\n            div.addEventListener(\"contextmenu\", noContextMenu, {\n                signal\n            });\n            div.tabIndex = -1;\n        }\n        this.div.prepend(this.#resizersDiv);\n    }\n    #resizerPointerdown(name, event) {\n        event.preventDefault();\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            return;\n        }\n        this.#altText?.toggle(false);\n        const savedDraggable = this._isDraggable;\n        this._isDraggable = false;\n        this.#lastPointerCoords = [\n            event.screenX,\n            event.screenY\n        ];\n        const ac = new AbortController();\n        const signal = this._uiManager.combinedSignal(ac);\n        this.parent.togglePointerEvents(false);\n        window.addEventListener(\"pointermove\", this.#resizerPointermove.bind(this, name), {\n            passive: true,\n            capture: true,\n            signal\n        });\n        window.addEventListener(\"touchmove\", stopEvent, {\n            passive: false,\n            signal\n        });\n        window.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        this.#savedDimensions = {\n            savedX: this.x,\n            savedY: this.y,\n            savedWidth: this.width,\n            savedHeight: this.height\n        };\n        const savedParentCursor = this.parent.div.style.cursor;\n        const savedCursor = this.div.style.cursor;\n        this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;\n        const pointerUpCallback = ()=>{\n            ac.abort();\n            this.parent.togglePointerEvents(true);\n            this.#altText?.toggle(true);\n            this._isDraggable = savedDraggable;\n            this.parent.div.style.cursor = savedParentCursor;\n            this.div.style.cursor = savedCursor;\n            this.#addResizeToUndoStack();\n        };\n        window.addEventListener(\"pointerup\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"blur\", pointerUpCallback, {\n            signal\n        });\n    }\n    #resize(x, y, width, height) {\n        this.width = width;\n        this.height = height;\n        this.x = x;\n        this.y = y;\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setDims(parentWidth * width, parentHeight * height);\n        this.fixAndSetPosition();\n        this._onResized();\n    }\n    _onResized() {}\n    #addResizeToUndoStack() {\n        if (!this.#savedDimensions) {\n            return;\n        }\n        const { savedX, savedY, savedWidth, savedHeight } = this.#savedDimensions;\n        this.#savedDimensions = null;\n        const newX = this.x;\n        const newY = this.y;\n        const newWidth = this.width;\n        const newHeight = this.height;\n        if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {\n            return;\n        }\n        this.addCommands({\n            cmd: this.#resize.bind(this, newX, newY, newWidth, newHeight),\n            undo: this.#resize.bind(this, savedX, savedY, savedWidth, savedHeight),\n            mustExec: true\n        });\n    }\n    static _round(x) {\n        return Math.round(x * 10000) / 10000;\n    }\n    #resizerPointermove(name, event) {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const savedX = this.x;\n        const savedY = this.y;\n        const savedWidth = this.width;\n        const savedHeight = this.height;\n        const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;\n        const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;\n        const rotationMatrix = this.#getRotationMatrix(this.rotation);\n        const transf = (x, y)=>[\n                rotationMatrix[0] * x + rotationMatrix[2] * y,\n                rotationMatrix[1] * x + rotationMatrix[3] * y\n            ];\n        const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);\n        const invTransf = (x, y)=>[\n                invRotationMatrix[0] * x + invRotationMatrix[2] * y,\n                invRotationMatrix[1] * x + invRotationMatrix[3] * y\n            ];\n        let getPoint;\n        let getOpposite;\n        let isDiagonal = false;\n        let isHorizontal = false;\n        switch(name){\n            case \"topLeft\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        0,\n                        0\n                    ];\n                getOpposite = (w, h)=>[\n                        w,\n                        h\n                    ];\n                break;\n            case \"topMiddle\":\n                getPoint = (w, h)=>[\n                        w / 2,\n                        0\n                    ];\n                getOpposite = (w, h)=>[\n                        w / 2,\n                        h\n                    ];\n                break;\n            case \"topRight\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        w,\n                        0\n                    ];\n                getOpposite = (w, h)=>[\n                        0,\n                        h\n                    ];\n                break;\n            case \"middleRight\":\n                isHorizontal = true;\n                getPoint = (w, h)=>[\n                        w,\n                        h / 2\n                    ];\n                getOpposite = (w, h)=>[\n                        0,\n                        h / 2\n                    ];\n                break;\n            case \"bottomRight\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        w,\n                        h\n                    ];\n                getOpposite = (w, h)=>[\n                        0,\n                        0\n                    ];\n                break;\n            case \"bottomMiddle\":\n                getPoint = (w, h)=>[\n                        w / 2,\n                        h\n                    ];\n                getOpposite = (w, h)=>[\n                        w / 2,\n                        0\n                    ];\n                break;\n            case \"bottomLeft\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        0,\n                        h\n                    ];\n                getOpposite = (w, h)=>[\n                        w,\n                        0\n                    ];\n                break;\n            case \"middleLeft\":\n                isHorizontal = true;\n                getPoint = (w, h)=>[\n                        0,\n                        h / 2\n                    ];\n                getOpposite = (w, h)=>[\n                        w,\n                        h / 2\n                    ];\n                break;\n        }\n        const point = getPoint(savedWidth, savedHeight);\n        const oppositePoint = getOpposite(savedWidth, savedHeight);\n        let transfOppositePoint = transf(...oppositePoint);\n        const oppositeX = AnnotationEditor._round(savedX + transfOppositePoint[0]);\n        const oppositeY = AnnotationEditor._round(savedY + transfOppositePoint[1]);\n        let ratioX = 1;\n        let ratioY = 1;\n        let deltaX, deltaY;\n        if (!event.fromKeyboard) {\n            const { screenX, screenY } = event;\n            const [lastScreenX, lastScreenY] = this.#lastPointerCoords;\n            [deltaX, deltaY] = this.screenToPageTranslation(screenX - lastScreenX, screenY - lastScreenY);\n            this.#lastPointerCoords[0] = screenX;\n            this.#lastPointerCoords[1] = screenY;\n        } else {\n            ({ deltaX, deltaY } = event);\n        }\n        [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);\n        if (isDiagonal) {\n            const oldDiag = Math.hypot(savedWidth, savedHeight);\n            ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);\n        } else if (isHorizontal) {\n            ratioX = Math.max(minWidth, Math.min(1, Math.abs(oppositePoint[0] - point[0] - deltaX))) / savedWidth;\n        } else {\n            ratioY = Math.max(minHeight, Math.min(1, Math.abs(oppositePoint[1] - point[1] - deltaY))) / savedHeight;\n        }\n        const newWidth = AnnotationEditor._round(savedWidth * ratioX);\n        const newHeight = AnnotationEditor._round(savedHeight * ratioY);\n        transfOppositePoint = transf(...getOpposite(newWidth, newHeight));\n        const newX = oppositeX - transfOppositePoint[0];\n        const newY = oppositeY - transfOppositePoint[1];\n        this.#initialRect ||= [\n            this.x,\n            this.y,\n            this.width,\n            this.height\n        ];\n        this.width = newWidth;\n        this.height = newHeight;\n        this.x = newX;\n        this.y = newY;\n        this.setDims(parentWidth * newWidth, parentHeight * newHeight);\n        this.fixAndSetPosition();\n        this._onResizing();\n    }\n    _onResizing() {}\n    altTextFinish() {\n        this.#altText?.finish();\n    }\n    async addEditToolbar() {\n        if (this._editToolbar || this.#isInEditMode) {\n            return this._editToolbar;\n        }\n        this._editToolbar = new EditorToolbar(this);\n        this.div.append(this._editToolbar.render());\n        if (this.#altText) {\n            await this._editToolbar.addAltText(this.#altText);\n        }\n        return this._editToolbar;\n    }\n    removeEditToolbar() {\n        if (!this._editToolbar) {\n            return;\n        }\n        this._editToolbar.remove();\n        this._editToolbar = null;\n        this.#altText?.destroy();\n    }\n    addContainer(container) {\n        const editToolbarDiv = this._editToolbar?.div;\n        if (editToolbarDiv) {\n            editToolbarDiv.before(container);\n        } else {\n            this.div.append(container);\n        }\n    }\n    getClientDimensions() {\n        return this.div.getBoundingClientRect();\n    }\n    async addAltTextButton() {\n        if (this.#altText) {\n            return;\n        }\n        AltText.initialize(AnnotationEditor._l10n);\n        this.#altText = new AltText(this);\n        if (this.#accessibilityData) {\n            this.#altText.data = this.#accessibilityData;\n            this.#accessibilityData = null;\n        }\n        await this.addEditToolbar();\n    }\n    get altTextData() {\n        return this.#altText?.data;\n    }\n    set altTextData(data) {\n        if (!this.#altText) {\n            return;\n        }\n        this.#altText.data = data;\n    }\n    get guessedAltText() {\n        return this.#altText?.guessedText;\n    }\n    async setGuessedAltText(text) {\n        await this.#altText?.setGuessedText(text);\n    }\n    serializeAltText(isForCopying) {\n        return this.#altText?.serialize(isForCopying);\n    }\n    hasAltText() {\n        return !!this.#altText && !this.#altText.isEmpty();\n    }\n    hasAltTextData() {\n        return this.#altText?.hasData() ?? false;\n    }\n    render() {\n        this.div = document.createElement(\"div\");\n        this.div.setAttribute(\"data-editor-rotation\", (360 - this.rotation) % 360);\n        this.div.className = this.name;\n        this.div.setAttribute(\"id\", this.id);\n        this.div.tabIndex = this.#disabled ? -1 : 0;\n        if (!this._isVisible) {\n            this.div.classList.add(\"hidden\");\n        }\n        this.setInForeground();\n        this.#addFocusListeners();\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        if (this.parentRotation % 180 !== 0) {\n            this.div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;\n            this.div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;\n        }\n        const [tx, ty] = this.getInitialTranslation();\n        this.translate(tx, ty);\n        bindEvents(this, this.div, [\n            \"pointerdown\"\n        ]);\n        if (this.isResizable && this._uiManager._supportsPinchToZoom) {\n            this.#touchManager ||= new TouchManager({\n                container: this.div,\n                isPinchingDisabled: ()=>!this.isSelected,\n                onPinchStart: this.#touchPinchStartCallback.bind(this),\n                onPinching: this.#touchPinchCallback.bind(this),\n                onPinchEnd: this.#touchPinchEndCallback.bind(this),\n                signal: this._uiManager._signal\n            });\n        }\n        this._uiManager._editorUndoBar?.hide();\n        return this.div;\n    }\n    #touchPinchStartCallback() {\n        this.#savedDimensions = {\n            savedX: this.x,\n            savedY: this.y,\n            savedWidth: this.width,\n            savedHeight: this.height\n        };\n        this.#altText?.toggle(false);\n        this.parent.togglePointerEvents(false);\n    }\n    #touchPinchCallback(_origin, prevDistance, distance) {\n        const slowDownFactor = 0.7;\n        let factor = slowDownFactor * (distance / prevDistance) + 1 - slowDownFactor;\n        if (factor === 1) {\n            return;\n        }\n        const rotationMatrix = this.#getRotationMatrix(this.rotation);\n        const transf = (x, y)=>[\n                rotationMatrix[0] * x + rotationMatrix[2] * y,\n                rotationMatrix[1] * x + rotationMatrix[3] * y\n            ];\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const savedX = this.x;\n        const savedY = this.y;\n        const savedWidth = this.width;\n        const savedHeight = this.height;\n        const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;\n        const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;\n        factor = Math.max(Math.min(factor, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);\n        const newWidth = AnnotationEditor._round(savedWidth * factor);\n        const newHeight = AnnotationEditor._round(savedHeight * factor);\n        if (newWidth === savedWidth && newHeight === savedHeight) {\n            return;\n        }\n        this.#initialRect ||= [\n            savedX,\n            savedY,\n            savedWidth,\n            savedHeight\n        ];\n        const transfCenterPoint = transf(savedWidth / 2, savedHeight / 2);\n        const centerX = AnnotationEditor._round(savedX + transfCenterPoint[0]);\n        const centerY = AnnotationEditor._round(savedY + transfCenterPoint[1]);\n        const newTransfCenterPoint = transf(newWidth / 2, newHeight / 2);\n        this.x = centerX - newTransfCenterPoint[0];\n        this.y = centerY - newTransfCenterPoint[1];\n        this.width = newWidth;\n        this.height = newHeight;\n        this.setDims(parentWidth * newWidth, parentHeight * newHeight);\n        this.fixAndSetPosition();\n        this._onResizing();\n    }\n    #touchPinchEndCallback() {\n        this.#altText?.toggle(true);\n        this.parent.togglePointerEvents(true);\n        this.#addResizeToUndoStack();\n    }\n    pointerdown(event) {\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            event.preventDefault();\n            return;\n        }\n        this.#hasBeenClicked = true;\n        if (this._isDraggable) {\n            this.#setUpDragSession(event);\n            return;\n        }\n        this.#selectOnPointerEvent(event);\n    }\n    get isSelected() {\n        return this._uiManager.isSelected(this);\n    }\n    #selectOnPointerEvent(event) {\n        const { isMac } = util_FeatureTest.platform;\n        if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {\n            this.parent.toggleSelected(this);\n        } else {\n            this.parent.setSelected(this);\n        }\n    }\n    #setUpDragSession(event) {\n        const { isSelected } = this;\n        this._uiManager.setUpDragSession();\n        let hasDraggingStarted = false;\n        const ac = new AbortController();\n        const signal = this._uiManager.combinedSignal(ac);\n        const opts = {\n            capture: true,\n            passive: false,\n            signal\n        };\n        const cancelDrag = (e)=>{\n            ac.abort();\n            this.#dragPointerId = null;\n            this.#hasBeenClicked = false;\n            if (!this._uiManager.endDragSession()) {\n                this.#selectOnPointerEvent(e);\n            }\n            if (hasDraggingStarted) {\n                this._onStopDragging();\n            }\n        };\n        if (isSelected) {\n            this.#prevDragX = event.clientX;\n            this.#prevDragY = event.clientY;\n            this.#dragPointerId = event.pointerId;\n            this.#dragPointerType = event.pointerType;\n            window.addEventListener(\"pointermove\", (e)=>{\n                if (!hasDraggingStarted) {\n                    hasDraggingStarted = true;\n                    this._onStartDragging();\n                }\n                const { clientX: x, clientY: y, pointerId } = e;\n                if (pointerId !== this.#dragPointerId) {\n                    stopEvent(e);\n                    return;\n                }\n                const [tx, ty] = this.screenToPageTranslation(x - this.#prevDragX, y - this.#prevDragY);\n                this.#prevDragX = x;\n                this.#prevDragY = y;\n                this._uiManager.dragSelectedEditors(tx, ty);\n            }, opts);\n            window.addEventListener(\"touchmove\", stopEvent, opts);\n            window.addEventListener(\"pointerdown\", (e)=>{\n                if (e.pointerType === this.#dragPointerType) {\n                    if (this.#touchManager || e.isPrimary) {\n                        cancelDrag(e);\n                    }\n                }\n                stopEvent(e);\n            }, opts);\n        }\n        const pointerUpCallback = (e)=>{\n            if (!this.#dragPointerId || this.#dragPointerId === e.pointerId) {\n                cancelDrag(e);\n                return;\n            }\n            stopEvent(e);\n        };\n        window.addEventListener(\"pointerup\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"blur\", pointerUpCallback, {\n            signal\n        });\n    }\n    _onStartDragging() {}\n    _onStopDragging() {}\n    moveInDOM() {\n        if (this.#moveInDOMTimeout) {\n            clearTimeout(this.#moveInDOMTimeout);\n        }\n        this.#moveInDOMTimeout = setTimeout(()=>{\n            this.#moveInDOMTimeout = null;\n            this.parent?.moveEditorInDOM(this);\n        }, 0);\n    }\n    _setParentAndPosition(parent, x, y) {\n        parent.changeParent(this);\n        this.x = x;\n        this.y = y;\n        this.fixAndSetPosition();\n        this._onTranslated();\n    }\n    getRect(tx, ty, rotation = this.rotation) {\n        const scale = this.parentScale;\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const [pageX, pageY] = this.pageTranslation;\n        const shiftX = tx / scale;\n        const shiftY = ty / scale;\n        const x = this.x * pageWidth;\n        const y = this.y * pageHeight;\n        const width = this.width * pageWidth;\n        const height = this.height * pageHeight;\n        switch(rotation){\n            case 0:\n                return [\n                    x + shiftX + pageX,\n                    pageHeight - y - shiftY - height + pageY,\n                    x + shiftX + width + pageX,\n                    pageHeight - y - shiftY + pageY\n                ];\n            case 90:\n                return [\n                    x + shiftY + pageX,\n                    pageHeight - y + shiftX + pageY,\n                    x + shiftY + height + pageX,\n                    pageHeight - y + shiftX + width + pageY\n                ];\n            case 180:\n                return [\n                    x - shiftX - width + pageX,\n                    pageHeight - y + shiftY + pageY,\n                    x - shiftX + pageX,\n                    pageHeight - y + shiftY + height + pageY\n                ];\n            case 270:\n                return [\n                    x - shiftY - height + pageX,\n                    pageHeight - y - shiftX - width + pageY,\n                    x - shiftY + pageX,\n                    pageHeight - y - shiftX + pageY\n                ];\n            default:\n                throw new Error(\"Invalid rotation\");\n        }\n    }\n    getRectInCurrentCoords(rect, pageHeight) {\n        const [x1, y1, x2, y2] = rect;\n        const width = x2 - x1;\n        const height = y2 - y1;\n        switch(this.rotation){\n            case 0:\n                return [\n                    x1,\n                    pageHeight - y2,\n                    width,\n                    height\n                ];\n            case 90:\n                return [\n                    x1,\n                    pageHeight - y1,\n                    height,\n                    width\n                ];\n            case 180:\n                return [\n                    x2,\n                    pageHeight - y1,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    x2,\n                    pageHeight - y2,\n                    height,\n                    width\n                ];\n            default:\n                throw new Error(\"Invalid rotation\");\n        }\n    }\n    onceAdded(focus) {}\n    isEmpty() {\n        return false;\n    }\n    enableEditMode() {\n        this.#isInEditMode = true;\n    }\n    disableEditMode() {\n        this.#isInEditMode = false;\n    }\n    isInEditMode() {\n        return this.#isInEditMode;\n    }\n    shouldGetKeyboardEvents() {\n        return this.#isResizerEnabledForKeyboard;\n    }\n    needsToBeRebuilt() {\n        return this.div && !this.isAttachedToDOM;\n    }\n    get isOnScreen() {\n        const { top, left, bottom, right } = this.getClientDimensions();\n        const { innerHeight, innerWidth } = window;\n        return left < innerWidth && right > 0 && top < innerHeight && bottom > 0;\n    }\n    #addFocusListeners() {\n        if (this.#focusAC || !this.div) {\n            return;\n        }\n        this.#focusAC = new AbortController();\n        const signal = this._uiManager.combinedSignal(this.#focusAC);\n        this.div.addEventListener(\"focusin\", this.focusin.bind(this), {\n            signal\n        });\n        this.div.addEventListener(\"focusout\", this.focusout.bind(this), {\n            signal\n        });\n    }\n    rebuild() {\n        this.#addFocusListeners();\n    }\n    rotate(_angle) {}\n    resize() {}\n    serializeDeleted() {\n        return {\n            id: this.annotationElementId,\n            deleted: true,\n            pageIndex: this.pageIndex,\n            popupRef: this._initialData?.popupRef || \"\"\n        };\n    }\n    serialize(isForCopying = false, context = null) {\n        unreachable(\"An editor must be serializable\");\n    }\n    static async deserialize(data, parent, uiManager) {\n        const editor = new this.prototype.constructor({\n            parent,\n            id: parent.getNextId(),\n            uiManager\n        });\n        editor.rotation = data.rotation;\n        editor.#accessibilityData = data.accessibilityData;\n        const [pageWidth, pageHeight] = editor.pageDimensions;\n        const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);\n        editor.x = x / pageWidth;\n        editor.y = y / pageHeight;\n        editor.width = width / pageWidth;\n        editor.height = height / pageHeight;\n        return editor;\n    }\n    get hasBeenModified() {\n        return !!this.annotationElementId && (this.deleted || this.serialize() !== null);\n    }\n    remove() {\n        this.#focusAC?.abort();\n        this.#focusAC = null;\n        if (!this.isEmpty()) {\n            this.commit();\n        }\n        if (this.parent) {\n            this.parent.remove(this);\n        } else {\n            this._uiManager.removeEditor(this);\n        }\n        if (this.#moveInDOMTimeout) {\n            clearTimeout(this.#moveInDOMTimeout);\n            this.#moveInDOMTimeout = null;\n        }\n        this.#stopResizing();\n        this.removeEditToolbar();\n        if (this.#telemetryTimeouts) {\n            for (const timeout of this.#telemetryTimeouts.values()){\n                clearTimeout(timeout);\n            }\n            this.#telemetryTimeouts = null;\n        }\n        this.parent = null;\n        this.#touchManager?.destroy();\n        this.#touchManager = null;\n    }\n    get isResizable() {\n        return false;\n    }\n    makeResizable() {\n        if (this.isResizable) {\n            this.#createResizers();\n            this.#resizersDiv.classList.remove(\"hidden\");\n            bindEvents(this, this.div, [\n                \"keydown\"\n            ]);\n        }\n    }\n    get toolbarPosition() {\n        return null;\n    }\n    keydown(event) {\n        if (!this.isResizable || event.target !== this.div || event.key !== \"Enter\") {\n            return;\n        }\n        this._uiManager.setSelected(this);\n        this.#savedDimensions = {\n            savedX: this.x,\n            savedY: this.y,\n            savedWidth: this.width,\n            savedHeight: this.height\n        };\n        const children = this.#resizersDiv.children;\n        if (!this.#allResizerDivs) {\n            this.#allResizerDivs = Array.from(children);\n            const boundResizerKeydown = this.#resizerKeydown.bind(this);\n            const boundResizerBlur = this.#resizerBlur.bind(this);\n            const signal = this._uiManager._signal;\n            for (const div of this.#allResizerDivs){\n                const name = div.getAttribute(\"data-resizer-name\");\n                div.setAttribute(\"role\", \"spinbutton\");\n                div.addEventListener(\"keydown\", boundResizerKeydown, {\n                    signal\n                });\n                div.addEventListener(\"blur\", boundResizerBlur, {\n                    signal\n                });\n                div.addEventListener(\"focus\", this.#resizerFocus.bind(this, name), {\n                    signal\n                });\n                div.setAttribute(\"data-l10n-id\", AnnotationEditor._l10nResizer[name]);\n            }\n        }\n        const first = this.#allResizerDivs[0];\n        let firstPosition = 0;\n        for (const div of children){\n            if (div === first) {\n                break;\n            }\n            firstPosition++;\n        }\n        const nextFirstPosition = (360 - this.rotation + this.parentRotation) % 360 / 90 * (this.#allResizerDivs.length / 4);\n        if (nextFirstPosition !== firstPosition) {\n            if (nextFirstPosition < firstPosition) {\n                for(let i = 0; i < firstPosition - nextFirstPosition; i++){\n                    this.#resizersDiv.append(this.#resizersDiv.firstChild);\n                }\n            } else if (nextFirstPosition > firstPosition) {\n                for(let i = 0; i < nextFirstPosition - firstPosition; i++){\n                    this.#resizersDiv.firstChild.before(this.#resizersDiv.lastChild);\n                }\n            }\n            let i = 0;\n            for (const child of children){\n                const div = this.#allResizerDivs[i++];\n                const name = div.getAttribute(\"data-resizer-name\");\n                child.setAttribute(\"data-l10n-id\", AnnotationEditor._l10nResizer[name]);\n            }\n        }\n        this.#setResizerTabIndex(0);\n        this.#isResizerEnabledForKeyboard = true;\n        this.#resizersDiv.firstChild.focus({\n            focusVisible: true\n        });\n        event.preventDefault();\n        event.stopImmediatePropagation();\n    }\n    #resizerKeydown(event) {\n        AnnotationEditor._resizerKeyboardManager.exec(this, event);\n    }\n    #resizerBlur(event) {\n        if (this.#isResizerEnabledForKeyboard && event.relatedTarget?.parentNode !== this.#resizersDiv) {\n            this.#stopResizing();\n        }\n    }\n    #resizerFocus(name) {\n        this.#focusedResizerName = this.#isResizerEnabledForKeyboard ? name : \"\";\n    }\n    #setResizerTabIndex(value) {\n        if (!this.#allResizerDivs) {\n            return;\n        }\n        for (const div of this.#allResizerDivs){\n            div.tabIndex = value;\n        }\n    }\n    _resizeWithKeyboard(x, y) {\n        if (!this.#isResizerEnabledForKeyboard) {\n            return;\n        }\n        this.#resizerPointermove(this.#focusedResizerName, {\n            deltaX: x,\n            deltaY: y,\n            fromKeyboard: true\n        });\n    }\n    #stopResizing() {\n        this.#isResizerEnabledForKeyboard = false;\n        this.#setResizerTabIndex(-1);\n        this.#addResizeToUndoStack();\n    }\n    _stopResizingWithKeyboard() {\n        this.#stopResizing();\n        this.div.focus();\n    }\n    select() {\n        this.makeResizable();\n        this.div?.classList.add(\"selectedEditor\");\n        if (!this._editToolbar) {\n            this.addEditToolbar().then(()=>{\n                if (this.div?.classList.contains(\"selectedEditor\")) {\n                    this._editToolbar?.show();\n                }\n            });\n            return;\n        }\n        this._editToolbar?.show();\n        this.#altText?.toggleAltTextBadge(false);\n    }\n    unselect() {\n        this.#resizersDiv?.classList.add(\"hidden\");\n        this.div?.classList.remove(\"selectedEditor\");\n        if (this.div?.contains(document.activeElement)) {\n            this._uiManager.currentLayer.div.focus({\n                preventScroll: true\n            });\n        }\n        this._editToolbar?.hide();\n        this.#altText?.toggleAltTextBadge(true);\n    }\n    updateParams(type, value) {}\n    disableEditing() {}\n    enableEditing() {}\n    enterInEditMode() {}\n    getImageForAltText() {\n        return null;\n    }\n    get contentDiv() {\n        return this.div;\n    }\n    get isEditing() {\n        return this.#isEditing;\n    }\n    set isEditing(value) {\n        this.#isEditing = value;\n        if (!this.parent) {\n            return;\n        }\n        if (value) {\n            this.parent.setSelected(this);\n            this.parent.setActiveEditor(this);\n        } else {\n            this.parent.setActiveEditor(null);\n        }\n    }\n    setAspectRatio(width, height) {\n        this.#keepAspectRatio = true;\n        const aspectRatio = width / height;\n        const { style } = this.div;\n        style.aspectRatio = aspectRatio;\n        style.height = \"auto\";\n    }\n    static get MIN_SIZE() {\n        return 16;\n    }\n    static canCreateNewEmptyEditor() {\n        return true;\n    }\n    get telemetryInitialData() {\n        return {\n            action: \"added\"\n        };\n    }\n    get telemetryFinalData() {\n        return null;\n    }\n    _reportTelemetry(data, mustWait = false) {\n        if (mustWait) {\n            this.#telemetryTimeouts ||= new Map();\n            const { action } = data;\n            let timeout = this.#telemetryTimeouts.get(action);\n            if (timeout) {\n                clearTimeout(timeout);\n            }\n            timeout = setTimeout(()=>{\n                this._reportTelemetry(data);\n                this.#telemetryTimeouts.delete(action);\n                if (this.#telemetryTimeouts.size === 0) {\n                    this.#telemetryTimeouts = null;\n                }\n            }, AnnotationEditor._telemetryTimeout);\n            this.#telemetryTimeouts.set(action, timeout);\n            return;\n        }\n        data.type ||= this.editorType;\n        this._uiManager._eventBus.dispatch(\"reporttelemetry\", {\n            source: this,\n            details: {\n                type: \"editing\",\n                data\n            }\n        });\n    }\n    show(visible = this._isVisible) {\n        this.div.classList.toggle(\"hidden\", !visible);\n        this._isVisible = visible;\n    }\n    enable() {\n        if (this.div) {\n            this.div.tabIndex = 0;\n        }\n        this.#disabled = false;\n    }\n    disable() {\n        if (this.div) {\n            this.div.tabIndex = -1;\n        }\n        this.#disabled = true;\n    }\n    renderAnnotationElement(annotation) {\n        let content = annotation.container.querySelector(\".annotationContent\");\n        if (!content) {\n            content = document.createElement(\"div\");\n            content.classList.add(\"annotationContent\", this.editorType);\n            annotation.container.prepend(content);\n        } else if (content.nodeName === \"CANVAS\") {\n            const canvas = content;\n            content = document.createElement(\"div\");\n            content.classList.add(\"annotationContent\", this.editorType);\n            canvas.before(content);\n        }\n        return content;\n    }\n    resetAnnotationElement(annotation) {\n        const { firstChild } = annotation.container;\n        if (firstChild?.nodeName === \"DIV\" && firstChild.classList.contains(\"annotationContent\")) {\n            firstChild.remove();\n        }\n    }\n}\nclass FakeEditor extends AnnotationEditor {\n    constructor(params){\n        super(params);\n        this.annotationElementId = params.annotationElementId;\n        this.deleted = true;\n    }\n    serialize() {\n        return this.serializeDeleted();\n    }\n}\n; // ./src/shared/murmurhash3.js\nconst SEED = 0xc3d2e1f0;\nconst MASK_HIGH = 0xffff0000;\nconst MASK_LOW = 0xffff;\nclass MurmurHash3_64 {\n    constructor(seed){\n        this.h1 = seed ? seed & 0xffffffff : SEED;\n        this.h2 = seed ? seed & 0xffffffff : SEED;\n    }\n    update(input) {\n        let data, length;\n        if (typeof input === \"string\") {\n            data = new Uint8Array(input.length * 2);\n            length = 0;\n            for(let i = 0, ii = input.length; i < ii; i++){\n                const code = input.charCodeAt(i);\n                if (code <= 0xff) {\n                    data[length++] = code;\n                } else {\n                    data[length++] = code >>> 8;\n                    data[length++] = code & 0xff;\n                }\n            }\n        } else if (ArrayBuffer.isView(input)) {\n            data = input.slice();\n            length = data.byteLength;\n        } else {\n            throw new Error(\"Invalid data format, must be a string or TypedArray.\");\n        }\n        const blockCounts = length >> 2;\n        const tailLength = length - blockCounts * 4;\n        const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);\n        let k1 = 0, k2 = 0;\n        let h1 = this.h1, h2 = this.h2;\n        const C1 = 0xcc9e2d51, C2 = 0x1b873593;\n        const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;\n        for(let i = 0; i < blockCounts; i++){\n            if (i & 1) {\n                k1 = dataUint32[i];\n                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n                k1 = k1 << 15 | k1 >>> 17;\n                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n                h1 ^= k1;\n                h1 = h1 << 13 | h1 >>> 19;\n                h1 = h1 * 5 + 0xe6546b64;\n            } else {\n                k2 = dataUint32[i];\n                k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;\n                k2 = k2 << 15 | k2 >>> 17;\n                k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;\n                h2 ^= k2;\n                h2 = h2 << 13 | h2 >>> 19;\n                h2 = h2 * 5 + 0xe6546b64;\n            }\n        }\n        k1 = 0;\n        switch(tailLength){\n            case 3:\n                k1 ^= data[blockCounts * 4 + 2] << 16;\n            case 2:\n                k1 ^= data[blockCounts * 4 + 1] << 8;\n            case 1:\n                k1 ^= data[blockCounts * 4];\n                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n                k1 = k1 << 15 | k1 >>> 17;\n                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n                if (blockCounts & 1) {\n                    h1 ^= k1;\n                } else {\n                    h2 ^= k1;\n                }\n        }\n        this.h1 = h1;\n        this.h2 = h2;\n    }\n    hexdigest() {\n        let h1 = this.h1, h2 = this.h2;\n        h1 ^= h2 >>> 1;\n        h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;\n        h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;\n        h1 ^= h2 >>> 1;\n        h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;\n        h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;\n        h1 ^= h2 >>> 1;\n        return (h1 >>> 0).toString(16).padStart(8, \"0\") + (h2 >>> 0).toString(16).padStart(8, \"0\");\n    }\n}\n; // ./src/display/annotation_storage.js\nconst SerializableEmpty = Object.freeze({\n    map: null,\n    hash: \"\",\n    transfer: undefined\n});\nclass AnnotationStorage {\n    #modified;\n    #modifiedIds;\n    #storage;\n    constructor(){\n        this.#modified = false;\n        this.#modifiedIds = null;\n        this.#storage = new Map();\n        this.onSetModified = null;\n        this.onResetModified = null;\n        this.onAnnotationEditor = null;\n    }\n    getValue(key, defaultValue) {\n        const value = this.#storage.get(key);\n        if (value === undefined) {\n            return defaultValue;\n        }\n        return Object.assign(defaultValue, value);\n    }\n    getRawValue(key) {\n        return this.#storage.get(key);\n    }\n    remove(key) {\n        this.#storage.delete(key);\n        if (this.#storage.size === 0) {\n            this.resetModified();\n        }\n        if (typeof this.onAnnotationEditor === \"function\") {\n            for (const value of this.#storage.values()){\n                if (value instanceof AnnotationEditor) {\n                    return;\n                }\n            }\n            this.onAnnotationEditor(null);\n        }\n    }\n    setValue(key, value) {\n        const obj = this.#storage.get(key);\n        let modified = false;\n        if (obj !== undefined) {\n            for (const [entry, val] of Object.entries(value)){\n                if (obj[entry] !== val) {\n                    modified = true;\n                    obj[entry] = val;\n                }\n            }\n        } else {\n            modified = true;\n            this.#storage.set(key, value);\n        }\n        if (modified) {\n            this.#setModified();\n        }\n        if (value instanceof AnnotationEditor && typeof this.onAnnotationEditor === \"function\") {\n            this.onAnnotationEditor(value.constructor._type);\n        }\n    }\n    has(key) {\n        return this.#storage.has(key);\n    }\n    getAll() {\n        return this.#storage.size > 0 ? objectFromMap(this.#storage) : null;\n    }\n    setAll(obj) {\n        for (const [key, val] of Object.entries(obj)){\n            this.setValue(key, val);\n        }\n    }\n    get size() {\n        return this.#storage.size;\n    }\n    #setModified() {\n        if (!this.#modified) {\n            this.#modified = true;\n            if (typeof this.onSetModified === \"function\") {\n                this.onSetModified();\n            }\n        }\n    }\n    resetModified() {\n        if (this.#modified) {\n            this.#modified = false;\n            if (typeof this.onResetModified === \"function\") {\n                this.onResetModified();\n            }\n        }\n    }\n    get print() {\n        return new PrintAnnotationStorage(this);\n    }\n    get serializable() {\n        if (this.#storage.size === 0) {\n            return SerializableEmpty;\n        }\n        const map = new Map(), hash = new MurmurHash3_64(), transfer = [];\n        const context = Object.create(null);\n        let hasBitmap = false;\n        for (const [key, val] of this.#storage){\n            const serialized = val instanceof AnnotationEditor ? val.serialize(false, context) : val;\n            if (serialized) {\n                map.set(key, serialized);\n                hash.update(`${key}:${JSON.stringify(serialized)}`);\n                hasBitmap ||= !!serialized.bitmap;\n            }\n        }\n        if (hasBitmap) {\n            for (const value of map.values()){\n                if (value.bitmap) {\n                    transfer.push(value.bitmap);\n                }\n            }\n        }\n        return map.size > 0 ? {\n            map,\n            hash: hash.hexdigest(),\n            transfer\n        } : SerializableEmpty;\n    }\n    get editorStats() {\n        let stats = null;\n        const typeToEditor = new Map();\n        for (const value of this.#storage.values()){\n            if (!(value instanceof AnnotationEditor)) {\n                continue;\n            }\n            const editorStats = value.telemetryFinalData;\n            if (!editorStats) {\n                continue;\n            }\n            const { type } = editorStats;\n            if (!typeToEditor.has(type)) {\n                typeToEditor.set(type, Object.getPrototypeOf(value).constructor);\n            }\n            stats ||= Object.create(null);\n            const map = stats[type] ||= new Map();\n            for (const [key, val] of Object.entries(editorStats)){\n                if (key === \"type\") {\n                    continue;\n                }\n                let counters = map.get(key);\n                if (!counters) {\n                    counters = new Map();\n                    map.set(key, counters);\n                }\n                const count = counters.get(val) ?? 0;\n                counters.set(val, count + 1);\n            }\n        }\n        for (const [type, editor] of typeToEditor){\n            stats[type] = editor.computeTelemetryFinalData(stats[type]);\n        }\n        return stats;\n    }\n    resetModifiedIds() {\n        this.#modifiedIds = null;\n    }\n    get modifiedIds() {\n        if (this.#modifiedIds) {\n            return this.#modifiedIds;\n        }\n        const ids = [];\n        for (const value of this.#storage.values()){\n            if (!(value instanceof AnnotationEditor) || !value.annotationElementId || !value.serialize()) {\n                continue;\n            }\n            ids.push(value.annotationElementId);\n        }\n        return this.#modifiedIds = {\n            ids: new Set(ids),\n            hash: ids.join(\",\")\n        };\n    }\n}\nclass PrintAnnotationStorage extends AnnotationStorage {\n    #serializable;\n    constructor(parent){\n        super();\n        const { map, hash, transfer } = parent.serializable;\n        const clone = structuredClone(map, transfer ? {\n            transfer\n        } : null);\n        this.#serializable = {\n            map: clone,\n            hash,\n            transfer\n        };\n    }\n    get print() {\n        unreachable(\"Should not call PrintAnnotationStorage.print\");\n    }\n    get serializable() {\n        return this.#serializable;\n    }\n    get modifiedIds() {\n        return shadow(this, \"modifiedIds\", {\n            ids: new Set(),\n            hash: \"\"\n        });\n    }\n}\n; // ./src/display/font_loader.js\nclass FontLoader {\n    #systemFonts;\n    constructor({ ownerDocument = globalThis.document, styleElement = null }){\n        this.#systemFonts = new Set();\n        this._document = ownerDocument;\n        this.nativeFontFaces = new Set();\n        this.styleElement = null;\n        this.loadingRequests = [];\n        this.loadTestFontId = 0;\n    }\n    addNativeFontFace(nativeFontFace) {\n        this.nativeFontFaces.add(nativeFontFace);\n        this._document.fonts.add(nativeFontFace);\n    }\n    removeNativeFontFace(nativeFontFace) {\n        this.nativeFontFaces.delete(nativeFontFace);\n        this._document.fonts.delete(nativeFontFace);\n    }\n    insertRule(rule) {\n        if (!this.styleElement) {\n            this.styleElement = this._document.createElement(\"style\");\n            this._document.documentElement.getElementsByTagName(\"head\")[0].append(this.styleElement);\n        }\n        const styleSheet = this.styleElement.sheet;\n        styleSheet.insertRule(rule, styleSheet.cssRules.length);\n    }\n    clear() {\n        for (const nativeFontFace of this.nativeFontFaces){\n            this._document.fonts.delete(nativeFontFace);\n        }\n        this.nativeFontFaces.clear();\n        this.#systemFonts.clear();\n        if (this.styleElement) {\n            this.styleElement.remove();\n            this.styleElement = null;\n        }\n    }\n    async loadSystemFont({ systemFontInfo: info, _inspectFont }) {\n        if (!info || this.#systemFonts.has(info.loadedName)) {\n            return;\n        }\n        assert(!this.disableFontFace, \"loadSystemFont shouldn't be called when `disableFontFace` is set.\");\n        if (this.isFontLoadingAPISupported) {\n            const { loadedName, src, style } = info;\n            const fontFace = new FontFace(loadedName, src, style);\n            this.addNativeFontFace(fontFace);\n            try {\n                await fontFace.load();\n                this.#systemFonts.add(loadedName);\n                _inspectFont?.(info);\n            } catch  {\n                warn(`Cannot load system font: ${info.baseFontName}, installing it could help to improve PDF rendering.`);\n                this.removeNativeFontFace(fontFace);\n            }\n            return;\n        }\n        unreachable(\"Not implemented: loadSystemFont without the Font Loading API.\");\n    }\n    async bind(font) {\n        if (font.attached || font.missingFile && !font.systemFontInfo) {\n            return;\n        }\n        font.attached = true;\n        if (font.systemFontInfo) {\n            await this.loadSystemFont(font);\n            return;\n        }\n        if (this.isFontLoadingAPISupported) {\n            const nativeFontFace = font.createNativeFontFace();\n            if (nativeFontFace) {\n                this.addNativeFontFace(nativeFontFace);\n                try {\n                    await nativeFontFace.loaded;\n                } catch (ex) {\n                    warn(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);\n                    font.disableFontFace = true;\n                    throw ex;\n                }\n            }\n            return;\n        }\n        const rule = font.createFontFaceRule();\n        if (rule) {\n            this.insertRule(rule);\n            if (this.isSyncFontLoadingSupported) {\n                return;\n            }\n            await new Promise((resolve)=>{\n                const request = this._queueLoadingCallback(resolve);\n                this._prepareFontLoadEvent(font, request);\n            });\n        }\n    }\n    get isFontLoadingAPISupported() {\n        const hasFonts = !!this._document?.fonts;\n        return shadow(this, \"isFontLoadingAPISupported\", hasFonts);\n    }\n    get isSyncFontLoadingSupported() {\n        let supported = false;\n        if (isNodeJS) {\n            supported = true;\n        } else if (typeof navigator !== \"undefined\" && typeof navigator?.userAgent === \"string\" && /Mozilla\\/5.0.*?rv:\\d+.*? Gecko/.test(navigator.userAgent)) {\n            supported = true;\n        }\n        return shadow(this, \"isSyncFontLoadingSupported\", supported);\n    }\n    _queueLoadingCallback(callback) {\n        function completeRequest() {\n            assert(!request.done, \"completeRequest() cannot be called twice.\");\n            request.done = true;\n            while(loadingRequests.length > 0 && loadingRequests[0].done){\n                const otherRequest = loadingRequests.shift();\n                setTimeout(otherRequest.callback, 0);\n            }\n        }\n        const { loadingRequests } = this;\n        const request = {\n            done: false,\n            complete: completeRequest,\n            callback\n        };\n        loadingRequests.push(request);\n        return request;\n    }\n    get _loadTestFont() {\n        const testFont = atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n        return shadow(this, \"_loadTestFont\", testFont);\n    }\n    _prepareFontLoadEvent(font, request) {\n        function int32(data, offset) {\n            return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n        }\n        function spliceString(s, offset, remove, insert) {\n            const chunk1 = s.substring(0, offset);\n            const chunk2 = s.substring(offset + remove);\n            return chunk1 + insert + chunk2;\n        }\n        let i, ii;\n        const canvas = this._document.createElement(\"canvas\");\n        canvas.width = 1;\n        canvas.height = 1;\n        const ctx = canvas.getContext(\"2d\");\n        let called = 0;\n        function isFontReady(name, callback) {\n            if (++called > 30) {\n                warn(\"Load test font never loaded.\");\n                callback();\n                return;\n            }\n            ctx.font = \"30px \" + name;\n            ctx.fillText(\".\", 0, 20);\n            const imageData = ctx.getImageData(0, 0, 1, 1);\n            if (imageData.data[3] > 0) {\n                callback();\n                return;\n            }\n            setTimeout(isFontReady.bind(null, name, callback));\n        }\n        const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;\n        let data = this._loadTestFont;\n        const COMMENT_OFFSET = 976;\n        data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n        const CFF_CHECKSUM_OFFSET = 16;\n        const XXXX_VALUE = 0x58585858;\n        let checksum = int32(data, CFF_CHECKSUM_OFFSET);\n        for(i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4){\n            checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n        }\n        if (i < loadTestFontId.length) {\n            checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\n        }\n        data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, string32(checksum));\n        const url = `url(data:font/opentype;base64,${btoa(data)});`;\n        const rule = `@font-face {font-family:\"${loadTestFontId}\";src:${url}}`;\n        this.insertRule(rule);\n        const div = this._document.createElement(\"div\");\n        div.style.visibility = \"hidden\";\n        div.style.width = div.style.height = \"10px\";\n        div.style.position = \"absolute\";\n        div.style.top = div.style.left = \"0px\";\n        for (const name of [\n            font.loadedName,\n            loadTestFontId\n        ]){\n            const span = this._document.createElement(\"span\");\n            span.textContent = \"Hi\";\n            span.style.fontFamily = name;\n            div.append(span);\n        }\n        this._document.body.append(div);\n        isFontReady(loadTestFontId, ()=>{\n            div.remove();\n            request.complete();\n        });\n    }\n}\nclass FontFaceObject {\n    constructor(translatedData, { disableFontFace = false, fontExtraProperties = false, inspectFont = null }){\n        this.compiledGlyphs = Object.create(null);\n        for(const i in translatedData){\n            this[i] = translatedData[i];\n        }\n        this.disableFontFace = disableFontFace === true;\n        this.fontExtraProperties = fontExtraProperties === true;\n        this._inspectFont = inspectFont;\n    }\n    createNativeFontFace() {\n        if (!this.data || this.disableFontFace) {\n            return null;\n        }\n        let nativeFontFace;\n        if (!this.cssFontInfo) {\n            nativeFontFace = new FontFace(this.loadedName, this.data, {});\n        } else {\n            const css = {\n                weight: this.cssFontInfo.fontWeight\n            };\n            if (this.cssFontInfo.italicAngle) {\n                css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;\n            }\n            nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);\n        }\n        this._inspectFont?.(this);\n        return nativeFontFace;\n    }\n    createFontFaceRule() {\n        if (!this.data || this.disableFontFace) {\n            return null;\n        }\n        const url = `url(data:${this.mimetype};base64,${toBase64Util(this.data)});`;\n        let rule;\n        if (!this.cssFontInfo) {\n            rule = `@font-face {font-family:\"${this.loadedName}\";src:${url}}`;\n        } else {\n            let css = `font-weight: ${this.cssFontInfo.fontWeight};`;\n            if (this.cssFontInfo.italicAngle) {\n                css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;\n            }\n            rule = `@font-face {font-family:\"${this.cssFontInfo.fontFamily}\";${css}src:${url}}`;\n        }\n        this._inspectFont?.(this, url);\n        return rule;\n    }\n    getPathGenerator(objs, character) {\n        if (this.compiledGlyphs[character] !== undefined) {\n            return this.compiledGlyphs[character];\n        }\n        const objId = this.loadedName + \"_path_\" + character;\n        let cmds;\n        try {\n            cmds = objs.get(objId);\n        } catch (ex) {\n            warn(`getPathGenerator - ignoring character: \"${ex}\".`);\n        }\n        const path = new Path2D(cmds || \"\");\n        if (!this.fontExtraProperties) {\n            objs.delete(objId);\n        }\n        return this.compiledGlyphs[character] = path;\n    }\n}\n; // ./src/shared/message_handler.js\nconst CallbackKind = {\n    DATA: 1,\n    ERROR: 2\n};\nconst StreamKind = {\n    CANCEL: 1,\n    CANCEL_COMPLETE: 2,\n    CLOSE: 3,\n    ENQUEUE: 4,\n    ERROR: 5,\n    PULL: 6,\n    PULL_COMPLETE: 7,\n    START_COMPLETE: 8\n};\nfunction onFn() {}\nfunction wrapReason(ex) {\n    if (ex instanceof AbortException || ex instanceof InvalidPDFException || ex instanceof MissingPDFException || ex instanceof PasswordException || ex instanceof UnexpectedResponseException || ex instanceof UnknownErrorException) {\n        return ex;\n    }\n    if (!(ex instanceof Error || typeof ex === \"object\" && ex !== null)) {\n        unreachable('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n    }\n    switch(ex.name){\n        case \"AbortException\":\n            return new AbortException(ex.message);\n        case \"InvalidPDFException\":\n            return new InvalidPDFException(ex.message);\n        case \"MissingPDFException\":\n            return new MissingPDFException(ex.message);\n        case \"PasswordException\":\n            return new PasswordException(ex.message, ex.code);\n        case \"UnexpectedResponseException\":\n            return new UnexpectedResponseException(ex.message, ex.status);\n        case \"UnknownErrorException\":\n            return new UnknownErrorException(ex.message, ex.details);\n    }\n    return new UnknownErrorException(ex.message, ex.toString());\n}\nclass MessageHandler {\n    #messageAC;\n    constructor(sourceName, targetName, comObj){\n        this.#messageAC = new AbortController();\n        this.sourceName = sourceName;\n        this.targetName = targetName;\n        this.comObj = comObj;\n        this.callbackId = 1;\n        this.streamId = 1;\n        this.streamSinks = Object.create(null);\n        this.streamControllers = Object.create(null);\n        this.callbackCapabilities = Object.create(null);\n        this.actionHandler = Object.create(null);\n        comObj.addEventListener(\"message\", this.#onMessage.bind(this), {\n            signal: this.#messageAC.signal\n        });\n    }\n    #onMessage({ data }) {\n        if (data.targetName !== this.sourceName) {\n            return;\n        }\n        if (data.stream) {\n            this.#processStreamMessage(data);\n            return;\n        }\n        if (data.callback) {\n            const callbackId = data.callbackId;\n            const capability = this.callbackCapabilities[callbackId];\n            if (!capability) {\n                throw new Error(`Cannot resolve callback ${callbackId}`);\n            }\n            delete this.callbackCapabilities[callbackId];\n            if (data.callback === CallbackKind.DATA) {\n                capability.resolve(data.data);\n            } else if (data.callback === CallbackKind.ERROR) {\n                capability.reject(wrapReason(data.reason));\n            } else {\n                throw new Error(\"Unexpected callback case\");\n            }\n            return;\n        }\n        const action = this.actionHandler[data.action];\n        if (!action) {\n            throw new Error(`Unknown action from worker: ${data.action}`);\n        }\n        if (data.callbackId) {\n            const sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n            Promise.try(action, data.data).then(function(result) {\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    callback: CallbackKind.DATA,\n                    callbackId: data.callbackId,\n                    data: result\n                });\n            }, function(reason) {\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    callback: CallbackKind.ERROR,\n                    callbackId: data.callbackId,\n                    reason: wrapReason(reason)\n                });\n            });\n            return;\n        }\n        if (data.streamId) {\n            this.#createStreamSink(data);\n            return;\n        }\n        action(data.data);\n    }\n    on(actionName, handler) {\n        const ah = this.actionHandler;\n        if (ah[actionName]) {\n            throw new Error(`There is already an actionName called \"${actionName}\"`);\n        }\n        ah[actionName] = handler;\n    }\n    send(actionName, data, transfers) {\n        this.comObj.postMessage({\n            sourceName: this.sourceName,\n            targetName: this.targetName,\n            action: actionName,\n            data\n        }, transfers);\n    }\n    sendWithPromise(actionName, data, transfers) {\n        const callbackId = this.callbackId++;\n        const capability = Promise.withResolvers();\n        this.callbackCapabilities[callbackId] = capability;\n        try {\n            this.comObj.postMessage({\n                sourceName: this.sourceName,\n                targetName: this.targetName,\n                action: actionName,\n                callbackId,\n                data\n            }, transfers);\n        } catch (ex) {\n            capability.reject(ex);\n        }\n        return capability.promise;\n    }\n    sendWithStream(actionName, data, queueingStrategy, transfers) {\n        const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;\n        return new ReadableStream({\n            start: (controller)=>{\n                const startCapability = Promise.withResolvers();\n                this.streamControllers[streamId] = {\n                    controller,\n                    startCall: startCapability,\n                    pullCall: null,\n                    cancelCall: null,\n                    isClosed: false\n                };\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    action: actionName,\n                    streamId,\n                    data,\n                    desiredSize: controller.desiredSize\n                }, transfers);\n                return startCapability.promise;\n            },\n            pull: (controller)=>{\n                const pullCapability = Promise.withResolvers();\n                this.streamControllers[streamId].pullCall = pullCapability;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.PULL,\n                    streamId,\n                    desiredSize: controller.desiredSize\n                });\n                return pullCapability.promise;\n            },\n            cancel: (reason)=>{\n                assert(reason instanceof Error, \"cancel must have a valid reason\");\n                const cancelCapability = Promise.withResolvers();\n                this.streamControllers[streamId].cancelCall = cancelCapability;\n                this.streamControllers[streamId].isClosed = true;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.CANCEL,\n                    streamId,\n                    reason: wrapReason(reason)\n                });\n                return cancelCapability.promise;\n            }\n        }, queueingStrategy);\n    }\n    #createStreamSink(data) {\n        const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n        const self = this, action = this.actionHandler[data.action];\n        const streamSink = {\n            enqueue (chunk, size = 1, transfers) {\n                if (this.isCancelled) {\n                    return;\n                }\n                const lastDesiredSize = this.desiredSize;\n                this.desiredSize -= size;\n                if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n                    this.sinkCapability = Promise.withResolvers();\n                    this.ready = this.sinkCapability.promise;\n                }\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.ENQUEUE,\n                    streamId,\n                    chunk\n                }, transfers);\n            },\n            close () {\n                if (this.isCancelled) {\n                    return;\n                }\n                this.isCancelled = true;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.CLOSE,\n                    streamId\n                });\n                delete self.streamSinks[streamId];\n            },\n            error (reason) {\n                assert(reason instanceof Error, \"error must have a valid reason\");\n                if (this.isCancelled) {\n                    return;\n                }\n                this.isCancelled = true;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.ERROR,\n                    streamId,\n                    reason: wrapReason(reason)\n                });\n            },\n            sinkCapability: Promise.withResolvers(),\n            onPull: null,\n            onCancel: null,\n            isCancelled: false,\n            desiredSize: data.desiredSize,\n            ready: null\n        };\n        streamSink.sinkCapability.resolve();\n        streamSink.ready = streamSink.sinkCapability.promise;\n        this.streamSinks[streamId] = streamSink;\n        Promise.try(action, data.data, streamSink).then(function() {\n            comObj.postMessage({\n                sourceName,\n                targetName,\n                stream: StreamKind.START_COMPLETE,\n                streamId,\n                success: true\n            });\n        }, function(reason) {\n            comObj.postMessage({\n                sourceName,\n                targetName,\n                stream: StreamKind.START_COMPLETE,\n                streamId,\n                reason: wrapReason(reason)\n            });\n        });\n    }\n    #processStreamMessage(data) {\n        const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n        const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];\n        switch(data.stream){\n            case StreamKind.START_COMPLETE:\n                if (data.success) {\n                    streamController.startCall.resolve();\n                } else {\n                    streamController.startCall.reject(wrapReason(data.reason));\n                }\n                break;\n            case StreamKind.PULL_COMPLETE:\n                if (data.success) {\n                    streamController.pullCall.resolve();\n                } else {\n                    streamController.pullCall.reject(wrapReason(data.reason));\n                }\n                break;\n            case StreamKind.PULL:\n                if (!streamSink) {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.PULL_COMPLETE,\n                        streamId,\n                        success: true\n                    });\n                    break;\n                }\n                if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {\n                    streamSink.sinkCapability.resolve();\n                }\n                streamSink.desiredSize = data.desiredSize;\n                Promise.try(streamSink.onPull || onFn).then(function() {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.PULL_COMPLETE,\n                        streamId,\n                        success: true\n                    });\n                }, function(reason) {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.PULL_COMPLETE,\n                        streamId,\n                        reason: wrapReason(reason)\n                    });\n                });\n                break;\n            case StreamKind.ENQUEUE:\n                assert(streamController, \"enqueue should have stream controller\");\n                if (streamController.isClosed) {\n                    break;\n                }\n                streamController.controller.enqueue(data.chunk);\n                break;\n            case StreamKind.CLOSE:\n                assert(streamController, \"close should have stream controller\");\n                if (streamController.isClosed) {\n                    break;\n                }\n                streamController.isClosed = true;\n                streamController.controller.close();\n                this.#deleteStreamController(streamController, streamId);\n                break;\n            case StreamKind.ERROR:\n                assert(streamController, \"error should have stream controller\");\n                streamController.controller.error(wrapReason(data.reason));\n                this.#deleteStreamController(streamController, streamId);\n                break;\n            case StreamKind.CANCEL_COMPLETE:\n                if (data.success) {\n                    streamController.cancelCall.resolve();\n                } else {\n                    streamController.cancelCall.reject(wrapReason(data.reason));\n                }\n                this.#deleteStreamController(streamController, streamId);\n                break;\n            case StreamKind.CANCEL:\n                if (!streamSink) {\n                    break;\n                }\n                const dataReason = wrapReason(data.reason);\n                Promise.try(streamSink.onCancel || onFn, dataReason).then(function() {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.CANCEL_COMPLETE,\n                        streamId,\n                        success: true\n                    });\n                }, function(reason) {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.CANCEL_COMPLETE,\n                        streamId,\n                        reason: wrapReason(reason)\n                    });\n                });\n                streamSink.sinkCapability.reject(dataReason);\n                streamSink.isCancelled = true;\n                delete this.streamSinks[streamId];\n                break;\n            default:\n                throw new Error(\"Unexpected stream case\");\n        }\n    }\n    async #deleteStreamController(streamController, streamId) {\n        await Promise.allSettled([\n            streamController.startCall?.promise,\n            streamController.pullCall?.promise,\n            streamController.cancelCall?.promise\n        ]);\n        delete this.streamControllers[streamId];\n    }\n    destroy() {\n        this.#messageAC?.abort();\n        this.#messageAC = null;\n    }\n}\n; // ./src/display/canvas_factory.js\nclass BaseCanvasFactory {\n    #enableHWA;\n    constructor({ enableHWA = false }){\n        this.#enableHWA = false;\n        this.#enableHWA = enableHWA;\n    }\n    create(width, height) {\n        if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid canvas size\");\n        }\n        const canvas = this._createCanvas(width, height);\n        return {\n            canvas,\n            context: canvas.getContext(\"2d\", {\n                willReadFrequently: !this.#enableHWA\n            })\n        };\n    }\n    reset(canvasAndContext, width, height) {\n        if (!canvasAndContext.canvas) {\n            throw new Error(\"Canvas is not specified\");\n        }\n        if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid canvas size\");\n        }\n        canvasAndContext.canvas.width = width;\n        canvasAndContext.canvas.height = height;\n    }\n    destroy(canvasAndContext) {\n        if (!canvasAndContext.canvas) {\n            throw new Error(\"Canvas is not specified\");\n        }\n        canvasAndContext.canvas.width = 0;\n        canvasAndContext.canvas.height = 0;\n        canvasAndContext.canvas = null;\n        canvasAndContext.context = null;\n    }\n    _createCanvas(width, height) {\n        unreachable(\"Abstract method `_createCanvas` called.\");\n    }\n}\nclass DOMCanvasFactory extends BaseCanvasFactory {\n    constructor({ ownerDocument = globalThis.document, enableHWA = false }){\n        super({\n            enableHWA\n        });\n        this._document = ownerDocument;\n    }\n    _createCanvas(width, height) {\n        const canvas = this._document.createElement(\"canvas\");\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n    }\n}\n; // ./src/display/cmap_reader_factory.js\nclass BaseCMapReaderFactory {\n    constructor({ baseUrl = null, isCompressed = true }){\n        this.baseUrl = baseUrl;\n        this.isCompressed = isCompressed;\n    }\n    async fetch({ name }) {\n        if (!this.baseUrl) {\n            throw new Error(\"Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.\");\n        }\n        if (!name) {\n            throw new Error(\"CMap name must be specified.\");\n        }\n        const url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n        return this._fetch(url).then((cMapData)=>({\n                cMapData,\n                isCompressed: this.isCompressed\n            })).catch((reason)=>{\n            throw new Error(`Unable to load ${this.isCompressed ? \"binary \" : \"\"}CMap at: ${url}`);\n        });\n    }\n    async _fetch(url) {\n        unreachable(\"Abstract method `_fetch` called.\");\n    }\n}\nclass DOMCMapReaderFactory extends BaseCMapReaderFactory {\n    async _fetch(url) {\n        const data = await fetchData(url, this.isCompressed ? \"arraybuffer\" : \"text\");\n        return data instanceof ArrayBuffer ? new Uint8Array(data) : stringToBytes(data);\n    }\n}\n; // ./src/display/filter_factory.js\nclass BaseFilterFactory {\n    addFilter(maps) {\n        return \"none\";\n    }\n    addHCMFilter(fgColor, bgColor) {\n        return \"none\";\n    }\n    addAlphaFilter(map) {\n        return \"none\";\n    }\n    addLuminosityFilter(map) {\n        return \"none\";\n    }\n    addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {\n        return \"none\";\n    }\n    destroy(keepHCM = false) {}\n}\nclass DOMFilterFactory extends BaseFilterFactory {\n    #baseUrl;\n    #_cache;\n    #_defs;\n    #docId;\n    #document;\n    #_hcmCache;\n    #id;\n    constructor({ docId, ownerDocument = globalThis.document }){\n        super();\n        this.#id = 0;\n        this.#docId = docId;\n        this.#document = ownerDocument;\n    }\n    get #cache() {\n        return this.#_cache ||= new Map();\n    }\n    get #hcmCache() {\n        return this.#_hcmCache ||= new Map();\n    }\n    get #defs() {\n        if (!this.#_defs) {\n            const div = this.#document.createElement(\"div\");\n            const { style } = div;\n            style.visibility = \"hidden\";\n            style.contain = \"strict\";\n            style.width = style.height = 0;\n            style.position = \"absolute\";\n            style.top = style.left = 0;\n            style.zIndex = -1;\n            const svg = this.#document.createElementNS(SVG_NS, \"svg\");\n            svg.setAttribute(\"width\", 0);\n            svg.setAttribute(\"height\", 0);\n            this.#_defs = this.#document.createElementNS(SVG_NS, \"defs\");\n            div.append(svg);\n            svg.append(this.#_defs);\n            this.#document.body.append(div);\n        }\n        return this.#_defs;\n    }\n    #createTables(maps) {\n        if (maps.length === 1) {\n            const mapR = maps[0];\n            const buffer = new Array(256);\n            for(let i = 0; i < 256; i++){\n                buffer[i] = mapR[i] / 255;\n            }\n            const table = buffer.join(\",\");\n            return [\n                table,\n                table,\n                table\n            ];\n        }\n        const [mapR, mapG, mapB] = maps;\n        const bufferR = new Array(256);\n        const bufferG = new Array(256);\n        const bufferB = new Array(256);\n        for(let i = 0; i < 256; i++){\n            bufferR[i] = mapR[i] / 255;\n            bufferG[i] = mapG[i] / 255;\n            bufferB[i] = mapB[i] / 255;\n        }\n        return [\n            bufferR.join(\",\"),\n            bufferG.join(\",\"),\n            bufferB.join(\",\")\n        ];\n    }\n    #createUrl(id) {\n        if (this.#baseUrl === undefined) {\n            this.#baseUrl = \"\";\n            const url = this.#document.URL;\n            if (url !== this.#document.baseURI) {\n                if (isDataScheme(url)) {\n                    warn('#createUrl: ignore \"data:\"-URL for performance reasons.');\n                } else {\n                    this.#baseUrl = url.split(\"#\", 1)[0];\n                }\n            }\n        }\n        return `url(${this.#baseUrl}#${id})`;\n    }\n    addFilter(maps) {\n        if (!maps) {\n            return \"none\";\n        }\n        let value = this.#cache.get(maps);\n        if (value) {\n            return value;\n        }\n        const [tableR, tableG, tableB] = this.#createTables(maps);\n        const key = maps.length === 1 ? tableR : `${tableR}${tableG}${tableB}`;\n        value = this.#cache.get(key);\n        if (value) {\n            this.#cache.set(maps, value);\n            return value;\n        }\n        const id = `g_${this.#docId}_transfer_map_${this.#id++}`;\n        const url = this.#createUrl(id);\n        this.#cache.set(maps, url);\n        this.#cache.set(key, url);\n        const filter = this.#createFilter(id);\n        this.#addTransferMapConversion(tableR, tableG, tableB, filter);\n        return url;\n    }\n    addHCMFilter(fgColor, bgColor) {\n        const key = `${fgColor}-${bgColor}`;\n        const filterName = \"base\";\n        let info = this.#hcmCache.get(filterName);\n        if (info?.key === key) {\n            return info.url;\n        }\n        if (info) {\n            info.filter?.remove();\n            info.key = key;\n            info.url = \"none\";\n            info.filter = null;\n        } else {\n            info = {\n                key,\n                url: \"none\",\n                filter: null\n            };\n            this.#hcmCache.set(filterName, info);\n        }\n        if (!fgColor || !bgColor) {\n            return info.url;\n        }\n        const fgRGB = this.#getRGB(fgColor);\n        fgColor = Util.makeHexColor(...fgRGB);\n        const bgRGB = this.#getRGB(bgColor);\n        bgColor = Util.makeHexColor(...bgRGB);\n        this.#defs.style.color = \"\";\n        if (fgColor === \"#000000\" && bgColor === \"#ffffff\" || fgColor === bgColor) {\n            return info.url;\n        }\n        const map = new Array(256);\n        for(let i = 0; i <= 255; i++){\n            const x = i / 255;\n            map[i] = x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;\n        }\n        const table = map.join(\",\");\n        const id = `g_${this.#docId}_hcm_filter`;\n        const filter = info.filter = this.#createFilter(id);\n        this.#addTransferMapConversion(table, table, table, filter);\n        this.#addGrayConversion(filter);\n        const getSteps = (c, n)=>{\n            const start = fgRGB[c] / 255;\n            const end = bgRGB[c] / 255;\n            const arr = new Array(n + 1);\n            for(let i = 0; i <= n; i++){\n                arr[i] = start + i / n * (end - start);\n            }\n            return arr.join(\",\");\n        };\n        this.#addTransferMapConversion(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);\n        info.url = this.#createUrl(id);\n        return info.url;\n    }\n    addAlphaFilter(map) {\n        let value = this.#cache.get(map);\n        if (value) {\n            return value;\n        }\n        const [tableA] = this.#createTables([\n            map\n        ]);\n        const key = `alpha_${tableA}`;\n        value = this.#cache.get(key);\n        if (value) {\n            this.#cache.set(map, value);\n            return value;\n        }\n        const id = `g_${this.#docId}_alpha_map_${this.#id++}`;\n        const url = this.#createUrl(id);\n        this.#cache.set(map, url);\n        this.#cache.set(key, url);\n        const filter = this.#createFilter(id);\n        this.#addTransferMapAlphaConversion(tableA, filter);\n        return url;\n    }\n    addLuminosityFilter(map) {\n        let value = this.#cache.get(map || \"luminosity\");\n        if (value) {\n            return value;\n        }\n        let tableA, key;\n        if (map) {\n            [tableA] = this.#createTables([\n                map\n            ]);\n            key = `luminosity_${tableA}`;\n        } else {\n            key = \"luminosity\";\n        }\n        value = this.#cache.get(key);\n        if (value) {\n            this.#cache.set(map, value);\n            return value;\n        }\n        const id = `g_${this.#docId}_luminosity_map_${this.#id++}`;\n        const url = this.#createUrl(id);\n        this.#cache.set(map, url);\n        this.#cache.set(key, url);\n        const filter = this.#createFilter(id);\n        this.#addLuminosityConversion(filter);\n        if (map) {\n            this.#addTransferMapAlphaConversion(tableA, filter);\n        }\n        return url;\n    }\n    addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {\n        const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;\n        let info = this.#hcmCache.get(filterName);\n        if (info?.key === key) {\n            return info.url;\n        }\n        if (info) {\n            info.filter?.remove();\n            info.key = key;\n            info.url = \"none\";\n            info.filter = null;\n        } else {\n            info = {\n                key,\n                url: \"none\",\n                filter: null\n            };\n            this.#hcmCache.set(filterName, info);\n        }\n        if (!fgColor || !bgColor) {\n            return info.url;\n        }\n        const [fgRGB, bgRGB] = [\n            fgColor,\n            bgColor\n        ].map(this.#getRGB.bind(this));\n        let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);\n        let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);\n        let [newFgRGB, newBgRGB] = [\n            newFgColor,\n            newBgColor\n        ].map(this.#getRGB.bind(this));\n        if (bgGray < fgGray) {\n            [fgGray, bgGray, newFgRGB, newBgRGB] = [\n                bgGray,\n                fgGray,\n                newBgRGB,\n                newFgRGB\n            ];\n        }\n        this.#defs.style.color = \"\";\n        const getSteps = (fg, bg, n)=>{\n            const arr = new Array(256);\n            const step = (bgGray - fgGray) / n;\n            const newStart = fg / 255;\n            const newStep = (bg - fg) / (255 * n);\n            let prev = 0;\n            for(let i = 0; i <= n; i++){\n                const k = Math.round(fgGray + i * step);\n                const value = newStart + i * newStep;\n                for(let j = prev; j <= k; j++){\n                    arr[j] = value;\n                }\n                prev = k + 1;\n            }\n            for(let i = prev; i < 256; i++){\n                arr[i] = arr[prev - 1];\n            }\n            return arr.join(\",\");\n        };\n        const id = `g_${this.#docId}_hcm_${filterName}_filter`;\n        const filter = info.filter = this.#createFilter(id);\n        this.#addGrayConversion(filter);\n        this.#addTransferMapConversion(getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);\n        info.url = this.#createUrl(id);\n        return info.url;\n    }\n    destroy(keepHCM = false) {\n        if (keepHCM && this.#_hcmCache?.size) {\n            return;\n        }\n        this.#_defs?.parentNode.parentNode.remove();\n        this.#_defs = null;\n        this.#_cache?.clear();\n        this.#_cache = null;\n        this.#_hcmCache?.clear();\n        this.#_hcmCache = null;\n        this.#id = 0;\n    }\n    #addLuminosityConversion(filter) {\n        const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n        feColorMatrix.setAttribute(\"type\", \"matrix\");\n        feColorMatrix.setAttribute(\"values\", \"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0\");\n        filter.append(feColorMatrix);\n    }\n    #addGrayConversion(filter) {\n        const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n        feColorMatrix.setAttribute(\"type\", \"matrix\");\n        feColorMatrix.setAttribute(\"values\", \"0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0\");\n        filter.append(feColorMatrix);\n    }\n    #createFilter(id) {\n        const filter = this.#document.createElementNS(SVG_NS, \"filter\");\n        filter.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n        filter.setAttribute(\"id\", id);\n        this.#defs.append(filter);\n        return filter;\n    }\n    #appendFeFunc(feComponentTransfer, func, table) {\n        const feFunc = this.#document.createElementNS(SVG_NS, func);\n        feFunc.setAttribute(\"type\", \"discrete\");\n        feFunc.setAttribute(\"tableValues\", table);\n        feComponentTransfer.append(feFunc);\n    }\n    #addTransferMapConversion(rTable, gTable, bTable, filter) {\n        const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n        filter.append(feComponentTransfer);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncR\", rTable);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncG\", gTable);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncB\", bTable);\n    }\n    #addTransferMapAlphaConversion(aTable, filter) {\n        const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n        filter.append(feComponentTransfer);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncA\", aTable);\n    }\n    #getRGB(color) {\n        this.#defs.style.color = color;\n        return getRGB(getComputedStyle(this.#defs).getPropertyValue(\"color\"));\n    }\n}\n; // ./src/display/standard_fontdata_factory.js\nclass BaseStandardFontDataFactory {\n    constructor({ baseUrl = null }){\n        this.baseUrl = baseUrl;\n    }\n    async fetch({ filename }) {\n        if (!this.baseUrl) {\n            throw new Error(\"Ensure that the `standardFontDataUrl` API parameter is provided.\");\n        }\n        if (!filename) {\n            throw new Error(\"Font filename must be specified.\");\n        }\n        const url = `${this.baseUrl}${filename}`;\n        return this._fetch(url).catch((reason)=>{\n            throw new Error(`Unable to load font data at: ${url}`);\n        });\n    }\n    async _fetch(url) {\n        unreachable(\"Abstract method `_fetch` called.\");\n    }\n}\nclass DOMStandardFontDataFactory extends BaseStandardFontDataFactory {\n    async _fetch(url) {\n        const data = await fetchData(url, \"arraybuffer\");\n        return new Uint8Array(data);\n    }\n}\n; // ./src/display/node_utils.js\nif (isNodeJS) {\n    warn(\"Please use the `legacy` build in Node.js environments.\");\n}\nasync function node_utils_fetchData(url) {\n    const fs = process.getBuiltinModule(\"fs\");\n    const data = await fs.promises.readFile(url);\n    return new Uint8Array(data);\n}\nclass NodeFilterFactory extends BaseFilterFactory {\n}\nclass NodeCanvasFactory extends BaseCanvasFactory {\n    _createCanvas(width, height) {\n        const require = process.getBuiltinModule(\"module\").createRequire(\"file:///Users/juliashevchuk/construct-ai-platform/frontend/node_modules/pdfjs-dist/build/pdf.mjs\");\n        const canvas = require(\"@napi-rs/canvas\");\n        return canvas.createCanvas(width, height);\n    }\n}\nclass NodeCMapReaderFactory extends BaseCMapReaderFactory {\n    async _fetch(url) {\n        return node_utils_fetchData(url);\n    }\n}\nclass NodeStandardFontDataFactory extends BaseStandardFontDataFactory {\n    async _fetch(url) {\n        return node_utils_fetchData(url);\n    }\n}\n; // ./src/display/pattern_helper.js\nconst PathType = {\n    FILL: \"Fill\",\n    STROKE: \"Stroke\",\n    SHADING: \"Shading\"\n};\nfunction applyBoundingBox(ctx, bbox) {\n    if (!bbox) {\n        return;\n    }\n    const width = bbox[2] - bbox[0];\n    const height = bbox[3] - bbox[1];\n    const region = new Path2D();\n    region.rect(bbox[0], bbox[1], width, height);\n    ctx.clip(region);\n}\nclass BaseShadingPattern {\n    getPattern() {\n        unreachable(\"Abstract method `getPattern` called.\");\n    }\n}\nclass RadialAxialShadingPattern extends BaseShadingPattern {\n    constructor(IR){\n        super();\n        this._type = IR[1];\n        this._bbox = IR[2];\n        this._colorStops = IR[3];\n        this._p0 = IR[4];\n        this._p1 = IR[5];\n        this._r0 = IR[6];\n        this._r1 = IR[7];\n        this.matrix = null;\n    }\n    _createGradient(ctx) {\n        let grad;\n        if (this._type === \"axial\") {\n            grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);\n        } else if (this._type === \"radial\") {\n            grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);\n        }\n        for (const colorStop of this._colorStops){\n            grad.addColorStop(colorStop[0], colorStop[1]);\n        }\n        return grad;\n    }\n    getPattern(ctx, owner, inverse, pathType) {\n        let pattern;\n        if (pathType === PathType.STROKE || pathType === PathType.FILL) {\n            const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, getCurrentTransform(ctx)) || [\n                0,\n                0,\n                0,\n                0\n            ];\n            const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;\n            const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;\n            const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", width, height);\n            const tmpCtx = tmpCanvas.context;\n            tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n            tmpCtx.beginPath();\n            tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n            tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);\n            inverse = Util.transform(inverse, [\n                1,\n                0,\n                0,\n                1,\n                ownerBBox[0],\n                ownerBBox[1]\n            ]);\n            tmpCtx.transform(...owner.baseTransform);\n            if (this.matrix) {\n                tmpCtx.transform(...this.matrix);\n            }\n            applyBoundingBox(tmpCtx, this._bbox);\n            tmpCtx.fillStyle = this._createGradient(tmpCtx);\n            tmpCtx.fill();\n            pattern = ctx.createPattern(tmpCanvas.canvas, \"no-repeat\");\n            const domMatrix = new DOMMatrix(inverse);\n            pattern.setTransform(domMatrix);\n        } else {\n            applyBoundingBox(ctx, this._bbox);\n            pattern = this._createGradient(ctx);\n        }\n        return pattern;\n    }\n}\nfunction drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n    const coords = context.coords, colors = context.colors;\n    const bytes = data.data, rowSize = data.width * 4;\n    let tmp;\n    if (coords[p1 + 1] > coords[p2 + 1]) {\n        tmp = p1;\n        p1 = p2;\n        p2 = tmp;\n        tmp = c1;\n        c1 = c2;\n        c2 = tmp;\n    }\n    if (coords[p2 + 1] > coords[p3 + 1]) {\n        tmp = p2;\n        p2 = p3;\n        p3 = tmp;\n        tmp = c2;\n        c2 = c3;\n        c3 = tmp;\n    }\n    if (coords[p1 + 1] > coords[p2 + 1]) {\n        tmp = p1;\n        p1 = p2;\n        p2 = tmp;\n        tmp = c1;\n        c1 = c2;\n        c2 = tmp;\n    }\n    const x1 = (coords[p1] + context.offsetX) * context.scaleX;\n    const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n    const x2 = (coords[p2] + context.offsetX) * context.scaleX;\n    const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n    const x3 = (coords[p3] + context.offsetX) * context.scaleX;\n    const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n    if (y1 >= y3) {\n        return;\n    }\n    const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];\n    const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];\n    const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];\n    const minY = Math.round(y1), maxY = Math.round(y3);\n    let xa, car, cag, cab;\n    let xb, cbr, cbg, cbb;\n    for(let y = minY; y <= maxY; y++){\n        if (y < y2) {\n            const k = y < y1 ? 0 : (y1 - y) / (y1 - y2);\n            xa = x1 - (x1 - x2) * k;\n            car = c1r - (c1r - c2r) * k;\n            cag = c1g - (c1g - c2g) * k;\n            cab = c1b - (c1b - c2b) * k;\n        } else {\n            let k;\n            if (y > y3) {\n                k = 1;\n            } else if (y2 === y3) {\n                k = 0;\n            } else {\n                k = (y2 - y) / (y2 - y3);\n            }\n            xa = x2 - (x2 - x3) * k;\n            car = c2r - (c2r - c3r) * k;\n            cag = c2g - (c2g - c3g) * k;\n            cab = c2b - (c2b - c3b) * k;\n        }\n        let k;\n        if (y < y1) {\n            k = 0;\n        } else if (y > y3) {\n            k = 1;\n        } else {\n            k = (y1 - y) / (y1 - y3);\n        }\n        xb = x1 - (x1 - x3) * k;\n        cbr = c1r - (c1r - c3r) * k;\n        cbg = c1g - (c1g - c3g) * k;\n        cbb = c1b - (c1b - c3b) * k;\n        const x1_ = Math.round(Math.min(xa, xb));\n        const x2_ = Math.round(Math.max(xa, xb));\n        let j = rowSize * y + x1_ * 4;\n        for(let x = x1_; x <= x2_; x++){\n            k = (xa - x) / (xa - xb);\n            if (k < 0) {\n                k = 0;\n            } else if (k > 1) {\n                k = 1;\n            }\n            bytes[j++] = car - (car - cbr) * k | 0;\n            bytes[j++] = cag - (cag - cbg) * k | 0;\n            bytes[j++] = cab - (cab - cbb) * k | 0;\n            bytes[j++] = 255;\n        }\n    }\n}\nfunction drawFigure(data, figure, context) {\n    const ps = figure.coords;\n    const cs = figure.colors;\n    let i, ii;\n    switch(figure.type){\n        case \"lattice\":\n            const verticesPerRow = figure.verticesPerRow;\n            const rows = Math.floor(ps.length / verticesPerRow) - 1;\n            const cols = verticesPerRow - 1;\n            for(i = 0; i < rows; i++){\n                let q = i * verticesPerRow;\n                for(let j = 0; j < cols; j++, q++){\n                    drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n                    drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n                }\n            }\n            break;\n        case \"triangles\":\n            for(i = 0, ii = ps.length; i < ii; i += 3){\n                drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n            }\n            break;\n        default:\n            throw new Error(\"illegal figure\");\n    }\n}\nclass MeshShadingPattern extends BaseShadingPattern {\n    constructor(IR){\n        super();\n        this._coords = IR[2];\n        this._colors = IR[3];\n        this._figures = IR[4];\n        this._bounds = IR[5];\n        this._bbox = IR[7];\n        this._background = IR[8];\n        this.matrix = null;\n    }\n    _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {\n        const EXPECTED_SCALE = 1.1;\n        const MAX_PATTERN_SIZE = 3000;\n        const BORDER_SIZE = 2;\n        const offsetX = Math.floor(this._bounds[0]);\n        const offsetY = Math.floor(this._bounds[1]);\n        const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;\n        const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;\n        const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n        const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n        const scaleX = boundsWidth / width;\n        const scaleY = boundsHeight / height;\n        const context = {\n            coords: this._coords,\n            colors: this._colors,\n            offsetX: -offsetX,\n            offsetY: -offsetY,\n            scaleX: 1 / scaleX,\n            scaleY: 1 / scaleY\n        };\n        const paddedWidth = width + BORDER_SIZE * 2;\n        const paddedHeight = height + BORDER_SIZE * 2;\n        const tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight);\n        const tmpCtx = tmpCanvas.context;\n        const data = tmpCtx.createImageData(width, height);\n        if (backgroundColor) {\n            const bytes = data.data;\n            for(let i = 0, ii = bytes.length; i < ii; i += 4){\n                bytes[i] = backgroundColor[0];\n                bytes[i + 1] = backgroundColor[1];\n                bytes[i + 2] = backgroundColor[2];\n                bytes[i + 3] = 255;\n            }\n        }\n        for (const figure of this._figures){\n            drawFigure(data, figure, context);\n        }\n        tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n        const canvas = tmpCanvas.canvas;\n        return {\n            canvas,\n            offsetX: offsetX - BORDER_SIZE * scaleX,\n            offsetY: offsetY - BORDER_SIZE * scaleY,\n            scaleX,\n            scaleY\n        };\n    }\n    getPattern(ctx, owner, inverse, pathType) {\n        applyBoundingBox(ctx, this._bbox);\n        let scale;\n        if (pathType === PathType.SHADING) {\n            scale = Util.singularValueDecompose2dScale(getCurrentTransform(ctx));\n        } else {\n            scale = Util.singularValueDecompose2dScale(owner.baseTransform);\n            if (this.matrix) {\n                const matrixScale = Util.singularValueDecompose2dScale(this.matrix);\n                scale = [\n                    scale[0] * matrixScale[0],\n                    scale[1] * matrixScale[1]\n                ];\n            }\n        }\n        const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);\n        if (pathType !== PathType.SHADING) {\n            ctx.setTransform(...owner.baseTransform);\n            if (this.matrix) {\n                ctx.transform(...this.matrix);\n            }\n        }\n        ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n        ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n        return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n    }\n}\nclass DummyShadingPattern extends BaseShadingPattern {\n    getPattern() {\n        return \"hotpink\";\n    }\n}\nfunction getShadingPattern(IR) {\n    switch(IR[0]){\n        case \"RadialAxial\":\n            return new RadialAxialShadingPattern(IR);\n        case \"Mesh\":\n            return new MeshShadingPattern(IR);\n        case \"Dummy\":\n            return new DummyShadingPattern();\n    }\n    throw new Error(`Unknown IR type: ${IR[0]}`);\n}\nconst PaintType = {\n    COLORED: 1,\n    UNCOLORED: 2\n};\nclass TilingPattern {\n    static{\n        this.MAX_PATTERN_SIZE = 3000;\n    }\n    constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform){\n        this.operatorList = IR[2];\n        this.matrix = IR[3];\n        this.bbox = IR[4];\n        this.xstep = IR[5];\n        this.ystep = IR[6];\n        this.paintType = IR[7];\n        this.tilingType = IR[8];\n        this.color = color;\n        this.ctx = ctx;\n        this.canvasGraphicsFactory = canvasGraphicsFactory;\n        this.baseTransform = baseTransform;\n    }\n    createPatternCanvas(owner) {\n        const { bbox, operatorList, paintType, tilingType, color, canvasGraphicsFactory } = this;\n        let { xstep, ystep } = this;\n        xstep = Math.abs(xstep);\n        ystep = Math.abs(ystep);\n        info(\"TilingType: \" + tilingType);\n        const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];\n        const width = x1 - x0;\n        const height = y1 - y0;\n        const matrixScale = Util.singularValueDecompose2dScale(this.matrix);\n        const curMatrixScale = Util.singularValueDecompose2dScale(this.baseTransform);\n        const combinedScaleX = matrixScale[0] * curMatrixScale[0];\n        const combinedScaleY = matrixScale[1] * curMatrixScale[1];\n        let canvasWidth = width, canvasHeight = height, redrawHorizontally = false, redrawVertically = false;\n        const xScaledStep = Math.ceil(xstep * combinedScaleX);\n        const yScaledStep = Math.ceil(ystep * combinedScaleY);\n        const xScaledWidth = Math.ceil(width * combinedScaleX);\n        const yScaledHeight = Math.ceil(height * combinedScaleY);\n        if (xScaledStep >= xScaledWidth) {\n            canvasWidth = xstep;\n        } else {\n            redrawHorizontally = true;\n        }\n        if (yScaledStep >= yScaledHeight) {\n            canvasHeight = ystep;\n        } else {\n            redrawVertically = true;\n        }\n        const dimx = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);\n        const dimy = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);\n        const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size);\n        const tmpCtx = tmpCanvas.context;\n        const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\n        graphics.groupLevel = owner.groupLevel;\n        this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n        tmpCtx.translate(-dimx.scale * x0, -dimy.scale * y0);\n        graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);\n        tmpCtx.save();\n        this.clipBbox(graphics, x0, y0, x1, y1);\n        graphics.baseTransform = getCurrentTransform(graphics.ctx);\n        graphics.executeOperatorList(operatorList);\n        graphics.endDrawing();\n        tmpCtx.restore();\n        if (redrawHorizontally || redrawVertically) {\n            const image = tmpCanvas.canvas;\n            if (redrawHorizontally) {\n                canvasWidth = xstep;\n            }\n            if (redrawVertically) {\n                canvasHeight = ystep;\n            }\n            const dimx2 = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);\n            const dimy2 = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);\n            const xSize = dimx2.size;\n            const ySize = dimy2.size;\n            const tmpCanvas2 = owner.cachedCanvases.getCanvas(\"pattern-workaround\", xSize, ySize);\n            const tmpCtx2 = tmpCanvas2.context;\n            const ii = redrawHorizontally ? Math.floor(width / xstep) : 0;\n            const jj = redrawVertically ? Math.floor(height / ystep) : 0;\n            for(let i = 0; i <= ii; i++){\n                for(let j = 0; j <= jj; j++){\n                    tmpCtx2.drawImage(image, xSize * i, ySize * j, xSize, ySize, 0, 0, xSize, ySize);\n                }\n            }\n            return {\n                canvas: tmpCanvas2.canvas,\n                scaleX: dimx2.scale,\n                scaleY: dimy2.scale,\n                offsetX: x0,\n                offsetY: y0\n            };\n        }\n        return {\n            canvas: tmpCanvas.canvas,\n            scaleX: dimx.scale,\n            scaleY: dimy.scale,\n            offsetX: x0,\n            offsetY: y0\n        };\n    }\n    getSizeAndScale(step, realOutputSize, scale) {\n        const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);\n        let size = Math.ceil(step * scale);\n        if (size >= maxSize) {\n            size = maxSize;\n        } else {\n            scale = size / step;\n        }\n        return {\n            scale,\n            size\n        };\n    }\n    clipBbox(graphics, x0, y0, x1, y1) {\n        const bboxWidth = x1 - x0;\n        const bboxHeight = y1 - y0;\n        graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n        graphics.current.updateRectMinMax(getCurrentTransform(graphics.ctx), [\n            x0,\n            y0,\n            x1,\n            y1\n        ]);\n        graphics.clip();\n        graphics.endPath();\n    }\n    setFillAndStrokeStyleToContext(graphics, paintType, color) {\n        const context = graphics.ctx, current = graphics.current;\n        switch(paintType){\n            case PaintType.COLORED:\n                const ctx = this.ctx;\n                context.fillStyle = ctx.fillStyle;\n                context.strokeStyle = ctx.strokeStyle;\n                current.fillColor = ctx.fillStyle;\n                current.strokeColor = ctx.strokeStyle;\n                break;\n            case PaintType.UNCOLORED:\n                const cssColor = Util.makeHexColor(color[0], color[1], color[2]);\n                context.fillStyle = cssColor;\n                context.strokeStyle = cssColor;\n                current.fillColor = cssColor;\n                current.strokeColor = cssColor;\n                break;\n            default:\n                throw new FormatError(`Unsupported paint type: ${paintType}`);\n        }\n    }\n    getPattern(ctx, owner, inverse, pathType) {\n        let matrix = inverse;\n        if (pathType !== PathType.SHADING) {\n            matrix = Util.transform(matrix, owner.baseTransform);\n            if (this.matrix) {\n                matrix = Util.transform(matrix, this.matrix);\n            }\n        }\n        const temporaryPatternCanvas = this.createPatternCanvas(owner);\n        let domMatrix = new DOMMatrix(matrix);\n        domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n        domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);\n        const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, \"repeat\");\n        pattern.setTransform(domMatrix);\n        return pattern;\n    }\n}\n; // ./src/shared/image_utils.js\nfunction convertToRGBA(params) {\n    switch(params.kind){\n        case ImageKind.GRAYSCALE_1BPP:\n            return convertBlackAndWhiteToRGBA(params);\n        case ImageKind.RGB_24BPP:\n            return convertRGBToRGBA(params);\n    }\n    return null;\n}\nfunction convertBlackAndWhiteToRGBA({ src, srcPos = 0, dest, width, height, nonBlackColor = 0xffffffff, inverseDecode = false }) {\n    const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n    const [zeroMapping, oneMapping] = inverseDecode ? [\n        nonBlackColor,\n        black\n    ] : [\n        black,\n        nonBlackColor\n    ];\n    const widthInSource = width >> 3;\n    const widthRemainder = width & 7;\n    const srcLength = src.length;\n    dest = new Uint32Array(dest.buffer);\n    let destPos = 0;\n    for(let i = 0; i < height; i++){\n        for(const max = srcPos + widthInSource; srcPos < max; srcPos++){\n            const elem = srcPos < srcLength ? src[srcPos] : 255;\n            dest[destPos++] = elem & 128 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 64 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 32 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 16 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 8 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 4 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 2 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 1 ? oneMapping : zeroMapping;\n        }\n        if (widthRemainder === 0) {\n            continue;\n        }\n        const elem = srcPos < srcLength ? src[srcPos++] : 255;\n        for(let j = 0; j < widthRemainder; j++){\n            dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;\n        }\n    }\n    return {\n        srcPos,\n        destPos\n    };\n}\nfunction convertRGBToRGBA({ src, srcPos = 0, dest, destPos = 0, width, height }) {\n    let i = 0;\n    const len = width * height * 3;\n    const len32 = len >> 2;\n    const src32 = new Uint32Array(src.buffer, srcPos, len32);\n    if (FeatureTest.isLittleEndian) {\n        for(; i < len32 - 2; i += 3, destPos += 4){\n            const s1 = src32[i];\n            const s2 = src32[i + 1];\n            const s3 = src32[i + 2];\n            dest[destPos] = s1 | 0xff000000;\n            dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 0xff000000;\n            dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 0xff000000;\n            dest[destPos + 3] = s3 >>> 8 | 0xff000000;\n        }\n        for(let j = i * 4, jj = srcPos + len; j < jj; j += 3){\n            dest[destPos++] = src[j] | src[j + 1] << 8 | src[j + 2] << 16 | 0xff000000;\n        }\n    } else {\n        for(; i < len32 - 2; i += 3, destPos += 4){\n            const s1 = src32[i];\n            const s2 = src32[i + 1];\n            const s3 = src32[i + 2];\n            dest[destPos] = s1 | 0xff;\n            dest[destPos + 1] = s1 << 24 | s2 >>> 8 | 0xff;\n            dest[destPos + 2] = s2 << 16 | s3 >>> 16 | 0xff;\n            dest[destPos + 3] = s3 << 8 | 0xff;\n        }\n        for(let j = i * 4, jj = srcPos + len; j < jj; j += 3){\n            dest[destPos++] = src[j] << 24 | src[j + 1] << 16 | src[j + 2] << 8 | 0xff;\n        }\n    }\n    return {\n        srcPos: srcPos + len,\n        destPos\n    };\n}\nfunction grayToRGBA(src, dest) {\n    if (FeatureTest.isLittleEndian) {\n        for(let i = 0, ii = src.length; i < ii; i++){\n            dest[i] = src[i] * 0x10101 | 0xff000000;\n        }\n    } else {\n        for(let i = 0, ii = src.length; i < ii; i++){\n            dest[i] = src[i] * 0x1010100 | 0x000000ff;\n        }\n    }\n}\n; // ./src/display/canvas.js\nconst MIN_FONT_SIZE = 16;\nconst MAX_FONT_SIZE = 100;\nconst EXECUTION_TIME = 15;\nconst EXECUTION_STEPS = 10;\nconst MAX_SIZE_TO_COMPILE = 1000;\nconst FULL_CHUNK_HEIGHT = 16;\nfunction mirrorContextOperations(ctx, destCtx) {\n    if (ctx._removeMirroring) {\n        throw new Error(\"Context is already forwarding operations.\");\n    }\n    ctx.__originalSave = ctx.save;\n    ctx.__originalRestore = ctx.restore;\n    ctx.__originalRotate = ctx.rotate;\n    ctx.__originalScale = ctx.scale;\n    ctx.__originalTranslate = ctx.translate;\n    ctx.__originalTransform = ctx.transform;\n    ctx.__originalSetTransform = ctx.setTransform;\n    ctx.__originalResetTransform = ctx.resetTransform;\n    ctx.__originalClip = ctx.clip;\n    ctx.__originalMoveTo = ctx.moveTo;\n    ctx.__originalLineTo = ctx.lineTo;\n    ctx.__originalBezierCurveTo = ctx.bezierCurveTo;\n    ctx.__originalRect = ctx.rect;\n    ctx.__originalClosePath = ctx.closePath;\n    ctx.__originalBeginPath = ctx.beginPath;\n    ctx._removeMirroring = ()=>{\n        ctx.save = ctx.__originalSave;\n        ctx.restore = ctx.__originalRestore;\n        ctx.rotate = ctx.__originalRotate;\n        ctx.scale = ctx.__originalScale;\n        ctx.translate = ctx.__originalTranslate;\n        ctx.transform = ctx.__originalTransform;\n        ctx.setTransform = ctx.__originalSetTransform;\n        ctx.resetTransform = ctx.__originalResetTransform;\n        ctx.clip = ctx.__originalClip;\n        ctx.moveTo = ctx.__originalMoveTo;\n        ctx.lineTo = ctx.__originalLineTo;\n        ctx.bezierCurveTo = ctx.__originalBezierCurveTo;\n        ctx.rect = ctx.__originalRect;\n        ctx.closePath = ctx.__originalClosePath;\n        ctx.beginPath = ctx.__originalBeginPath;\n        delete ctx._removeMirroring;\n    };\n    ctx.save = function ctxSave() {\n        destCtx.save();\n        this.__originalSave();\n    };\n    ctx.restore = function ctxRestore() {\n        destCtx.restore();\n        this.__originalRestore();\n    };\n    ctx.translate = function ctxTranslate(x, y) {\n        destCtx.translate(x, y);\n        this.__originalTranslate(x, y);\n    };\n    ctx.scale = function ctxScale(x, y) {\n        destCtx.scale(x, y);\n        this.__originalScale(x, y);\n    };\n    ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n        destCtx.transform(a, b, c, d, e, f);\n        this.__originalTransform(a, b, c, d, e, f);\n    };\n    ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n        destCtx.setTransform(a, b, c, d, e, f);\n        this.__originalSetTransform(a, b, c, d, e, f);\n    };\n    ctx.resetTransform = function ctxResetTransform() {\n        destCtx.resetTransform();\n        this.__originalResetTransform();\n    };\n    ctx.rotate = function ctxRotate(angle) {\n        destCtx.rotate(angle);\n        this.__originalRotate(angle);\n    };\n    ctx.clip = function ctxRotate(rule) {\n        destCtx.clip(rule);\n        this.__originalClip(rule);\n    };\n    ctx.moveTo = function(x, y) {\n        destCtx.moveTo(x, y);\n        this.__originalMoveTo(x, y);\n    };\n    ctx.lineTo = function(x, y) {\n        destCtx.lineTo(x, y);\n        this.__originalLineTo(x, y);\n    };\n    ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {\n        destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n        this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n    };\n    ctx.rect = function(x, y, width, height) {\n        destCtx.rect(x, y, width, height);\n        this.__originalRect(x, y, width, height);\n    };\n    ctx.closePath = function() {\n        destCtx.closePath();\n        this.__originalClosePath();\n    };\n    ctx.beginPath = function() {\n        destCtx.beginPath();\n        this.__originalBeginPath();\n    };\n}\nclass CachedCanvases {\n    constructor(canvasFactory){\n        this.canvasFactory = canvasFactory;\n        this.cache = Object.create(null);\n    }\n    getCanvas(id, width, height) {\n        let canvasEntry;\n        if (this.cache[id] !== undefined) {\n            canvasEntry = this.cache[id];\n            this.canvasFactory.reset(canvasEntry, width, height);\n        } else {\n            canvasEntry = this.canvasFactory.create(width, height);\n            this.cache[id] = canvasEntry;\n        }\n        return canvasEntry;\n    }\n    delete(id) {\n        delete this.cache[id];\n    }\n    clear() {\n        for(const id in this.cache){\n            const canvasEntry = this.cache[id];\n            this.canvasFactory.destroy(canvasEntry);\n            delete this.cache[id];\n        }\n    }\n}\nfunction drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {\n    const [a, b, c, d, tx, ty] = getCurrentTransform(ctx);\n    if (b === 0 && c === 0) {\n        const tlX = destX * a + tx;\n        const rTlX = Math.round(tlX);\n        const tlY = destY * d + ty;\n        const rTlY = Math.round(tlY);\n        const brX = (destX + destW) * a + tx;\n        const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n        const brY = (destY + destH) * d + ty;\n        const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n        ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);\n        ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);\n        ctx.setTransform(a, b, c, d, tx, ty);\n        return [\n            rWidth,\n            rHeight\n        ];\n    }\n    if (a === 0 && d === 0) {\n        const tlX = destY * c + tx;\n        const rTlX = Math.round(tlX);\n        const tlY = destX * b + ty;\n        const rTlY = Math.round(tlY);\n        const brX = (destY + destH) * c + tx;\n        const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n        const brY = (destX + destW) * b + ty;\n        const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n        ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);\n        ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);\n        ctx.setTransform(a, b, c, d, tx, ty);\n        return [\n            rHeight,\n            rWidth\n        ];\n    }\n    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);\n    const scaleX = Math.hypot(a, b);\n    const scaleY = Math.hypot(c, d);\n    return [\n        scaleX * destW,\n        scaleY * destH\n    ];\n}\nfunction compileType3Glyph(imgData) {\n    const { width, height } = imgData;\n    if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {\n        return null;\n    }\n    const POINT_TO_PROCESS_LIMIT = 1000;\n    const POINT_TYPES = new Uint8Array([\n        0,\n        2,\n        4,\n        0,\n        1,\n        0,\n        5,\n        4,\n        8,\n        10,\n        0,\n        8,\n        0,\n        2,\n        1,\n        0\n    ]);\n    const width1 = width + 1;\n    let points = new Uint8Array(width1 * (height + 1));\n    let i, j, j0;\n    const lineSize = width + 7 & ~7;\n    let data = new Uint8Array(lineSize * height), pos = 0;\n    for (const elem of imgData.data){\n        let mask = 128;\n        while(mask > 0){\n            data[pos++] = elem & mask ? 0 : 255;\n            mask >>= 1;\n        }\n    }\n    let count = 0;\n    pos = 0;\n    if (data[pos] !== 0) {\n        points[0] = 1;\n        ++count;\n    }\n    for(j = 1; j < width; j++){\n        if (data[pos] !== data[pos + 1]) {\n            points[j] = data[pos] ? 2 : 1;\n            ++count;\n        }\n        pos++;\n    }\n    if (data[pos] !== 0) {\n        points[j] = 2;\n        ++count;\n    }\n    for(i = 1; i < height; i++){\n        pos = i * lineSize;\n        j0 = i * width1;\n        if (data[pos - lineSize] !== data[pos]) {\n            points[j0] = data[pos] ? 1 : 8;\n            ++count;\n        }\n        let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);\n        for(j = 1; j < width; j++){\n            sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);\n            if (POINT_TYPES[sum]) {\n                points[j0 + j] = POINT_TYPES[sum];\n                ++count;\n            }\n            pos++;\n        }\n        if (data[pos - lineSize] !== data[pos]) {\n            points[j0 + j] = data[pos] ? 2 : 4;\n            ++count;\n        }\n        if (count > POINT_TO_PROCESS_LIMIT) {\n            return null;\n        }\n    }\n    pos = lineSize * (height - 1);\n    j0 = i * width1;\n    if (data[pos] !== 0) {\n        points[j0] = 8;\n        ++count;\n    }\n    for(j = 1; j < width; j++){\n        if (data[pos] !== data[pos + 1]) {\n            points[j0 + j] = data[pos] ? 4 : 8;\n            ++count;\n        }\n        pos++;\n    }\n    if (data[pos] !== 0) {\n        points[j0 + j] = 4;\n        ++count;\n    }\n    if (count > POINT_TO_PROCESS_LIMIT) {\n        return null;\n    }\n    const steps = new Int32Array([\n        0,\n        width1,\n        -1,\n        0,\n        -width1,\n        0,\n        0,\n        0,\n        1\n    ]);\n    const path = new Path2D();\n    for(i = 0; count && i <= height; i++){\n        let p = i * width1;\n        const end = p + width;\n        while(p < end && !points[p]){\n            p++;\n        }\n        if (p === end) {\n            continue;\n        }\n        path.moveTo(p % width1, i);\n        const p0 = p;\n        let type = points[p];\n        do {\n            const step = steps[type];\n            do {\n                p += step;\n            }while (!points[p]);\n            const pp = points[p];\n            if (pp !== 5 && pp !== 10) {\n                type = pp;\n                points[p] = 0;\n            } else {\n                type = pp & 0x33 * type >> 4;\n                points[p] &= type >> 2 | type << 2;\n            }\n            path.lineTo(p % width1, p / width1 | 0);\n            if (!points[p]) {\n                --count;\n            }\n        }while (p0 !== p);\n        --i;\n    }\n    data = null;\n    points = null;\n    const drawOutline = function(c) {\n        c.save();\n        c.scale(1 / width, -1 / height);\n        c.translate(0, -height);\n        c.fill(path);\n        c.beginPath();\n        c.restore();\n    };\n    return drawOutline;\n}\nclass CanvasExtraState {\n    constructor(width, height){\n        this.alphaIsShape = false;\n        this.fontSize = 0;\n        this.fontSizeScale = 1;\n        this.textMatrix = IDENTITY_MATRIX;\n        this.textMatrixScale = 1;\n        this.fontMatrix = FONT_IDENTITY_MATRIX;\n        this.leading = 0;\n        this.x = 0;\n        this.y = 0;\n        this.lineX = 0;\n        this.lineY = 0;\n        this.charSpacing = 0;\n        this.wordSpacing = 0;\n        this.textHScale = 1;\n        this.textRenderingMode = TextRenderingMode.FILL;\n        this.textRise = 0;\n        this.fillColor = \"#000000\";\n        this.strokeColor = \"#000000\";\n        this.patternFill = false;\n        this.patternStroke = false;\n        this.fillAlpha = 1;\n        this.strokeAlpha = 1;\n        this.lineWidth = 1;\n        this.activeSMask = null;\n        this.transferMaps = \"none\";\n        this.startNewPathAndClipBox([\n            0,\n            0,\n            width,\n            height\n        ]);\n    }\n    clone() {\n        const clone = Object.create(this);\n        clone.clipBox = this.clipBox.slice();\n        return clone;\n    }\n    setCurrentPoint(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    updatePathMinMax(transform, x, y) {\n        [x, y] = Util.applyTransform([\n            x,\n            y\n        ], transform);\n        this.minX = Math.min(this.minX, x);\n        this.minY = Math.min(this.minY, y);\n        this.maxX = Math.max(this.maxX, x);\n        this.maxY = Math.max(this.maxY, y);\n    }\n    updateRectMinMax(transform, rect) {\n        const p1 = Util.applyTransform(rect, transform);\n        const p2 = Util.applyTransform(rect.slice(2), transform);\n        const p3 = Util.applyTransform([\n            rect[0],\n            rect[3]\n        ], transform);\n        const p4 = Util.applyTransform([\n            rect[2],\n            rect[1]\n        ], transform);\n        this.minX = Math.min(this.minX, p1[0], p2[0], p3[0], p4[0]);\n        this.minY = Math.min(this.minY, p1[1], p2[1], p3[1], p4[1]);\n        this.maxX = Math.max(this.maxX, p1[0], p2[0], p3[0], p4[0]);\n        this.maxY = Math.max(this.maxY, p1[1], p2[1], p3[1], p4[1]);\n    }\n    updateScalingPathMinMax(transform, minMax) {\n        Util.scaleMinMax(transform, minMax);\n        this.minX = Math.min(this.minX, minMax[0]);\n        this.minY = Math.min(this.minY, minMax[1]);\n        this.maxX = Math.max(this.maxX, minMax[2]);\n        this.maxY = Math.max(this.maxY, minMax[3]);\n    }\n    updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {\n        const box = Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax);\n        if (minMax) {\n            return;\n        }\n        this.updateRectMinMax(transform, box);\n    }\n    getPathBoundingBox(pathType = PathType.FILL, transform = null) {\n        const box = [\n            this.minX,\n            this.minY,\n            this.maxX,\n            this.maxY\n        ];\n        if (pathType === PathType.STROKE) {\n            if (!transform) {\n                unreachable(\"Stroke bounding box must include transform.\");\n            }\n            const scale = Util.singularValueDecompose2dScale(transform);\n            const xStrokePad = scale[0] * this.lineWidth / 2;\n            const yStrokePad = scale[1] * this.lineWidth / 2;\n            box[0] -= xStrokePad;\n            box[1] -= yStrokePad;\n            box[2] += xStrokePad;\n            box[3] += yStrokePad;\n        }\n        return box;\n    }\n    updateClipFromPath() {\n        const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());\n        this.startNewPathAndClipBox(intersect || [\n            0,\n            0,\n            0,\n            0\n        ]);\n    }\n    isEmptyClip() {\n        return this.minX === Infinity;\n    }\n    startNewPathAndClipBox(box) {\n        this.clipBox = box;\n        this.minX = Infinity;\n        this.minY = Infinity;\n        this.maxX = 0;\n        this.maxY = 0;\n    }\n    getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {\n        return Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));\n    }\n}\nfunction putBinaryImageData(ctx, imgData) {\n    if (imgData instanceof ImageData) {\n        ctx.putImageData(imgData, 0, 0);\n        return;\n    }\n    const height = imgData.height, width = imgData.width;\n    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n    let srcPos = 0, destPos;\n    const src = imgData.data;\n    const dest = chunkImgData.data;\n    let i, j, thisChunkHeight, elemsInThisChunk;\n    if (imgData.kind === util_ImageKind.GRAYSCALE_1BPP) {\n        const srcLength = src.byteLength;\n        const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n        const dest32DataLength = dest32.length;\n        const fullSrcDiff = width + 7 >> 3;\n        const white = 0xffffffff;\n        const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n        for(i = 0; i < totalChunks; i++){\n            thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n            destPos = 0;\n            for(j = 0; j < thisChunkHeight; j++){\n                const srcDiff = srcLength - srcPos;\n                let k = 0;\n                const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n                const kEndUnrolled = kEnd & ~7;\n                let mask = 0;\n                let srcByte = 0;\n                for(; k < kEndUnrolled; k += 8){\n                    srcByte = src[srcPos++];\n                    dest32[destPos++] = srcByte & 128 ? white : black;\n                    dest32[destPos++] = srcByte & 64 ? white : black;\n                    dest32[destPos++] = srcByte & 32 ? white : black;\n                    dest32[destPos++] = srcByte & 16 ? white : black;\n                    dest32[destPos++] = srcByte & 8 ? white : black;\n                    dest32[destPos++] = srcByte & 4 ? white : black;\n                    dest32[destPos++] = srcByte & 2 ? white : black;\n                    dest32[destPos++] = srcByte & 1 ? white : black;\n                }\n                for(; k < kEnd; k++){\n                    if (mask === 0) {\n                        srcByte = src[srcPos++];\n                        mask = 128;\n                    }\n                    dest32[destPos++] = srcByte & mask ? white : black;\n                    mask >>= 1;\n                }\n            }\n            while(destPos < dest32DataLength){\n                dest32[destPos++] = 0;\n            }\n            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n        }\n    } else if (imgData.kind === util_ImageKind.RGBA_32BPP) {\n        j = 0;\n        elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n        for(i = 0; i < fullChunks; i++){\n            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n            srcPos += elemsInThisChunk;\n            ctx.putImageData(chunkImgData, 0, j);\n            j += FULL_CHUNK_HEIGHT;\n        }\n        if (i < totalChunks) {\n            elemsInThisChunk = width * partialChunkHeight * 4;\n            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n            ctx.putImageData(chunkImgData, 0, j);\n        }\n    } else if (imgData.kind === util_ImageKind.RGB_24BPP) {\n        thisChunkHeight = FULL_CHUNK_HEIGHT;\n        elemsInThisChunk = width * thisChunkHeight;\n        for(i = 0; i < totalChunks; i++){\n            if (i >= fullChunks) {\n                thisChunkHeight = partialChunkHeight;\n                elemsInThisChunk = width * thisChunkHeight;\n            }\n            destPos = 0;\n            for(j = elemsInThisChunk; j--;){\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = 255;\n            }\n            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n        }\n    } else {\n        throw new Error(`bad image kind: ${imgData.kind}`);\n    }\n}\nfunction putBinaryImageMask(ctx, imgData) {\n    if (imgData.bitmap) {\n        ctx.drawImage(imgData.bitmap, 0, 0);\n        return;\n    }\n    const height = imgData.height, width = imgData.width;\n    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n    let srcPos = 0;\n    const src = imgData.data;\n    const dest = chunkImgData.data;\n    for(let i = 0; i < totalChunks; i++){\n        const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n        ({ srcPos } = convertBlackAndWhiteToRGBA({\n            src,\n            srcPos,\n            dest,\n            width,\n            height: thisChunkHeight,\n            nonBlackColor: 0\n        }));\n        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n}\nfunction copyCtxState(sourceCtx, destCtx) {\n    const properties = [\n        \"strokeStyle\",\n        \"fillStyle\",\n        \"fillRule\",\n        \"globalAlpha\",\n        \"lineWidth\",\n        \"lineCap\",\n        \"lineJoin\",\n        \"miterLimit\",\n        \"globalCompositeOperation\",\n        \"font\",\n        \"filter\"\n    ];\n    for (const property of properties){\n        if (sourceCtx[property] !== undefined) {\n            destCtx[property] = sourceCtx[property];\n        }\n    }\n    if (sourceCtx.setLineDash !== undefined) {\n        destCtx.setLineDash(sourceCtx.getLineDash());\n        destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n    }\n}\nfunction resetCtxToDefault(ctx) {\n    ctx.strokeStyle = ctx.fillStyle = \"#000000\";\n    ctx.fillRule = \"nonzero\";\n    ctx.globalAlpha = 1;\n    ctx.lineWidth = 1;\n    ctx.lineCap = \"butt\";\n    ctx.lineJoin = \"miter\";\n    ctx.miterLimit = 10;\n    ctx.globalCompositeOperation = \"source-over\";\n    ctx.font = \"10px sans-serif\";\n    if (ctx.setLineDash !== undefined) {\n        ctx.setLineDash([]);\n        ctx.lineDashOffset = 0;\n    }\n    if (!isNodeJS) {\n        const { filter } = ctx;\n        if (filter !== \"none\" && filter !== \"\") {\n            ctx.filter = \"none\";\n        }\n    }\n}\nfunction getImageSmoothingEnabled(transform, interpolate) {\n    if (interpolate) {\n        return true;\n    }\n    const scale = Util.singularValueDecompose2dScale(transform);\n    scale[0] = Math.fround(scale[0]);\n    scale[1] = Math.fround(scale[1]);\n    const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * PixelsPerInch.PDF_TO_CSS_UNITS);\n    return scale[0] <= actualScale && scale[1] <= actualScale;\n}\nconst LINE_CAP_STYLES = [\n    \"butt\",\n    \"round\",\n    \"square\"\n];\nconst LINE_JOIN_STYLES = [\n    \"miter\",\n    \"round\",\n    \"bevel\"\n];\nconst NORMAL_CLIP = {};\nconst EO_CLIP = {};\nclass CanvasGraphics {\n    constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, { optionalContentConfig, markedContentStack = null }, annotationCanvasMap, pageColors){\n        this.ctx = canvasCtx;\n        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n        this.stateStack = [];\n        this.pendingClip = null;\n        this.pendingEOFill = false;\n        this.res = null;\n        this.xobjs = null;\n        this.commonObjs = commonObjs;\n        this.objs = objs;\n        this.canvasFactory = canvasFactory;\n        this.filterFactory = filterFactory;\n        this.groupStack = [];\n        this.processingType3 = null;\n        this.baseTransform = null;\n        this.baseTransformStack = [];\n        this.groupLevel = 0;\n        this.smaskStack = [];\n        this.smaskCounter = 0;\n        this.tempSMask = null;\n        this.suspendedCtx = null;\n        this.contentVisible = true;\n        this.markedContentStack = markedContentStack || [];\n        this.optionalContentConfig = optionalContentConfig;\n        this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n        this.cachedPatterns = new Map();\n        this.annotationCanvasMap = annotationCanvasMap;\n        this.viewportScale = 1;\n        this.outputScaleX = 1;\n        this.outputScaleY = 1;\n        this.pageColors = pageColors;\n        this._cachedScaleForStroking = [\n            -1,\n            0\n        ];\n        this._cachedGetSinglePixelWidth = null;\n        this._cachedBitmapsMap = new Map();\n    }\n    getObject(data, fallback = null) {\n        if (typeof data === \"string\") {\n            return data.startsWith(\"g_\") ? this.commonObjs.get(data) : this.objs.get(data);\n        }\n        return fallback;\n    }\n    beginDrawing({ transform, viewport, transparency = false, background = null }) {\n        const width = this.ctx.canvas.width;\n        const height = this.ctx.canvas.height;\n        const savedFillStyle = this.ctx.fillStyle;\n        this.ctx.fillStyle = background || \"#ffffff\";\n        this.ctx.fillRect(0, 0, width, height);\n        this.ctx.fillStyle = savedFillStyle;\n        if (transparency) {\n            const transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height);\n            this.compositeCtx = this.ctx;\n            this.transparentCanvas = transparentCanvas.canvas;\n            this.ctx = transparentCanvas.context;\n            this.ctx.save();\n            this.ctx.transform(...getCurrentTransform(this.compositeCtx));\n        }\n        this.ctx.save();\n        resetCtxToDefault(this.ctx);\n        if (transform) {\n            this.ctx.transform(...transform);\n            this.outputScaleX = transform[0];\n            this.outputScaleY = transform[0];\n        }\n        this.ctx.transform(...viewport.transform);\n        this.viewportScale = viewport.scale;\n        this.baseTransform = getCurrentTransform(this.ctx);\n    }\n    executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {\n        const argsArray = operatorList.argsArray;\n        const fnArray = operatorList.fnArray;\n        let i = executionStartIdx || 0;\n        const argsArrayLen = argsArray.length;\n        if (argsArrayLen === i) {\n            return i;\n        }\n        const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\n        const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n        let steps = 0;\n        const commonObjs = this.commonObjs;\n        const objs = this.objs;\n        let fnId;\n        while(true){\n            if (stepper !== undefined && i === stepper.nextBreakPoint) {\n                stepper.breakIt(i, continueCallback);\n                return i;\n            }\n            fnId = fnArray[i];\n            if (fnId !== OPS.dependency) {\n                this[fnId].apply(this, argsArray[i]);\n            } else {\n                for (const depObjId of argsArray[i]){\n                    const objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n                    if (!objsPool.has(depObjId)) {\n                        objsPool.get(depObjId, continueCallback);\n                        return i;\n                    }\n                }\n            }\n            i++;\n            if (i === argsArrayLen) {\n                return i;\n            }\n            if (chunkOperations && ++steps > EXECUTION_STEPS) {\n                if (Date.now() > endTime) {\n                    continueCallback();\n                    return i;\n                }\n                steps = 0;\n            }\n        }\n    }\n    #restoreInitialState() {\n        while(this.stateStack.length || this.inSMaskMode){\n            this.restore();\n        }\n        this.current.activeSMask = null;\n        this.ctx.restore();\n        if (this.transparentCanvas) {\n            this.ctx = this.compositeCtx;\n            this.ctx.save();\n            this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n            this.ctx.drawImage(this.transparentCanvas, 0, 0);\n            this.ctx.restore();\n            this.transparentCanvas = null;\n        }\n    }\n    endDrawing() {\n        this.#restoreInitialState();\n        this.cachedCanvases.clear();\n        this.cachedPatterns.clear();\n        for (const cache of this._cachedBitmapsMap.values()){\n            for (const canvas of cache.values()){\n                if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement) {\n                    canvas.width = canvas.height = 0;\n                }\n            }\n            cache.clear();\n        }\n        this._cachedBitmapsMap.clear();\n        this.#drawFilter();\n    }\n    #drawFilter() {\n        if (this.pageColors) {\n            const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);\n            if (hcmFilterId !== \"none\") {\n                const savedFilter = this.ctx.filter;\n                this.ctx.filter = hcmFilterId;\n                this.ctx.drawImage(this.ctx.canvas, 0, 0);\n                this.ctx.filter = savedFilter;\n            }\n        }\n    }\n    _scaleImage(img, inverseTransform) {\n        const width = img.width ?? img.displayWidth;\n        const height = img.height ?? img.displayHeight;\n        let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);\n        let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);\n        let paintWidth = width, paintHeight = height;\n        let tmpCanvasId = \"prescale1\";\n        let tmpCanvas, tmpCtx;\n        while(widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1){\n            let newWidth = paintWidth, newHeight = paintHeight;\n            if (widthScale > 2 && paintWidth > 1) {\n                newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);\n                widthScale /= paintWidth / newWidth;\n            }\n            if (heightScale > 2 && paintHeight > 1) {\n                newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;\n                heightScale /= paintHeight / newHeight;\n            }\n            tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n            tmpCtx = tmpCanvas.context;\n            tmpCtx.clearRect(0, 0, newWidth, newHeight);\n            tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n            img = tmpCanvas.canvas;\n            paintWidth = newWidth;\n            paintHeight = newHeight;\n            tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n        }\n        return {\n            img,\n            paintWidth,\n            paintHeight\n        };\n    }\n    _createMaskCanvas(img) {\n        const ctx = this.ctx;\n        const { width, height } = img;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        const currentTransform = getCurrentTransform(ctx);\n        let cache, cacheKey, scaled, maskCanvas;\n        if ((img.bitmap || img.data) && img.count > 1) {\n            const mainKey = img.bitmap || img.data.buffer;\n            cacheKey = JSON.stringify(isPatternFill ? currentTransform : [\n                currentTransform.slice(0, 4),\n                fillColor\n            ]);\n            cache = this._cachedBitmapsMap.get(mainKey);\n            if (!cache) {\n                cache = new Map();\n                this._cachedBitmapsMap.set(mainKey, cache);\n            }\n            const cachedImage = cache.get(cacheKey);\n            if (cachedImage && !isPatternFill) {\n                const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);\n                const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);\n                return {\n                    canvas: cachedImage,\n                    offsetX,\n                    offsetY\n                };\n            }\n            scaled = cachedImage;\n        }\n        if (!scaled) {\n            maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n            putBinaryImageMask(maskCanvas.context, img);\n        }\n        let maskToCanvas = Util.transform(currentTransform, [\n            1 / width,\n            0,\n            0,\n            -1 / height,\n            0,\n            0\n        ]);\n        maskToCanvas = Util.transform(maskToCanvas, [\n            1,\n            0,\n            0,\n            1,\n            0,\n            -height\n        ]);\n        const [minX, minY, maxX, maxY] = Util.getAxialAlignedBoundingBox([\n            0,\n            0,\n            width,\n            height\n        ], maskToCanvas);\n        const drawnWidth = Math.round(maxX - minX) || 1;\n        const drawnHeight = Math.round(maxY - minY) || 1;\n        const fillCanvas = this.cachedCanvases.getCanvas(\"fillCanvas\", drawnWidth, drawnHeight);\n        const fillCtx = fillCanvas.context;\n        const offsetX = minX;\n        const offsetY = minY;\n        fillCtx.translate(-offsetX, -offsetY);\n        fillCtx.transform(...maskToCanvas);\n        if (!scaled) {\n            scaled = this._scaleImage(maskCanvas.canvas, getCurrentTransformInverse(fillCtx));\n            scaled = scaled.img;\n            if (cache && isPatternFill) {\n                cache.set(cacheKey, scaled);\n            }\n        }\n        fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(fillCtx), img.interpolate);\n        drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);\n        fillCtx.globalCompositeOperation = \"source-in\";\n        const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [\n            1,\n            0,\n            0,\n            1,\n            -offsetX,\n            -offsetY\n        ]);\n        fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, PathType.FILL) : fillColor;\n        fillCtx.fillRect(0, 0, width, height);\n        if (cache && !isPatternFill) {\n            this.cachedCanvases.delete(\"fillCanvas\");\n            cache.set(cacheKey, fillCanvas.canvas);\n        }\n        return {\n            canvas: fillCanvas.canvas,\n            offsetX: Math.round(offsetX),\n            offsetY: Math.round(offsetY)\n        };\n    }\n    setLineWidth(width) {\n        if (width !== this.current.lineWidth) {\n            this._cachedScaleForStroking[0] = -1;\n        }\n        this.current.lineWidth = width;\n        this.ctx.lineWidth = width;\n    }\n    setLineCap(style) {\n        this.ctx.lineCap = LINE_CAP_STYLES[style];\n    }\n    setLineJoin(style) {\n        this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n    }\n    setMiterLimit(limit) {\n        this.ctx.miterLimit = limit;\n    }\n    setDash(dashArray, dashPhase) {\n        const ctx = this.ctx;\n        if (ctx.setLineDash !== undefined) {\n            ctx.setLineDash(dashArray);\n            ctx.lineDashOffset = dashPhase;\n        }\n    }\n    setRenderingIntent(intent) {}\n    setFlatness(flatness) {}\n    setGState(states) {\n        for (const [key, value] of states){\n            switch(key){\n                case \"LW\":\n                    this.setLineWidth(value);\n                    break;\n                case \"LC\":\n                    this.setLineCap(value);\n                    break;\n                case \"LJ\":\n                    this.setLineJoin(value);\n                    break;\n                case \"ML\":\n                    this.setMiterLimit(value);\n                    break;\n                case \"D\":\n                    this.setDash(value[0], value[1]);\n                    break;\n                case \"RI\":\n                    this.setRenderingIntent(value);\n                    break;\n                case \"FL\":\n                    this.setFlatness(value);\n                    break;\n                case \"Font\":\n                    this.setFont(value[0], value[1]);\n                    break;\n                case \"CA\":\n                    this.current.strokeAlpha = value;\n                    break;\n                case \"ca\":\n                    this.current.fillAlpha = value;\n                    this.ctx.globalAlpha = value;\n                    break;\n                case \"BM\":\n                    this.ctx.globalCompositeOperation = value;\n                    break;\n                case \"SMask\":\n                    this.current.activeSMask = value ? this.tempSMask : null;\n                    this.tempSMask = null;\n                    this.checkSMaskState();\n                    break;\n                case \"TR\":\n                    this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);\n                    break;\n            }\n        }\n    }\n    get inSMaskMode() {\n        return !!this.suspendedCtx;\n    }\n    checkSMaskState() {\n        const inSMaskMode = this.inSMaskMode;\n        if (this.current.activeSMask && !inSMaskMode) {\n            this.beginSMaskMode();\n        } else if (!this.current.activeSMask && inSMaskMode) {\n            this.endSMaskMode();\n        }\n    }\n    beginSMaskMode() {\n        if (this.inSMaskMode) {\n            throw new Error(\"beginSMaskMode called while already in smask mode\");\n        }\n        const drawnWidth = this.ctx.canvas.width;\n        const drawnHeight = this.ctx.canvas.height;\n        const cacheId = \"smaskGroupAt\" + this.groupLevel;\n        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n        this.suspendedCtx = this.ctx;\n        this.ctx = scratchCanvas.context;\n        const ctx = this.ctx;\n        ctx.setTransform(...getCurrentTransform(this.suspendedCtx));\n        copyCtxState(this.suspendedCtx, ctx);\n        mirrorContextOperations(ctx, this.suspendedCtx);\n        this.setGState([\n            [\n                \"BM\",\n                \"source-over\"\n            ],\n            [\n                \"ca\",\n                1\n            ],\n            [\n                \"CA\",\n                1\n            ]\n        ]);\n    }\n    endSMaskMode() {\n        if (!this.inSMaskMode) {\n            throw new Error(\"endSMaskMode called while not in smask mode\");\n        }\n        this.ctx._removeMirroring();\n        copyCtxState(this.ctx, this.suspendedCtx);\n        this.ctx = this.suspendedCtx;\n        this.suspendedCtx = null;\n    }\n    compose(dirtyBox) {\n        if (!this.current.activeSMask) {\n            return;\n        }\n        if (!dirtyBox) {\n            dirtyBox = [\n                0,\n                0,\n                this.ctx.canvas.width,\n                this.ctx.canvas.height\n            ];\n        } else {\n            dirtyBox[0] = Math.floor(dirtyBox[0]);\n            dirtyBox[1] = Math.floor(dirtyBox[1]);\n            dirtyBox[2] = Math.ceil(dirtyBox[2]);\n            dirtyBox[3] = Math.ceil(dirtyBox[3]);\n        }\n        const smask = this.current.activeSMask;\n        const suspendedCtx = this.suspendedCtx;\n        this.composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);\n        this.ctx.save();\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n        this.ctx.restore();\n    }\n    composeSMask(ctx, smask, layerCtx, layerBox) {\n        const layerOffsetX = layerBox[0];\n        const layerOffsetY = layerBox[1];\n        const layerWidth = layerBox[2] - layerOffsetX;\n        const layerHeight = layerBox[3] - layerOffsetY;\n        if (layerWidth === 0 || layerHeight === 0) {\n            return;\n        }\n        this.genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);\n        ctx.save();\n        ctx.globalAlpha = 1;\n        ctx.globalCompositeOperation = \"source-over\";\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.drawImage(layerCtx.canvas, 0, 0);\n        ctx.restore();\n    }\n    genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {\n        let maskCanvas = maskCtx.canvas;\n        let maskX = layerOffsetX - maskOffsetX;\n        let maskY = layerOffsetY - maskOffsetY;\n        if (backdrop) {\n            const backdropRGB = Util.makeHexColor(...backdrop);\n            if (maskX < 0 || maskY < 0 || maskX + width > maskCanvas.width || maskY + height > maskCanvas.height) {\n                const canvas = this.cachedCanvases.getCanvas(\"maskExtension\", width, height);\n                const ctx = canvas.context;\n                ctx.drawImage(maskCanvas, -maskX, -maskY);\n                ctx.globalCompositeOperation = \"destination-atop\";\n                ctx.fillStyle = backdropRGB;\n                ctx.fillRect(0, 0, width, height);\n                ctx.globalCompositeOperation = \"source-over\";\n                maskCanvas = canvas.canvas;\n                maskX = maskY = 0;\n            } else {\n                maskCtx.save();\n                maskCtx.globalAlpha = 1;\n                maskCtx.setTransform(1, 0, 0, 1, 0, 0);\n                const clip = new Path2D();\n                clip.rect(maskX, maskY, width, height);\n                maskCtx.clip(clip);\n                maskCtx.globalCompositeOperation = \"destination-atop\";\n                maskCtx.fillStyle = backdropRGB;\n                maskCtx.fillRect(maskX, maskY, width, height);\n                maskCtx.restore();\n            }\n        }\n        layerCtx.save();\n        layerCtx.globalAlpha = 1;\n        layerCtx.setTransform(1, 0, 0, 1, 0, 0);\n        if (subtype === \"Alpha\" && transferMap) {\n            layerCtx.filter = this.filterFactory.addAlphaFilter(transferMap);\n        } else if (subtype === \"Luminosity\") {\n            layerCtx.filter = this.filterFactory.addLuminosityFilter(transferMap);\n        }\n        const clip = new Path2D();\n        clip.rect(layerOffsetX, layerOffsetY, width, height);\n        layerCtx.clip(clip);\n        layerCtx.globalCompositeOperation = \"destination-in\";\n        layerCtx.drawImage(maskCanvas, maskX, maskY, width, height, layerOffsetX, layerOffsetY, width, height);\n        layerCtx.restore();\n    }\n    save() {\n        if (this.inSMaskMode) {\n            copyCtxState(this.ctx, this.suspendedCtx);\n            this.suspendedCtx.save();\n        } else {\n            this.ctx.save();\n        }\n        const old = this.current;\n        this.stateStack.push(old);\n        this.current = old.clone();\n    }\n    restore() {\n        if (this.stateStack.length === 0 && this.inSMaskMode) {\n            this.endSMaskMode();\n        }\n        if (this.stateStack.length !== 0) {\n            this.current = this.stateStack.pop();\n            if (this.inSMaskMode) {\n                this.suspendedCtx.restore();\n                copyCtxState(this.suspendedCtx, this.ctx);\n            } else {\n                this.ctx.restore();\n            }\n            this.checkSMaskState();\n            this.pendingClip = null;\n            this._cachedScaleForStroking[0] = -1;\n            this._cachedGetSinglePixelWidth = null;\n        }\n    }\n    transform(a, b, c, d, e, f) {\n        this.ctx.transform(a, b, c, d, e, f);\n        this._cachedScaleForStroking[0] = -1;\n        this._cachedGetSinglePixelWidth = null;\n    }\n    constructPath(ops, args, minMax) {\n        const ctx = this.ctx;\n        const current = this.current;\n        let x = current.x, y = current.y;\n        let startX, startY;\n        const currentTransform = getCurrentTransform(ctx);\n        const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;\n        const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;\n        for(let i = 0, j = 0, ii = ops.length; i < ii; i++){\n            switch(ops[i] | 0){\n                case OPS.rectangle:\n                    x = args[j++];\n                    y = args[j++];\n                    const width = args[j++];\n                    const height = args[j++];\n                    const xw = x + width;\n                    const yh = y + height;\n                    ctx.moveTo(x, y);\n                    if (width === 0 || height === 0) {\n                        ctx.lineTo(xw, yh);\n                    } else {\n                        ctx.lineTo(xw, y);\n                        ctx.lineTo(xw, yh);\n                        ctx.lineTo(x, yh);\n                    }\n                    if (!isScalingMatrix) {\n                        current.updateRectMinMax(currentTransform, [\n                            x,\n                            y,\n                            xw,\n                            yh\n                        ]);\n                    }\n                    ctx.closePath();\n                    break;\n                case OPS.moveTo:\n                    x = args[j++];\n                    y = args[j++];\n                    ctx.moveTo(x, y);\n                    if (!isScalingMatrix) {\n                        current.updatePathMinMax(currentTransform, x, y);\n                    }\n                    break;\n                case OPS.lineTo:\n                    x = args[j++];\n                    y = args[j++];\n                    ctx.lineTo(x, y);\n                    if (!isScalingMatrix) {\n                        current.updatePathMinMax(currentTransform, x, y);\n                    }\n                    break;\n                case OPS.curveTo:\n                    startX = x;\n                    startY = y;\n                    x = args[j + 4];\n                    y = args[j + 5];\n                    ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);\n                    current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);\n                    j += 6;\n                    break;\n                case OPS.curveTo2:\n                    startX = x;\n                    startY = y;\n                    ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);\n                    current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);\n                    x = args[j + 2];\n                    y = args[j + 3];\n                    j += 4;\n                    break;\n                case OPS.curveTo3:\n                    startX = x;\n                    startY = y;\n                    x = args[j + 2];\n                    y = args[j + 3];\n                    ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);\n                    current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);\n                    j += 4;\n                    break;\n                case OPS.closePath:\n                    ctx.closePath();\n                    break;\n            }\n        }\n        if (isScalingMatrix) {\n            current.updateScalingPathMinMax(currentTransform, minMaxForBezier);\n        }\n        current.setCurrentPoint(x, y);\n    }\n    closePath() {\n        this.ctx.closePath();\n    }\n    stroke(consumePath = true) {\n        const ctx = this.ctx;\n        const strokeColor = this.current.strokeColor;\n        ctx.globalAlpha = this.current.strokeAlpha;\n        if (this.contentVisible) {\n            if (typeof strokeColor === \"object\" && strokeColor?.getPattern) {\n                ctx.save();\n                ctx.strokeStyle = strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE);\n                this.rescaleAndStroke(false);\n                ctx.restore();\n            } else {\n                this.rescaleAndStroke(true);\n            }\n        }\n        if (consumePath) {\n            this.consumePath(this.current.getClippedPathBoundingBox());\n        }\n        ctx.globalAlpha = this.current.fillAlpha;\n    }\n    closeStroke() {\n        this.closePath();\n        this.stroke();\n    }\n    fill(consumePath = true) {\n        const ctx = this.ctx;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        let needRestore = false;\n        if (isPatternFill) {\n            ctx.save();\n            ctx.fillStyle = fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL);\n            needRestore = true;\n        }\n        const intersect = this.current.getClippedPathBoundingBox();\n        if (this.contentVisible && intersect !== null) {\n            if (this.pendingEOFill) {\n                ctx.fill(\"evenodd\");\n                this.pendingEOFill = false;\n            } else {\n                ctx.fill();\n            }\n        }\n        if (needRestore) {\n            ctx.restore();\n        }\n        if (consumePath) {\n            this.consumePath(intersect);\n        }\n    }\n    eoFill() {\n        this.pendingEOFill = true;\n        this.fill();\n    }\n    fillStroke() {\n        this.fill(false);\n        this.stroke(false);\n        this.consumePath();\n    }\n    eoFillStroke() {\n        this.pendingEOFill = true;\n        this.fillStroke();\n    }\n    closeFillStroke() {\n        this.closePath();\n        this.fillStroke();\n    }\n    closeEOFillStroke() {\n        this.pendingEOFill = true;\n        this.closePath();\n        this.fillStroke();\n    }\n    endPath() {\n        this.consumePath();\n    }\n    clip() {\n        this.pendingClip = NORMAL_CLIP;\n    }\n    eoClip() {\n        this.pendingClip = EO_CLIP;\n    }\n    beginText() {\n        this.current.textMatrix = IDENTITY_MATRIX;\n        this.current.textMatrixScale = 1;\n        this.current.x = this.current.lineX = 0;\n        this.current.y = this.current.lineY = 0;\n    }\n    endText() {\n        const paths = this.pendingTextPaths;\n        const ctx = this.ctx;\n        if (paths === undefined) {\n            ctx.beginPath();\n            return;\n        }\n        const newPath = new Path2D();\n        const invTransf = ctx.getTransform().invertSelf();\n        for (const { transform, x, y, fontSize, path } of paths){\n            newPath.addPath(path, new DOMMatrix(transform).preMultiplySelf(invTransf).translate(x, y).scale(fontSize, -fontSize));\n        }\n        ctx.clip(newPath);\n        ctx.beginPath();\n        delete this.pendingTextPaths;\n    }\n    setCharSpacing(spacing) {\n        this.current.charSpacing = spacing;\n    }\n    setWordSpacing(spacing) {\n        this.current.wordSpacing = spacing;\n    }\n    setHScale(scale) {\n        this.current.textHScale = scale / 100;\n    }\n    setLeading(leading) {\n        this.current.leading = -leading;\n    }\n    setFont(fontRefName, size) {\n        const fontObj = this.commonObjs.get(fontRefName);\n        const current = this.current;\n        if (!fontObj) {\n            throw new Error(`Can't find font for ${fontRefName}`);\n        }\n        current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;\n        if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n            warn(\"Invalid font matrix for font \" + fontRefName);\n        }\n        if (size < 0) {\n            size = -size;\n            current.fontDirection = -1;\n        } else {\n            current.fontDirection = 1;\n        }\n        this.current.font = fontObj;\n        this.current.fontSize = size;\n        if (fontObj.isType3Font) {\n            return;\n        }\n        const name = fontObj.loadedName || \"sans-serif\";\n        const typeface = fontObj.systemFontInfo?.css || `\"${name}\", ${fontObj.fallbackName}`;\n        let bold = \"normal\";\n        if (fontObj.black) {\n            bold = \"900\";\n        } else if (fontObj.bold) {\n            bold = \"bold\";\n        }\n        const italic = fontObj.italic ? \"italic\" : \"normal\";\n        let browserFontSize = size;\n        if (size < MIN_FONT_SIZE) {\n            browserFontSize = MIN_FONT_SIZE;\n        } else if (size > MAX_FONT_SIZE) {\n            browserFontSize = MAX_FONT_SIZE;\n        }\n        this.current.fontSizeScale = size / browserFontSize;\n        this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;\n    }\n    setTextRenderingMode(mode) {\n        this.current.textRenderingMode = mode;\n    }\n    setTextRise(rise) {\n        this.current.textRise = rise;\n    }\n    moveText(x, y) {\n        this.current.x = this.current.lineX += x;\n        this.current.y = this.current.lineY += y;\n    }\n    setLeadingMoveText(x, y) {\n        this.setLeading(-y);\n        this.moveText(x, y);\n    }\n    setTextMatrix(a, b, c, d, e, f) {\n        this.current.textMatrix = [\n            a,\n            b,\n            c,\n            d,\n            e,\n            f\n        ];\n        this.current.textMatrixScale = Math.hypot(a, b);\n        this.current.x = this.current.lineX = 0;\n        this.current.y = this.current.lineY = 0;\n    }\n    nextLine() {\n        this.moveText(0, this.current.leading);\n    }\n    #getScaledPath(path, currentTransform, transform) {\n        const newPath = new Path2D();\n        newPath.addPath(path, new DOMMatrix(transform).invertSelf().multiplySelf(currentTransform));\n        return newPath;\n    }\n    paintChar(character, x, y, patternFillTransform, patternStrokeTransform) {\n        const ctx = this.ctx;\n        const current = this.current;\n        const font = current.font;\n        const textRenderingMode = current.textRenderingMode;\n        const fontSize = current.fontSize / current.fontSizeScale;\n        const fillStrokeMode = textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n        const isAddToPathSet = !!(textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);\n        const patternFill = current.patternFill && !font.missingFile;\n        const patternStroke = current.patternStroke && !font.missingFile;\n        let path;\n        if (font.disableFontFace || isAddToPathSet || patternFill || patternStroke) {\n            path = font.getPathGenerator(this.commonObjs, character);\n        }\n        if (font.disableFontFace || patternFill || patternStroke) {\n            ctx.save();\n            ctx.translate(x, y);\n            ctx.scale(fontSize, -fontSize);\n            if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                if (patternFillTransform) {\n                    const currentTransform = ctx.getTransform();\n                    ctx.setTransform(...patternFillTransform);\n                    ctx.fill(this.#getScaledPath(path, currentTransform, patternFillTransform));\n                } else {\n                    ctx.fill(path);\n                }\n            }\n            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                if (patternStrokeTransform) {\n                    const currentTransform = ctx.getTransform();\n                    ctx.setTransform(...patternStrokeTransform);\n                    ctx.stroke(this.#getScaledPath(path, currentTransform, patternStrokeTransform));\n                } else {\n                    ctx.lineWidth /= fontSize;\n                    ctx.stroke(path);\n                }\n            }\n            ctx.restore();\n        } else {\n            if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                ctx.fillText(character, x, y);\n            }\n            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                ctx.strokeText(character, x, y);\n            }\n        }\n        if (isAddToPathSet) {\n            const paths = this.pendingTextPaths ||= [];\n            paths.push({\n                transform: getCurrentTransform(ctx),\n                x,\n                y,\n                fontSize,\n                path\n            });\n        }\n    }\n    get isFontSubpixelAAEnabled() {\n        const { context: ctx } = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10);\n        ctx.scale(1.5, 1);\n        ctx.fillText(\"I\", 0, 10);\n        const data = ctx.getImageData(0, 0, 10, 10).data;\n        let enabled = false;\n        for(let i = 3; i < data.length; i += 4){\n            if (data[i] > 0 && data[i] < 255) {\n                enabled = true;\n                break;\n            }\n        }\n        return shadow(this, \"isFontSubpixelAAEnabled\", enabled);\n    }\n    showText(glyphs) {\n        const current = this.current;\n        const font = current.font;\n        if (font.isType3Font) {\n            return this.showType3Text(glyphs);\n        }\n        const fontSize = current.fontSize;\n        if (fontSize === 0) {\n            return undefined;\n        }\n        const ctx = this.ctx;\n        const fontSizeScale = current.fontSizeScale;\n        const charSpacing = current.charSpacing;\n        const wordSpacing = current.wordSpacing;\n        const fontDirection = current.fontDirection;\n        const textHScale = current.textHScale * fontDirection;\n        const glyphsLength = glyphs.length;\n        const vertical = font.vertical;\n        const spacingDir = vertical ? 1 : -1;\n        const defaultVMetrics = font.defaultVMetrics;\n        const widthAdvanceScale = fontSize * current.fontMatrix[0];\n        const simpleFillText = current.textRenderingMode === TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n        ctx.save();\n        ctx.transform(...current.textMatrix);\n        ctx.translate(current.x, current.y + current.textRise);\n        if (fontDirection > 0) {\n            ctx.scale(textHScale, -1);\n        } else {\n            ctx.scale(textHScale, 1);\n        }\n        let patternFillTransform, patternStrokeTransform;\n        if (current.patternFill) {\n            ctx.save();\n            const pattern = current.fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL);\n            patternFillTransform = getCurrentTransform(ctx);\n            ctx.restore();\n            ctx.fillStyle = pattern;\n        }\n        if (current.patternStroke) {\n            ctx.save();\n            const pattern = current.strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE);\n            patternStrokeTransform = getCurrentTransform(ctx);\n            ctx.restore();\n            ctx.strokeStyle = pattern;\n        }\n        let lineWidth = current.lineWidth;\n        const scale = current.textMatrixScale;\n        if (scale === 0 || lineWidth === 0) {\n            const fillStrokeMode = current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                lineWidth = this.getSinglePixelWidth();\n            }\n        } else {\n            lineWidth /= scale;\n        }\n        if (fontSizeScale !== 1.0) {\n            ctx.scale(fontSizeScale, fontSizeScale);\n            lineWidth /= fontSizeScale;\n        }\n        ctx.lineWidth = lineWidth;\n        if (font.isInvalidPDFjsFont) {\n            const chars = [];\n            let width = 0;\n            for (const glyph of glyphs){\n                chars.push(glyph.unicode);\n                width += glyph.width;\n            }\n            ctx.fillText(chars.join(\"\"), 0, 0);\n            current.x += width * widthAdvanceScale * textHScale;\n            ctx.restore();\n            this.compose();\n            return undefined;\n        }\n        let x = 0, i;\n        for(i = 0; i < glyphsLength; ++i){\n            const glyph = glyphs[i];\n            if (typeof glyph === \"number\") {\n                x += spacingDir * glyph * fontSize / 1000;\n                continue;\n            }\n            let restoreNeeded = false;\n            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n            const character = glyph.fontChar;\n            const accent = glyph.accent;\n            let scaledX, scaledY;\n            let width = glyph.width;\n            if (vertical) {\n                const vmetric = glyph.vmetric || defaultVMetrics;\n                const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;\n                const vy = vmetric[2] * widthAdvanceScale;\n                width = vmetric ? -vmetric[0] : width;\n                scaledX = vx / fontSizeScale;\n                scaledY = (x + vy) / fontSizeScale;\n            } else {\n                scaledX = x / fontSizeScale;\n                scaledY = 0;\n            }\n            if (font.remeasure && width > 0) {\n                const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;\n                if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n                    const characterScaleX = width / measuredWidth;\n                    restoreNeeded = true;\n                    ctx.save();\n                    ctx.scale(characterScaleX, 1);\n                    scaledX /= characterScaleX;\n                } else if (width !== measuredWidth) {\n                    scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n                }\n            }\n            if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n                if (simpleFillText && !accent) {\n                    ctx.fillText(character, scaledX, scaledY);\n                } else {\n                    this.paintChar(character, scaledX, scaledY, patternFillTransform, patternStrokeTransform);\n                    if (accent) {\n                        const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n                        const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n                        this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternFillTransform, patternStrokeTransform);\n                    }\n                }\n            }\n            const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;\n            x += charWidth;\n            if (restoreNeeded) {\n                ctx.restore();\n            }\n        }\n        if (vertical) {\n            current.y -= x;\n        } else {\n            current.x += x * textHScale;\n        }\n        ctx.restore();\n        this.compose();\n        return undefined;\n    }\n    showType3Text(glyphs) {\n        const ctx = this.ctx;\n        const current = this.current;\n        const font = current.font;\n        const fontSize = current.fontSize;\n        const fontDirection = current.fontDirection;\n        const spacingDir = font.vertical ? 1 : -1;\n        const charSpacing = current.charSpacing;\n        const wordSpacing = current.wordSpacing;\n        const textHScale = current.textHScale * fontDirection;\n        const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;\n        const glyphsLength = glyphs.length;\n        const isTextInvisible = current.textRenderingMode === TextRenderingMode.INVISIBLE;\n        let i, glyph, width, spacingLength;\n        if (isTextInvisible || fontSize === 0) {\n            return;\n        }\n        this._cachedScaleForStroking[0] = -1;\n        this._cachedGetSinglePixelWidth = null;\n        ctx.save();\n        ctx.transform(...current.textMatrix);\n        ctx.translate(current.x, current.y);\n        ctx.scale(textHScale, fontDirection);\n        for(i = 0; i < glyphsLength; ++i){\n            glyph = glyphs[i];\n            if (typeof glyph === \"number\") {\n                spacingLength = spacingDir * glyph * fontSize / 1000;\n                this.ctx.translate(spacingLength, 0);\n                current.x += spacingLength * textHScale;\n                continue;\n            }\n            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n            const operatorList = font.charProcOperatorList[glyph.operatorListId];\n            if (!operatorList) {\n                warn(`Type3 character \"${glyph.operatorListId}\" is not available.`);\n                continue;\n            }\n            if (this.contentVisible) {\n                this.processingType3 = glyph;\n                this.save();\n                ctx.scale(fontSize, fontSize);\n                ctx.transform(...fontMatrix);\n                this.executeOperatorList(operatorList);\n                this.restore();\n            }\n            const transformed = Util.applyTransform([\n                glyph.width,\n                0\n            ], fontMatrix);\n            width = transformed[0] * fontSize + spacing;\n            ctx.translate(width, 0);\n            current.x += width * textHScale;\n        }\n        ctx.restore();\n        this.processingType3 = null;\n    }\n    setCharWidth(xWidth, yWidth) {}\n    setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {\n        this.ctx.rect(llx, lly, urx - llx, ury - lly);\n        this.ctx.clip();\n        this.endPath();\n    }\n    getColorN_Pattern(IR) {\n        let pattern;\n        if (IR[0] === \"TilingPattern\") {\n            const color = IR[1];\n            const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);\n            const canvasGraphicsFactory = {\n                createCanvasGraphics: (ctx)=>new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n                        optionalContentConfig: this.optionalContentConfig,\n                        markedContentStack: this.markedContentStack\n                    })\n            };\n            pattern = new TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);\n        } else {\n            pattern = this._getPattern(IR[1], IR[2]);\n        }\n        return pattern;\n    }\n    setStrokeColorN() {\n        this.current.strokeColor = this.getColorN_Pattern(arguments);\n        this.current.patternStroke = true;\n    }\n    setFillColorN() {\n        this.current.fillColor = this.getColorN_Pattern(arguments);\n        this.current.patternFill = true;\n    }\n    setStrokeRGBColor(r, g, b) {\n        this.ctx.strokeStyle = this.current.strokeColor = Util.makeHexColor(r, g, b);\n        this.current.patternStroke = false;\n    }\n    setStrokeTransparent() {\n        this.ctx.strokeStyle = this.current.strokeColor = \"transparent\";\n        this.current.patternStroke = false;\n    }\n    setFillRGBColor(r, g, b) {\n        this.ctx.fillStyle = this.current.fillColor = Util.makeHexColor(r, g, b);\n        this.current.patternFill = false;\n    }\n    setFillTransparent() {\n        this.ctx.fillStyle = this.current.fillColor = \"transparent\";\n        this.current.patternFill = false;\n    }\n    _getPattern(objId, matrix = null) {\n        let pattern;\n        if (this.cachedPatterns.has(objId)) {\n            pattern = this.cachedPatterns.get(objId);\n        } else {\n            pattern = getShadingPattern(this.getObject(objId));\n            this.cachedPatterns.set(objId, pattern);\n        }\n        if (matrix) {\n            pattern.matrix = matrix;\n        }\n        return pattern;\n    }\n    shadingFill(objId) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const ctx = this.ctx;\n        this.save();\n        const pattern = this._getPattern(objId);\n        ctx.fillStyle = pattern.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.SHADING);\n        const inv = getCurrentTransformInverse(ctx);\n        if (inv) {\n            const { width, height } = ctx.canvas;\n            const [x0, y0, x1, y1] = Util.getAxialAlignedBoundingBox([\n                0,\n                0,\n                width,\n                height\n            ], inv);\n            this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n        } else {\n            this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n        }\n        this.compose(this.current.getClippedPathBoundingBox());\n        this.restore();\n    }\n    beginInlineImage() {\n        unreachable(\"Should not call beginInlineImage\");\n    }\n    beginImageData() {\n        unreachable(\"Should not call beginImageData\");\n    }\n    paintFormXObjectBegin(matrix, bbox) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.save();\n        this.baseTransformStack.push(this.baseTransform);\n        if (matrix) {\n            this.transform(...matrix);\n        }\n        this.baseTransform = getCurrentTransform(this.ctx);\n        if (bbox) {\n            const width = bbox[2] - bbox[0];\n            const height = bbox[3] - bbox[1];\n            this.ctx.rect(bbox[0], bbox[1], width, height);\n            this.current.updateRectMinMax(getCurrentTransform(this.ctx), bbox);\n            this.clip();\n            this.endPath();\n        }\n    }\n    paintFormXObjectEnd() {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.restore();\n        this.baseTransform = this.baseTransformStack.pop();\n    }\n    beginGroup(group) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.save();\n        if (this.inSMaskMode) {\n            this.endSMaskMode();\n            this.current.activeSMask = null;\n        }\n        const currentCtx = this.ctx;\n        if (!group.isolated) {\n            info(\"TODO: Support non-isolated groups.\");\n        }\n        if (group.knockout) {\n            warn(\"Knockout groups not supported.\");\n        }\n        const currentTransform = getCurrentTransform(currentCtx);\n        if (group.matrix) {\n            currentCtx.transform(...group.matrix);\n        }\n        if (!group.bbox) {\n            throw new Error(\"Bounding box is required.\");\n        }\n        let bounds = Util.getAxialAlignedBoundingBox(group.bbox, getCurrentTransform(currentCtx));\n        const canvasBounds = [\n            0,\n            0,\n            currentCtx.canvas.width,\n            currentCtx.canvas.height\n        ];\n        bounds = Util.intersect(bounds, canvasBounds) || [\n            0,\n            0,\n            0,\n            0\n        ];\n        const offsetX = Math.floor(bounds[0]);\n        const offsetY = Math.floor(bounds[1]);\n        const drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n        const drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n        this.current.startNewPathAndClipBox([\n            0,\n            0,\n            drawnWidth,\n            drawnHeight\n        ]);\n        let cacheId = \"groupAt\" + this.groupLevel;\n        if (group.smask) {\n            cacheId += \"_smask_\" + this.smaskCounter++ % 2;\n        }\n        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n        const groupCtx = scratchCanvas.context;\n        groupCtx.translate(-offsetX, -offsetY);\n        groupCtx.transform(...currentTransform);\n        if (group.smask) {\n            this.smaskStack.push({\n                canvas: scratchCanvas.canvas,\n                context: groupCtx,\n                offsetX,\n                offsetY,\n                subtype: group.smask.subtype,\n                backdrop: group.smask.backdrop,\n                transferMap: group.smask.transferMap || null,\n                startTransformInverse: null\n            });\n        } else {\n            currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n            currentCtx.translate(offsetX, offsetY);\n            currentCtx.save();\n        }\n        copyCtxState(currentCtx, groupCtx);\n        this.ctx = groupCtx;\n        this.setGState([\n            [\n                \"BM\",\n                \"source-over\"\n            ],\n            [\n                \"ca\",\n                1\n            ],\n            [\n                \"CA\",\n                1\n            ]\n        ]);\n        this.groupStack.push(currentCtx);\n        this.groupLevel++;\n    }\n    endGroup(group) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.groupLevel--;\n        const groupCtx = this.ctx;\n        const ctx = this.groupStack.pop();\n        this.ctx = ctx;\n        this.ctx.imageSmoothingEnabled = false;\n        if (group.smask) {\n            this.tempSMask = this.smaskStack.pop();\n            this.restore();\n        } else {\n            this.ctx.restore();\n            const currentMtx = getCurrentTransform(this.ctx);\n            this.restore();\n            this.ctx.save();\n            this.ctx.setTransform(...currentMtx);\n            const dirtyBox = Util.getAxialAlignedBoundingBox([\n                0,\n                0,\n                groupCtx.canvas.width,\n                groupCtx.canvas.height\n            ], currentMtx);\n            this.ctx.drawImage(groupCtx.canvas, 0, 0);\n            this.ctx.restore();\n            this.compose(dirtyBox);\n        }\n    }\n    beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {\n        this.#restoreInitialState();\n        resetCtxToDefault(this.ctx);\n        this.ctx.save();\n        this.save();\n        if (this.baseTransform) {\n            this.ctx.setTransform(...this.baseTransform);\n        }\n        if (rect) {\n            const width = rect[2] - rect[0];\n            const height = rect[3] - rect[1];\n            if (hasOwnCanvas && this.annotationCanvasMap) {\n                transform = transform.slice();\n                transform[4] -= rect[0];\n                transform[5] -= rect[1];\n                rect = rect.slice();\n                rect[0] = rect[1] = 0;\n                rect[2] = width;\n                rect[3] = height;\n                const [scaleX, scaleY] = Util.singularValueDecompose2dScale(getCurrentTransform(this.ctx));\n                const { viewportScale } = this;\n                const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);\n                const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);\n                this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);\n                const { canvas, context } = this.annotationCanvas;\n                this.annotationCanvasMap.set(id, canvas);\n                this.annotationCanvas.savedCtx = this.ctx;\n                this.ctx = context;\n                this.ctx.save();\n                this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);\n                resetCtxToDefault(this.ctx);\n            } else {\n                resetCtxToDefault(this.ctx);\n                this.endPath();\n                this.ctx.rect(rect[0], rect[1], width, height);\n                this.ctx.clip();\n                this.ctx.beginPath();\n            }\n        }\n        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n        this.transform(...transform);\n        this.transform(...matrix);\n    }\n    endAnnotation() {\n        if (this.annotationCanvas) {\n            this.ctx.restore();\n            this.#drawFilter();\n            this.ctx = this.annotationCanvas.savedCtx;\n            delete this.annotationCanvas.savedCtx;\n            delete this.annotationCanvas;\n        }\n    }\n    paintImageMaskXObject(img) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const count = img.count;\n        img = this.getObject(img.data, img);\n        img.count = count;\n        const ctx = this.ctx;\n        const glyph = this.processingType3;\n        if (glyph) {\n            if (glyph.compiled === undefined) {\n                glyph.compiled = compileType3Glyph(img);\n            }\n            if (glyph.compiled) {\n                glyph.compiled(ctx);\n                return;\n            }\n        }\n        const mask = this._createMaskCanvas(img);\n        const maskCanvas = mask.canvas;\n        ctx.save();\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);\n        ctx.restore();\n        this.compose();\n    }\n    paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {\n        if (!this.contentVisible) {\n            return;\n        }\n        img = this.getObject(img.data, img);\n        const ctx = this.ctx;\n        ctx.save();\n        const currentTransform = getCurrentTransform(ctx);\n        ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);\n        const mask = this._createMaskCanvas(img);\n        ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);\n        for(let i = 0, ii = positions.length; i < ii; i += 2){\n            const trans = Util.transform(currentTransform, [\n                scaleX,\n                skewX,\n                skewY,\n                scaleY,\n                positions[i],\n                positions[i + 1]\n            ]);\n            const [x, y] = Util.applyTransform([\n                0,\n                0\n            ], trans);\n            ctx.drawImage(mask.canvas, x, y);\n        }\n        ctx.restore();\n        this.compose();\n    }\n    paintImageMaskXObjectGroup(images) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const ctx = this.ctx;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        for (const image of images){\n            const { data, width, height, transform } = image;\n            const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n            const maskCtx = maskCanvas.context;\n            maskCtx.save();\n            const img = this.getObject(data, image);\n            putBinaryImageMask(maskCtx, img);\n            maskCtx.globalCompositeOperation = \"source-in\";\n            maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, getCurrentTransformInverse(ctx), PathType.FILL) : fillColor;\n            maskCtx.fillRect(0, 0, width, height);\n            maskCtx.restore();\n            ctx.save();\n            ctx.transform(...transform);\n            ctx.scale(1, -1);\n            drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n            ctx.restore();\n        }\n        this.compose();\n    }\n    paintImageXObject(objId) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const imgData = this.getObject(objId);\n        if (!imgData) {\n            warn(\"Dependent image isn't ready yet\");\n            return;\n        }\n        this.paintInlineImageXObject(imgData);\n    }\n    paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const imgData = this.getObject(objId);\n        if (!imgData) {\n            warn(\"Dependent image isn't ready yet\");\n            return;\n        }\n        const width = imgData.width;\n        const height = imgData.height;\n        const map = [];\n        for(let i = 0, ii = positions.length; i < ii; i += 2){\n            map.push({\n                transform: [\n                    scaleX,\n                    0,\n                    0,\n                    scaleY,\n                    positions[i],\n                    positions[i + 1]\n                ],\n                x: 0,\n                y: 0,\n                w: width,\n                h: height\n            });\n        }\n        this.paintInlineImageXObjectGroup(imgData, map);\n    }\n    applyTransferMapsToCanvas(ctx) {\n        if (this.current.transferMaps !== \"none\") {\n            ctx.filter = this.current.transferMaps;\n            ctx.drawImage(ctx.canvas, 0, 0);\n            ctx.filter = \"none\";\n        }\n        return ctx.canvas;\n    }\n    applyTransferMapsToBitmap(imgData) {\n        if (this.current.transferMaps === \"none\") {\n            return imgData.bitmap;\n        }\n        const { bitmap, width, height } = imgData;\n        const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n        const tmpCtx = tmpCanvas.context;\n        tmpCtx.filter = this.current.transferMaps;\n        tmpCtx.drawImage(bitmap, 0, 0);\n        tmpCtx.filter = \"none\";\n        return tmpCanvas.canvas;\n    }\n    paintInlineImageXObject(imgData) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const width = imgData.width;\n        const height = imgData.height;\n        const ctx = this.ctx;\n        this.save();\n        if (!isNodeJS) {\n            const { filter } = ctx;\n            if (filter !== \"none\" && filter !== \"\") {\n                ctx.filter = \"none\";\n            }\n        }\n        ctx.scale(1 / width, -1 / height);\n        let imgToPaint;\n        if (imgData.bitmap) {\n            imgToPaint = this.applyTransferMapsToBitmap(imgData);\n        } else if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\n            imgToPaint = imgData;\n        } else {\n            const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n            const tmpCtx = tmpCanvas.context;\n            putBinaryImageData(tmpCtx, imgData);\n            imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n        }\n        const scaled = this._scaleImage(imgToPaint, getCurrentTransformInverse(ctx));\n        ctx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(ctx), imgData.interpolate);\n        drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);\n        this.compose();\n        this.restore();\n    }\n    paintInlineImageXObjectGroup(imgData, map) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const ctx = this.ctx;\n        let imgToPaint;\n        if (imgData.bitmap) {\n            imgToPaint = imgData.bitmap;\n        } else {\n            const w = imgData.width;\n            const h = imgData.height;\n            const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n            const tmpCtx = tmpCanvas.context;\n            putBinaryImageData(tmpCtx, imgData);\n            imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n        }\n        for (const entry of map){\n            ctx.save();\n            ctx.transform(...entry.transform);\n            ctx.scale(1, -1);\n            drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n            ctx.restore();\n        }\n        this.compose();\n    }\n    paintSolidColorImageMask() {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.ctx.fillRect(0, 0, 1, 1);\n        this.compose();\n    }\n    markPoint(tag) {}\n    markPointProps(tag, properties) {}\n    beginMarkedContent(tag) {\n        this.markedContentStack.push({\n            visible: true\n        });\n    }\n    beginMarkedContentProps(tag, properties) {\n        if (tag === \"OC\") {\n            this.markedContentStack.push({\n                visible: this.optionalContentConfig.isVisible(properties)\n            });\n        } else {\n            this.markedContentStack.push({\n                visible: true\n            });\n        }\n        this.contentVisible = this.isContentVisible();\n    }\n    endMarkedContent() {\n        this.markedContentStack.pop();\n        this.contentVisible = this.isContentVisible();\n    }\n    beginCompat() {}\n    endCompat() {}\n    consumePath(clipBox) {\n        const isEmpty = this.current.isEmptyClip();\n        if (this.pendingClip) {\n            this.current.updateClipFromPath();\n        }\n        if (!this.pendingClip) {\n            this.compose(clipBox);\n        }\n        const ctx = this.ctx;\n        if (this.pendingClip) {\n            if (!isEmpty) {\n                if (this.pendingClip === EO_CLIP) {\n                    ctx.clip(\"evenodd\");\n                } else {\n                    ctx.clip();\n                }\n            }\n            this.pendingClip = null;\n        }\n        this.current.startNewPathAndClipBox(this.current.clipBox);\n        ctx.beginPath();\n    }\n    getSinglePixelWidth() {\n        if (!this._cachedGetSinglePixelWidth) {\n            const m = getCurrentTransform(this.ctx);\n            if (m[1] === 0 && m[2] === 0) {\n                this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));\n            } else {\n                const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n                const normX = Math.hypot(m[0], m[2]);\n                const normY = Math.hypot(m[1], m[3]);\n                this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;\n            }\n        }\n        return this._cachedGetSinglePixelWidth;\n    }\n    getScaleForStroking() {\n        if (this._cachedScaleForStroking[0] === -1) {\n            const { lineWidth } = this.current;\n            const { a, b, c, d } = this.ctx.getTransform();\n            let scaleX, scaleY;\n            if (b === 0 && c === 0) {\n                const normX = Math.abs(a);\n                const normY = Math.abs(d);\n                if (normX === normY) {\n                    if (lineWidth === 0) {\n                        scaleX = scaleY = 1 / normX;\n                    } else {\n                        const scaledLineWidth = normX * lineWidth;\n                        scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;\n                    }\n                } else if (lineWidth === 0) {\n                    scaleX = 1 / normX;\n                    scaleY = 1 / normY;\n                } else {\n                    const scaledXLineWidth = normX * lineWidth;\n                    const scaledYLineWidth = normY * lineWidth;\n                    scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;\n                    scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;\n                }\n            } else {\n                const absDet = Math.abs(a * d - b * c);\n                const normX = Math.hypot(a, b);\n                const normY = Math.hypot(c, d);\n                if (lineWidth === 0) {\n                    scaleX = normY / absDet;\n                    scaleY = normX / absDet;\n                } else {\n                    const baseArea = lineWidth * absDet;\n                    scaleX = normY > baseArea ? normY / baseArea : 1;\n                    scaleY = normX > baseArea ? normX / baseArea : 1;\n                }\n            }\n            this._cachedScaleForStroking[0] = scaleX;\n            this._cachedScaleForStroking[1] = scaleY;\n        }\n        return this._cachedScaleForStroking;\n    }\n    rescaleAndStroke(saveRestore) {\n        const { ctx } = this;\n        const { lineWidth } = this.current;\n        const [scaleX, scaleY] = this.getScaleForStroking();\n        ctx.lineWidth = lineWidth || 1;\n        if (scaleX === 1 && scaleY === 1) {\n            ctx.stroke();\n            return;\n        }\n        const dashes = ctx.getLineDash();\n        if (saveRestore) {\n            ctx.save();\n        }\n        ctx.scale(scaleX, scaleY);\n        if (dashes.length > 0) {\n            const scale = Math.max(scaleX, scaleY);\n            ctx.setLineDash(dashes.map((x)=>x / scale));\n            ctx.lineDashOffset /= scale;\n        }\n        ctx.stroke();\n        if (saveRestore) {\n            ctx.restore();\n        }\n    }\n    isContentVisible() {\n        for(let i = this.markedContentStack.length - 1; i >= 0; i--){\n            if (!this.markedContentStack[i].visible) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nfor(const op in OPS){\n    if (CanvasGraphics.prototype[op] !== undefined) {\n        CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];\n    }\n}\n; // ./src/display/worker_options.js\nclass GlobalWorkerOptions {\n    static #port = null;\n    static #src = \"\";\n    static get workerPort() {\n        return this.#port;\n    }\n    static set workerPort(val) {\n        if (!(typeof Worker !== \"undefined\" && val instanceof Worker) && val !== null) {\n            throw new Error(\"Invalid `workerPort` type.\");\n        }\n        this.#port = val;\n    }\n    static get workerSrc() {\n        return this.#src;\n    }\n    static set workerSrc(val) {\n        if (typeof val !== \"string\") {\n            throw new Error(\"Invalid `workerSrc` type.\");\n        }\n        this.#src = val;\n    }\n}\n; // ./src/display/metadata.js\nclass Metadata {\n    #metadataMap;\n    #data;\n    constructor({ parsedData, rawData }){\n        this.#metadataMap = parsedData;\n        this.#data = rawData;\n    }\n    getRaw() {\n        return this.#data;\n    }\n    get(name) {\n        return this.#metadataMap.get(name) ?? null;\n    }\n    getAll() {\n        return objectFromMap(this.#metadataMap);\n    }\n    has(name) {\n        return this.#metadataMap.has(name);\n    }\n}\n; // ./src/display/optional_content_config.js\nconst INTERNAL = Symbol(\"INTERNAL\");\nclass OptionalContentGroup {\n    #isDisplay;\n    #isPrint;\n    #userSet;\n    #visible;\n    constructor(renderingIntent, { name, intent, usage, rbGroups }){\n        this.#isDisplay = false;\n        this.#isPrint = false;\n        this.#userSet = false;\n        this.#visible = true;\n        this.#isDisplay = !!(renderingIntent & RenderingIntentFlag.DISPLAY);\n        this.#isPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);\n        this.name = name;\n        this.intent = intent;\n        this.usage = usage;\n        this.rbGroups = rbGroups;\n    }\n    get visible() {\n        if (this.#userSet) {\n            return this.#visible;\n        }\n        if (!this.#visible) {\n            return false;\n        }\n        const { print, view } = this.usage;\n        if (this.#isDisplay) {\n            return view?.viewState !== \"OFF\";\n        } else if (this.#isPrint) {\n            return print?.printState !== \"OFF\";\n        }\n        return true;\n    }\n    _setVisible(internal, visible, userSet = false) {\n        if (internal !== INTERNAL) {\n            unreachable(\"Internal method `_setVisible` called.\");\n        }\n        this.#userSet = userSet;\n        this.#visible = visible;\n    }\n}\nclass OptionalContentConfig {\n    #cachedGetHash;\n    #groups;\n    #initialHash;\n    #order;\n    constructor(data, renderingIntent = RenderingIntentFlag.DISPLAY){\n        this.#cachedGetHash = null;\n        this.#groups = new Map();\n        this.#initialHash = null;\n        this.#order = null;\n        this.renderingIntent = renderingIntent;\n        this.name = null;\n        this.creator = null;\n        if (data === null) {\n            return;\n        }\n        this.name = data.name;\n        this.creator = data.creator;\n        this.#order = data.order;\n        for (const group of data.groups){\n            this.#groups.set(group.id, new OptionalContentGroup(renderingIntent, group));\n        }\n        if (data.baseState === \"OFF\") {\n            for (const group of this.#groups.values()){\n                group._setVisible(INTERNAL, false);\n            }\n        }\n        for (const on of data.on){\n            this.#groups.get(on)._setVisible(INTERNAL, true);\n        }\n        for (const off of data.off){\n            this.#groups.get(off)._setVisible(INTERNAL, false);\n        }\n        this.#initialHash = this.getHash();\n    }\n    #evaluateVisibilityExpression(array) {\n        const length = array.length;\n        if (length < 2) {\n            return true;\n        }\n        const operator = array[0];\n        for(let i = 1; i < length; i++){\n            const element = array[i];\n            let state;\n            if (Array.isArray(element)) {\n                state = this.#evaluateVisibilityExpression(element);\n            } else if (this.#groups.has(element)) {\n                state = this.#groups.get(element).visible;\n            } else {\n                warn(`Optional content group not found: ${element}`);\n                return true;\n            }\n            switch(operator){\n                case \"And\":\n                    if (!state) {\n                        return false;\n                    }\n                    break;\n                case \"Or\":\n                    if (state) {\n                        return true;\n                    }\n                    break;\n                case \"Not\":\n                    return !state;\n                default:\n                    return true;\n            }\n        }\n        return operator === \"And\";\n    }\n    isVisible(group) {\n        if (this.#groups.size === 0) {\n            return true;\n        }\n        if (!group) {\n            info(\"Optional content group not defined.\");\n            return true;\n        }\n        if (group.type === \"OCG\") {\n            if (!this.#groups.has(group.id)) {\n                warn(`Optional content group not found: ${group.id}`);\n                return true;\n            }\n            return this.#groups.get(group.id).visible;\n        } else if (group.type === \"OCMD\") {\n            if (group.expression) {\n                return this.#evaluateVisibilityExpression(group.expression);\n            }\n            if (!group.policy || group.policy === \"AnyOn\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (this.#groups.get(id).visible) {\n                        return true;\n                    }\n                }\n                return false;\n            } else if (group.policy === \"AllOn\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (!this.#groups.get(id).visible) {\n                        return false;\n                    }\n                }\n                return true;\n            } else if (group.policy === \"AnyOff\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (!this.#groups.get(id).visible) {\n                        return true;\n                    }\n                }\n                return false;\n            } else if (group.policy === \"AllOff\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (this.#groups.get(id).visible) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            warn(`Unknown optional content policy ${group.policy}.`);\n            return true;\n        }\n        warn(`Unknown group type ${group.type}.`);\n        return true;\n    }\n    setVisibility(id, visible = true, preserveRB = true) {\n        const group = this.#groups.get(id);\n        if (!group) {\n            warn(`Optional content group not found: ${id}`);\n            return;\n        }\n        if (preserveRB && visible && group.rbGroups.length) {\n            for (const rbGroup of group.rbGroups){\n                for (const otherId of rbGroup){\n                    if (otherId !== id) {\n                        this.#groups.get(otherId)?._setVisible(INTERNAL, false, true);\n                    }\n                }\n            }\n        }\n        group._setVisible(INTERNAL, !!visible, true);\n        this.#cachedGetHash = null;\n    }\n    setOCGState({ state, preserveRB }) {\n        let operator;\n        for (const elem of state){\n            switch(elem){\n                case \"ON\":\n                case \"OFF\":\n                case \"Toggle\":\n                    operator = elem;\n                    continue;\n            }\n            const group = this.#groups.get(elem);\n            if (!group) {\n                continue;\n            }\n            switch(operator){\n                case \"ON\":\n                    this.setVisibility(elem, true, preserveRB);\n                    break;\n                case \"OFF\":\n                    this.setVisibility(elem, false, preserveRB);\n                    break;\n                case \"Toggle\":\n                    this.setVisibility(elem, !group.visible, preserveRB);\n                    break;\n            }\n        }\n        this.#cachedGetHash = null;\n    }\n    get hasInitialVisibility() {\n        return this.#initialHash === null || this.getHash() === this.#initialHash;\n    }\n    getOrder() {\n        if (!this.#groups.size) {\n            return null;\n        }\n        if (this.#order) {\n            return this.#order.slice();\n        }\n        return [\n            ...this.#groups.keys()\n        ];\n    }\n    getGroups() {\n        return this.#groups.size > 0 ? objectFromMap(this.#groups) : null;\n    }\n    getGroup(id) {\n        return this.#groups.get(id) || null;\n    }\n    getHash() {\n        if (this.#cachedGetHash !== null) {\n            return this.#cachedGetHash;\n        }\n        const hash = new MurmurHash3_64();\n        for (const [id, group] of this.#groups){\n            hash.update(`${id}:${group.visible}`);\n        }\n        return this.#cachedGetHash = hash.hexdigest();\n    }\n}\n; // ./src/display/transport_stream.js\nclass PDFDataTransportStream {\n    constructor(pdfDataRangeTransport, { disableRange = false, disableStream = false }){\n        assert(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n        const { length, initialData, progressiveDone, contentDispositionFilename } = pdfDataRangeTransport;\n        this._queuedChunks = [];\n        this._progressiveDone = progressiveDone;\n        this._contentDispositionFilename = contentDispositionFilename;\n        if (initialData?.length > 0) {\n            const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;\n            this._queuedChunks.push(buffer);\n        }\n        this._pdfDataRangeTransport = pdfDataRangeTransport;\n        this._isStreamingSupported = !disableStream;\n        this._isRangeSupported = !disableRange;\n        this._contentLength = length;\n        this._fullRequestReader = null;\n        this._rangeReaders = [];\n        pdfDataRangeTransport.addRangeListener((begin, chunk)=>{\n            this._onReceiveData({\n                begin,\n                chunk\n            });\n        });\n        pdfDataRangeTransport.addProgressListener((loaded, total)=>{\n            this._onProgress({\n                loaded,\n                total\n            });\n        });\n        pdfDataRangeTransport.addProgressiveReadListener((chunk)=>{\n            this._onReceiveData({\n                chunk\n            });\n        });\n        pdfDataRangeTransport.addProgressiveDoneListener(()=>{\n            this._onProgressiveDone();\n        });\n        pdfDataRangeTransport.transportReady();\n    }\n    _onReceiveData({ begin, chunk }) {\n        const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;\n        if (begin === undefined) {\n            if (this._fullRequestReader) {\n                this._fullRequestReader._enqueue(buffer);\n            } else {\n                this._queuedChunks.push(buffer);\n            }\n        } else {\n            const found = this._rangeReaders.some(function(rangeReader) {\n                if (rangeReader._begin !== begin) {\n                    return false;\n                }\n                rangeReader._enqueue(buffer);\n                return true;\n            });\n            assert(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n        }\n    }\n    get _progressiveDataLength() {\n        return this._fullRequestReader?._loaded ?? 0;\n    }\n    _onProgress(evt) {\n        if (evt.total === undefined) {\n            this._rangeReaders[0]?.onProgress?.({\n                loaded: evt.loaded\n            });\n        } else {\n            this._fullRequestReader?.onProgress?.({\n                loaded: evt.loaded,\n                total: evt.total\n            });\n        }\n    }\n    _onProgressiveDone() {\n        this._fullRequestReader?.progressiveDone();\n        this._progressiveDone = true;\n    }\n    _removeRangeReader(reader) {\n        const i = this._rangeReaders.indexOf(reader);\n        if (i >= 0) {\n            this._rangeReaders.splice(i, 1);\n        }\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n        const queuedChunks = this._queuedChunks;\n        this._queuedChunks = null;\n        return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);\n    }\n    getRangeReader(begin, end) {\n        if (end <= this._progressiveDataLength) {\n            return null;\n        }\n        const reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n        this._pdfDataRangeTransport.requestDataRange(begin, end);\n        this._rangeReaders.push(reader);\n        return reader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeReaders.slice(0)){\n            reader.cancel(reason);\n        }\n        this._pdfDataRangeTransport.abort();\n    }\n}\nclass PDFDataTransportStreamReader {\n    constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null){\n        this._stream = stream;\n        this._done = progressiveDone || false;\n        this._filename = isPdfFile(contentDispositionFilename) ? contentDispositionFilename : null;\n        this._queuedChunks = queuedChunks || [];\n        this._loaded = 0;\n        for (const chunk of this._queuedChunks){\n            this._loaded += chunk.byteLength;\n        }\n        this._requests = [];\n        this._headersReady = Promise.resolve();\n        stream._fullRequestReader = this;\n        this.onProgress = null;\n    }\n    _enqueue(chunk) {\n        if (this._done) {\n            return;\n        }\n        if (this._requests.length > 0) {\n            const requestCapability = this._requests.shift();\n            requestCapability.resolve({\n                value: chunk,\n                done: false\n            });\n        } else {\n            this._queuedChunks.push(chunk);\n        }\n        this._loaded += chunk.byteLength;\n    }\n    get headersReady() {\n        return this._headersReady;\n    }\n    get filename() {\n        return this._filename;\n    }\n    get isRangeSupported() {\n        return this._stream._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._stream._isStreamingSupported;\n    }\n    get contentLength() {\n        return this._stream._contentLength;\n    }\n    async read() {\n        if (this._queuedChunks.length > 0) {\n            const chunk = this._queuedChunks.shift();\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n    }\n    progressiveDone() {\n        if (this._done) {\n            return;\n        }\n        this._done = true;\n    }\n}\nclass PDFDataTransportStreamRangeReader {\n    constructor(stream, begin, end){\n        this._stream = stream;\n        this._begin = begin;\n        this._end = end;\n        this._queuedChunk = null;\n        this._requests = [];\n        this._done = false;\n        this.onProgress = null;\n    }\n    _enqueue(chunk) {\n        if (this._done) {\n            return;\n        }\n        if (this._requests.length === 0) {\n            this._queuedChunk = chunk;\n        } else {\n            const requestsCapability = this._requests.shift();\n            requestsCapability.resolve({\n                value: chunk,\n                done: false\n            });\n            for (const requestCapability of this._requests){\n                requestCapability.resolve({\n                    value: undefined,\n                    done: true\n                });\n            }\n            this._requests.length = 0;\n        }\n        this._done = true;\n        this._stream._removeRangeReader(this);\n    }\n    get isStreamingSupported() {\n        return false;\n    }\n    async read() {\n        if (this._queuedChunk) {\n            const chunk = this._queuedChunk;\n            this._queuedChunk = null;\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        this._stream._removeRangeReader(this);\n    }\n}\n; // ./src/display/content_disposition.js\nfunction getFilenameFromContentDispositionHeader(contentDisposition) {\n    let needsEncodingFixup = true;\n    let tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n    if (tmp) {\n        tmp = tmp[1];\n        let filename = rfc2616unquote(tmp);\n        filename = unescape(filename);\n        filename = rfc5987decode(filename);\n        filename = rfc2047decode(filename);\n        return fixupEncoding(filename);\n    }\n    tmp = rfc2231getparam(contentDisposition);\n    if (tmp) {\n        const filename = rfc2047decode(tmp);\n        return fixupEncoding(filename);\n    }\n    tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n    if (tmp) {\n        tmp = tmp[1];\n        let filename = rfc2616unquote(tmp);\n        filename = rfc2047decode(filename);\n        return fixupEncoding(filename);\n    }\n    function toParamRegExp(attributePattern, flags) {\n        return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags);\n    }\n    function textdecode(encoding, value) {\n        if (encoding) {\n            if (!/^[\\x00-\\xFF]+$/.test(value)) {\n                return value;\n            }\n            try {\n                const decoder = new TextDecoder(encoding, {\n                    fatal: true\n                });\n                const buffer = stringToBytes(value);\n                value = decoder.decode(buffer);\n                needsEncodingFixup = false;\n            } catch  {}\n        }\n        return value;\n    }\n    function fixupEncoding(value) {\n        if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n            value = textdecode(\"utf-8\", value);\n            if (needsEncodingFixup) {\n                value = textdecode(\"iso-8859-1\", value);\n            }\n        }\n        return value;\n    }\n    function rfc2231getparam(contentDispositionStr) {\n        const matches = [];\n        let match;\n        const iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n        while((match = iter.exec(contentDispositionStr)) !== null){\n            let [, n, quot, part] = match;\n            n = parseInt(n, 10);\n            if (n in matches) {\n                if (n === 0) {\n                    break;\n                }\n                continue;\n            }\n            matches[n] = [\n                quot,\n                part\n            ];\n        }\n        const parts = [];\n        for(let n = 0; n < matches.length; ++n){\n            if (!(n in matches)) {\n                break;\n            }\n            let [quot, part] = matches[n];\n            part = rfc2616unquote(part);\n            if (quot) {\n                part = unescape(part);\n                if (n === 0) {\n                    part = rfc5987decode(part);\n                }\n            }\n            parts.push(part);\n        }\n        return parts.join(\"\");\n    }\n    function rfc2616unquote(value) {\n        if (value.startsWith('\"')) {\n            const parts = value.slice(1).split('\\\\\"');\n            for(let i = 0; i < parts.length; ++i){\n                const quotindex = parts[i].indexOf('\"');\n                if (quotindex !== -1) {\n                    parts[i] = parts[i].slice(0, quotindex);\n                    parts.length = i + 1;\n                }\n                parts[i] = parts[i].replaceAll(/\\\\(.)/g, \"$1\");\n            }\n            value = parts.join('\"');\n        }\n        return value;\n    }\n    function rfc5987decode(extvalue) {\n        const encodingend = extvalue.indexOf(\"'\");\n        if (encodingend === -1) {\n            return extvalue;\n        }\n        const encoding = extvalue.slice(0, encodingend);\n        const langvalue = extvalue.slice(encodingend + 1);\n        const value = langvalue.replace(/^[^']*'/, \"\");\n        return textdecode(encoding, value);\n    }\n    function rfc2047decode(value) {\n        if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n            return value;\n        }\n        return value.replaceAll(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function(matches, charset, encoding, text) {\n            if (encoding === \"q\" || encoding === \"Q\") {\n                text = text.replaceAll(\"_\", \" \");\n                text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function(match, hex) {\n                    return String.fromCharCode(parseInt(hex, 16));\n                });\n                return textdecode(charset, text);\n            }\n            try {\n                text = atob(text);\n            } catch  {}\n            return textdecode(charset, text);\n        });\n    }\n    return \"\";\n}\n; // ./src/display/network_utils.js\nfunction createHeaders(isHttp, httpHeaders) {\n    const headers = new Headers();\n    if (!isHttp || !httpHeaders || typeof httpHeaders !== \"object\") {\n        return headers;\n    }\n    for(const key in httpHeaders){\n        const val = httpHeaders[key];\n        if (val !== undefined) {\n            headers.append(key, val);\n        }\n    }\n    return headers;\n}\nfunction getResponseOrigin(url) {\n    try {\n        return new URL(url).origin;\n    } catch  {}\n    return null;\n}\nfunction validateRangeRequestCapabilities({ responseHeaders, isHttp, rangeChunkSize, disableRange }) {\n    const returnValues = {\n        allowRangeRequests: false,\n        suggestedLength: undefined\n    };\n    const length = parseInt(responseHeaders.get(\"Content-Length\"), 10);\n    if (!Number.isInteger(length)) {\n        return returnValues;\n    }\n    returnValues.suggestedLength = length;\n    if (length <= 2 * rangeChunkSize) {\n        return returnValues;\n    }\n    if (disableRange || !isHttp) {\n        return returnValues;\n    }\n    if (responseHeaders.get(\"Accept-Ranges\") !== \"bytes\") {\n        return returnValues;\n    }\n    const contentEncoding = responseHeaders.get(\"Content-Encoding\") || \"identity\";\n    if (contentEncoding !== \"identity\") {\n        return returnValues;\n    }\n    returnValues.allowRangeRequests = true;\n    return returnValues;\n}\nfunction extractFilenameFromHeader(responseHeaders) {\n    const contentDisposition = responseHeaders.get(\"Content-Disposition\");\n    if (contentDisposition) {\n        let filename = getFilenameFromContentDispositionHeader(contentDisposition);\n        if (filename.includes(\"%\")) {\n            try {\n                filename = decodeURIComponent(filename);\n            } catch  {}\n        }\n        if (isPdfFile(filename)) {\n            return filename;\n        }\n    }\n    return null;\n}\nfunction createResponseStatusError(status, url) {\n    if (status === 404 || status === 0 && url.startsWith(\"file:\")) {\n        return new MissingPDFException('Missing PDF \"' + url + '\".');\n    }\n    return new UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF \"${url}\".`, status);\n}\nfunction validateResponseStatus(status) {\n    return status === 200 || status === 206;\n}\n; // ./src/display/fetch_stream.js\nfunction createFetchOptions(headers, withCredentials, abortController) {\n    return {\n        method: \"GET\",\n        headers,\n        signal: abortController.signal,\n        mode: \"cors\",\n        credentials: withCredentials ? \"include\" : \"same-origin\",\n        redirect: \"follow\"\n    };\n}\nfunction getArrayBuffer(val) {\n    if (val instanceof Uint8Array) {\n        return val.buffer;\n    }\n    if (val instanceof ArrayBuffer) {\n        return val;\n    }\n    warn(`getArrayBuffer - unexpected data format: ${val}`);\n    return new Uint8Array(val).buffer;\n}\nclass PDFFetchStream {\n    constructor(source){\n        this._responseOrigin = null;\n        this.source = source;\n        this.isHttp = /^https?:/i.test(source.url);\n        this.headers = createHeaders(this.isHttp, source.httpHeaders);\n        this._fullRequestReader = null;\n        this._rangeRequestReaders = [];\n    }\n    get _progressiveDataLength() {\n        return this._fullRequestReader?._loaded ?? 0;\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n        this._fullRequestReader = new PDFFetchStreamReader(this);\n        return this._fullRequestReader;\n    }\n    getRangeReader(begin, end) {\n        if (end <= this._progressiveDataLength) {\n            return null;\n        }\n        const reader = new PDFFetchStreamRangeReader(this, begin, end);\n        this._rangeRequestReaders.push(reader);\n        return reader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeRequestReaders.slice(0)){\n            reader.cancel(reason);\n        }\n    }\n}\nclass PDFFetchStreamReader {\n    constructor(stream){\n        this._stream = stream;\n        this._reader = null;\n        this._loaded = 0;\n        this._filename = null;\n        const source = stream.source;\n        this._withCredentials = source.withCredentials || false;\n        this._contentLength = source.length;\n        this._headersCapability = Promise.withResolvers();\n        this._disableRange = source.disableRange || false;\n        this._rangeChunkSize = source.rangeChunkSize;\n        if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n        }\n        this._abortController = new AbortController();\n        this._isStreamingSupported = !source.disableStream;\n        this._isRangeSupported = !source.disableRange;\n        const headers = new Headers(stream.headers);\n        const url = source.url;\n        fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response)=>{\n            stream._responseOrigin = getResponseOrigin(response.url);\n            if (!validateResponseStatus(response.status)) {\n                throw createResponseStatusError(response.status, url);\n            }\n            this._reader = response.body.getReader();\n            this._headersCapability.resolve();\n            const responseHeaders = response.headers;\n            const { allowRangeRequests, suggestedLength } = validateRangeRequestCapabilities({\n                responseHeaders,\n                isHttp: stream.isHttp,\n                rangeChunkSize: this._rangeChunkSize,\n                disableRange: this._disableRange\n            });\n            this._isRangeSupported = allowRangeRequests;\n            this._contentLength = suggestedLength || this._contentLength;\n            this._filename = extractFilenameFromHeader(responseHeaders);\n            if (!this._isStreamingSupported && this._isRangeSupported) {\n                this.cancel(new AbortException(\"Streaming is disabled.\"));\n            }\n        }).catch(this._headersCapability.reject);\n        this.onProgress = null;\n    }\n    get headersReady() {\n        return this._headersCapability.promise;\n    }\n    get filename() {\n        return this._filename;\n    }\n    get contentLength() {\n        return this._contentLength;\n    }\n    get isRangeSupported() {\n        return this._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._headersCapability.promise;\n        const { value, done } = await this._reader.read();\n        if (done) {\n            return {\n                value,\n                done\n            };\n        }\n        this._loaded += value.byteLength;\n        this.onProgress?.({\n            loaded: this._loaded,\n            total: this._contentLength\n        });\n        return {\n            value: getArrayBuffer(value),\n            done: false\n        };\n    }\n    cancel(reason) {\n        this._reader?.cancel(reason);\n        this._abortController.abort();\n    }\n}\nclass PDFFetchStreamRangeReader {\n    constructor(stream, begin, end){\n        this._stream = stream;\n        this._reader = null;\n        this._loaded = 0;\n        const source = stream.source;\n        this._withCredentials = source.withCredentials || false;\n        this._readCapability = Promise.withResolvers();\n        this._isStreamingSupported = !source.disableStream;\n        this._abortController = new AbortController();\n        const headers = new Headers(stream.headers);\n        headers.append(\"Range\", `bytes=${begin}-${end - 1}`);\n        const url = source.url;\n        fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response)=>{\n            const responseOrigin = getResponseOrigin(response.url);\n            if (responseOrigin !== stream._responseOrigin) {\n                throw new Error(`Expected range response-origin \"${responseOrigin}\" to match \"${stream._responseOrigin}\".`);\n            }\n            if (!validateResponseStatus(response.status)) {\n                throw createResponseStatusError(response.status, url);\n            }\n            this._readCapability.resolve();\n            this._reader = response.body.getReader();\n        }).catch(this._readCapability.reject);\n        this.onProgress = null;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._readCapability.promise;\n        const { value, done } = await this._reader.read();\n        if (done) {\n            return {\n                value,\n                done\n            };\n        }\n        this._loaded += value.byteLength;\n        this.onProgress?.({\n            loaded: this._loaded\n        });\n        return {\n            value: getArrayBuffer(value),\n            done: false\n        };\n    }\n    cancel(reason) {\n        this._reader?.cancel(reason);\n        this._abortController.abort();\n    }\n}\n; // ./src/display/network.js\nconst OK_RESPONSE = 200;\nconst PARTIAL_CONTENT_RESPONSE = 206;\nfunction network_getArrayBuffer(xhr) {\n    const data = xhr.response;\n    if (typeof data !== \"string\") {\n        return data;\n    }\n    return stringToBytes(data).buffer;\n}\nclass NetworkManager {\n    constructor({ url, httpHeaders, withCredentials }){\n        this._responseOrigin = null;\n        this.url = url;\n        this.isHttp = /^https?:/i.test(url);\n        this.headers = createHeaders(this.isHttp, httpHeaders);\n        this.withCredentials = withCredentials || false;\n        this.currXhrId = 0;\n        this.pendingRequests = Object.create(null);\n    }\n    request(args) {\n        const xhr = new XMLHttpRequest();\n        const xhrId = this.currXhrId++;\n        const pendingRequest = this.pendingRequests[xhrId] = {\n            xhr\n        };\n        xhr.open(\"GET\", this.url);\n        xhr.withCredentials = this.withCredentials;\n        for (const [key, val] of this.headers){\n            xhr.setRequestHeader(key, val);\n        }\n        if (this.isHttp && \"begin\" in args && \"end\" in args) {\n            xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`);\n            pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n        } else {\n            pendingRequest.expectedStatus = OK_RESPONSE;\n        }\n        xhr.responseType = \"arraybuffer\";\n        assert(args.onError, \"Expected `onError` callback to be provided.\");\n        xhr.onerror = ()=>{\n            args.onError(xhr.status);\n        };\n        xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n        xhr.onprogress = this.onProgress.bind(this, xhrId);\n        pendingRequest.onHeadersReceived = args.onHeadersReceived;\n        pendingRequest.onDone = args.onDone;\n        pendingRequest.onError = args.onError;\n        pendingRequest.onProgress = args.onProgress;\n        xhr.send(null);\n        return xhrId;\n    }\n    onProgress(xhrId, evt) {\n        const pendingRequest = this.pendingRequests[xhrId];\n        if (!pendingRequest) {\n            return;\n        }\n        pendingRequest.onProgress?.(evt);\n    }\n    onStateChange(xhrId, evt) {\n        const pendingRequest = this.pendingRequests[xhrId];\n        if (!pendingRequest) {\n            return;\n        }\n        const xhr = pendingRequest.xhr;\n        if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n            pendingRequest.onHeadersReceived();\n            delete pendingRequest.onHeadersReceived;\n        }\n        if (xhr.readyState !== 4) {\n            return;\n        }\n        if (!(xhrId in this.pendingRequests)) {\n            return;\n        }\n        delete this.pendingRequests[xhrId];\n        if (xhr.status === 0 && this.isHttp) {\n            pendingRequest.onError(xhr.status);\n            return;\n        }\n        const xhrStatus = xhr.status || OK_RESPONSE;\n        const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n        if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n            pendingRequest.onError(xhr.status);\n            return;\n        }\n        const chunk = network_getArrayBuffer(xhr);\n        if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n            const rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n            const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n            if (matches) {\n                pendingRequest.onDone({\n                    begin: parseInt(matches[1], 10),\n                    chunk\n                });\n            } else {\n                warn(`Missing or invalid \"Content-Range\" header.`);\n                pendingRequest.onError(0);\n            }\n        } else if (chunk) {\n            pendingRequest.onDone({\n                begin: 0,\n                chunk\n            });\n        } else {\n            pendingRequest.onError(xhr.status);\n        }\n    }\n    getRequestXhr(xhrId) {\n        return this.pendingRequests[xhrId].xhr;\n    }\n    isPendingRequest(xhrId) {\n        return xhrId in this.pendingRequests;\n    }\n    abortRequest(xhrId) {\n        const xhr = this.pendingRequests[xhrId].xhr;\n        delete this.pendingRequests[xhrId];\n        xhr.abort();\n    }\n}\nclass PDFNetworkStream {\n    constructor(source){\n        this._source = source;\n        this._manager = new NetworkManager(source);\n        this._rangeChunkSize = source.rangeChunkSize;\n        this._fullRequestReader = null;\n        this._rangeRequestReaders = [];\n    }\n    _onRangeRequestReaderClosed(reader) {\n        const i = this._rangeRequestReaders.indexOf(reader);\n        if (i >= 0) {\n            this._rangeRequestReaders.splice(i, 1);\n        }\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n        this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n        return this._fullRequestReader;\n    }\n    getRangeReader(begin, end) {\n        const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n        reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n        this._rangeRequestReaders.push(reader);\n        return reader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeRequestReaders.slice(0)){\n            reader.cancel(reason);\n        }\n    }\n}\nclass PDFNetworkStreamFullRequestReader {\n    constructor(manager, source){\n        this._manager = manager;\n        this._url = source.url;\n        this._fullRequestId = manager.request({\n            onHeadersReceived: this._onHeadersReceived.bind(this),\n            onDone: this._onDone.bind(this),\n            onError: this._onError.bind(this),\n            onProgress: this._onProgress.bind(this)\n        });\n        this._headersCapability = Promise.withResolvers();\n        this._disableRange = source.disableRange || false;\n        this._contentLength = source.length;\n        this._rangeChunkSize = source.rangeChunkSize;\n        if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n        }\n        this._isStreamingSupported = false;\n        this._isRangeSupported = false;\n        this._cachedChunks = [];\n        this._requests = [];\n        this._done = false;\n        this._storedError = undefined;\n        this._filename = null;\n        this.onProgress = null;\n    }\n    _onHeadersReceived() {\n        const fullRequestXhrId = this._fullRequestId;\n        const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n        this._manager._responseOrigin = getResponseOrigin(fullRequestXhr.responseURL);\n        const rawResponseHeaders = fullRequestXhr.getAllResponseHeaders();\n        const responseHeaders = new Headers(rawResponseHeaders ? rawResponseHeaders.trimStart().replace(/[^\\S ]+$/, \"\").split(/[\\r\\n]+/).map((x)=>{\n            const [key, ...val] = x.split(\": \");\n            return [\n                key,\n                val.join(\": \")\n            ];\n        }) : []);\n        const { allowRangeRequests, suggestedLength } = validateRangeRequestCapabilities({\n            responseHeaders,\n            isHttp: this._manager.isHttp,\n            rangeChunkSize: this._rangeChunkSize,\n            disableRange: this._disableRange\n        });\n        if (allowRangeRequests) {\n            this._isRangeSupported = true;\n        }\n        this._contentLength = suggestedLength || this._contentLength;\n        this._filename = extractFilenameFromHeader(responseHeaders);\n        if (this._isRangeSupported) {\n            this._manager.abortRequest(fullRequestXhrId);\n        }\n        this._headersCapability.resolve();\n    }\n    _onDone(data) {\n        if (data) {\n            if (this._requests.length > 0) {\n                const requestCapability = this._requests.shift();\n                requestCapability.resolve({\n                    value: data.chunk,\n                    done: false\n                });\n            } else {\n                this._cachedChunks.push(data.chunk);\n            }\n        }\n        this._done = true;\n        if (this._cachedChunks.length > 0) {\n            return;\n        }\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n    }\n    _onError(status) {\n        this._storedError = createResponseStatusError(status, this._url);\n        this._headersCapability.reject(this._storedError);\n        for (const requestCapability of this._requests){\n            requestCapability.reject(this._storedError);\n        }\n        this._requests.length = 0;\n        this._cachedChunks.length = 0;\n    }\n    _onProgress(evt) {\n        this.onProgress?.({\n            loaded: evt.loaded,\n            total: evt.lengthComputable ? evt.total : this._contentLength\n        });\n    }\n    get filename() {\n        return this._filename;\n    }\n    get isRangeSupported() {\n        return this._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    get contentLength() {\n        return this._contentLength;\n    }\n    get headersReady() {\n        return this._headersCapability.promise;\n    }\n    async read() {\n        await this._headersCapability.promise;\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        if (this._cachedChunks.length > 0) {\n            const chunk = this._cachedChunks.shift();\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        this._headersCapability.reject(reason);\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        if (this._manager.isPendingRequest(this._fullRequestId)) {\n            this._manager.abortRequest(this._fullRequestId);\n        }\n        this._fullRequestReader = null;\n    }\n}\nclass PDFNetworkStreamRangeRequestReader {\n    constructor(manager, begin, end){\n        this._manager = manager;\n        this._url = manager.url;\n        this._requestId = manager.request({\n            begin,\n            end,\n            onHeadersReceived: this._onHeadersReceived.bind(this),\n            onDone: this._onDone.bind(this),\n            onError: this._onError.bind(this),\n            onProgress: this._onProgress.bind(this)\n        });\n        this._requests = [];\n        this._queuedChunk = null;\n        this._done = false;\n        this._storedError = undefined;\n        this.onProgress = null;\n        this.onClosed = null;\n    }\n    _onHeadersReceived() {\n        const responseOrigin = getResponseOrigin(this._manager.getRequestXhr(this._requestId)?.responseURL);\n        if (responseOrigin !== this._manager._responseOrigin) {\n            this._storedError = new Error(`Expected range response-origin \"${responseOrigin}\" to match \"${this._manager._responseOrigin}\".`);\n            this._onError(0);\n        }\n    }\n    _close() {\n        this.onClosed?.(this);\n    }\n    _onDone(data) {\n        const chunk = data.chunk;\n        if (this._requests.length > 0) {\n            const requestCapability = this._requests.shift();\n            requestCapability.resolve({\n                value: chunk,\n                done: false\n            });\n        } else {\n            this._queuedChunk = chunk;\n        }\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        this._close();\n    }\n    _onError(status) {\n        this._storedError ??= createResponseStatusError(status, this._url);\n        for (const requestCapability of this._requests){\n            requestCapability.reject(this._storedError);\n        }\n        this._requests.length = 0;\n        this._queuedChunk = null;\n    }\n    _onProgress(evt) {\n        if (!this.isStreamingSupported) {\n            this.onProgress?.({\n                loaded: evt.loaded\n            });\n        }\n    }\n    get isStreamingSupported() {\n        return false;\n    }\n    async read() {\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        if (this._queuedChunk !== null) {\n            const chunk = this._queuedChunk;\n            this._queuedChunk = null;\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        if (this._manager.isPendingRequest(this._requestId)) {\n            this._manager.abortRequest(this._requestId);\n        }\n        this._close();\n    }\n}\n; // ./src/display/node_stream.js\nconst urlRegex = /^[a-z][a-z0-9\\-+.]+:/i;\nfunction parseUrlOrPath(sourceUrl) {\n    if (urlRegex.test(sourceUrl)) {\n        return new URL(sourceUrl);\n    }\n    const url = process.getBuiltinModule(\"url\");\n    return new URL(url.pathToFileURL(sourceUrl));\n}\nclass PDFNodeStream {\n    constructor(source){\n        this.source = source;\n        this.url = parseUrlOrPath(source.url);\n        assert(this.url.protocol === \"file:\", \"PDFNodeStream only supports file:// URLs.\");\n        this._fullRequestReader = null;\n        this._rangeRequestReaders = [];\n    }\n    get _progressiveDataLength() {\n        return this._fullRequestReader?._loaded ?? 0;\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n        this._fullRequestReader = new PDFNodeStreamFsFullReader(this);\n        return this._fullRequestReader;\n    }\n    getRangeReader(start, end) {\n        if (end <= this._progressiveDataLength) {\n            return null;\n        }\n        const rangeReader = new PDFNodeStreamFsRangeReader(this, start, end);\n        this._rangeRequestReaders.push(rangeReader);\n        return rangeReader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeRequestReaders.slice(0)){\n            reader.cancel(reason);\n        }\n    }\n}\nclass PDFNodeStreamFsFullReader {\n    constructor(stream){\n        this._url = stream.url;\n        this._done = false;\n        this._storedError = null;\n        this.onProgress = null;\n        const source = stream.source;\n        this._contentLength = source.length;\n        this._loaded = 0;\n        this._filename = null;\n        this._disableRange = source.disableRange || false;\n        this._rangeChunkSize = source.rangeChunkSize;\n        if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n        }\n        this._isStreamingSupported = !source.disableStream;\n        this._isRangeSupported = !source.disableRange;\n        this._readableStream = null;\n        this._readCapability = Promise.withResolvers();\n        this._headersCapability = Promise.withResolvers();\n        const fs = process.getBuiltinModule(\"fs\");\n        fs.promises.lstat(this._url).then((stat)=>{\n            this._contentLength = stat.size;\n            this._setReadableStream(fs.createReadStream(this._url));\n            this._headersCapability.resolve();\n        }, (error)=>{\n            if (error.code === \"ENOENT\") {\n                error = new MissingPDFException(`Missing PDF \"${this._url}\".`);\n            }\n            this._storedError = error;\n            this._headersCapability.reject(error);\n        });\n    }\n    get headersReady() {\n        return this._headersCapability.promise;\n    }\n    get filename() {\n        return this._filename;\n    }\n    get contentLength() {\n        return this._contentLength;\n    }\n    get isRangeSupported() {\n        return this._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._readCapability.promise;\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        const chunk = this._readableStream.read();\n        if (chunk === null) {\n            this._readCapability = Promise.withResolvers();\n            return this.read();\n        }\n        this._loaded += chunk.length;\n        this.onProgress?.({\n            loaded: this._loaded,\n            total: this._contentLength\n        });\n        const buffer = new Uint8Array(chunk).buffer;\n        return {\n            value: buffer,\n            done: false\n        };\n    }\n    cancel(reason) {\n        if (!this._readableStream) {\n            this._error(reason);\n            return;\n        }\n        this._readableStream.destroy(reason);\n    }\n    _error(reason) {\n        this._storedError = reason;\n        this._readCapability.resolve();\n    }\n    _setReadableStream(readableStream) {\n        this._readableStream = readableStream;\n        readableStream.on(\"readable\", ()=>{\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"end\", ()=>{\n            readableStream.destroy();\n            this._done = true;\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"error\", (reason)=>{\n            this._error(reason);\n        });\n        if (!this._isStreamingSupported && this._isRangeSupported) {\n            this._error(new AbortException(\"streaming is disabled\"));\n        }\n        if (this._storedError) {\n            this._readableStream.destroy(this._storedError);\n        }\n    }\n}\nclass PDFNodeStreamFsRangeReader {\n    constructor(stream, start, end){\n        this._url = stream.url;\n        this._done = false;\n        this._storedError = null;\n        this.onProgress = null;\n        this._loaded = 0;\n        this._readableStream = null;\n        this._readCapability = Promise.withResolvers();\n        const source = stream.source;\n        this._isStreamingSupported = !source.disableStream;\n        const fs = process.getBuiltinModule(\"fs\");\n        this._setReadableStream(fs.createReadStream(this._url, {\n            start,\n            end: end - 1\n        }));\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._readCapability.promise;\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        const chunk = this._readableStream.read();\n        if (chunk === null) {\n            this._readCapability = Promise.withResolvers();\n            return this.read();\n        }\n        this._loaded += chunk.length;\n        this.onProgress?.({\n            loaded: this._loaded\n        });\n        const buffer = new Uint8Array(chunk).buffer;\n        return {\n            value: buffer,\n            done: false\n        };\n    }\n    cancel(reason) {\n        if (!this._readableStream) {\n            this._error(reason);\n            return;\n        }\n        this._readableStream.destroy(reason);\n    }\n    _error(reason) {\n        this._storedError = reason;\n        this._readCapability.resolve();\n    }\n    _setReadableStream(readableStream) {\n        this._readableStream = readableStream;\n        readableStream.on(\"readable\", ()=>{\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"end\", ()=>{\n            readableStream.destroy();\n            this._done = true;\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"error\", (reason)=>{\n            this._error(reason);\n        });\n        if (this._storedError) {\n            this._readableStream.destroy(this._storedError);\n        }\n    }\n}\n; // ./src/display/text_layer.js\nconst MAX_TEXT_DIVS_TO_RENDER = 100000;\nconst DEFAULT_FONT_SIZE = 30;\nconst DEFAULT_FONT_ASCENT = 0.8;\nclass TextLayer {\n    #capability;\n    #container;\n    #disableProcessItems;\n    #fontInspectorEnabled;\n    #lang;\n    #layoutTextParams;\n    #pageHeight;\n    #pageWidth;\n    #reader;\n    #rootContainer;\n    #rotation;\n    #scale;\n    #styleCache;\n    #textContentItemsStr;\n    #textContentSource;\n    #textDivs;\n    #textDivProperties;\n    #transform;\n    static #ascentCache = new Map();\n    static #canvasContexts = new Map();\n    static #canvasCtxFonts = new WeakMap();\n    static #minFontSize = null;\n    static #pendingTextLayers = new Set();\n    constructor({ textContentSource, container, viewport }){\n        this.#capability = Promise.withResolvers();\n        this.#container = null;\n        this.#disableProcessItems = false;\n        this.#fontInspectorEnabled = !!globalThis.FontInspector?.enabled;\n        this.#lang = null;\n        this.#layoutTextParams = null;\n        this.#pageHeight = 0;\n        this.#pageWidth = 0;\n        this.#reader = null;\n        this.#rootContainer = null;\n        this.#rotation = 0;\n        this.#scale = 0;\n        this.#styleCache = Object.create(null);\n        this.#textContentItemsStr = [];\n        this.#textContentSource = null;\n        this.#textDivs = [];\n        this.#textDivProperties = new WeakMap();\n        this.#transform = null;\n        if (textContentSource instanceof ReadableStream) {\n            this.#textContentSource = textContentSource;\n        } else if (typeof textContentSource === \"object\") {\n            this.#textContentSource = new ReadableStream({\n                start (controller) {\n                    controller.enqueue(textContentSource);\n                    controller.close();\n                }\n            });\n        } else {\n            throw new Error('No \"textContentSource\" parameter specified.');\n        }\n        this.#container = this.#rootContainer = container;\n        this.#scale = viewport.scale * (globalThis.devicePixelRatio || 1);\n        this.#rotation = viewport.rotation;\n        this.#layoutTextParams = {\n            div: null,\n            properties: null,\n            ctx: null\n        };\n        const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;\n        this.#transform = [\n            1,\n            0,\n            0,\n            -1,\n            -pageX,\n            pageY + pageHeight\n        ];\n        this.#pageWidth = pageWidth;\n        this.#pageHeight = pageHeight;\n        TextLayer.#ensureMinFontSizeComputed();\n        setLayerDimensions(container, viewport);\n        this.#capability.promise.finally(()=>{\n            TextLayer.#pendingTextLayers.delete(this);\n            this.#layoutTextParams = null;\n            this.#styleCache = null;\n        }).catch(()=>{});\n    }\n    static get fontFamilyMap() {\n        const { isWindows, isFirefox } = util_FeatureTest.platform;\n        return shadow(this, \"fontFamilyMap\", new Map([\n            [\n                \"sans-serif\",\n                `${isWindows && isFirefox ? \"Calibri, \" : \"\"}sans-serif`\n            ],\n            [\n                \"monospace\",\n                `${isWindows && isFirefox ? \"Lucida Console, \" : \"\"}monospace`\n            ]\n        ]));\n    }\n    render() {\n        const pump = ()=>{\n            this.#reader.read().then(({ value, done })=>{\n                if (done) {\n                    this.#capability.resolve();\n                    return;\n                }\n                this.#lang ??= value.lang;\n                Object.assign(this.#styleCache, value.styles);\n                this.#processItems(value.items);\n                pump();\n            }, this.#capability.reject);\n        };\n        this.#reader = this.#textContentSource.getReader();\n        TextLayer.#pendingTextLayers.add(this);\n        pump();\n        return this.#capability.promise;\n    }\n    update({ viewport, onBefore = null }) {\n        const scale = viewport.scale * (globalThis.devicePixelRatio || 1);\n        const rotation = viewport.rotation;\n        if (rotation !== this.#rotation) {\n            onBefore?.();\n            this.#rotation = rotation;\n            setLayerDimensions(this.#rootContainer, {\n                rotation\n            });\n        }\n        if (scale !== this.#scale) {\n            onBefore?.();\n            this.#scale = scale;\n            const params = {\n                div: null,\n                properties: null,\n                ctx: TextLayer.#getCtx(this.#lang)\n            };\n            for (const div of this.#textDivs){\n                params.properties = this.#textDivProperties.get(div);\n                params.div = div;\n                this.#layout(params);\n            }\n        }\n    }\n    cancel() {\n        const abortEx = new AbortException(\"TextLayer task cancelled.\");\n        this.#reader?.cancel(abortEx).catch(()=>{});\n        this.#reader = null;\n        this.#capability.reject(abortEx);\n    }\n    get textDivs() {\n        return this.#textDivs;\n    }\n    get textContentItemsStr() {\n        return this.#textContentItemsStr;\n    }\n    #processItems(items) {\n        if (this.#disableProcessItems) {\n            return;\n        }\n        this.#layoutTextParams.ctx ??= TextLayer.#getCtx(this.#lang);\n        const textDivs = this.#textDivs, textContentItemsStr = this.#textContentItemsStr;\n        for (const item of items){\n            if (textDivs.length > MAX_TEXT_DIVS_TO_RENDER) {\n                warn(\"Ignoring additional textDivs for performance reasons.\");\n                this.#disableProcessItems = true;\n                return;\n            }\n            if (item.str === undefined) {\n                if (item.type === \"beginMarkedContentProps\" || item.type === \"beginMarkedContent\") {\n                    const parent = this.#container;\n                    this.#container = document.createElement(\"span\");\n                    this.#container.classList.add(\"markedContent\");\n                    if (item.id !== null) {\n                        this.#container.setAttribute(\"id\", `${item.id}`);\n                    }\n                    parent.append(this.#container);\n                } else if (item.type === \"endMarkedContent\") {\n                    this.#container = this.#container.parentNode;\n                }\n                continue;\n            }\n            textContentItemsStr.push(item.str);\n            this.#appendText(item);\n        }\n    }\n    #appendText(geom) {\n        const textDiv = document.createElement(\"span\");\n        const textDivProperties = {\n            angle: 0,\n            canvasWidth: 0,\n            hasText: geom.str !== \"\",\n            hasEOL: geom.hasEOL,\n            fontSize: 0\n        };\n        this.#textDivs.push(textDiv);\n        const tx = Util.transform(this.#transform, geom.transform);\n        let angle = Math.atan2(tx[1], tx[0]);\n        const style = this.#styleCache[geom.fontName];\n        if (style.vertical) {\n            angle += Math.PI / 2;\n        }\n        let fontFamily = this.#fontInspectorEnabled && style.fontSubstitution || style.fontFamily;\n        fontFamily = TextLayer.fontFamilyMap.get(fontFamily) || fontFamily;\n        const fontHeight = Math.hypot(tx[2], tx[3]);\n        const fontAscent = fontHeight * TextLayer.#getAscent(fontFamily, this.#lang);\n        let left, top;\n        if (angle === 0) {\n            left = tx[4];\n            top = tx[5] - fontAscent;\n        } else {\n            left = tx[4] + fontAscent * Math.sin(angle);\n            top = tx[5] - fontAscent * Math.cos(angle);\n        }\n        const scaleFactorStr = \"calc(var(--scale-factor)*\";\n        const divStyle = textDiv.style;\n        if (this.#container === this.#rootContainer) {\n            divStyle.left = `${(100 * left / this.#pageWidth).toFixed(2)}%`;\n            divStyle.top = `${(100 * top / this.#pageHeight).toFixed(2)}%`;\n        } else {\n            divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;\n            divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;\n        }\n        divStyle.fontSize = `${scaleFactorStr}${(TextLayer.#minFontSize * fontHeight).toFixed(2)}px)`;\n        divStyle.fontFamily = fontFamily;\n        textDivProperties.fontSize = fontHeight;\n        textDiv.setAttribute(\"role\", \"presentation\");\n        textDiv.textContent = geom.str;\n        textDiv.dir = geom.dir;\n        if (this.#fontInspectorEnabled) {\n            textDiv.dataset.fontName = style.fontSubstitutionLoadedName || geom.fontName;\n        }\n        if (angle !== 0) {\n            textDivProperties.angle = angle * (180 / Math.PI);\n        }\n        let shouldScaleText = false;\n        if (geom.str.length > 1) {\n            shouldScaleText = true;\n        } else if (geom.str !== \" \" && geom.transform[0] !== geom.transform[3]) {\n            const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);\n            if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n                shouldScaleText = true;\n            }\n        }\n        if (shouldScaleText) {\n            textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;\n        }\n        this.#textDivProperties.set(textDiv, textDivProperties);\n        this.#layoutTextParams.div = textDiv;\n        this.#layoutTextParams.properties = textDivProperties;\n        this.#layout(this.#layoutTextParams);\n        if (textDivProperties.hasText) {\n            this.#container.append(textDiv);\n        }\n        if (textDivProperties.hasEOL) {\n            const br = document.createElement(\"br\");\n            br.setAttribute(\"role\", \"presentation\");\n            this.#container.append(br);\n        }\n    }\n    #layout(params) {\n        const { div, properties, ctx } = params;\n        const { style } = div;\n        let transform = \"\";\n        if (TextLayer.#minFontSize > 1) {\n            transform = `scale(${1 / TextLayer.#minFontSize})`;\n        }\n        if (properties.canvasWidth !== 0 && properties.hasText) {\n            const { fontFamily } = style;\n            const { canvasWidth, fontSize } = properties;\n            TextLayer.#ensureCtxFont(ctx, fontSize * this.#scale, fontFamily);\n            const { width } = ctx.measureText(div.textContent);\n            if (width > 0) {\n                transform = `scaleX(${canvasWidth * this.#scale / width}) ${transform}`;\n            }\n        }\n        if (properties.angle !== 0) {\n            transform = `rotate(${properties.angle}deg) ${transform}`;\n        }\n        if (transform.length > 0) {\n            style.transform = transform;\n        }\n    }\n    static cleanup() {\n        if (this.#pendingTextLayers.size > 0) {\n            return;\n        }\n        this.#ascentCache.clear();\n        for (const { canvas } of this.#canvasContexts.values()){\n            canvas.remove();\n        }\n        this.#canvasContexts.clear();\n    }\n    static #getCtx(lang = null) {\n        let ctx = this.#canvasContexts.get(lang ||= \"\");\n        if (!ctx) {\n            const canvas = document.createElement(\"canvas\");\n            canvas.className = \"hiddenCanvasElement\";\n            canvas.lang = lang;\n            document.body.append(canvas);\n            ctx = canvas.getContext(\"2d\", {\n                alpha: false,\n                willReadFrequently: true\n            });\n            this.#canvasContexts.set(lang, ctx);\n            this.#canvasCtxFonts.set(ctx, {\n                size: 0,\n                family: \"\"\n            });\n        }\n        return ctx;\n    }\n    static #ensureCtxFont(ctx, size, family) {\n        const cached = this.#canvasCtxFonts.get(ctx);\n        if (size === cached.size && family === cached.family) {\n            return;\n        }\n        ctx.font = `${size}px ${family}`;\n        cached.size = size;\n        cached.family = family;\n    }\n    static #ensureMinFontSizeComputed() {\n        if (this.#minFontSize !== null) {\n            return;\n        }\n        const div = document.createElement(\"div\");\n        div.style.opacity = 0;\n        div.style.lineHeight = 1;\n        div.style.fontSize = \"1px\";\n        div.style.position = \"absolute\";\n        div.textContent = \"X\";\n        document.body.append(div);\n        this.#minFontSize = div.getBoundingClientRect().height;\n        div.remove();\n    }\n    static #getAscent(fontFamily, lang) {\n        const cachedAscent = this.#ascentCache.get(fontFamily);\n        if (cachedAscent) {\n            return cachedAscent;\n        }\n        const ctx = this.#getCtx(lang);\n        ctx.canvas.width = ctx.canvas.height = DEFAULT_FONT_SIZE;\n        this.#ensureCtxFont(ctx, DEFAULT_FONT_SIZE, fontFamily);\n        const metrics = ctx.measureText(\"\");\n        let ascent = metrics.fontBoundingBoxAscent;\n        let descent = Math.abs(metrics.fontBoundingBoxDescent);\n        if (ascent) {\n            const ratio = ascent / (ascent + descent);\n            this.#ascentCache.set(fontFamily, ratio);\n            ctx.canvas.width = ctx.canvas.height = 0;\n            return ratio;\n        }\n        ctx.strokeStyle = \"red\";\n        ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n        ctx.strokeText(\"g\", 0, 0);\n        let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n        descent = 0;\n        for(let i = pixels.length - 1 - 3; i >= 0; i -= 4){\n            if (pixels[i] > 0) {\n                descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);\n                break;\n            }\n        }\n        ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n        ctx.strokeText(\"A\", 0, DEFAULT_FONT_SIZE);\n        pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n        ascent = 0;\n        for(let i = 0, ii = pixels.length; i < ii; i += 4){\n            if (pixels[i] > 0) {\n                ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);\n                break;\n            }\n        }\n        ctx.canvas.width = ctx.canvas.height = 0;\n        const ratio = ascent ? ascent / (ascent + descent) : DEFAULT_FONT_ASCENT;\n        this.#ascentCache.set(fontFamily, ratio);\n        return ratio;\n    }\n}\n; // ./src/display/xfa_text.js\nclass XfaText {\n    static textContent(xfa) {\n        const items = [];\n        const output = {\n            items,\n            styles: Object.create(null)\n        };\n        function walk(node) {\n            if (!node) {\n                return;\n            }\n            let str = null;\n            const name = node.name;\n            if (name === \"#text\") {\n                str = node.value;\n            } else if (!XfaText.shouldBuildText(name)) {\n                return;\n            } else if (node?.attributes?.textContent) {\n                str = node.attributes.textContent;\n            } else if (node.value) {\n                str = node.value;\n            }\n            if (str !== null) {\n                items.push({\n                    str\n                });\n            }\n            if (!node.children) {\n                return;\n            }\n            for (const child of node.children){\n                walk(child);\n            }\n        }\n        walk(xfa);\n        return output;\n    }\n    static shouldBuildText(name) {\n        return !(name === \"textarea\" || name === \"input\" || name === \"option\" || name === \"select\");\n    }\n}\n; // ./src/display/api.js\nconst DEFAULT_RANGE_CHUNK_SIZE = 65536;\nconst RENDERING_CANCELLED_TIMEOUT = 100;\nconst DELAYED_CLEANUP_TIMEOUT = 5000;\nconst DefaultCanvasFactory = isNodeJS ? NodeCanvasFactory : DOMCanvasFactory;\nconst DefaultCMapReaderFactory = isNodeJS ? NodeCMapReaderFactory : DOMCMapReaderFactory;\nconst DefaultFilterFactory = isNodeJS ? NodeFilterFactory : DOMFilterFactory;\nconst DefaultStandardFontDataFactory = isNodeJS ? NodeStandardFontDataFactory : DOMStandardFontDataFactory;\nfunction getDocument(src = {}) {\n    if (typeof src === \"string\" || src instanceof URL) {\n        src = {\n            url: src\n        };\n    } else if (src instanceof ArrayBuffer || ArrayBuffer.isView(src)) {\n        src = {\n            data: src\n        };\n    }\n    const task = new PDFDocumentLoadingTask();\n    const { docId } = task;\n    const url = src.url ? getUrlProp(src.url) : null;\n    const data = src.data ? getDataProp(src.data) : null;\n    const httpHeaders = src.httpHeaders || null;\n    const withCredentials = src.withCredentials === true;\n    const password = src.password ?? null;\n    const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;\n    const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;\n    let worker = src.worker instanceof PDFWorker ? src.worker : null;\n    const verbosity = src.verbosity;\n    const docBaseUrl = typeof src.docBaseUrl === \"string\" && !isDataScheme(src.docBaseUrl) ? src.docBaseUrl : null;\n    const cMapUrl = typeof src.cMapUrl === \"string\" ? src.cMapUrl : null;\n    const cMapPacked = src.cMapPacked !== false;\n    const CMapReaderFactory = src.CMapReaderFactory || DefaultCMapReaderFactory;\n    const standardFontDataUrl = typeof src.standardFontDataUrl === \"string\" ? src.standardFontDataUrl : null;\n    const StandardFontDataFactory = src.StandardFontDataFactory || DefaultStandardFontDataFactory;\n    const ignoreErrors = src.stopAtErrors !== true;\n    const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;\n    const isEvalSupported = src.isEvalSupported !== false;\n    const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === \"boolean\" ? src.isOffscreenCanvasSupported : !isNodeJS;\n    const isImageDecoderSupported = typeof src.isImageDecoderSupported === \"boolean\" ? src.isImageDecoderSupported : !isNodeJS && (util_FeatureTest.platform.isFirefox || !globalThis.chrome);\n    const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;\n    const disableFontFace = typeof src.disableFontFace === \"boolean\" ? src.disableFontFace : isNodeJS;\n    const fontExtraProperties = src.fontExtraProperties === true;\n    const enableXfa = src.enableXfa === true;\n    const ownerDocument = src.ownerDocument || globalThis.document;\n    const disableRange = src.disableRange === true;\n    const disableStream = src.disableStream === true;\n    const disableAutoFetch = src.disableAutoFetch === true;\n    const pdfBug = src.pdfBug === true;\n    const CanvasFactory = src.CanvasFactory || DefaultCanvasFactory;\n    const FilterFactory = src.FilterFactory || DefaultFilterFactory;\n    const enableHWA = src.enableHWA === true;\n    const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;\n    const useSystemFonts = typeof src.useSystemFonts === \"boolean\" ? src.useSystemFonts : !isNodeJS && !disableFontFace;\n    const useWorkerFetch = typeof src.useWorkerFetch === \"boolean\" ? src.useWorkerFetch : CMapReaderFactory === DOMCMapReaderFactory && StandardFontDataFactory === DOMStandardFontDataFactory && cMapUrl && standardFontDataUrl && isValidFetchUrl(cMapUrl, document.baseURI) && isValidFetchUrl(standardFontDataUrl, document.baseURI);\n    const styleElement = null;\n    setVerbosityLevel(verbosity);\n    const transportFactory = {\n        canvasFactory: new CanvasFactory({\n            ownerDocument,\n            enableHWA\n        }),\n        filterFactory: new FilterFactory({\n            docId,\n            ownerDocument\n        }),\n        cMapReaderFactory: useWorkerFetch ? null : new CMapReaderFactory({\n            baseUrl: cMapUrl,\n            isCompressed: cMapPacked\n        }),\n        standardFontDataFactory: useWorkerFetch ? null : new StandardFontDataFactory({\n            baseUrl: standardFontDataUrl\n        })\n    };\n    if (!worker) {\n        const workerParams = {\n            verbosity,\n            port: GlobalWorkerOptions.workerPort\n        };\n        worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);\n        task._worker = worker;\n    }\n    const docParams = {\n        docId,\n        apiVersion: \"4.10.38\",\n        data,\n        password,\n        disableAutoFetch,\n        rangeChunkSize,\n        length,\n        docBaseUrl,\n        enableXfa,\n        evaluatorOptions: {\n            maxImageSize,\n            disableFontFace,\n            ignoreErrors,\n            isEvalSupported,\n            isOffscreenCanvasSupported,\n            isImageDecoderSupported,\n            canvasMaxAreaInBytes,\n            fontExtraProperties,\n            useSystemFonts,\n            cMapUrl: useWorkerFetch ? cMapUrl : null,\n            standardFontDataUrl: useWorkerFetch ? standardFontDataUrl : null\n        }\n    };\n    const transportParams = {\n        disableFontFace,\n        fontExtraProperties,\n        ownerDocument,\n        pdfBug,\n        styleElement,\n        loadingParams: {\n            disableAutoFetch,\n            enableXfa\n        }\n    };\n    worker.promise.then(function() {\n        if (task.destroyed) {\n            throw new Error(\"Loading aborted\");\n        }\n        if (worker.destroyed) {\n            throw new Error(\"Worker was destroyed\");\n        }\n        const workerIdPromise = worker.messageHandler.sendWithPromise(\"GetDocRequest\", docParams, data ? [\n            data.buffer\n        ] : null);\n        let networkStream;\n        if (rangeTransport) {\n            networkStream = new PDFDataTransportStream(rangeTransport, {\n                disableRange,\n                disableStream\n            });\n        } else if (!data) {\n            if (!url) {\n                throw new Error(\"getDocument - no `url` parameter provided.\");\n            }\n            let NetworkStream;\n            if (isNodeJS) {\n                if (isValidFetchUrl(url)) {\n                    if (typeof fetch === \"undefined\" || typeof Response === \"undefined\" || !(\"body\" in Response.prototype)) {\n                        throw new Error(\"getDocument - the Fetch API was disabled in Node.js, see `--no-experimental-fetch`.\");\n                    }\n                    NetworkStream = PDFFetchStream;\n                } else {\n                    NetworkStream = PDFNodeStream;\n                }\n            } else {\n                NetworkStream = isValidFetchUrl(url) ? PDFFetchStream : PDFNetworkStream;\n            }\n            networkStream = new NetworkStream({\n                url,\n                length,\n                httpHeaders,\n                withCredentials,\n                rangeChunkSize,\n                disableRange,\n                disableStream\n            });\n        }\n        return workerIdPromise.then((workerId)=>{\n            if (task.destroyed) {\n                throw new Error(\"Loading aborted\");\n            }\n            if (worker.destroyed) {\n                throw new Error(\"Worker was destroyed\");\n            }\n            const messageHandler = new MessageHandler(docId, workerId, worker.port);\n            const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory);\n            task._transport = transport;\n            messageHandler.send(\"Ready\", null);\n        });\n    }).catch(task._capability.reject);\n    return task;\n}\nfunction getUrlProp(val) {\n    if (val instanceof URL) {\n        return val.href;\n    }\n    try {\n        return new URL(val, window.location).href;\n    } catch  {\n        if (isNodeJS && typeof val === \"string\") {\n            return val;\n        }\n    }\n    throw new Error(\"Invalid PDF url data: \" + \"either string or URL-object is expected in the url property.\");\n}\nfunction getDataProp(val) {\n    if (isNodeJS && typeof Buffer !== \"undefined\" && val instanceof Buffer) {\n        throw new Error(\"Please provide binary data as `Uint8Array`, rather than `Buffer`.\");\n    }\n    if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {\n        return val;\n    }\n    if (typeof val === \"string\") {\n        return stringToBytes(val);\n    }\n    if (val instanceof ArrayBuffer || ArrayBuffer.isView(val) || typeof val === \"object\" && !isNaN(val?.length)) {\n        return new Uint8Array(val);\n    }\n    throw new Error(\"Invalid PDF binary data: either TypedArray, \" + \"string, or array-like object is expected in the data property.\");\n}\nfunction isRefProxy(ref) {\n    return typeof ref === \"object\" && Number.isInteger(ref?.num) && ref.num >= 0 && Number.isInteger(ref?.gen) && ref.gen >= 0;\n}\nclass PDFDocumentLoadingTask {\n    static #docId = 0;\n    constructor(){\n        this._capability = Promise.withResolvers();\n        this._transport = null;\n        this._worker = null;\n        this.docId = `d${PDFDocumentLoadingTask.#docId++}`;\n        this.destroyed = false;\n        this.onPassword = null;\n        this.onProgress = null;\n    }\n    get promise() {\n        return this._capability.promise;\n    }\n    async destroy() {\n        this.destroyed = true;\n        try {\n            if (this._worker?.port) {\n                this._worker._pendingDestroy = true;\n            }\n            await this._transport?.destroy();\n        } catch (ex) {\n            if (this._worker?.port) {\n                delete this._worker._pendingDestroy;\n            }\n            throw ex;\n        }\n        this._transport = null;\n        this._worker?.destroy();\n        this._worker = null;\n    }\n}\nclass PDFDataRangeTransport {\n    constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null){\n        this.length = length;\n        this.initialData = initialData;\n        this.progressiveDone = progressiveDone;\n        this.contentDispositionFilename = contentDispositionFilename;\n        this._rangeListeners = [];\n        this._progressListeners = [];\n        this._progressiveReadListeners = [];\n        this._progressiveDoneListeners = [];\n        this._readyCapability = Promise.withResolvers();\n    }\n    addRangeListener(listener) {\n        this._rangeListeners.push(listener);\n    }\n    addProgressListener(listener) {\n        this._progressListeners.push(listener);\n    }\n    addProgressiveReadListener(listener) {\n        this._progressiveReadListeners.push(listener);\n    }\n    addProgressiveDoneListener(listener) {\n        this._progressiveDoneListeners.push(listener);\n    }\n    onDataRange(begin, chunk) {\n        for (const listener of this._rangeListeners){\n            listener(begin, chunk);\n        }\n    }\n    onDataProgress(loaded, total) {\n        this._readyCapability.promise.then(()=>{\n            for (const listener of this._progressListeners){\n                listener(loaded, total);\n            }\n        });\n    }\n    onDataProgressiveRead(chunk) {\n        this._readyCapability.promise.then(()=>{\n            for (const listener of this._progressiveReadListeners){\n                listener(chunk);\n            }\n        });\n    }\n    onDataProgressiveDone() {\n        this._readyCapability.promise.then(()=>{\n            for (const listener of this._progressiveDoneListeners){\n                listener();\n            }\n        });\n    }\n    transportReady() {\n        this._readyCapability.resolve();\n    }\n    requestDataRange(begin, end) {\n        unreachable(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n    }\n    abort() {}\n}\nclass PDFDocumentProxy {\n    constructor(pdfInfo, transport){\n        this._pdfInfo = pdfInfo;\n        this._transport = transport;\n    }\n    get annotationStorage() {\n        return this._transport.annotationStorage;\n    }\n    get canvasFactory() {\n        return this._transport.canvasFactory;\n    }\n    get filterFactory() {\n        return this._transport.filterFactory;\n    }\n    get numPages() {\n        return this._pdfInfo.numPages;\n    }\n    get fingerprints() {\n        return this._pdfInfo.fingerprints;\n    }\n    get isPureXfa() {\n        return shadow(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n    }\n    get allXfaHtml() {\n        return this._transport._htmlForXfa;\n    }\n    getPage(pageNumber) {\n        return this._transport.getPage(pageNumber);\n    }\n    getPageIndex(ref) {\n        return this._transport.getPageIndex(ref);\n    }\n    getDestinations() {\n        return this._transport.getDestinations();\n    }\n    getDestination(id) {\n        return this._transport.getDestination(id);\n    }\n    getPageLabels() {\n        return this._transport.getPageLabels();\n    }\n    getPageLayout() {\n        return this._transport.getPageLayout();\n    }\n    getPageMode() {\n        return this._transport.getPageMode();\n    }\n    getViewerPreferences() {\n        return this._transport.getViewerPreferences();\n    }\n    getOpenAction() {\n        return this._transport.getOpenAction();\n    }\n    getAttachments() {\n        return this._transport.getAttachments();\n    }\n    getJSActions() {\n        return this._transport.getDocJSActions();\n    }\n    getOutline() {\n        return this._transport.getOutline();\n    }\n    getOptionalContentConfig({ intent = \"display\" } = {}) {\n        const { renderingIntent } = this._transport.getRenderingIntent(intent);\n        return this._transport.getOptionalContentConfig(renderingIntent);\n    }\n    getPermissions() {\n        return this._transport.getPermissions();\n    }\n    getMetadata() {\n        return this._transport.getMetadata();\n    }\n    getMarkInfo() {\n        return this._transport.getMarkInfo();\n    }\n    getData() {\n        return this._transport.getData();\n    }\n    saveDocument() {\n        return this._transport.saveDocument();\n    }\n    getDownloadInfo() {\n        return this._transport.downloadInfoCapability.promise;\n    }\n    cleanup(keepLoadedFonts = false) {\n        return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);\n    }\n    destroy() {\n        return this.loadingTask.destroy();\n    }\n    cachedPageNumber(ref) {\n        return this._transport.cachedPageNumber(ref);\n    }\n    get loadingParams() {\n        return this._transport.loadingParams;\n    }\n    get loadingTask() {\n        return this._transport.loadingTask;\n    }\n    getFieldObjects() {\n        return this._transport.getFieldObjects();\n    }\n    hasJSActions() {\n        return this._transport.hasJSActions();\n    }\n    getCalculationOrderIds() {\n        return this._transport.getCalculationOrderIds();\n    }\n}\nclass PDFPageProxy {\n    #delayedCleanupTimeout;\n    #pendingCleanup;\n    constructor(pageIndex, pageInfo, transport, pdfBug = false){\n        this.#delayedCleanupTimeout = null;\n        this.#pendingCleanup = false;\n        this._pageIndex = pageIndex;\n        this._pageInfo = pageInfo;\n        this._transport = transport;\n        this._stats = pdfBug ? new StatTimer() : null;\n        this._pdfBug = pdfBug;\n        this.commonObjs = transport.commonObjs;\n        this.objs = new PDFObjects();\n        this._maybeCleanupAfterRender = false;\n        this._intentStates = new Map();\n        this.destroyed = false;\n    }\n    get pageNumber() {\n        return this._pageIndex + 1;\n    }\n    get rotate() {\n        return this._pageInfo.rotate;\n    }\n    get ref() {\n        return this._pageInfo.ref;\n    }\n    get userUnit() {\n        return this._pageInfo.userUnit;\n    }\n    get view() {\n        return this._pageInfo.view;\n    }\n    getViewport({ scale, rotation = this.rotate, offsetX = 0, offsetY = 0, dontFlip = false } = {}) {\n        return new PageViewport({\n            viewBox: this.view,\n            userUnit: this.userUnit,\n            scale,\n            rotation,\n            offsetX,\n            offsetY,\n            dontFlip\n        });\n    }\n    getAnnotations({ intent = \"display\" } = {}) {\n        const { renderingIntent } = this._transport.getRenderingIntent(intent);\n        return this._transport.getAnnotations(this._pageIndex, renderingIntent);\n    }\n    getJSActions() {\n        return this._transport.getPageJSActions(this._pageIndex);\n    }\n    get filterFactory() {\n        return this._transport.filterFactory;\n    }\n    get isPureXfa() {\n        return shadow(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n    }\n    async getXfa() {\n        return this._transport._htmlForXfa?.children[this._pageIndex] || null;\n    }\n    render({ canvasContext, viewport, intent = \"display\", annotationMode = AnnotationMode.ENABLE, transform = null, background = null, optionalContentConfigPromise = null, annotationCanvasMap = null, pageColors = null, printAnnotationStorage = null, isEditing = false }) {\n        this._stats?.time(\"Overall\");\n        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing);\n        const { renderingIntent, cacheKey } = intentArgs;\n        this.#pendingCleanup = false;\n        this.#abortDelayedCleanup();\n        optionalContentConfigPromise ||= this._transport.getOptionalContentConfig(renderingIntent);\n        let intentState = this._intentStates.get(cacheKey);\n        if (!intentState) {\n            intentState = Object.create(null);\n            this._intentStates.set(cacheKey, intentState);\n        }\n        if (intentState.streamReaderCancelTimeout) {\n            clearTimeout(intentState.streamReaderCancelTimeout);\n            intentState.streamReaderCancelTimeout = null;\n        }\n        const intentPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);\n        if (!intentState.displayReadyCapability) {\n            intentState.displayReadyCapability = Promise.withResolvers();\n            intentState.operatorList = {\n                fnArray: [],\n                argsArray: [],\n                lastChunk: false,\n                separateAnnots: null\n            };\n            this._stats?.time(\"Page Request\");\n            this._pumpOperatorList(intentArgs);\n        }\n        const complete = (error)=>{\n            intentState.renderTasks.delete(internalRenderTask);\n            if (this._maybeCleanupAfterRender || intentPrint) {\n                this.#pendingCleanup = true;\n            }\n            this.#tryCleanup(!intentPrint);\n            if (error) {\n                internalRenderTask.capability.reject(error);\n                this._abortOperatorList({\n                    intentState,\n                    reason: error instanceof Error ? error : new Error(error)\n                });\n            } else {\n                internalRenderTask.capability.resolve();\n            }\n            if (this._stats) {\n                this._stats.timeEnd(\"Rendering\");\n                this._stats.timeEnd(\"Overall\");\n                if (globalThis.Stats?.enabled) {\n                    globalThis.Stats.add(this.pageNumber, this._stats);\n                }\n            }\n        };\n        const internalRenderTask = new InternalRenderTask({\n            callback: complete,\n            params: {\n                canvasContext,\n                viewport,\n                transform,\n                background\n            },\n            objs: this.objs,\n            commonObjs: this.commonObjs,\n            annotationCanvasMap,\n            operatorList: intentState.operatorList,\n            pageIndex: this._pageIndex,\n            canvasFactory: this._transport.canvasFactory,\n            filterFactory: this._transport.filterFactory,\n            useRequestAnimationFrame: !intentPrint,\n            pdfBug: this._pdfBug,\n            pageColors\n        });\n        (intentState.renderTasks ||= new Set()).add(internalRenderTask);\n        const renderTask = internalRenderTask.task;\n        Promise.all([\n            intentState.displayReadyCapability.promise,\n            optionalContentConfigPromise\n        ]).then(([transparency, optionalContentConfig])=>{\n            if (this.destroyed) {\n                complete();\n                return;\n            }\n            this._stats?.time(\"Rendering\");\n            if (!(optionalContentConfig.renderingIntent & renderingIntent)) {\n                throw new Error(\"Must use the same `intent`-argument when calling the `PDFPageProxy.render` \" + \"and `PDFDocumentProxy.getOptionalContentConfig` methods.\");\n            }\n            internalRenderTask.initializeGraphics({\n                transparency,\n                optionalContentConfig\n            });\n            internalRenderTask.operatorListChanged();\n        }).catch(complete);\n        return renderTask;\n    }\n    getOperatorList({ intent = \"display\", annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false } = {}) {\n        function operatorListChanged() {\n            if (intentState.operatorList.lastChunk) {\n                intentState.opListReadCapability.resolve(intentState.operatorList);\n                intentState.renderTasks.delete(opListTask);\n            }\n        }\n        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing, true);\n        let intentState = this._intentStates.get(intentArgs.cacheKey);\n        if (!intentState) {\n            intentState = Object.create(null);\n            this._intentStates.set(intentArgs.cacheKey, intentState);\n        }\n        let opListTask;\n        if (!intentState.opListReadCapability) {\n            opListTask = Object.create(null);\n            opListTask.operatorListChanged = operatorListChanged;\n            intentState.opListReadCapability = Promise.withResolvers();\n            (intentState.renderTasks ||= new Set()).add(opListTask);\n            intentState.operatorList = {\n                fnArray: [],\n                argsArray: [],\n                lastChunk: false,\n                separateAnnots: null\n            };\n            this._stats?.time(\"Page Request\");\n            this._pumpOperatorList(intentArgs);\n        }\n        return intentState.opListReadCapability.promise;\n    }\n    streamTextContent({ includeMarkedContent = false, disableNormalization = false } = {}) {\n        const TEXT_CONTENT_CHUNK_SIZE = 100;\n        return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n            pageIndex: this._pageIndex,\n            includeMarkedContent: includeMarkedContent === true,\n            disableNormalization: disableNormalization === true\n        }, {\n            highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n            size (textContent) {\n                return textContent.items.length;\n            }\n        });\n    }\n    getTextContent(params = {}) {\n        if (this._transport._htmlForXfa) {\n            return this.getXfa().then((xfa)=>XfaText.textContent(xfa));\n        }\n        const readableStream = this.streamTextContent(params);\n        return new Promise(function(resolve, reject) {\n            function pump() {\n                reader.read().then(function({ value, done }) {\n                    if (done) {\n                        resolve(textContent);\n                        return;\n                    }\n                    textContent.lang ??= value.lang;\n                    Object.assign(textContent.styles, value.styles);\n                    textContent.items.push(...value.items);\n                    pump();\n                }, reject);\n            }\n            const reader = readableStream.getReader();\n            const textContent = {\n                items: [],\n                styles: Object.create(null),\n                lang: null\n            };\n            pump();\n        });\n    }\n    getStructTree() {\n        return this._transport.getStructTree(this._pageIndex);\n    }\n    _destroy() {\n        this.destroyed = true;\n        const waitOn = [];\n        for (const intentState of this._intentStates.values()){\n            this._abortOperatorList({\n                intentState,\n                reason: new Error(\"Page was destroyed.\"),\n                force: true\n            });\n            if (intentState.opListReadCapability) {\n                continue;\n            }\n            for (const internalRenderTask of intentState.renderTasks){\n                waitOn.push(internalRenderTask.completed);\n                internalRenderTask.cancel();\n            }\n        }\n        this.objs.clear();\n        this.#pendingCleanup = false;\n        this.#abortDelayedCleanup();\n        return Promise.all(waitOn);\n    }\n    cleanup(resetStats = false) {\n        this.#pendingCleanup = true;\n        const success = this.#tryCleanup(false);\n        if (resetStats && success) {\n            this._stats &&= new StatTimer();\n        }\n        return success;\n    }\n    #tryCleanup(delayed = false) {\n        this.#abortDelayedCleanup();\n        if (!this.#pendingCleanup || this.destroyed) {\n            return false;\n        }\n        if (delayed) {\n            this.#delayedCleanupTimeout = setTimeout(()=>{\n                this.#delayedCleanupTimeout = null;\n                this.#tryCleanup(false);\n            }, DELAYED_CLEANUP_TIMEOUT);\n            return false;\n        }\n        for (const { renderTasks, operatorList } of this._intentStates.values()){\n            if (renderTasks.size > 0 || !operatorList.lastChunk) {\n                return false;\n            }\n        }\n        this._intentStates.clear();\n        this.objs.clear();\n        this.#pendingCleanup = false;\n        return true;\n    }\n    #abortDelayedCleanup() {\n        if (this.#delayedCleanupTimeout) {\n            clearTimeout(this.#delayedCleanupTimeout);\n            this.#delayedCleanupTimeout = null;\n        }\n    }\n    _startRenderPage(transparency, cacheKey) {\n        const intentState = this._intentStates.get(cacheKey);\n        if (!intentState) {\n            return;\n        }\n        this._stats?.timeEnd(\"Page Request\");\n        intentState.displayReadyCapability?.resolve(transparency);\n    }\n    _renderPageChunk(operatorListChunk, intentState) {\n        for(let i = 0, ii = operatorListChunk.length; i < ii; i++){\n            intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n            intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n        }\n        intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n        intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;\n        for (const internalRenderTask of intentState.renderTasks){\n            internalRenderTask.operatorListChanged();\n        }\n        if (operatorListChunk.lastChunk) {\n            this.#tryCleanup(true);\n        }\n    }\n    _pumpOperatorList({ renderingIntent, cacheKey, annotationStorageSerializable, modifiedIds }) {\n        const { map, transfer } = annotationStorageSerializable;\n        const readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", {\n            pageIndex: this._pageIndex,\n            intent: renderingIntent,\n            cacheKey,\n            annotationStorage: map,\n            modifiedIds\n        }, transfer);\n        const reader = readableStream.getReader();\n        const intentState = this._intentStates.get(cacheKey);\n        intentState.streamReader = reader;\n        const pump = ()=>{\n            reader.read().then(({ value, done })=>{\n                if (done) {\n                    intentState.streamReader = null;\n                    return;\n                }\n                if (this._transport.destroyed) {\n                    return;\n                }\n                this._renderPageChunk(value, intentState);\n                pump();\n            }, (reason)=>{\n                intentState.streamReader = null;\n                if (this._transport.destroyed) {\n                    return;\n                }\n                if (intentState.operatorList) {\n                    intentState.operatorList.lastChunk = true;\n                    for (const internalRenderTask of intentState.renderTasks){\n                        internalRenderTask.operatorListChanged();\n                    }\n                    this.#tryCleanup(true);\n                }\n                if (intentState.displayReadyCapability) {\n                    intentState.displayReadyCapability.reject(reason);\n                } else if (intentState.opListReadCapability) {\n                    intentState.opListReadCapability.reject(reason);\n                } else {\n                    throw reason;\n                }\n            });\n        };\n        pump();\n    }\n    _abortOperatorList({ intentState, reason, force = false }) {\n        if (!intentState.streamReader) {\n            return;\n        }\n        if (intentState.streamReaderCancelTimeout) {\n            clearTimeout(intentState.streamReaderCancelTimeout);\n            intentState.streamReaderCancelTimeout = null;\n        }\n        if (!force) {\n            if (intentState.renderTasks.size > 0) {\n                return;\n            }\n            if (reason instanceof RenderingCancelledException) {\n                let delay = RENDERING_CANCELLED_TIMEOUT;\n                if (reason.extraDelay > 0 && reason.extraDelay < 1000) {\n                    delay += reason.extraDelay;\n                }\n                intentState.streamReaderCancelTimeout = setTimeout(()=>{\n                    intentState.streamReaderCancelTimeout = null;\n                    this._abortOperatorList({\n                        intentState,\n                        reason,\n                        force: true\n                    });\n                }, delay);\n                return;\n            }\n        }\n        intentState.streamReader.cancel(new AbortException(reason.message)).catch(()=>{});\n        intentState.streamReader = null;\n        if (this._transport.destroyed) {\n            return;\n        }\n        for (const [curCacheKey, curIntentState] of this._intentStates){\n            if (curIntentState === intentState) {\n                this._intentStates.delete(curCacheKey);\n                break;\n            }\n        }\n        this.cleanup();\n    }\n    get stats() {\n        return this._stats;\n    }\n}\nclass LoopbackPort {\n    #listeners;\n    #deferred;\n    postMessage(obj, transfer) {\n        const event = {\n            data: structuredClone(obj, transfer ? {\n                transfer\n            } : null)\n        };\n        this.#deferred.then(()=>{\n            for (const [listener] of this.#listeners){\n                listener.call(this, event);\n            }\n        });\n    }\n    addEventListener(name, listener, options = null) {\n        let rmAbort = null;\n        if (options?.signal instanceof AbortSignal) {\n            const { signal } = options;\n            if (signal.aborted) {\n                warn(\"LoopbackPort - cannot use an `aborted` signal.\");\n                return;\n            }\n            const onAbort = ()=>this.removeEventListener(name, listener);\n            rmAbort = ()=>signal.removeEventListener(\"abort\", onAbort);\n            signal.addEventListener(\"abort\", onAbort);\n        }\n        this.#listeners.set(listener, rmAbort);\n    }\n    removeEventListener(name, listener) {\n        const rmAbort = this.#listeners.get(listener);\n        rmAbort?.();\n        this.#listeners.delete(listener);\n    }\n    terminate() {\n        for (const [, rmAbort] of this.#listeners){\n            rmAbort?.();\n        }\n        this.#listeners.clear();\n    }\n    constructor(){\n        this.#listeners = new Map();\n        this.#deferred = Promise.resolve();\n    }\n}\nclass PDFWorker {\n    static #fakeWorkerId = 0;\n    static #isWorkerDisabled = false;\n    static #workerPorts;\n    static{\n        if (isNodeJS) {\n            this.#isWorkerDisabled = true;\n            GlobalWorkerOptions.workerSrc ||= \"./pdf.worker.mjs\";\n        }\n        this._isSameOrigin = (baseUrl, otherUrl)=>{\n            let base;\n            try {\n                base = new URL(baseUrl);\n                if (!base.origin || base.origin === \"null\") {\n                    return false;\n                }\n            } catch  {\n                return false;\n            }\n            const other = new URL(otherUrl, base);\n            return base.origin === other.origin;\n        };\n        this._createCDNWrapper = (url)=>{\n            const wrapper = `await import(\"${url}\");`;\n            return URL.createObjectURL(new Blob([\n                wrapper\n            ], {\n                type: \"text/javascript\"\n            }));\n        };\n    }\n    constructor({ name = null, port = null, verbosity = getVerbosityLevel() } = {}){\n        this.name = name;\n        this.destroyed = false;\n        this.verbosity = verbosity;\n        this._readyCapability = Promise.withResolvers();\n        this._port = null;\n        this._webWorker = null;\n        this._messageHandler = null;\n        if (port) {\n            if (PDFWorker.#workerPorts?.has(port)) {\n                throw new Error(\"Cannot use more than one PDFWorker per port.\");\n            }\n            (PDFWorker.#workerPorts ||= new WeakMap()).set(port, this);\n            this._initializeFromPort(port);\n            return;\n        }\n        this._initialize();\n    }\n    get promise() {\n        return this._readyCapability.promise;\n    }\n    #resolve() {\n        this._readyCapability.resolve();\n        this._messageHandler.send(\"configure\", {\n            verbosity: this.verbosity\n        });\n    }\n    get port() {\n        return this._port;\n    }\n    get messageHandler() {\n        return this._messageHandler;\n    }\n    _initializeFromPort(port) {\n        this._port = port;\n        this._messageHandler = new MessageHandler(\"main\", \"worker\", port);\n        this._messageHandler.on(\"ready\", function() {});\n        this.#resolve();\n    }\n    _initialize() {\n        if (PDFWorker.#isWorkerDisabled || PDFWorker.#mainThreadWorkerMessageHandler) {\n            this._setupFakeWorker();\n            return;\n        }\n        let { workerSrc } = PDFWorker;\n        try {\n            if (!PDFWorker._isSameOrigin(window.location.href, workerSrc)) {\n                workerSrc = PDFWorker._createCDNWrapper(new URL(workerSrc, window.location).href);\n            }\n            const worker = new Worker(workerSrc, {\n                type: \"module\"\n            });\n            const messageHandler = new MessageHandler(\"main\", \"worker\", worker);\n            const terminateEarly = ()=>{\n                ac.abort();\n                messageHandler.destroy();\n                worker.terminate();\n                if (this.destroyed) {\n                    this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n                } else {\n                    this._setupFakeWorker();\n                }\n            };\n            const ac = new AbortController();\n            worker.addEventListener(\"error\", ()=>{\n                if (!this._webWorker) {\n                    terminateEarly();\n                }\n            }, {\n                signal: ac.signal\n            });\n            messageHandler.on(\"test\", (data)=>{\n                ac.abort();\n                if (this.destroyed || !data) {\n                    terminateEarly();\n                    return;\n                }\n                this._messageHandler = messageHandler;\n                this._port = worker;\n                this._webWorker = worker;\n                this.#resolve();\n            });\n            messageHandler.on(\"ready\", (data)=>{\n                ac.abort();\n                if (this.destroyed) {\n                    terminateEarly();\n                    return;\n                }\n                try {\n                    sendTest();\n                } catch  {\n                    this._setupFakeWorker();\n                }\n            });\n            const sendTest = ()=>{\n                const testObj = new Uint8Array();\n                messageHandler.send(\"test\", testObj, [\n                    testObj.buffer\n                ]);\n            };\n            sendTest();\n            return;\n        } catch  {\n            info(\"The worker has been disabled.\");\n        }\n        this._setupFakeWorker();\n    }\n    _setupFakeWorker() {\n        if (!PDFWorker.#isWorkerDisabled) {\n            warn(\"Setting up fake worker.\");\n            PDFWorker.#isWorkerDisabled = true;\n        }\n        PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler)=>{\n            if (this.destroyed) {\n                this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n                return;\n            }\n            const port = new LoopbackPort();\n            this._port = port;\n            const id = `fake${PDFWorker.#fakeWorkerId++}`;\n            const workerHandler = new MessageHandler(id + \"_worker\", id, port);\n            WorkerMessageHandler.setup(workerHandler, port);\n            this._messageHandler = new MessageHandler(id, id + \"_worker\", port);\n            this.#resolve();\n        }).catch((reason)=>{\n            this._readyCapability.reject(new Error(`Setting up fake worker failed: \"${reason.message}\".`));\n        });\n    }\n    destroy() {\n        this.destroyed = true;\n        this._webWorker?.terminate();\n        this._webWorker = null;\n        PDFWorker.#workerPorts?.delete(this._port);\n        this._port = null;\n        this._messageHandler?.destroy();\n        this._messageHandler = null;\n    }\n    static fromPort(params) {\n        if (!params?.port) {\n            throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n        }\n        const cachedPort = this.#workerPorts?.get(params.port);\n        if (cachedPort) {\n            if (cachedPort._pendingDestroy) {\n                throw new Error(\"PDFWorker.fromPort - the worker is being destroyed.\\n\" + \"Please remember to await `PDFDocumentLoadingTask.destroy()`-calls.\");\n            }\n            return cachedPort;\n        }\n        return new PDFWorker(params);\n    }\n    static get workerSrc() {\n        if (GlobalWorkerOptions.workerSrc) {\n            return GlobalWorkerOptions.workerSrc;\n        }\n        throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n    }\n    static get #mainThreadWorkerMessageHandler() {\n        try {\n            return globalThis.pdfjsWorker?.WorkerMessageHandler || null;\n        } catch  {\n            return null;\n        }\n    }\n    static get _setupFakeWorkerGlobal() {\n        const loader = async ()=>{\n            if (this.#mainThreadWorkerMessageHandler) {\n                return this.#mainThreadWorkerMessageHandler;\n            }\n            const worker = await import(/*webpackIgnore: true*/ this.workerSrc);\n            return worker.WorkerMessageHandler;\n        };\n        return shadow(this, \"_setupFakeWorkerGlobal\", loader());\n    }\n}\nclass WorkerTransport {\n    #methodPromises;\n    #pageCache;\n    #pagePromises;\n    #pageRefCache;\n    #passwordCapability;\n    constructor(messageHandler, loadingTask, networkStream, params, factory){\n        this.#methodPromises = new Map();\n        this.#pageCache = new Map();\n        this.#pagePromises = new Map();\n        this.#pageRefCache = new Map();\n        this.#passwordCapability = null;\n        this.messageHandler = messageHandler;\n        this.loadingTask = loadingTask;\n        this.commonObjs = new PDFObjects();\n        this.fontLoader = new FontLoader({\n            ownerDocument: params.ownerDocument,\n            styleElement: params.styleElement\n        });\n        this.loadingParams = params.loadingParams;\n        this._params = params;\n        this.canvasFactory = factory.canvasFactory;\n        this.filterFactory = factory.filterFactory;\n        this.cMapReaderFactory = factory.cMapReaderFactory;\n        this.standardFontDataFactory = factory.standardFontDataFactory;\n        this.destroyed = false;\n        this.destroyCapability = null;\n        this._networkStream = networkStream;\n        this._fullReader = null;\n        this._lastProgress = null;\n        this.downloadInfoCapability = Promise.withResolvers();\n        this.setupMessageHandler();\n    }\n    #cacheSimpleMethod(name, data = null) {\n        const cachedPromise = this.#methodPromises.get(name);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n        const promise = this.messageHandler.sendWithPromise(name, data);\n        this.#methodPromises.set(name, promise);\n        return promise;\n    }\n    get annotationStorage() {\n        return shadow(this, \"annotationStorage\", new AnnotationStorage());\n    }\n    getRenderingIntent(intent, annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false, isOpList = false) {\n        let renderingIntent = RenderingIntentFlag.DISPLAY;\n        let annotationStorageSerializable = SerializableEmpty;\n        switch(intent){\n            case \"any\":\n                renderingIntent = RenderingIntentFlag.ANY;\n                break;\n            case \"display\":\n                break;\n            case \"print\":\n                renderingIntent = RenderingIntentFlag.PRINT;\n                break;\n            default:\n                warn(`getRenderingIntent - invalid intent: ${intent}`);\n        }\n        const annotationStorage = renderingIntent & RenderingIntentFlag.PRINT && printAnnotationStorage instanceof PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;\n        switch(annotationMode){\n            case AnnotationMode.DISABLE:\n                renderingIntent += RenderingIntentFlag.ANNOTATIONS_DISABLE;\n                break;\n            case AnnotationMode.ENABLE:\n                break;\n            case AnnotationMode.ENABLE_FORMS:\n                renderingIntent += RenderingIntentFlag.ANNOTATIONS_FORMS;\n                break;\n            case AnnotationMode.ENABLE_STORAGE:\n                renderingIntent += RenderingIntentFlag.ANNOTATIONS_STORAGE;\n                annotationStorageSerializable = annotationStorage.serializable;\n                break;\n            default:\n                warn(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);\n        }\n        if (isEditing) {\n            renderingIntent += RenderingIntentFlag.IS_EDITING;\n        }\n        if (isOpList) {\n            renderingIntent += RenderingIntentFlag.OPLIST;\n        }\n        const { ids: modifiedIds, hash: modifiedIdsHash } = annotationStorage.modifiedIds;\n        const cacheKeyBuf = [\n            renderingIntent,\n            annotationStorageSerializable.hash,\n            modifiedIdsHash\n        ];\n        return {\n            renderingIntent,\n            cacheKey: cacheKeyBuf.join(\"_\"),\n            annotationStorageSerializable,\n            modifiedIds\n        };\n    }\n    destroy() {\n        if (this.destroyCapability) {\n            return this.destroyCapability.promise;\n        }\n        this.destroyed = true;\n        this.destroyCapability = Promise.withResolvers();\n        this.#passwordCapability?.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n        const waitOn = [];\n        for (const page of this.#pageCache.values()){\n            waitOn.push(page._destroy());\n        }\n        this.#pageCache.clear();\n        this.#pagePromises.clear();\n        this.#pageRefCache.clear();\n        if (this.hasOwnProperty(\"annotationStorage\")) {\n            this.annotationStorage.resetModified();\n        }\n        const terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n        waitOn.push(terminated);\n        Promise.all(waitOn).then(()=>{\n            this.commonObjs.clear();\n            this.fontLoader.clear();\n            this.#methodPromises.clear();\n            this.filterFactory.destroy();\n            TextLayer.cleanup();\n            this._networkStream?.cancelAllRequests(new AbortException(\"Worker was terminated.\"));\n            this.messageHandler?.destroy();\n            this.messageHandler = null;\n            this.destroyCapability.resolve();\n        }, this.destroyCapability.reject);\n        return this.destroyCapability.promise;\n    }\n    setupMessageHandler() {\n        const { messageHandler, loadingTask } = this;\n        messageHandler.on(\"GetReader\", (data, sink)=>{\n            assert(this._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n            this._fullReader = this._networkStream.getFullReader();\n            this._fullReader.onProgress = (evt)=>{\n                this._lastProgress = {\n                    loaded: evt.loaded,\n                    total: evt.total\n                };\n            };\n            sink.onPull = ()=>{\n                this._fullReader.read().then(function({ value, done }) {\n                    if (done) {\n                        sink.close();\n                        return;\n                    }\n                    assert(value instanceof ArrayBuffer, \"GetReader - expected an ArrayBuffer.\");\n                    sink.enqueue(new Uint8Array(value), 1, [\n                        value\n                    ]);\n                }).catch((reason)=>{\n                    sink.error(reason);\n                });\n            };\n            sink.onCancel = (reason)=>{\n                this._fullReader.cancel(reason);\n                sink.ready.catch((readyReason)=>{\n                    if (this.destroyed) {\n                        return;\n                    }\n                    throw readyReason;\n                });\n            };\n        });\n        messageHandler.on(\"ReaderHeadersReady\", async (data)=>{\n            await this._fullReader.headersReady;\n            const { isStreamingSupported, isRangeSupported, contentLength } = this._fullReader;\n            if (!isStreamingSupported || !isRangeSupported) {\n                if (this._lastProgress) {\n                    loadingTask.onProgress?.(this._lastProgress);\n                }\n                this._fullReader.onProgress = (evt)=>{\n                    loadingTask.onProgress?.({\n                        loaded: evt.loaded,\n                        total: evt.total\n                    });\n                };\n            }\n            return {\n                isStreamingSupported,\n                isRangeSupported,\n                contentLength\n            };\n        });\n        messageHandler.on(\"GetRangeReader\", (data, sink)=>{\n            assert(this._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n            const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);\n            if (!rangeReader) {\n                sink.close();\n                return;\n            }\n            sink.onPull = ()=>{\n                rangeReader.read().then(function({ value, done }) {\n                    if (done) {\n                        sink.close();\n                        return;\n                    }\n                    assert(value instanceof ArrayBuffer, \"GetRangeReader - expected an ArrayBuffer.\");\n                    sink.enqueue(new Uint8Array(value), 1, [\n                        value\n                    ]);\n                }).catch((reason)=>{\n                    sink.error(reason);\n                });\n            };\n            sink.onCancel = (reason)=>{\n                rangeReader.cancel(reason);\n                sink.ready.catch((readyReason)=>{\n                    if (this.destroyed) {\n                        return;\n                    }\n                    throw readyReason;\n                });\n            };\n        });\n        messageHandler.on(\"GetDoc\", ({ pdfInfo })=>{\n            this._numPages = pdfInfo.numPages;\n            this._htmlForXfa = pdfInfo.htmlForXfa;\n            delete pdfInfo.htmlForXfa;\n            loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));\n        });\n        messageHandler.on(\"DocException\", (ex)=>{\n            loadingTask._capability.reject(wrapReason(ex));\n        });\n        messageHandler.on(\"PasswordRequest\", (ex)=>{\n            this.#passwordCapability = Promise.withResolvers();\n            try {\n                if (!loadingTask.onPassword) {\n                    throw wrapReason(ex);\n                }\n                const updatePassword = (password)=>{\n                    if (password instanceof Error) {\n                        this.#passwordCapability.reject(password);\n                    } else {\n                        this.#passwordCapability.resolve({\n                            password\n                        });\n                    }\n                };\n                loadingTask.onPassword(updatePassword, ex.code);\n            } catch (err) {\n                this.#passwordCapability.reject(err);\n            }\n            return this.#passwordCapability.promise;\n        });\n        messageHandler.on(\"DataLoaded\", (data)=>{\n            loadingTask.onProgress?.({\n                loaded: data.length,\n                total: data.length\n            });\n            this.downloadInfoCapability.resolve(data);\n        });\n        messageHandler.on(\"StartRenderPage\", (data)=>{\n            if (this.destroyed) {\n                return;\n            }\n            const page = this.#pageCache.get(data.pageIndex);\n            page._startRenderPage(data.transparency, data.cacheKey);\n        });\n        messageHandler.on(\"commonobj\", ([id, type, exportedData])=>{\n            if (this.destroyed) {\n                return null;\n            }\n            if (this.commonObjs.has(id)) {\n                return null;\n            }\n            switch(type){\n                case \"Font\":\n                    const { disableFontFace, fontExtraProperties, pdfBug } = this._params;\n                    if (\"error\" in exportedData) {\n                        const exportedError = exportedData.error;\n                        warn(`Error during font loading: ${exportedError}`);\n                        this.commonObjs.resolve(id, exportedError);\n                        break;\n                    }\n                    const inspectFont = pdfBug && globalThis.FontInspector?.enabled ? (font, url)=>globalThis.FontInspector.fontAdded(font, url) : null;\n                    const font = new FontFaceObject(exportedData, {\n                        disableFontFace,\n                        fontExtraProperties,\n                        inspectFont\n                    });\n                    this.fontLoader.bind(font).catch(()=>messageHandler.sendWithPromise(\"FontFallback\", {\n                            id\n                        })).finally(()=>{\n                        if (!fontExtraProperties && font.data) {\n                            font.data = null;\n                        }\n                        this.commonObjs.resolve(id, font);\n                    });\n                    break;\n                case \"CopyLocalImage\":\n                    const { imageRef } = exportedData;\n                    assert(imageRef, \"The imageRef must be defined.\");\n                    for (const pageProxy of this.#pageCache.values()){\n                        for (const [, data] of pageProxy.objs){\n                            if (data?.ref !== imageRef) {\n                                continue;\n                            }\n                            if (!data.dataLen) {\n                                return null;\n                            }\n                            this.commonObjs.resolve(id, structuredClone(data));\n                            return data.dataLen;\n                        }\n                    }\n                    break;\n                case \"FontPath\":\n                case \"Image\":\n                case \"Pattern\":\n                    this.commonObjs.resolve(id, exportedData);\n                    break;\n                default:\n                    throw new Error(`Got unknown common object type ${type}`);\n            }\n            return null;\n        });\n        messageHandler.on(\"obj\", ([id, pageIndex, type, imageData])=>{\n            if (this.destroyed) {\n                return;\n            }\n            const pageProxy = this.#pageCache.get(pageIndex);\n            if (pageProxy.objs.has(id)) {\n                return;\n            }\n            if (pageProxy._intentStates.size === 0) {\n                imageData?.bitmap?.close();\n                return;\n            }\n            switch(type){\n                case \"Image\":\n                    pageProxy.objs.resolve(id, imageData);\n                    if (imageData?.dataLen > MAX_IMAGE_SIZE_TO_CACHE) {\n                        pageProxy._maybeCleanupAfterRender = true;\n                    }\n                    break;\n                case \"Pattern\":\n                    pageProxy.objs.resolve(id, imageData);\n                    break;\n                default:\n                    throw new Error(`Got unknown object type ${type}`);\n            }\n        });\n        messageHandler.on(\"DocProgress\", (data)=>{\n            if (this.destroyed) {\n                return;\n            }\n            loadingTask.onProgress?.({\n                loaded: data.loaded,\n                total: data.total\n            });\n        });\n        messageHandler.on(\"FetchBuiltInCMap\", async (data)=>{\n            if (this.destroyed) {\n                throw new Error(\"Worker was destroyed.\");\n            }\n            if (!this.cMapReaderFactory) {\n                throw new Error(\"CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.\");\n            }\n            return this.cMapReaderFactory.fetch(data);\n        });\n        messageHandler.on(\"FetchStandardFontData\", async (data)=>{\n            if (this.destroyed) {\n                throw new Error(\"Worker was destroyed.\");\n            }\n            if (!this.standardFontDataFactory) {\n                throw new Error(\"StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.\");\n            }\n            return this.standardFontDataFactory.fetch(data);\n        });\n    }\n    getData() {\n        return this.messageHandler.sendWithPromise(\"GetData\", null);\n    }\n    saveDocument() {\n        if (this.annotationStorage.size <= 0) {\n            warn(\"saveDocument called while `annotationStorage` is empty, \" + \"please use the getData-method instead.\");\n        }\n        const { map, transfer } = this.annotationStorage.serializable;\n        return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n            isPureXfa: !!this._htmlForXfa,\n            numPages: this._numPages,\n            annotationStorage: map,\n            filename: this._fullReader?.filename ?? null\n        }, transfer).finally(()=>{\n            this.annotationStorage.resetModified();\n        });\n    }\n    getPage(pageNumber) {\n        if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n            return Promise.reject(new Error(\"Invalid page request.\"));\n        }\n        const pageIndex = pageNumber - 1, cachedPromise = this.#pagePromises.get(pageIndex);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n        const promise = this.messageHandler.sendWithPromise(\"GetPage\", {\n            pageIndex\n        }).then((pageInfo)=>{\n            if (this.destroyed) {\n                throw new Error(\"Transport destroyed\");\n            }\n            if (pageInfo.refStr) {\n                this.#pageRefCache.set(pageInfo.refStr, pageNumber);\n            }\n            const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);\n            this.#pageCache.set(pageIndex, page);\n            return page;\n        });\n        this.#pagePromises.set(pageIndex, promise);\n        return promise;\n    }\n    getPageIndex(ref) {\n        if (!isRefProxy(ref)) {\n            return Promise.reject(new Error(\"Invalid pageIndex request.\"));\n        }\n        return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n            num: ref.num,\n            gen: ref.gen\n        });\n    }\n    getAnnotations(pageIndex, intent) {\n        return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n            pageIndex,\n            intent\n        });\n    }\n    getFieldObjects() {\n        return this.#cacheSimpleMethod(\"GetFieldObjects\");\n    }\n    hasJSActions() {\n        return this.#cacheSimpleMethod(\"HasJSActions\");\n    }\n    getCalculationOrderIds() {\n        return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n    }\n    getDestinations() {\n        return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n    }\n    getDestination(id) {\n        if (typeof id !== \"string\") {\n            return Promise.reject(new Error(\"Invalid destination request.\"));\n        }\n        return this.messageHandler.sendWithPromise(\"GetDestination\", {\n            id\n        });\n    }\n    getPageLabels() {\n        return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n    }\n    getPageLayout() {\n        return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n    }\n    getPageMode() {\n        return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n    }\n    getViewerPreferences() {\n        return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n    }\n    getOpenAction() {\n        return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n    }\n    getAttachments() {\n        return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n    }\n    getDocJSActions() {\n        return this.#cacheSimpleMethod(\"GetDocJSActions\");\n    }\n    getPageJSActions(pageIndex) {\n        return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n            pageIndex\n        });\n    }\n    getStructTree(pageIndex) {\n        return this.messageHandler.sendWithPromise(\"GetStructTree\", {\n            pageIndex\n        });\n    }\n    getOutline() {\n        return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n    }\n    getOptionalContentConfig(renderingIntent) {\n        return this.#cacheSimpleMethod(\"GetOptionalContentConfig\").then((data)=>new OptionalContentConfig(data, renderingIntent));\n    }\n    getPermissions() {\n        return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n    }\n    getMetadata() {\n        const name = \"GetMetadata\", cachedPromise = this.#methodPromises.get(name);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n        const promise = this.messageHandler.sendWithPromise(name, null).then((results)=>({\n                info: results[0],\n                metadata: results[1] ? new Metadata(results[1]) : null,\n                contentDispositionFilename: this._fullReader?.filename ?? null,\n                contentLength: this._fullReader?.contentLength ?? null\n            }));\n        this.#methodPromises.set(name, promise);\n        return promise;\n    }\n    getMarkInfo() {\n        return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n    }\n    async startCleanup(keepLoadedFonts = false) {\n        if (this.destroyed) {\n            return;\n        }\n        await this.messageHandler.sendWithPromise(\"Cleanup\", null);\n        for (const page of this.#pageCache.values()){\n            const cleanupSuccessful = page.cleanup();\n            if (!cleanupSuccessful) {\n                throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);\n            }\n        }\n        this.commonObjs.clear();\n        if (!keepLoadedFonts) {\n            this.fontLoader.clear();\n        }\n        this.#methodPromises.clear();\n        this.filterFactory.destroy(true);\n        TextLayer.cleanup();\n    }\n    cachedPageNumber(ref) {\n        if (!isRefProxy(ref)) {\n            return null;\n        }\n        const refStr = ref.gen === 0 ? `${ref.num}R` : `${ref.num}R${ref.gen}`;\n        return this.#pageRefCache.get(refStr) ?? null;\n    }\n}\nconst INITIAL_DATA = Symbol(\"INITIAL_DATA\");\nclass PDFObjects {\n    #objs;\n    #ensureObj(objId) {\n        return this.#objs[objId] ||= {\n            ...Promise.withResolvers(),\n            data: INITIAL_DATA\n        };\n    }\n    get(objId, callback = null) {\n        if (callback) {\n            const obj = this.#ensureObj(objId);\n            obj.promise.then(()=>callback(obj.data));\n            return null;\n        }\n        const obj = this.#objs[objId];\n        if (!obj || obj.data === INITIAL_DATA) {\n            throw new Error(`Requesting object that isn't resolved yet ${objId}.`);\n        }\n        return obj.data;\n    }\n    has(objId) {\n        const obj = this.#objs[objId];\n        return !!obj && obj.data !== INITIAL_DATA;\n    }\n    delete(objId) {\n        const obj = this.#objs[objId];\n        if (!obj || obj.data === INITIAL_DATA) {\n            return false;\n        }\n        delete this.#objs[objId];\n        return true;\n    }\n    resolve(objId, data = null) {\n        const obj = this.#ensureObj(objId);\n        obj.data = data;\n        obj.resolve();\n    }\n    clear() {\n        for(const objId in this.#objs){\n            const { data } = this.#objs[objId];\n            data?.bitmap?.close();\n        }\n        this.#objs = Object.create(null);\n    }\n    *[Symbol.iterator]() {\n        for(const objId in this.#objs){\n            const { data } = this.#objs[objId];\n            if (data === INITIAL_DATA) {\n                continue;\n            }\n            yield [\n                objId,\n                data\n            ];\n        }\n    }\n    constructor(){\n        this.#objs = Object.create(null);\n    }\n}\nclass RenderTask {\n    #internalRenderTask;\n    constructor(internalRenderTask){\n        this.#internalRenderTask = null;\n        this.#internalRenderTask = internalRenderTask;\n        this.onContinue = null;\n    }\n    get promise() {\n        return this.#internalRenderTask.capability.promise;\n    }\n    cancel(extraDelay = 0) {\n        this.#internalRenderTask.cancel(null, extraDelay);\n    }\n    get separateAnnots() {\n        const { separateAnnots } = this.#internalRenderTask.operatorList;\n        if (!separateAnnots) {\n            return false;\n        }\n        const { annotationCanvasMap } = this.#internalRenderTask;\n        return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;\n    }\n}\nclass InternalRenderTask {\n    #rAF;\n    static #canvasInUse = new WeakSet();\n    constructor({ callback, params, objs, commonObjs, annotationCanvasMap, operatorList, pageIndex, canvasFactory, filterFactory, useRequestAnimationFrame = false, pdfBug = false, pageColors = null }){\n        this.#rAF = null;\n        this.callback = callback;\n        this.params = params;\n        this.objs = objs;\n        this.commonObjs = commonObjs;\n        this.annotationCanvasMap = annotationCanvasMap;\n        this.operatorListIdx = null;\n        this.operatorList = operatorList;\n        this._pageIndex = pageIndex;\n        this.canvasFactory = canvasFactory;\n        this.filterFactory = filterFactory;\n        this._pdfBug = pdfBug;\n        this.pageColors = pageColors;\n        this.running = false;\n        this.graphicsReadyCallback = null;\n        this.graphicsReady = false;\n        this._useRequestAnimationFrame = useRequestAnimationFrame === true && \"undefined\" !== \"undefined\";\n        this.cancelled = false;\n        this.capability = Promise.withResolvers();\n        this.task = new RenderTask(this);\n        this._cancelBound = this.cancel.bind(this);\n        this._continueBound = this._continue.bind(this);\n        this._scheduleNextBound = this._scheduleNext.bind(this);\n        this._nextBound = this._next.bind(this);\n        this._canvas = params.canvasContext.canvas;\n    }\n    get completed() {\n        return this.capability.promise.catch(function() {});\n    }\n    initializeGraphics({ transparency = false, optionalContentConfig }) {\n        if (this.cancelled) {\n            return;\n        }\n        if (this._canvas) {\n            if (InternalRenderTask.#canvasInUse.has(this._canvas)) {\n                throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\n            }\n            InternalRenderTask.#canvasInUse.add(this._canvas);\n        }\n        if (this._pdfBug && globalThis.StepperManager?.enabled) {\n            this.stepper = globalThis.StepperManager.create(this._pageIndex);\n            this.stepper.init(this.operatorList);\n            this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n        }\n        const { canvasContext, viewport, transform, background } = this.params;\n        this.gfx = new CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n            optionalContentConfig\n        }, this.annotationCanvasMap, this.pageColors);\n        this.gfx.beginDrawing({\n            transform,\n            viewport,\n            transparency,\n            background\n        });\n        this.operatorListIdx = 0;\n        this.graphicsReady = true;\n        this.graphicsReadyCallback?.();\n    }\n    cancel(error = null, extraDelay = 0) {\n        this.running = false;\n        this.cancelled = true;\n        this.gfx?.endDrawing();\n        if (this.#rAF) {\n            window.cancelAnimationFrame(this.#rAF);\n            this.#rAF = null;\n        }\n        InternalRenderTask.#canvasInUse.delete(this._canvas);\n        this.callback(error || new RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay));\n    }\n    operatorListChanged() {\n        if (!this.graphicsReady) {\n            this.graphicsReadyCallback ||= this._continueBound;\n            return;\n        }\n        this.stepper?.updateOperatorList(this.operatorList);\n        if (this.running) {\n            return;\n        }\n        this._continue();\n    }\n    _continue() {\n        this.running = true;\n        if (this.cancelled) {\n            return;\n        }\n        if (this.task.onContinue) {\n            this.task.onContinue(this._scheduleNextBound);\n        } else {\n            this._scheduleNext();\n        }\n    }\n    _scheduleNext() {\n        if (this._useRequestAnimationFrame) {\n            this.#rAF = window.requestAnimationFrame(()=>{\n                this.#rAF = null;\n                this._nextBound().catch(this._cancelBound);\n            });\n        } else {\n            Promise.resolve().then(this._nextBound).catch(this._cancelBound);\n        }\n    }\n    async _next() {\n        if (this.cancelled) {\n            return;\n        }\n        this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);\n        if (this.operatorListIdx === this.operatorList.argsArray.length) {\n            this.running = false;\n            if (this.operatorList.lastChunk) {\n                this.gfx.endDrawing();\n                InternalRenderTask.#canvasInUse.delete(this._canvas);\n                this.callback();\n            }\n        }\n    }\n}\nconst version = \"4.10.38\";\nconst build = \"f9bea397f\";\n; // ./src/shared/scripting_utils.js\nfunction makeColorComp(n) {\n    return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\n}\nfunction scaleAndClamp(x) {\n    return Math.max(0, Math.min(255, 255 * x));\n}\nclass ColorConverters {\n    static CMYK_G([c, y, m, k]) {\n        return [\n            \"G\",\n            1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)\n        ];\n    }\n    static G_CMYK([g]) {\n        return [\n            \"CMYK\",\n            0,\n            0,\n            0,\n            1 - g\n        ];\n    }\n    static G_RGB([g]) {\n        return [\n            \"RGB\",\n            g,\n            g,\n            g\n        ];\n    }\n    static G_rgb([g]) {\n        g = scaleAndClamp(g);\n        return [\n            g,\n            g,\n            g\n        ];\n    }\n    static G_HTML([g]) {\n        const G = makeColorComp(g);\n        return `#${G}${G}${G}`;\n    }\n    static RGB_G([r, g, b]) {\n        return [\n            \"G\",\n            0.3 * r + 0.59 * g + 0.11 * b\n        ];\n    }\n    static RGB_rgb(color) {\n        return color.map(scaleAndClamp);\n    }\n    static RGB_HTML(color) {\n        return `#${color.map(makeColorComp).join(\"\")}`;\n    }\n    static T_HTML() {\n        return \"#00000000\";\n    }\n    static T_rgb() {\n        return [\n            null\n        ];\n    }\n    static CMYK_RGB([c, y, m, k]) {\n        return [\n            \"RGB\",\n            1 - Math.min(1, c + k),\n            1 - Math.min(1, m + k),\n            1 - Math.min(1, y + k)\n        ];\n    }\n    static CMYK_rgb([c, y, m, k]) {\n        return [\n            scaleAndClamp(1 - Math.min(1, c + k)),\n            scaleAndClamp(1 - Math.min(1, m + k)),\n            scaleAndClamp(1 - Math.min(1, y + k))\n        ];\n    }\n    static CMYK_HTML(components) {\n        const rgb = this.CMYK_RGB(components).slice(1);\n        return this.RGB_HTML(rgb);\n    }\n    static RGB_CMYK([r, g, b]) {\n        const c = 1 - r;\n        const m = 1 - g;\n        const y = 1 - b;\n        const k = Math.min(c, m, y);\n        return [\n            \"CMYK\",\n            c,\n            m,\n            y,\n            k\n        ];\n    }\n}\n; // ./src/display/svg_factory.js\nclass BaseSVGFactory {\n    create(width, height, skipDimensions = false) {\n        if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid SVG dimensions\");\n        }\n        const svg = this._createSVG(\"svg:svg\");\n        svg.setAttribute(\"version\", \"1.1\");\n        if (!skipDimensions) {\n            svg.setAttribute(\"width\", `${width}px`);\n            svg.setAttribute(\"height\", `${height}px`);\n        }\n        svg.setAttribute(\"preserveAspectRatio\", \"none\");\n        svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n        return svg;\n    }\n    createElement(type) {\n        if (typeof type !== \"string\") {\n            throw new Error(\"Invalid SVG element type\");\n        }\n        return this._createSVG(type);\n    }\n    _createSVG(type) {\n        unreachable(\"Abstract method `_createSVG` called.\");\n    }\n}\nclass DOMSVGFactory extends BaseSVGFactory {\n    _createSVG(type) {\n        return document.createElementNS(SVG_NS, type);\n    }\n}\n; // ./src/display/xfa_layer.js\nclass XfaLayer {\n    static setupStorage(html, id, element, storage, intent) {\n        const storedData = storage.getValue(id, {\n            value: null\n        });\n        switch(element.name){\n            case \"textarea\":\n                if (storedData.value !== null) {\n                    html.textContent = storedData.value;\n                }\n                if (intent === \"print\") {\n                    break;\n                }\n                html.addEventListener(\"input\", (event)=>{\n                    storage.setValue(id, {\n                        value: event.target.value\n                    });\n                });\n                break;\n            case \"input\":\n                if (element.attributes.type === \"radio\" || element.attributes.type === \"checkbox\") {\n                    if (storedData.value === element.attributes.xfaOn) {\n                        html.setAttribute(\"checked\", true);\n                    } else if (storedData.value === element.attributes.xfaOff) {\n                        html.removeAttribute(\"checked\");\n                    }\n                    if (intent === \"print\") {\n                        break;\n                    }\n                    html.addEventListener(\"change\", (event)=>{\n                        storage.setValue(id, {\n                            value: event.target.checked ? event.target.getAttribute(\"xfaOn\") : event.target.getAttribute(\"xfaOff\")\n                        });\n                    });\n                } else {\n                    if (storedData.value !== null) {\n                        html.setAttribute(\"value\", storedData.value);\n                    }\n                    if (intent === \"print\") {\n                        break;\n                    }\n                    html.addEventListener(\"input\", (event)=>{\n                        storage.setValue(id, {\n                            value: event.target.value\n                        });\n                    });\n                }\n                break;\n            case \"select\":\n                if (storedData.value !== null) {\n                    html.setAttribute(\"value\", storedData.value);\n                    for (const option of element.children){\n                        if (option.attributes.value === storedData.value) {\n                            option.attributes.selected = true;\n                        } else if (option.attributes.hasOwnProperty(\"selected\")) {\n                            delete option.attributes.selected;\n                        }\n                    }\n                }\n                html.addEventListener(\"input\", (event)=>{\n                    const options = event.target.options;\n                    const value = options.selectedIndex === -1 ? \"\" : options[options.selectedIndex].value;\n                    storage.setValue(id, {\n                        value\n                    });\n                });\n                break;\n        }\n    }\n    static setAttributes({ html, element, storage = null, intent, linkService }) {\n        const { attributes } = element;\n        const isHTMLAnchorElement = html instanceof HTMLAnchorElement;\n        if (attributes.type === \"radio\") {\n            attributes.name = `${attributes.name}-${intent}`;\n        }\n        for (const [key, value] of Object.entries(attributes)){\n            if (value === null || value === undefined) {\n                continue;\n            }\n            switch(key){\n                case \"class\":\n                    if (value.length) {\n                        html.setAttribute(key, value.join(\" \"));\n                    }\n                    break;\n                case \"dataId\":\n                    break;\n                case \"id\":\n                    html.setAttribute(\"data-element-id\", value);\n                    break;\n                case \"style\":\n                    Object.assign(html.style, value);\n                    break;\n                case \"textContent\":\n                    html.textContent = value;\n                    break;\n                default:\n                    if (!isHTMLAnchorElement || key !== \"href\" && key !== \"newWindow\") {\n                        html.setAttribute(key, value);\n                    }\n            }\n        }\n        if (isHTMLAnchorElement) {\n            linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);\n        }\n        if (storage && attributes.dataId) {\n            this.setupStorage(html, attributes.dataId, element, storage);\n        }\n    }\n    static render(parameters) {\n        const storage = parameters.annotationStorage;\n        const linkService = parameters.linkService;\n        const root = parameters.xfaHtml;\n        const intent = parameters.intent || \"display\";\n        const rootHtml = document.createElement(root.name);\n        if (root.attributes) {\n            this.setAttributes({\n                html: rootHtml,\n                element: root,\n                intent,\n                linkService\n            });\n        }\n        const isNotForRichText = intent !== \"richText\";\n        const rootDiv = parameters.div;\n        rootDiv.append(rootHtml);\n        if (parameters.viewport) {\n            const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n            rootDiv.style.transform = transform;\n        }\n        if (isNotForRichText) {\n            rootDiv.setAttribute(\"class\", \"xfaLayer xfaFont\");\n        }\n        const textDivs = [];\n        if (root.children.length === 0) {\n            if (root.value) {\n                const node = document.createTextNode(root.value);\n                rootHtml.append(node);\n                if (isNotForRichText && XfaText.shouldBuildText(root.name)) {\n                    textDivs.push(node);\n                }\n            }\n            return {\n                textDivs\n            };\n        }\n        const stack = [\n            [\n                root,\n                -1,\n                rootHtml\n            ]\n        ];\n        while(stack.length > 0){\n            const [parent, i, html] = stack.at(-1);\n            if (i + 1 === parent.children.length) {\n                stack.pop();\n                continue;\n            }\n            const child = parent.children[++stack.at(-1)[1]];\n            if (child === null) {\n                continue;\n            }\n            const { name } = child;\n            if (name === \"#text\") {\n                const node = document.createTextNode(child.value);\n                textDivs.push(node);\n                html.append(node);\n                continue;\n            }\n            const childHtml = child?.attributes?.xmlns ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);\n            html.append(childHtml);\n            if (child.attributes) {\n                this.setAttributes({\n                    html: childHtml,\n                    element: child,\n                    storage,\n                    intent,\n                    linkService\n                });\n            }\n            if (child.children?.length > 0) {\n                stack.push([\n                    child,\n                    -1,\n                    childHtml\n                ]);\n            } else if (child.value) {\n                const node = document.createTextNode(child.value);\n                if (isNotForRichText && XfaText.shouldBuildText(name)) {\n                    textDivs.push(node);\n                }\n                childHtml.append(node);\n            }\n        }\n        for (const el of rootDiv.querySelectorAll(\".xfaNonInteractive input, .xfaNonInteractive textarea\")){\n            el.setAttribute(\"readOnly\", true);\n        }\n        return {\n            textDivs\n        };\n    }\n    static update(parameters) {\n        const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n        parameters.div.style.transform = transform;\n        parameters.div.hidden = false;\n    }\n}\n; // ./src/display/annotation_layer.js\nconst DEFAULT_TAB_INDEX = 1000;\nconst annotation_layer_DEFAULT_FONT_SIZE = 9;\nconst GetElementsByNameSet = new WeakSet();\nfunction getRectDims(rect) {\n    return {\n        width: rect[2] - rect[0],\n        height: rect[3] - rect[1]\n    };\n}\nclass AnnotationElementFactory {\n    static create(parameters) {\n        const subtype = parameters.data.annotationType;\n        switch(subtype){\n            case AnnotationType.LINK:\n                return new LinkAnnotationElement(parameters);\n            case AnnotationType.TEXT:\n                return new TextAnnotationElement(parameters);\n            case AnnotationType.WIDGET:\n                const fieldType = parameters.data.fieldType;\n                switch(fieldType){\n                    case \"Tx\":\n                        return new TextWidgetAnnotationElement(parameters);\n                    case \"Btn\":\n                        if (parameters.data.radioButton) {\n                            return new RadioButtonWidgetAnnotationElement(parameters);\n                        } else if (parameters.data.checkBox) {\n                            return new CheckboxWidgetAnnotationElement(parameters);\n                        }\n                        return new PushButtonWidgetAnnotationElement(parameters);\n                    case \"Ch\":\n                        return new ChoiceWidgetAnnotationElement(parameters);\n                    case \"Sig\":\n                        return new SignatureWidgetAnnotationElement(parameters);\n                }\n                return new WidgetAnnotationElement(parameters);\n            case AnnotationType.POPUP:\n                return new PopupAnnotationElement(parameters);\n            case AnnotationType.FREETEXT:\n                return new FreeTextAnnotationElement(parameters);\n            case AnnotationType.LINE:\n                return new LineAnnotationElement(parameters);\n            case AnnotationType.SQUARE:\n                return new SquareAnnotationElement(parameters);\n            case AnnotationType.CIRCLE:\n                return new CircleAnnotationElement(parameters);\n            case AnnotationType.POLYLINE:\n                return new PolylineAnnotationElement(parameters);\n            case AnnotationType.CARET:\n                return new CaretAnnotationElement(parameters);\n            case AnnotationType.INK:\n                return new InkAnnotationElement(parameters);\n            case AnnotationType.POLYGON:\n                return new PolygonAnnotationElement(parameters);\n            case AnnotationType.HIGHLIGHT:\n                return new HighlightAnnotationElement(parameters);\n            case AnnotationType.UNDERLINE:\n                return new UnderlineAnnotationElement(parameters);\n            case AnnotationType.SQUIGGLY:\n                return new SquigglyAnnotationElement(parameters);\n            case AnnotationType.STRIKEOUT:\n                return new StrikeOutAnnotationElement(parameters);\n            case AnnotationType.STAMP:\n                return new StampAnnotationElement(parameters);\n            case AnnotationType.FILEATTACHMENT:\n                return new FileAttachmentAnnotationElement(parameters);\n            default:\n                return new AnnotationElement(parameters);\n        }\n    }\n}\nclass AnnotationElement {\n    #updates;\n    #hasBorder;\n    #popupElement;\n    constructor(parameters, { isRenderable = false, ignoreBorder = false, createQuadrilaterals = false } = {}){\n        this.#updates = null;\n        this.#hasBorder = false;\n        this.#popupElement = null;\n        this.isRenderable = isRenderable;\n        this.data = parameters.data;\n        this.layer = parameters.layer;\n        this.linkService = parameters.linkService;\n        this.downloadManager = parameters.downloadManager;\n        this.imageResourcesPath = parameters.imageResourcesPath;\n        this.renderForms = parameters.renderForms;\n        this.svgFactory = parameters.svgFactory;\n        this.annotationStorage = parameters.annotationStorage;\n        this.enableScripting = parameters.enableScripting;\n        this.hasJSActions = parameters.hasJSActions;\n        this._fieldObjects = parameters.fieldObjects;\n        this.parent = parameters.parent;\n        if (isRenderable) {\n            this.container = this._createContainer(ignoreBorder);\n        }\n        if (createQuadrilaterals) {\n            this._createQuadrilaterals();\n        }\n    }\n    static _hasPopupData({ titleObj, contentsObj, richText }) {\n        return !!(titleObj?.str || contentsObj?.str || richText?.str);\n    }\n    get _isEditable() {\n        return this.data.isEditable;\n    }\n    get hasPopupData() {\n        return AnnotationElement._hasPopupData(this.data);\n    }\n    updateEdited(params) {\n        if (!this.container) {\n            return;\n        }\n        this.#updates ||= {\n            rect: this.data.rect.slice(0)\n        };\n        const { rect } = params;\n        if (rect) {\n            this.#setRectEdited(rect);\n        }\n        this.#popupElement?.popup.updateEdited(params);\n    }\n    resetEdited() {\n        if (!this.#updates) {\n            return;\n        }\n        this.#setRectEdited(this.#updates.rect);\n        this.#popupElement?.popup.resetEdited();\n        this.#updates = null;\n    }\n    #setRectEdited(rect) {\n        const { container: { style }, data: { rect: currentRect, rotation }, parent: { viewport: { rawDims: { pageWidth, pageHeight, pageX, pageY } } } } = this;\n        currentRect?.splice(0, 4, ...rect);\n        const { width, height } = getRectDims(rect);\n        style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n        style.top = `${100 * (pageHeight - rect[3] + pageY) / pageHeight}%`;\n        if (rotation === 0) {\n            style.width = `${100 * width / pageWidth}%`;\n            style.height = `${100 * height / pageHeight}%`;\n        } else {\n            this.setRotation(rotation);\n        }\n    }\n    _createContainer(ignoreBorder) {\n        const { data, parent: { page, viewport } } = this;\n        const container = document.createElement(\"section\");\n        container.setAttribute(\"data-annotation-id\", data.id);\n        if (!(this instanceof WidgetAnnotationElement)) {\n            container.tabIndex = DEFAULT_TAB_INDEX;\n        }\n        const { style } = container;\n        style.zIndex = this.parent.zIndex++;\n        if (data.alternativeText) {\n            container.title = data.alternativeText;\n        }\n        if (data.noRotate) {\n            container.classList.add(\"norotate\");\n        }\n        if (!data.rect || this instanceof PopupAnnotationElement) {\n            const { rotation } = data;\n            if (!data.hasOwnCanvas && rotation !== 0) {\n                this.setRotation(rotation, container);\n            }\n            return container;\n        }\n        const { width, height } = getRectDims(data.rect);\n        if (!ignoreBorder && data.borderStyle.width > 0) {\n            style.borderWidth = `${data.borderStyle.width}px`;\n            const horizontalRadius = data.borderStyle.horizontalCornerRadius;\n            const verticalRadius = data.borderStyle.verticalCornerRadius;\n            if (horizontalRadius > 0 || verticalRadius > 0) {\n                const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;\n                style.borderRadius = radius;\n            } else if (this instanceof RadioButtonWidgetAnnotationElement) {\n                const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;\n                style.borderRadius = radius;\n            }\n            switch(data.borderStyle.style){\n                case AnnotationBorderStyleType.SOLID:\n                    style.borderStyle = \"solid\";\n                    break;\n                case AnnotationBorderStyleType.DASHED:\n                    style.borderStyle = \"dashed\";\n                    break;\n                case AnnotationBorderStyleType.BEVELED:\n                    warn(\"Unimplemented border style: beveled\");\n                    break;\n                case AnnotationBorderStyleType.INSET:\n                    warn(\"Unimplemented border style: inset\");\n                    break;\n                case AnnotationBorderStyleType.UNDERLINE:\n                    style.borderBottomStyle = \"solid\";\n                    break;\n                default:\n                    break;\n            }\n            const borderColor = data.borderColor || null;\n            if (borderColor) {\n                this.#hasBorder = true;\n                style.borderColor = Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);\n            } else {\n                style.borderWidth = 0;\n            }\n        }\n        const rect = Util.normalizeRect([\n            data.rect[0],\n            page.view[3] - data.rect[1] + page.view[1],\n            data.rect[2],\n            page.view[3] - data.rect[3] + page.view[1]\n        ]);\n        const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;\n        style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n        style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;\n        const { rotation } = data;\n        if (data.hasOwnCanvas || rotation === 0) {\n            style.width = `${100 * width / pageWidth}%`;\n            style.height = `${100 * height / pageHeight}%`;\n        } else {\n            this.setRotation(rotation, container);\n        }\n        return container;\n    }\n    setRotation(angle, container = this.container) {\n        if (!this.data.rect) {\n            return;\n        }\n        const { pageWidth, pageHeight } = this.parent.viewport.rawDims;\n        const { width, height } = getRectDims(this.data.rect);\n        let elementWidth, elementHeight;\n        if (angle % 180 === 0) {\n            elementWidth = 100 * width / pageWidth;\n            elementHeight = 100 * height / pageHeight;\n        } else {\n            elementWidth = 100 * height / pageWidth;\n            elementHeight = 100 * width / pageHeight;\n        }\n        container.style.width = `${elementWidth}%`;\n        container.style.height = `${elementHeight}%`;\n        container.setAttribute(\"data-main-rotation\", (360 - angle) % 360);\n    }\n    get _commonActions() {\n        const setColor = (jsName, styleName, event)=>{\n            const color = event.detail[jsName];\n            const colorType = color[0];\n            const colorArray = color.slice(1);\n            event.target.style[styleName] = ColorConverters[`${colorType}_HTML`](colorArray);\n            this.annotationStorage.setValue(this.data.id, {\n                [styleName]: ColorConverters[`${colorType}_rgb`](colorArray)\n            });\n        };\n        return shadow(this, \"_commonActions\", {\n            display: (event)=>{\n                const { display } = event.detail;\n                const hidden = display % 2 === 1;\n                this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n                this.annotationStorage.setValue(this.data.id, {\n                    noView: hidden,\n                    noPrint: display === 1 || display === 2\n                });\n            },\n            print: (event)=>{\n                this.annotationStorage.setValue(this.data.id, {\n                    noPrint: !event.detail.print\n                });\n            },\n            hidden: (event)=>{\n                const { hidden } = event.detail;\n                this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n                this.annotationStorage.setValue(this.data.id, {\n                    noPrint: hidden,\n                    noView: hidden\n                });\n            },\n            focus: (event)=>{\n                setTimeout(()=>event.target.focus({\n                        preventScroll: false\n                    }), 0);\n            },\n            userName: (event)=>{\n                event.target.title = event.detail.userName;\n            },\n            readonly: (event)=>{\n                event.target.disabled = event.detail.readonly;\n            },\n            required: (event)=>{\n                this._setRequired(event.target, event.detail.required);\n            },\n            bgColor: (event)=>{\n                setColor(\"bgColor\", \"backgroundColor\", event);\n            },\n            fillColor: (event)=>{\n                setColor(\"fillColor\", \"backgroundColor\", event);\n            },\n            fgColor: (event)=>{\n                setColor(\"fgColor\", \"color\", event);\n            },\n            textColor: (event)=>{\n                setColor(\"textColor\", \"color\", event);\n            },\n            borderColor: (event)=>{\n                setColor(\"borderColor\", \"borderColor\", event);\n            },\n            strokeColor: (event)=>{\n                setColor(\"strokeColor\", \"borderColor\", event);\n            },\n            rotation: (event)=>{\n                const angle = event.detail.rotation;\n                this.setRotation(angle);\n                this.annotationStorage.setValue(this.data.id, {\n                    rotation: angle\n                });\n            }\n        });\n    }\n    _dispatchEventFromSandbox(actions, jsEvent) {\n        const commonActions = this._commonActions;\n        for (const name of Object.keys(jsEvent.detail)){\n            const action = actions[name] || commonActions[name];\n            action?.(jsEvent);\n        }\n    }\n    _setDefaultPropertiesFromJS(element) {\n        if (!this.enableScripting) {\n            return;\n        }\n        const storedData = this.annotationStorage.getRawValue(this.data.id);\n        if (!storedData) {\n            return;\n        }\n        const commonActions = this._commonActions;\n        for (const [actionName, detail] of Object.entries(storedData)){\n            const action = commonActions[actionName];\n            if (action) {\n                const eventProxy = {\n                    detail: {\n                        [actionName]: detail\n                    },\n                    target: element\n                };\n                action(eventProxy);\n                delete storedData[actionName];\n            }\n        }\n    }\n    _createQuadrilaterals() {\n        if (!this.container) {\n            return;\n        }\n        const { quadPoints } = this.data;\n        if (!quadPoints) {\n            return;\n        }\n        const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect.map((x)=>Math.fround(x));\n        if (quadPoints.length === 8) {\n            const [trX, trY, blX, blY] = quadPoints.subarray(2, 6);\n            if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {\n                return;\n            }\n        }\n        const { style } = this.container;\n        let svgBuffer;\n        if (this.#hasBorder) {\n            const { borderColor, borderWidth } = style;\n            style.borderWidth = 0;\n            svgBuffer = [\n                \"url('data:image/svg+xml;utf8,\",\n                `<svg xmlns=\"http://www.w3.org/2000/svg\"`,\n                ` preserveAspectRatio=\"none\" viewBox=\"0 0 1 1\">`,\n                `<g fill=\"transparent\" stroke=\"${borderColor}\" stroke-width=\"${borderWidth}\">`\n            ];\n            this.container.classList.add(\"hasBorder\");\n        }\n        const width = rectTrX - rectBlX;\n        const height = rectTrY - rectBlY;\n        const { svgFactory } = this;\n        const svg = svgFactory.createElement(\"svg\");\n        svg.classList.add(\"quadrilateralsContainer\");\n        svg.setAttribute(\"width\", 0);\n        svg.setAttribute(\"height\", 0);\n        const defs = svgFactory.createElement(\"defs\");\n        svg.append(defs);\n        const clipPath = svgFactory.createElement(\"clipPath\");\n        const id = `clippath_${this.data.id}`;\n        clipPath.setAttribute(\"id\", id);\n        clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n        defs.append(clipPath);\n        for(let i = 2, ii = quadPoints.length; i < ii; i += 8){\n            const trX = quadPoints[i];\n            const trY = quadPoints[i + 1];\n            const blX = quadPoints[i + 2];\n            const blY = quadPoints[i + 3];\n            const rect = svgFactory.createElement(\"rect\");\n            const x = (blX - rectBlX) / width;\n            const y = (rectTrY - trY) / height;\n            const rectWidth = (trX - blX) / width;\n            const rectHeight = (trY - blY) / height;\n            rect.setAttribute(\"x\", x);\n            rect.setAttribute(\"y\", y);\n            rect.setAttribute(\"width\", rectWidth);\n            rect.setAttribute(\"height\", rectHeight);\n            clipPath.append(rect);\n            svgBuffer?.push(`<rect vector-effect=\"non-scaling-stroke\" x=\"${x}\" y=\"${y}\" width=\"${rectWidth}\" height=\"${rectHeight}\"/>`);\n        }\n        if (this.#hasBorder) {\n            svgBuffer.push(`</g></svg>')`);\n            style.backgroundImage = svgBuffer.join(\"\");\n        }\n        this.container.append(svg);\n        this.container.style.clipPath = `url(#${id})`;\n    }\n    _createPopup() {\n        const { data } = this;\n        const popup = this.#popupElement = new PopupAnnotationElement({\n            data: {\n                color: data.color,\n                titleObj: data.titleObj,\n                modificationDate: data.modificationDate,\n                contentsObj: data.contentsObj,\n                richText: data.richText,\n                parentRect: data.rect,\n                borderStyle: 0,\n                id: `popup_${data.id}`,\n                rotation: data.rotation\n            },\n            parent: this.parent,\n            elements: [\n                this\n            ]\n        });\n        this.parent.div.append(popup.render());\n    }\n    render() {\n        unreachable(\"Abstract method `AnnotationElement.render` called\");\n    }\n    _getElementsByName(name, skipId = null) {\n        const fields = [];\n        if (this._fieldObjects) {\n            const fieldObj = this._fieldObjects[name];\n            if (fieldObj) {\n                for (const { page, id, exportValues } of fieldObj){\n                    if (page === -1) {\n                        continue;\n                    }\n                    if (id === skipId) {\n                        continue;\n                    }\n                    const exportValue = typeof exportValues === \"string\" ? exportValues : null;\n                    const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n                    if (domElement && !GetElementsByNameSet.has(domElement)) {\n                        warn(`_getElementsByName - element not allowed: ${id}`);\n                        continue;\n                    }\n                    fields.push({\n                        id,\n                        exportValue,\n                        domElement\n                    });\n                }\n            }\n            return fields;\n        }\n        for (const domElement of document.getElementsByName(name)){\n            const { exportValue } = domElement;\n            const id = domElement.getAttribute(\"data-element-id\");\n            if (id === skipId) {\n                continue;\n            }\n            if (!GetElementsByNameSet.has(domElement)) {\n                continue;\n            }\n            fields.push({\n                id,\n                exportValue,\n                domElement\n            });\n        }\n        return fields;\n    }\n    show() {\n        if (this.container) {\n            this.container.hidden = false;\n        }\n        this.popup?.maybeShow();\n    }\n    hide() {\n        if (this.container) {\n            this.container.hidden = true;\n        }\n        this.popup?.forceHide();\n    }\n    getElementsToTriggerPopup() {\n        return this.container;\n    }\n    addHighlightArea() {\n        const triggers = this.getElementsToTriggerPopup();\n        if (Array.isArray(triggers)) {\n            for (const element of triggers){\n                element.classList.add(\"highlightArea\");\n            }\n        } else {\n            triggers.classList.add(\"highlightArea\");\n        }\n    }\n    _editOnDoubleClick() {\n        if (!this._isEditable) {\n            return;\n        }\n        const { annotationEditorType: mode, data: { id: editId } } = this;\n        this.container.addEventListener(\"dblclick\", ()=>{\n            this.linkService.eventBus?.dispatch(\"switchannotationeditormode\", {\n                source: this,\n                mode,\n                editId\n            });\n        });\n    }\n}\nclass LinkAnnotationElement extends AnnotationElement {\n    constructor(parameters, options = null){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: !!options?.ignoreBorder,\n            createQuadrilaterals: true\n        });\n        this.isTooltipOnly = parameters.data.isTooltipOnly;\n    }\n    render() {\n        const { data, linkService } = this;\n        const link = document.createElement(\"a\");\n        link.setAttribute(\"data-element-id\", data.id);\n        let isBound = false;\n        if (data.url) {\n            linkService.addLinkAttributes(link, data.url, data.newWindow);\n            isBound = true;\n        } else if (data.action) {\n            this._bindNamedAction(link, data.action);\n            isBound = true;\n        } else if (data.attachment) {\n            this.#bindAttachment(link, data.attachment, data.attachmentDest);\n            isBound = true;\n        } else if (data.setOCGState) {\n            this.#bindSetOCGState(link, data.setOCGState);\n            isBound = true;\n        } else if (data.dest) {\n            this._bindLink(link, data.dest);\n            isBound = true;\n        } else {\n            if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\n                this._bindJSAction(link, data);\n                isBound = true;\n            }\n            if (data.resetForm) {\n                this._bindResetFormAction(link, data.resetForm);\n                isBound = true;\n            } else if (this.isTooltipOnly && !isBound) {\n                this._bindLink(link, \"\");\n                isBound = true;\n            }\n        }\n        this.container.classList.add(\"linkAnnotation\");\n        if (isBound) {\n            this.container.append(link);\n        }\n        return this.container;\n    }\n    #setInternalLink() {\n        this.container.setAttribute(\"data-internal-link\", \"\");\n    }\n    _bindLink(link, destination) {\n        link.href = this.linkService.getDestinationHash(destination);\n        link.onclick = ()=>{\n            if (destination) {\n                this.linkService.goToDestination(destination);\n            }\n            return false;\n        };\n        if (destination || destination === \"\") {\n            this.#setInternalLink();\n        }\n    }\n    _bindNamedAction(link, action) {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        link.onclick = ()=>{\n            this.linkService.executeNamedAction(action);\n            return false;\n        };\n        this.#setInternalLink();\n    }\n    #bindAttachment(link, attachment, dest = null) {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        if (attachment.description) {\n            link.title = attachment.description;\n        }\n        link.onclick = ()=>{\n            this.downloadManager?.openOrDownloadData(attachment.content, attachment.filename, dest);\n            return false;\n        };\n        this.#setInternalLink();\n    }\n    #bindSetOCGState(link, action) {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        link.onclick = ()=>{\n            this.linkService.executeSetOCGState(action);\n            return false;\n        };\n        this.#setInternalLink();\n    }\n    _bindJSAction(link, data) {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        const map = new Map([\n            [\n                \"Action\",\n                \"onclick\"\n            ],\n            [\n                \"Mouse Up\",\n                \"onmouseup\"\n            ],\n            [\n                \"Mouse Down\",\n                \"onmousedown\"\n            ]\n        ]);\n        for (const name of Object.keys(data.actions)){\n            const jsName = map.get(name);\n            if (!jsName) {\n                continue;\n            }\n            link[jsName] = ()=>{\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: data.id,\n                        name\n                    }\n                });\n                return false;\n            };\n        }\n        if (!link.onclick) {\n            link.onclick = ()=>false;\n        }\n        this.#setInternalLink();\n    }\n    _bindResetFormAction(link, resetForm) {\n        const otherClickAction = link.onclick;\n        if (!otherClickAction) {\n            link.href = this.linkService.getAnchorUrl(\"\");\n        }\n        this.#setInternalLink();\n        if (!this._fieldObjects) {\n            warn(`_bindResetFormAction - \"resetForm\" action not supported, ` + \"ensure that the `fieldObjects` parameter is provided.\");\n            if (!otherClickAction) {\n                link.onclick = ()=>false;\n            }\n            return;\n        }\n        link.onclick = ()=>{\n            otherClickAction?.();\n            const { fields: resetFormFields, refs: resetFormRefs, include } = resetForm;\n            const allFields = [];\n            if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {\n                const fieldIds = new Set(resetFormRefs);\n                for (const fieldName of resetFormFields){\n                    const fields = this._fieldObjects[fieldName] || [];\n                    for (const { id } of fields){\n                        fieldIds.add(id);\n                    }\n                }\n                for (const fields of Object.values(this._fieldObjects)){\n                    for (const field of fields){\n                        if (fieldIds.has(field.id) === include) {\n                            allFields.push(field);\n                        }\n                    }\n                }\n            } else {\n                for (const fields of Object.values(this._fieldObjects)){\n                    allFields.push(...fields);\n                }\n            }\n            const storage = this.annotationStorage;\n            const allIds = [];\n            for (const field of allFields){\n                const { id } = field;\n                allIds.push(id);\n                switch(field.type){\n                    case \"text\":\n                        {\n                            const value = field.defaultValue || \"\";\n                            storage.setValue(id, {\n                                value\n                            });\n                            break;\n                        }\n                    case \"checkbox\":\n                    case \"radiobutton\":\n                        {\n                            const value = field.defaultValue === field.exportValues;\n                            storage.setValue(id, {\n                                value\n                            });\n                            break;\n                        }\n                    case \"combobox\":\n                    case \"listbox\":\n                        {\n                            const value = field.defaultValue || \"\";\n                            storage.setValue(id, {\n                                value\n                            });\n                            break;\n                        }\n                    default:\n                        continue;\n                }\n                const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n                if (!domElement) {\n                    continue;\n                } else if (!GetElementsByNameSet.has(domElement)) {\n                    warn(`_bindResetFormAction - element not allowed: ${id}`);\n                    continue;\n                }\n                domElement.dispatchEvent(new Event(\"resetform\"));\n            }\n            if (this.enableScripting) {\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: \"app\",\n                        ids: allIds,\n                        name: \"ResetForm\"\n                    }\n                });\n            }\n            return false;\n        };\n    }\n}\nclass TextAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true\n        });\n    }\n    render() {\n        this.container.classList.add(\"textAnnotation\");\n        const image = document.createElement(\"img\");\n        image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n        image.setAttribute(\"data-l10n-id\", \"pdfjs-text-annotation-type\");\n        image.setAttribute(\"data-l10n-args\", JSON.stringify({\n            type: this.data.name\n        }));\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.append(image);\n        return this.container;\n    }\n}\nclass WidgetAnnotationElement extends AnnotationElement {\n    render() {\n        return this.container;\n    }\n    showElementAndHideCanvas(element) {\n        if (this.data.hasOwnCanvas) {\n            if (element.previousSibling?.nodeName === \"CANVAS\") {\n                element.previousSibling.hidden = true;\n            }\n            element.hidden = false;\n        }\n    }\n    _getKeyModifier(event) {\n        return util_FeatureTest.platform.isMac ? event.metaKey : event.ctrlKey;\n    }\n    _setEventListener(element, elementData, baseName, eventName, valueGetter) {\n        if (baseName.includes(\"mouse\")) {\n            element.addEventListener(baseName, (event)=>{\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: this.data.id,\n                        name: eventName,\n                        value: valueGetter(event),\n                        shift: event.shiftKey,\n                        modifier: this._getKeyModifier(event)\n                    }\n                });\n            });\n        } else {\n            element.addEventListener(baseName, (event)=>{\n                if (baseName === \"blur\") {\n                    if (!elementData.focused || !event.relatedTarget) {\n                        return;\n                    }\n                    elementData.focused = false;\n                } else if (baseName === \"focus\") {\n                    if (elementData.focused) {\n                        return;\n                    }\n                    elementData.focused = true;\n                }\n                if (!valueGetter) {\n                    return;\n                }\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: this.data.id,\n                        name: eventName,\n                        value: valueGetter(event)\n                    }\n                });\n            });\n        }\n    }\n    _setEventListeners(element, elementData, names, getter) {\n        for (const [baseName, eventName] of names){\n            if (eventName === \"Action\" || this.data.actions?.[eventName]) {\n                if (eventName === \"Focus\" || eventName === \"Blur\") {\n                    elementData ||= {\n                        focused: false\n                    };\n                }\n                this._setEventListener(element, elementData, baseName, eventName, getter);\n                if (eventName === \"Focus\" && !this.data.actions?.Blur) {\n                    this._setEventListener(element, elementData, \"blur\", \"Blur\", null);\n                } else if (eventName === \"Blur\" && !this.data.actions?.Focus) {\n                    this._setEventListener(element, elementData, \"focus\", \"Focus\", null);\n                }\n            }\n        }\n    }\n    _setBackgroundColor(element) {\n        const color = this.data.backgroundColor || null;\n        element.style.backgroundColor = color === null ? \"transparent\" : Util.makeHexColor(color[0], color[1], color[2]);\n    }\n    _setTextStyle(element) {\n        const TEXT_ALIGNMENT = [\n            \"left\",\n            \"center\",\n            \"right\"\n        ];\n        const { fontColor } = this.data.defaultAppearanceData;\n        const fontSize = this.data.defaultAppearanceData.fontSize || annotation_layer_DEFAULT_FONT_SIZE;\n        const style = element.style;\n        let computedFontSize;\n        const BORDER_SIZE = 2;\n        const roundToOneDecimal = (x)=>Math.round(10 * x) / 10;\n        if (this.data.multiLine) {\n            const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n            const numberOfLines = Math.round(height / (LINE_FACTOR * fontSize)) || 1;\n            const lineHeight = height / numberOfLines;\n            computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / LINE_FACTOR));\n        } else {\n            const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n            computedFontSize = Math.min(fontSize, roundToOneDecimal(height / LINE_FACTOR));\n        }\n        style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;\n        style.color = Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\n        if (this.data.textAlignment !== null) {\n            style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n        }\n    }\n    _setRequired(element, isRequired) {\n        if (isRequired) {\n            element.setAttribute(\"required\", true);\n        } else {\n            element.removeAttribute(\"required\");\n        }\n        element.setAttribute(\"aria-required\", isRequired);\n    }\n}\nclass TextWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        const isRenderable = parameters.renderForms || parameters.data.hasOwnCanvas || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n        super(parameters, {\n            isRenderable\n        });\n    }\n    setPropertyOnSiblings(base, key, value, keyInStorage) {\n        const storage = this.annotationStorage;\n        for (const element of this._getElementsByName(base.name, base.id)){\n            if (element.domElement) {\n                element.domElement[key] = value;\n            }\n            storage.setValue(element.id, {\n                [keyInStorage]: value\n            });\n        }\n    }\n    render() {\n        const storage = this.annotationStorage;\n        const id = this.data.id;\n        this.container.classList.add(\"textWidgetAnnotation\");\n        let element = null;\n        if (this.renderForms) {\n            const storedData = storage.getValue(id, {\n                value: this.data.fieldValue\n            });\n            let textContent = storedData.value || \"\";\n            const maxLen = storage.getValue(id, {\n                charLimit: this.data.maxLen\n            }).charLimit;\n            if (maxLen && textContent.length > maxLen) {\n                textContent = textContent.slice(0, maxLen);\n            }\n            let fieldFormattedValues = storedData.formattedValue || this.data.textContent?.join(\"\\n\") || null;\n            if (fieldFormattedValues && this.data.comb) {\n                fieldFormattedValues = fieldFormattedValues.replaceAll(/\\s+/g, \"\");\n            }\n            const elementData = {\n                userValue: textContent,\n                formattedValue: fieldFormattedValues,\n                lastCommittedValue: null,\n                commitKey: 1,\n                focused: false\n            };\n            if (this.data.multiLine) {\n                element = document.createElement(\"textarea\");\n                element.textContent = fieldFormattedValues ?? textContent;\n                if (this.data.doNotScroll) {\n                    element.style.overflowY = \"hidden\";\n                }\n            } else {\n                element = document.createElement(\"input\");\n                element.type = \"text\";\n                element.setAttribute(\"value\", fieldFormattedValues ?? textContent);\n                if (this.data.doNotScroll) {\n                    element.style.overflowX = \"hidden\";\n                }\n            }\n            if (this.data.hasOwnCanvas) {\n                element.hidden = true;\n            }\n            GetElementsByNameSet.add(element);\n            element.setAttribute(\"data-element-id\", id);\n            element.disabled = this.data.readOnly;\n            element.name = this.data.fieldName;\n            element.tabIndex = DEFAULT_TAB_INDEX;\n            this._setRequired(element, this.data.required);\n            if (maxLen) {\n                element.maxLength = maxLen;\n            }\n            element.addEventListener(\"input\", (event)=>{\n                storage.setValue(id, {\n                    value: event.target.value\n                });\n                this.setPropertyOnSiblings(element, \"value\", event.target.value, \"value\");\n                elementData.formattedValue = null;\n            });\n            element.addEventListener(\"resetform\", (event)=>{\n                const defaultValue = this.data.defaultFieldValue ?? \"\";\n                element.value = elementData.userValue = defaultValue;\n                elementData.formattedValue = null;\n            });\n            let blurListener = (event)=>{\n                const { formattedValue } = elementData;\n                if (formattedValue !== null && formattedValue !== undefined) {\n                    event.target.value = formattedValue;\n                }\n                event.target.scrollLeft = 0;\n            };\n            if (this.enableScripting && this.hasJSActions) {\n                element.addEventListener(\"focus\", (event)=>{\n                    if (elementData.focused) {\n                        return;\n                    }\n                    const { target } = event;\n                    if (elementData.userValue) {\n                        target.value = elementData.userValue;\n                    }\n                    elementData.lastCommittedValue = target.value;\n                    elementData.commitKey = 1;\n                    if (!this.data.actions?.Focus) {\n                        elementData.focused = true;\n                    }\n                });\n                element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                    this.showElementAndHideCanvas(jsEvent.target);\n                    const actions = {\n                        value (event) {\n                            elementData.userValue = event.detail.value ?? \"\";\n                            storage.setValue(id, {\n                                value: elementData.userValue.toString()\n                            });\n                            event.target.value = elementData.userValue;\n                        },\n                        formattedValue (event) {\n                            const { formattedValue } = event.detail;\n                            elementData.formattedValue = formattedValue;\n                            if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {\n                                event.target.value = formattedValue;\n                            }\n                            storage.setValue(id, {\n                                formattedValue\n                            });\n                        },\n                        selRange (event) {\n                            event.target.setSelectionRange(...event.detail.selRange);\n                        },\n                        charLimit: (event)=>{\n                            const { charLimit } = event.detail;\n                            const { target } = event;\n                            if (charLimit === 0) {\n                                target.removeAttribute(\"maxLength\");\n                                return;\n                            }\n                            target.setAttribute(\"maxLength\", charLimit);\n                            let value = elementData.userValue;\n                            if (!value || value.length <= charLimit) {\n                                return;\n                            }\n                            value = value.slice(0, charLimit);\n                            target.value = elementData.userValue = value;\n                            storage.setValue(id, {\n                                value\n                            });\n                            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                source: this,\n                                detail: {\n                                    id,\n                                    name: \"Keystroke\",\n                                    value,\n                                    willCommit: true,\n                                    commitKey: 1,\n                                    selStart: target.selectionStart,\n                                    selEnd: target.selectionEnd\n                                }\n                            });\n                        }\n                    };\n                    this._dispatchEventFromSandbox(actions, jsEvent);\n                });\n                element.addEventListener(\"keydown\", (event)=>{\n                    elementData.commitKey = 1;\n                    let commitKey = -1;\n                    if (event.key === \"Escape\") {\n                        commitKey = 0;\n                    } else if (event.key === \"Enter\" && !this.data.multiLine) {\n                        commitKey = 2;\n                    } else if (event.key === \"Tab\") {\n                        elementData.commitKey = 3;\n                    }\n                    if (commitKey === -1) {\n                        return;\n                    }\n                    const { value } = event.target;\n                    if (elementData.lastCommittedValue === value) {\n                        return;\n                    }\n                    elementData.lastCommittedValue = value;\n                    elementData.userValue = value;\n                    this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                        source: this,\n                        detail: {\n                            id,\n                            name: \"Keystroke\",\n                            value,\n                            willCommit: true,\n                            commitKey,\n                            selStart: event.target.selectionStart,\n                            selEnd: event.target.selectionEnd\n                        }\n                    });\n                });\n                const _blurListener = blurListener;\n                blurListener = null;\n                element.addEventListener(\"blur\", (event)=>{\n                    if (!elementData.focused || !event.relatedTarget) {\n                        return;\n                    }\n                    if (!this.data.actions?.Blur) {\n                        elementData.focused = false;\n                    }\n                    const { value } = event.target;\n                    elementData.userValue = value;\n                    if (elementData.lastCommittedValue !== value) {\n                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                            source: this,\n                            detail: {\n                                id,\n                                name: \"Keystroke\",\n                                value,\n                                willCommit: true,\n                                commitKey: elementData.commitKey,\n                                selStart: event.target.selectionStart,\n                                selEnd: event.target.selectionEnd\n                            }\n                        });\n                    }\n                    _blurListener(event);\n                });\n                if (this.data.actions?.Keystroke) {\n                    element.addEventListener(\"beforeinput\", (event)=>{\n                        elementData.lastCommittedValue = null;\n                        const { data, target } = event;\n                        const { value, selectionStart, selectionEnd } = target;\n                        let selStart = selectionStart, selEnd = selectionEnd;\n                        switch(event.inputType){\n                            case \"deleteWordBackward\":\n                                {\n                                    const match = value.substring(0, selectionStart).match(/\\w*[^\\w]*$/);\n                                    if (match) {\n                                        selStart -= match[0].length;\n                                    }\n                                    break;\n                                }\n                            case \"deleteWordForward\":\n                                {\n                                    const match = value.substring(selectionStart).match(/^[^\\w]*\\w*/);\n                                    if (match) {\n                                        selEnd += match[0].length;\n                                    }\n                                    break;\n                                }\n                            case \"deleteContentBackward\":\n                                if (selectionStart === selectionEnd) {\n                                    selStart -= 1;\n                                }\n                                break;\n                            case \"deleteContentForward\":\n                                if (selectionStart === selectionEnd) {\n                                    selEnd += 1;\n                                }\n                                break;\n                        }\n                        event.preventDefault();\n                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                            source: this,\n                            detail: {\n                                id,\n                                name: \"Keystroke\",\n                                value,\n                                change: data || \"\",\n                                willCommit: false,\n                                selStart,\n                                selEnd\n                            }\n                        });\n                    });\n                }\n                this._setEventListeners(element, elementData, [\n                    [\n                        \"focus\",\n                        \"Focus\"\n                    ],\n                    [\n                        \"blur\",\n                        \"Blur\"\n                    ],\n                    [\n                        \"mousedown\",\n                        \"Mouse Down\"\n                    ],\n                    [\n                        \"mouseenter\",\n                        \"Mouse Enter\"\n                    ],\n                    [\n                        \"mouseleave\",\n                        \"Mouse Exit\"\n                    ],\n                    [\n                        \"mouseup\",\n                        \"Mouse Up\"\n                    ]\n                ], (event)=>event.target.value);\n            }\n            if (blurListener) {\n                element.addEventListener(\"blur\", blurListener);\n            }\n            if (this.data.comb) {\n                const fieldWidth = this.data.rect[2] - this.data.rect[0];\n                const combWidth = fieldWidth / maxLen;\n                element.classList.add(\"comb\");\n                element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;\n            }\n        } else {\n            element = document.createElement(\"div\");\n            element.textContent = this.data.fieldValue;\n            element.style.verticalAlign = \"middle\";\n            element.style.display = \"table-cell\";\n            if (this.data.hasOwnCanvas) {\n                element.hidden = true;\n            }\n        }\n        this._setTextStyle(element);\n        this._setBackgroundColor(element);\n        this._setDefaultPropertiesFromJS(element);\n        this.container.append(element);\n        return this.container;\n    }\n}\nclass SignatureWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: !!parameters.data.hasOwnCanvas\n        });\n    }\n}\nclass CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: parameters.renderForms\n        });\n    }\n    render() {\n        const storage = this.annotationStorage;\n        const data = this.data;\n        const id = data.id;\n        let value = storage.getValue(id, {\n            value: data.exportValue === data.fieldValue\n        }).value;\n        if (typeof value === \"string\") {\n            value = value !== \"Off\";\n            storage.setValue(id, {\n                value\n            });\n        }\n        this.container.classList.add(\"buttonWidgetAnnotation\", \"checkBox\");\n        const element = document.createElement(\"input\");\n        GetElementsByNameSet.add(element);\n        element.setAttribute(\"data-element-id\", id);\n        element.disabled = data.readOnly;\n        this._setRequired(element, this.data.required);\n        element.type = \"checkbox\";\n        element.name = data.fieldName;\n        if (value) {\n            element.setAttribute(\"checked\", true);\n        }\n        element.setAttribute(\"exportValue\", data.exportValue);\n        element.tabIndex = DEFAULT_TAB_INDEX;\n        element.addEventListener(\"change\", (event)=>{\n            const { name, checked } = event.target;\n            for (const checkbox of this._getElementsByName(name, id)){\n                const curChecked = checked && checkbox.exportValue === data.exportValue;\n                if (checkbox.domElement) {\n                    checkbox.domElement.checked = curChecked;\n                }\n                storage.setValue(checkbox.id, {\n                    value: curChecked\n                });\n            }\n            storage.setValue(id, {\n                value: checked\n            });\n        });\n        element.addEventListener(\"resetform\", (event)=>{\n            const defaultValue = data.defaultFieldValue || \"Off\";\n            event.target.checked = defaultValue === data.exportValue;\n        });\n        if (this.enableScripting && this.hasJSActions) {\n            element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                const actions = {\n                    value (event) {\n                        event.target.checked = event.detail.value !== \"Off\";\n                        storage.setValue(id, {\n                            value: event.target.checked\n                        });\n                    }\n                };\n                this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            this._setEventListeners(element, null, [\n                [\n                    \"change\",\n                    \"Validate\"\n                ],\n                [\n                    \"change\",\n                    \"Action\"\n                ],\n                [\n                    \"focus\",\n                    \"Focus\"\n                ],\n                [\n                    \"blur\",\n                    \"Blur\"\n                ],\n                [\n                    \"mousedown\",\n                    \"Mouse Down\"\n                ],\n                [\n                    \"mouseenter\",\n                    \"Mouse Enter\"\n                ],\n                [\n                    \"mouseleave\",\n                    \"Mouse Exit\"\n                ],\n                [\n                    \"mouseup\",\n                    \"Mouse Up\"\n                ]\n            ], (event)=>event.target.checked);\n        }\n        this._setBackgroundColor(element);\n        this._setDefaultPropertiesFromJS(element);\n        this.container.append(element);\n        return this.container;\n    }\n}\nclass RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: parameters.renderForms\n        });\n    }\n    render() {\n        this.container.classList.add(\"buttonWidgetAnnotation\", \"radioButton\");\n        const storage = this.annotationStorage;\n        const data = this.data;\n        const id = data.id;\n        let value = storage.getValue(id, {\n            value: data.fieldValue === data.buttonValue\n        }).value;\n        if (typeof value === \"string\") {\n            value = value !== data.buttonValue;\n            storage.setValue(id, {\n                value\n            });\n        }\n        if (value) {\n            for (const radio of this._getElementsByName(data.fieldName, id)){\n                storage.setValue(radio.id, {\n                    value: false\n                });\n            }\n        }\n        const element = document.createElement(\"input\");\n        GetElementsByNameSet.add(element);\n        element.setAttribute(\"data-element-id\", id);\n        element.disabled = data.readOnly;\n        this._setRequired(element, this.data.required);\n        element.type = \"radio\";\n        element.name = data.fieldName;\n        if (value) {\n            element.setAttribute(\"checked\", true);\n        }\n        element.tabIndex = DEFAULT_TAB_INDEX;\n        element.addEventListener(\"change\", (event)=>{\n            const { name, checked } = event.target;\n            for (const radio of this._getElementsByName(name, id)){\n                storage.setValue(radio.id, {\n                    value: false\n                });\n            }\n            storage.setValue(id, {\n                value: checked\n            });\n        });\n        element.addEventListener(\"resetform\", (event)=>{\n            const defaultValue = data.defaultFieldValue;\n            event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;\n        });\n        if (this.enableScripting && this.hasJSActions) {\n            const pdfButtonValue = data.buttonValue;\n            element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                const actions = {\n                    value: (event)=>{\n                        const checked = pdfButtonValue === event.detail.value;\n                        for (const radio of this._getElementsByName(event.target.name)){\n                            const curChecked = checked && radio.id === id;\n                            if (radio.domElement) {\n                                radio.domElement.checked = curChecked;\n                            }\n                            storage.setValue(radio.id, {\n                                value: curChecked\n                            });\n                        }\n                    }\n                };\n                this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            this._setEventListeners(element, null, [\n                [\n                    \"change\",\n                    \"Validate\"\n                ],\n                [\n                    \"change\",\n                    \"Action\"\n                ],\n                [\n                    \"focus\",\n                    \"Focus\"\n                ],\n                [\n                    \"blur\",\n                    \"Blur\"\n                ],\n                [\n                    \"mousedown\",\n                    \"Mouse Down\"\n                ],\n                [\n                    \"mouseenter\",\n                    \"Mouse Enter\"\n                ],\n                [\n                    \"mouseleave\",\n                    \"Mouse Exit\"\n                ],\n                [\n                    \"mouseup\",\n                    \"Mouse Up\"\n                ]\n            ], (event)=>event.target.checked);\n        }\n        this._setBackgroundColor(element);\n        this._setDefaultPropertiesFromJS(element);\n        this.container.append(element);\n        return this.container;\n    }\n}\nclass PushButtonWidgetAnnotationElement extends LinkAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            ignoreBorder: parameters.data.hasAppearance\n        });\n    }\n    render() {\n        const container = super.render();\n        container.classList.add(\"buttonWidgetAnnotation\", \"pushButton\");\n        const linkElement = container.lastChild;\n        if (this.enableScripting && this.hasJSActions && linkElement) {\n            this._setDefaultPropertiesFromJS(linkElement);\n            linkElement.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                this._dispatchEventFromSandbox({}, jsEvent);\n            });\n        }\n        return container;\n    }\n}\nclass ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: parameters.renderForms\n        });\n    }\n    render() {\n        this.container.classList.add(\"choiceWidgetAnnotation\");\n        const storage = this.annotationStorage;\n        const id = this.data.id;\n        const storedData = storage.getValue(id, {\n            value: this.data.fieldValue\n        });\n        const selectElement = document.createElement(\"select\");\n        GetElementsByNameSet.add(selectElement);\n        selectElement.setAttribute(\"data-element-id\", id);\n        selectElement.disabled = this.data.readOnly;\n        this._setRequired(selectElement, this.data.required);\n        selectElement.name = this.data.fieldName;\n        selectElement.tabIndex = DEFAULT_TAB_INDEX;\n        let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;\n        if (!this.data.combo) {\n            selectElement.size = this.data.options.length;\n            if (this.data.multiSelect) {\n                selectElement.multiple = true;\n            }\n        }\n        selectElement.addEventListener(\"resetform\", (event)=>{\n            const defaultValue = this.data.defaultFieldValue;\n            for (const option of selectElement.options){\n                option.selected = option.value === defaultValue;\n            }\n        });\n        for (const option of this.data.options){\n            const optionElement = document.createElement(\"option\");\n            optionElement.textContent = option.displayValue;\n            optionElement.value = option.exportValue;\n            if (storedData.value.includes(option.exportValue)) {\n                optionElement.setAttribute(\"selected\", true);\n                addAnEmptyEntry = false;\n            }\n            selectElement.append(optionElement);\n        }\n        let removeEmptyEntry = null;\n        if (addAnEmptyEntry) {\n            const noneOptionElement = document.createElement(\"option\");\n            noneOptionElement.value = \" \";\n            noneOptionElement.setAttribute(\"hidden\", true);\n            noneOptionElement.setAttribute(\"selected\", true);\n            selectElement.prepend(noneOptionElement);\n            removeEmptyEntry = ()=>{\n                noneOptionElement.remove();\n                selectElement.removeEventListener(\"input\", removeEmptyEntry);\n                removeEmptyEntry = null;\n            };\n            selectElement.addEventListener(\"input\", removeEmptyEntry);\n        }\n        const getValue = (isExport)=>{\n            const name = isExport ? \"value\" : \"textContent\";\n            const { options, multiple } = selectElement;\n            if (!multiple) {\n                return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];\n            }\n            return Array.prototype.filter.call(options, (option)=>option.selected).map((option)=>option[name]);\n        };\n        let selectedValues = getValue(false);\n        const getItems = (event)=>{\n            const options = event.target.options;\n            return Array.prototype.map.call(options, (option)=>({\n                    displayValue: option.textContent,\n                    exportValue: option.value\n                }));\n        };\n        if (this.enableScripting && this.hasJSActions) {\n            selectElement.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                const actions = {\n                    value (event) {\n                        removeEmptyEntry?.();\n                        const value = event.detail.value;\n                        const values = new Set(Array.isArray(value) ? value : [\n                            value\n                        ]);\n                        for (const option of selectElement.options){\n                            option.selected = values.has(option.value);\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    multipleSelection (event) {\n                        selectElement.multiple = true;\n                    },\n                    remove (event) {\n                        const options = selectElement.options;\n                        const index = event.detail.remove;\n                        options[index].selected = false;\n                        selectElement.remove(index);\n                        if (options.length > 0) {\n                            const i = Array.prototype.findIndex.call(options, (option)=>option.selected);\n                            if (i === -1) {\n                                options[0].selected = true;\n                            }\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true),\n                            items: getItems(event)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    clear (event) {\n                        while(selectElement.length !== 0){\n                            selectElement.remove(0);\n                        }\n                        storage.setValue(id, {\n                            value: null,\n                            items: []\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    insert (event) {\n                        const { index, displayValue, exportValue } = event.detail.insert;\n                        const selectChild = selectElement.children[index];\n                        const optionElement = document.createElement(\"option\");\n                        optionElement.textContent = displayValue;\n                        optionElement.value = exportValue;\n                        if (selectChild) {\n                            selectChild.before(optionElement);\n                        } else {\n                            selectElement.append(optionElement);\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true),\n                            items: getItems(event)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    items (event) {\n                        const { items } = event.detail;\n                        while(selectElement.length !== 0){\n                            selectElement.remove(0);\n                        }\n                        for (const item of items){\n                            const { displayValue, exportValue } = item;\n                            const optionElement = document.createElement(\"option\");\n                            optionElement.textContent = displayValue;\n                            optionElement.value = exportValue;\n                            selectElement.append(optionElement);\n                        }\n                        if (selectElement.options.length > 0) {\n                            selectElement.options[0].selected = true;\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true),\n                            items: getItems(event)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    indices (event) {\n                        const indices = new Set(event.detail.indices);\n                        for (const option of event.target.options){\n                            option.selected = indices.has(option.index);\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    editable (event) {\n                        event.target.disabled = !event.detail.editable;\n                    }\n                };\n                this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            selectElement.addEventListener(\"input\", (event)=>{\n                const exportValue = getValue(true);\n                const change = getValue(false);\n                storage.setValue(id, {\n                    value: exportValue\n                });\n                event.preventDefault();\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id,\n                        name: \"Keystroke\",\n                        value: selectedValues,\n                        change,\n                        changeEx: exportValue,\n                        willCommit: false,\n                        commitKey: 1,\n                        keyDown: false\n                    }\n                });\n            });\n            this._setEventListeners(selectElement, null, [\n                [\n                    \"focus\",\n                    \"Focus\"\n                ],\n                [\n                    \"blur\",\n                    \"Blur\"\n                ],\n                [\n                    \"mousedown\",\n                    \"Mouse Down\"\n                ],\n                [\n                    \"mouseenter\",\n                    \"Mouse Enter\"\n                ],\n                [\n                    \"mouseleave\",\n                    \"Mouse Exit\"\n                ],\n                [\n                    \"mouseup\",\n                    \"Mouse Up\"\n                ],\n                [\n                    \"input\",\n                    \"Action\"\n                ],\n                [\n                    \"input\",\n                    \"Validate\"\n                ]\n            ], (event)=>event.target.value);\n        } else {\n            selectElement.addEventListener(\"input\", function(event) {\n                storage.setValue(id, {\n                    value: getValue(true)\n                });\n            });\n        }\n        if (this.data.combo) {\n            this._setTextStyle(selectElement);\n        } else {}\n        this._setBackgroundColor(selectElement);\n        this._setDefaultPropertiesFromJS(selectElement);\n        this.container.append(selectElement);\n        return this.container;\n    }\n}\nclass PopupAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        const { data, elements } = parameters;\n        super(parameters, {\n            isRenderable: AnnotationElement._hasPopupData(data)\n        });\n        this.elements = elements;\n        this.popup = null;\n    }\n    render() {\n        this.container.classList.add(\"popupAnnotation\");\n        const popup = this.popup = new PopupElement({\n            container: this.container,\n            color: this.data.color,\n            titleObj: this.data.titleObj,\n            modificationDate: this.data.modificationDate,\n            contentsObj: this.data.contentsObj,\n            richText: this.data.richText,\n            rect: this.data.rect,\n            parentRect: this.data.parentRect || null,\n            parent: this.parent,\n            elements: this.elements,\n            open: this.data.open\n        });\n        const elementIds = [];\n        for (const element of this.elements){\n            element.popup = popup;\n            element.container.ariaHasPopup = \"dialog\";\n            elementIds.push(element.data.id);\n            element.addHighlightArea();\n        }\n        this.container.setAttribute(\"aria-controls\", elementIds.map((id)=>`${AnnotationPrefix}${id}`).join(\",\"));\n        return this.container;\n    }\n}\nclass PopupElement {\n    #boundKeyDown;\n    #boundHide;\n    #boundShow;\n    #boundToggle;\n    #color;\n    #container;\n    #contentsObj;\n    #dateObj;\n    #elements;\n    #parent;\n    #parentRect;\n    #pinned;\n    #popup;\n    #position;\n    #rect;\n    #richText;\n    #titleObj;\n    #updates;\n    #wasVisible;\n    constructor({ container, color, elements, titleObj, modificationDate, contentsObj, richText, parent, rect, parentRect, open }){\n        this.#boundKeyDown = this.#keyDown.bind(this);\n        this.#boundHide = this.#hide.bind(this);\n        this.#boundShow = this.#show.bind(this);\n        this.#boundToggle = this.#toggle.bind(this);\n        this.#color = null;\n        this.#container = null;\n        this.#contentsObj = null;\n        this.#dateObj = null;\n        this.#elements = null;\n        this.#parent = null;\n        this.#parentRect = null;\n        this.#pinned = false;\n        this.#popup = null;\n        this.#position = null;\n        this.#rect = null;\n        this.#richText = null;\n        this.#titleObj = null;\n        this.#updates = null;\n        this.#wasVisible = false;\n        this.#container = container;\n        this.#titleObj = titleObj;\n        this.#contentsObj = contentsObj;\n        this.#richText = richText;\n        this.#parent = parent;\n        this.#color = color;\n        this.#rect = rect;\n        this.#parentRect = parentRect;\n        this.#elements = elements;\n        this.#dateObj = PDFDateString.toDateObject(modificationDate);\n        this.trigger = elements.flatMap((e)=>e.getElementsToTriggerPopup());\n        for (const element of this.trigger){\n            element.addEventListener(\"click\", this.#boundToggle);\n            element.addEventListener(\"mouseenter\", this.#boundShow);\n            element.addEventListener(\"mouseleave\", this.#boundHide);\n            element.classList.add(\"popupTriggerArea\");\n        }\n        for (const element of elements){\n            element.container?.addEventListener(\"keydown\", this.#boundKeyDown);\n        }\n        this.#container.hidden = true;\n        if (open) {\n            this.#toggle();\n        }\n    }\n    render() {\n        if (this.#popup) {\n            return;\n        }\n        const popup = this.#popup = document.createElement(\"div\");\n        popup.className = \"popup\";\n        if (this.#color) {\n            const baseColor = popup.style.outlineColor = Util.makeHexColor(...this.#color);\n            if (CSS.supports(\"background-color\", \"color-mix(in srgb, red 30%, white)\")) {\n                popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;\n            } else {\n                const BACKGROUND_ENLIGHT = 0.7;\n                popup.style.backgroundColor = Util.makeHexColor(...this.#color.map((c)=>Math.floor(BACKGROUND_ENLIGHT * (255 - c) + c)));\n            }\n        }\n        const header = document.createElement(\"span\");\n        header.className = \"header\";\n        const title = document.createElement(\"h1\");\n        header.append(title);\n        ({ dir: title.dir, str: title.textContent } = this.#titleObj);\n        popup.append(header);\n        if (this.#dateObj) {\n            const modificationDate = document.createElement(\"span\");\n            modificationDate.classList.add(\"popupDate\");\n            modificationDate.setAttribute(\"data-l10n-id\", \"pdfjs-annotation-date-time-string\");\n            modificationDate.setAttribute(\"data-l10n-args\", JSON.stringify({\n                dateObj: this.#dateObj.valueOf()\n            }));\n            header.append(modificationDate);\n        }\n        const html = this.#html;\n        if (html) {\n            XfaLayer.render({\n                xfaHtml: html,\n                intent: \"richText\",\n                div: popup\n            });\n            popup.lastChild.classList.add(\"richText\", \"popupContent\");\n        } else {\n            const contents = this._formatContents(this.#contentsObj);\n            popup.append(contents);\n        }\n        this.#container.append(popup);\n    }\n    get #html() {\n        const richText = this.#richText;\n        const contentsObj = this.#contentsObj;\n        if (richText?.str && (!contentsObj?.str || contentsObj.str === richText.str)) {\n            return this.#richText.html || null;\n        }\n        return null;\n    }\n    get #fontSize() {\n        return this.#html?.attributes?.style?.fontSize || 0;\n    }\n    get #fontColor() {\n        return this.#html?.attributes?.style?.color || null;\n    }\n    #makePopupContent(text) {\n        const popupLines = [];\n        const popupContent = {\n            str: text,\n            html: {\n                name: \"div\",\n                attributes: {\n                    dir: \"auto\"\n                },\n                children: [\n                    {\n                        name: \"p\",\n                        children: popupLines\n                    }\n                ]\n            }\n        };\n        const lineAttributes = {\n            style: {\n                color: this.#fontColor,\n                fontSize: this.#fontSize ? `calc(${this.#fontSize}px * var(--scale-factor))` : \"\"\n            }\n        };\n        for (const line of text.split(\"\\n\")){\n            popupLines.push({\n                name: \"span\",\n                value: line,\n                attributes: lineAttributes\n            });\n        }\n        return popupContent;\n    }\n    _formatContents({ str, dir }) {\n        const p = document.createElement(\"p\");\n        p.classList.add(\"popupContent\");\n        p.dir = dir;\n        const lines = str.split(/(?:\\r\\n?|\\n)/);\n        for(let i = 0, ii = lines.length; i < ii; ++i){\n            const line = lines[i];\n            p.append(document.createTextNode(line));\n            if (i < ii - 1) {\n                p.append(document.createElement(\"br\"));\n            }\n        }\n        return p;\n    }\n    #keyDown(event) {\n        if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {\n            return;\n        }\n        if (event.key === \"Enter\" || event.key === \"Escape\" && this.#pinned) {\n            this.#toggle();\n        }\n    }\n    updateEdited({ rect, popupContent }) {\n        this.#updates ||= {\n            contentsObj: this.#contentsObj,\n            richText: this.#richText\n        };\n        if (rect) {\n            this.#position = null;\n        }\n        if (popupContent) {\n            this.#richText = this.#makePopupContent(popupContent);\n            this.#contentsObj = null;\n        }\n        this.#popup?.remove();\n        this.#popup = null;\n    }\n    resetEdited() {\n        if (!this.#updates) {\n            return;\n        }\n        ({ contentsObj: this.#contentsObj, richText: this.#richText } = this.#updates);\n        this.#updates = null;\n        this.#popup?.remove();\n        this.#popup = null;\n        this.#position = null;\n    }\n    #setPosition() {\n        if (this.#position !== null) {\n            return;\n        }\n        const { page: { view }, viewport: { rawDims: { pageWidth, pageHeight, pageX, pageY } } } = this.#parent;\n        let useParentRect = !!this.#parentRect;\n        let rect = useParentRect ? this.#parentRect : this.#rect;\n        for (const element of this.#elements){\n            if (!rect || Util.intersect(element.data.rect, rect) !== null) {\n                rect = element.data.rect;\n                useParentRect = true;\n                break;\n            }\n        }\n        const normalizedRect = Util.normalizeRect([\n            rect[0],\n            view[3] - rect[1] + view[1],\n            rect[2],\n            view[3] - rect[3] + view[1]\n        ]);\n        const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;\n        const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;\n        const popupLeft = normalizedRect[0] + parentWidth;\n        const popupTop = normalizedRect[1];\n        this.#position = [\n            100 * (popupLeft - pageX) / pageWidth,\n            100 * (popupTop - pageY) / pageHeight\n        ];\n        const { style } = this.#container;\n        style.left = `${this.#position[0]}%`;\n        style.top = `${this.#position[1]}%`;\n    }\n    #toggle() {\n        this.#pinned = !this.#pinned;\n        if (this.#pinned) {\n            this.#show();\n            this.#container.addEventListener(\"click\", this.#boundToggle);\n            this.#container.addEventListener(\"keydown\", this.#boundKeyDown);\n        } else {\n            this.#hide();\n            this.#container.removeEventListener(\"click\", this.#boundToggle);\n            this.#container.removeEventListener(\"keydown\", this.#boundKeyDown);\n        }\n    }\n    #show() {\n        if (!this.#popup) {\n            this.render();\n        }\n        if (!this.isVisible) {\n            this.#setPosition();\n            this.#container.hidden = false;\n            this.#container.style.zIndex = parseInt(this.#container.style.zIndex) + 1000;\n        } else if (this.#pinned) {\n            this.#container.classList.add(\"focused\");\n        }\n    }\n    #hide() {\n        this.#container.classList.remove(\"focused\");\n        if (this.#pinned || !this.isVisible) {\n            return;\n        }\n        this.#container.hidden = true;\n        this.#container.style.zIndex = parseInt(this.#container.style.zIndex) - 1000;\n    }\n    forceHide() {\n        this.#wasVisible = this.isVisible;\n        if (!this.#wasVisible) {\n            return;\n        }\n        this.#container.hidden = true;\n    }\n    maybeShow() {\n        if (!this.#wasVisible) {\n            return;\n        }\n        if (!this.#popup) {\n            this.#show();\n        }\n        this.#wasVisible = false;\n        this.#container.hidden = false;\n    }\n    get isVisible() {\n        return this.#container.hidden === false;\n    }\n}\nclass FreeTextAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.textContent = parameters.data.textContent;\n        this.textPosition = parameters.data.textPosition;\n        this.annotationEditorType = AnnotationEditorType.FREETEXT;\n    }\n    render() {\n        this.container.classList.add(\"freeTextAnnotation\");\n        if (this.textContent) {\n            const content = document.createElement(\"div\");\n            content.classList.add(\"annotationTextContent\");\n            content.setAttribute(\"role\", \"comment\");\n            for (const line of this.textContent){\n                const lineSpan = document.createElement(\"span\");\n                lineSpan.textContent = line;\n                content.append(lineSpan);\n            }\n            this.container.append(content);\n        }\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this._editOnDoubleClick();\n        return this.container;\n    }\n}\nclass LineAnnotationElement extends AnnotationElement {\n    #line;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#line = null;\n    }\n    render() {\n        this.container.classList.add(\"lineAnnotation\");\n        const data = this.data;\n        const { width, height } = getRectDims(data.rect);\n        const svg = this.svgFactory.create(width, height, true);\n        const line = this.#line = this.svgFactory.createElement(\"svg:line\");\n        line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n        line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n        line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n        line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n        line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n        line.setAttribute(\"stroke\", \"transparent\");\n        line.setAttribute(\"fill\", \"transparent\");\n        svg.append(line);\n        this.container.append(svg);\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#line;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass SquareAnnotationElement extends AnnotationElement {\n    #square;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#square = null;\n    }\n    render() {\n        this.container.classList.add(\"squareAnnotation\");\n        const data = this.data;\n        const { width, height } = getRectDims(data.rect);\n        const svg = this.svgFactory.create(width, height, true);\n        const borderWidth = data.borderStyle.width;\n        const square = this.#square = this.svgFactory.createElement(\"svg:rect\");\n        square.setAttribute(\"x\", borderWidth / 2);\n        square.setAttribute(\"y\", borderWidth / 2);\n        square.setAttribute(\"width\", width - borderWidth);\n        square.setAttribute(\"height\", height - borderWidth);\n        square.setAttribute(\"stroke-width\", borderWidth || 1);\n        square.setAttribute(\"stroke\", \"transparent\");\n        square.setAttribute(\"fill\", \"transparent\");\n        svg.append(square);\n        this.container.append(svg);\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#square;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass CircleAnnotationElement extends AnnotationElement {\n    #circle;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#circle = null;\n    }\n    render() {\n        this.container.classList.add(\"circleAnnotation\");\n        const data = this.data;\n        const { width, height } = getRectDims(data.rect);\n        const svg = this.svgFactory.create(width, height, true);\n        const borderWidth = data.borderStyle.width;\n        const circle = this.#circle = this.svgFactory.createElement(\"svg:ellipse\");\n        circle.setAttribute(\"cx\", width / 2);\n        circle.setAttribute(\"cy\", height / 2);\n        circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n        circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n        circle.setAttribute(\"stroke-width\", borderWidth || 1);\n        circle.setAttribute(\"stroke\", \"transparent\");\n        circle.setAttribute(\"fill\", \"transparent\");\n        svg.append(circle);\n        this.container.append(svg);\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#circle;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass PolylineAnnotationElement extends AnnotationElement {\n    #polyline;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#polyline = null;\n        this.containerClassName = \"polylineAnnotation\";\n        this.svgElementName = \"svg:polyline\";\n    }\n    render() {\n        this.container.classList.add(this.containerClassName);\n        const { data: { rect, vertices, borderStyle, popupRef } } = this;\n        if (!vertices) {\n            return this.container;\n        }\n        const { width, height } = getRectDims(rect);\n        const svg = this.svgFactory.create(width, height, true);\n        let points = [];\n        for(let i = 0, ii = vertices.length; i < ii; i += 2){\n            const x = vertices[i] - rect[0];\n            const y = rect[3] - vertices[i + 1];\n            points.push(`${x},${y}`);\n        }\n        points = points.join(\" \");\n        const polyline = this.#polyline = this.svgFactory.createElement(this.svgElementName);\n        polyline.setAttribute(\"points\", points);\n        polyline.setAttribute(\"stroke-width\", borderStyle.width || 1);\n        polyline.setAttribute(\"stroke\", \"transparent\");\n        polyline.setAttribute(\"fill\", \"transparent\");\n        svg.append(polyline);\n        this.container.append(svg);\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#polyline;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass PolygonAnnotationElement extends PolylineAnnotationElement {\n    constructor(parameters){\n        super(parameters);\n        this.containerClassName = \"polygonAnnotation\";\n        this.svgElementName = \"svg:polygon\";\n    }\n}\nclass CaretAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n    }\n    render() {\n        this.container.classList.add(\"caretAnnotation\");\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n}\nclass InkAnnotationElement extends AnnotationElement {\n    #polylinesGroupElement;\n    #polylines;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#polylinesGroupElement = null;\n        this.#polylines = [];\n        this.containerClassName = \"inkAnnotation\";\n        this.svgElementName = \"svg:polyline\";\n        this.annotationEditorType = this.data.it === \"InkHighlight\" ? AnnotationEditorType.HIGHLIGHT : AnnotationEditorType.INK;\n    }\n    #getTransform(rotation, rect) {\n        switch(rotation){\n            case 90:\n                return {\n                    transform: `rotate(90) translate(${-rect[0]},${rect[1]}) scale(1,-1)`,\n                    width: rect[3] - rect[1],\n                    height: rect[2] - rect[0]\n                };\n            case 180:\n                return {\n                    transform: `rotate(180) translate(${-rect[2]},${rect[1]}) scale(1,-1)`,\n                    width: rect[2] - rect[0],\n                    height: rect[3] - rect[1]\n                };\n            case 270:\n                return {\n                    transform: `rotate(270) translate(${-rect[2]},${rect[3]}) scale(1,-1)`,\n                    width: rect[3] - rect[1],\n                    height: rect[2] - rect[0]\n                };\n            default:\n                return {\n                    transform: `translate(${-rect[0]},${rect[3]}) scale(1,-1)`,\n                    width: rect[2] - rect[0],\n                    height: rect[3] - rect[1]\n                };\n        }\n    }\n    render() {\n        this.container.classList.add(this.containerClassName);\n        const { data: { rect, rotation, inkLists, borderStyle, popupRef } } = this;\n        const { transform, width, height } = this.#getTransform(rotation, rect);\n        const svg = this.svgFactory.create(width, height, true);\n        const g = this.#polylinesGroupElement = this.svgFactory.createElement(\"svg:g\");\n        svg.append(g);\n        g.setAttribute(\"stroke-width\", borderStyle.width || 1);\n        g.setAttribute(\"stroke-linecap\", \"round\");\n        g.setAttribute(\"stroke-linejoin\", \"round\");\n        g.setAttribute(\"stroke-miterlimit\", 10);\n        g.setAttribute(\"stroke\", \"transparent\");\n        g.setAttribute(\"fill\", \"transparent\");\n        g.setAttribute(\"transform\", transform);\n        for(let i = 0, ii = inkLists.length; i < ii; i++){\n            const polyline = this.svgFactory.createElement(this.svgElementName);\n            this.#polylines.push(polyline);\n            polyline.setAttribute(\"points\", inkLists[i].join(\",\"));\n            g.append(polyline);\n        }\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.append(svg);\n        this._editOnDoubleClick();\n        return this.container;\n    }\n    updateEdited(params) {\n        super.updateEdited(params);\n        const { thickness, points, rect } = params;\n        const g = this.#polylinesGroupElement;\n        if (thickness >= 0) {\n            g.setAttribute(\"stroke-width\", thickness || 1);\n        }\n        if (points) {\n            for(let i = 0, ii = this.#polylines.length; i < ii; i++){\n                this.#polylines[i].setAttribute(\"points\", points[i].join(\",\"));\n            }\n        }\n        if (rect) {\n            const { transform, width, height } = this.#getTransform(this.data.rotation, rect);\n            const root = g.parentElement;\n            root.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n            g.setAttribute(\"transform\", transform);\n        }\n    }\n    getElementsToTriggerPopup() {\n        return this.#polylines;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass HighlightAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n        this.annotationEditorType = AnnotationEditorType.HIGHLIGHT;\n    }\n    render() {\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"highlightAnnotation\");\n        this._editOnDoubleClick();\n        return this.container;\n    }\n}\nclass UnderlineAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n    }\n    render() {\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"underlineAnnotation\");\n        return this.container;\n    }\n}\nclass SquigglyAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n    }\n    render() {\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"squigglyAnnotation\");\n        return this.container;\n    }\n}\nclass StrikeOutAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n    }\n    render() {\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"strikeoutAnnotation\");\n        return this.container;\n    }\n}\nclass StampAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.annotationEditorType = AnnotationEditorType.STAMP;\n    }\n    render() {\n        this.container.classList.add(\"stampAnnotation\");\n        this.container.setAttribute(\"role\", \"img\");\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this._editOnDoubleClick();\n        return this.container;\n    }\n}\nclass FileAttachmentAnnotationElement extends AnnotationElement {\n    #trigger;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true\n        });\n        this.#trigger = null;\n        const { file } = this.data;\n        this.filename = file.filename;\n        this.content = file.content;\n        this.linkService.eventBus?.dispatch(\"fileattachmentannotation\", {\n            source: this,\n            ...file\n        });\n    }\n    render() {\n        this.container.classList.add(\"fileAttachmentAnnotation\");\n        const { container, data } = this;\n        let trigger;\n        if (data.hasAppearance || data.fillAlpha === 0) {\n            trigger = document.createElement(\"div\");\n        } else {\n            trigger = document.createElement(\"img\");\n            trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? \"paperclip\" : \"pushpin\"}.svg`;\n            if (data.fillAlpha && data.fillAlpha < 1) {\n                trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;\n            }\n        }\n        trigger.addEventListener(\"dblclick\", this.#download.bind(this));\n        this.#trigger = trigger;\n        const { isMac } = util_FeatureTest.platform;\n        container.addEventListener(\"keydown\", (evt)=>{\n            if (evt.key === \"Enter\" && (isMac ? evt.metaKey : evt.ctrlKey)) {\n                this.#download();\n            }\n        });\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        } else {\n            trigger.classList.add(\"popupTriggerArea\");\n        }\n        container.append(trigger);\n        return container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#trigger;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n    #download() {\n        this.downloadManager?.openOrDownloadData(this.content, this.filename);\n    }\n}\nclass AnnotationLayer {\n    #accessibilityManager;\n    #annotationCanvasMap;\n    #editableAnnotations;\n    #structTreeLayer;\n    constructor({ div, accessibilityManager, annotationCanvasMap, annotationEditorUIManager, page, viewport, structTreeLayer }){\n        this.#accessibilityManager = null;\n        this.#annotationCanvasMap = null;\n        this.#editableAnnotations = new Map();\n        this.#structTreeLayer = null;\n        this.div = div;\n        this.#accessibilityManager = accessibilityManager;\n        this.#annotationCanvasMap = annotationCanvasMap;\n        this.#structTreeLayer = structTreeLayer || null;\n        this.page = page;\n        this.viewport = viewport;\n        this.zIndex = 0;\n        this._annotationEditorUIManager = annotationEditorUIManager;\n    }\n    hasEditableAnnotations() {\n        return this.#editableAnnotations.size > 0;\n    }\n    async #appendElement(element, id) {\n        const contentElement = element.firstChild || element;\n        const annotationId = contentElement.id = `${AnnotationPrefix}${id}`;\n        const ariaAttributes = await this.#structTreeLayer?.getAriaAttributes(annotationId);\n        if (ariaAttributes) {\n            for (const [key, value] of ariaAttributes){\n                contentElement.setAttribute(key, value);\n            }\n        }\n        this.div.append(element);\n        this.#accessibilityManager?.moveElementInDOM(this.div, element, contentElement, false);\n    }\n    async render(params) {\n        const { annotations } = params;\n        const layer = this.div;\n        setLayerDimensions(layer, this.viewport);\n        const popupToElements = new Map();\n        const elementParams = {\n            data: null,\n            layer,\n            linkService: params.linkService,\n            downloadManager: params.downloadManager,\n            imageResourcesPath: params.imageResourcesPath || \"\",\n            renderForms: params.renderForms !== false,\n            svgFactory: new DOMSVGFactory(),\n            annotationStorage: params.annotationStorage || new AnnotationStorage(),\n            enableScripting: params.enableScripting === true,\n            hasJSActions: params.hasJSActions,\n            fieldObjects: params.fieldObjects,\n            parent: this,\n            elements: null\n        };\n        for (const data of annotations){\n            if (data.noHTML) {\n                continue;\n            }\n            const isPopupAnnotation = data.annotationType === AnnotationType.POPUP;\n            if (!isPopupAnnotation) {\n                const { width, height } = getRectDims(data.rect);\n                if (width <= 0 || height <= 0) {\n                    continue;\n                }\n            } else {\n                const elements = popupToElements.get(data.id);\n                if (!elements) {\n                    continue;\n                }\n                elementParams.elements = elements;\n            }\n            elementParams.data = data;\n            const element = AnnotationElementFactory.create(elementParams);\n            if (!element.isRenderable) {\n                continue;\n            }\n            if (!isPopupAnnotation && data.popupRef) {\n                const elements = popupToElements.get(data.popupRef);\n                if (!elements) {\n                    popupToElements.set(data.popupRef, [\n                        element\n                    ]);\n                } else {\n                    elements.push(element);\n                }\n            }\n            const rendered = element.render();\n            if (data.hidden) {\n                rendered.style.visibility = \"hidden\";\n            }\n            await this.#appendElement(rendered, data.id);\n            if (element._isEditable) {\n                this.#editableAnnotations.set(element.data.id, element);\n                this._annotationEditorUIManager?.renderAnnotationElement(element);\n            }\n        }\n        this.#setAnnotationCanvasMap();\n    }\n    update({ viewport }) {\n        const layer = this.div;\n        this.viewport = viewport;\n        setLayerDimensions(layer, {\n            rotation: viewport.rotation\n        });\n        this.#setAnnotationCanvasMap();\n        layer.hidden = false;\n    }\n    #setAnnotationCanvasMap() {\n        if (!this.#annotationCanvasMap) {\n            return;\n        }\n        const layer = this.div;\n        for (const [id, canvas] of this.#annotationCanvasMap){\n            const element = layer.querySelector(`[data-annotation-id=\"${id}\"]`);\n            if (!element) {\n                continue;\n            }\n            canvas.className = \"annotationContent\";\n            const { firstChild } = element;\n            if (!firstChild) {\n                element.append(canvas);\n            } else if (firstChild.nodeName === \"CANVAS\") {\n                firstChild.replaceWith(canvas);\n            } else if (!firstChild.classList.contains(\"annotationContent\")) {\n                firstChild.before(canvas);\n            } else {\n                firstChild.after(canvas);\n            }\n        }\n        this.#annotationCanvasMap.clear();\n    }\n    getEditableAnnotations() {\n        return Array.from(this.#editableAnnotations.values());\n    }\n    getEditableAnnotation(id) {\n        return this.#editableAnnotations.get(id);\n    }\n}\n; // ./src/display/editor/freetext.js\nconst EOL_PATTERN = /\\r\\n?|\\n/g;\nclass FreeTextEditor extends AnnotationEditor {\n    #color;\n    #content;\n    #editorDivId;\n    #editModeAC;\n    #fontSize;\n    static{\n        this._freeTextDefaultContent = \"\";\n    }\n    static{\n        this._internalPadding = 0;\n    }\n    static{\n        this._defaultColor = null;\n    }\n    static{\n        this._defaultFontSize = 10;\n    }\n    static get _keyboardManager() {\n        const proto = FreeTextEditor.prototype;\n        const arrowChecker = (self)=>self.isEmpty();\n        const small = AnnotationEditorUIManager.TRANSLATE_SMALL;\n        const big = AnnotationEditorUIManager.TRANSLATE_BIG;\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ctrl+s\",\n                    \"mac+meta+s\",\n                    \"ctrl+p\",\n                    \"mac+meta+p\"\n                ],\n                proto.commitOrRemove,\n                {\n                    bubbles: true\n                }\n            ],\n            [\n                [\n                    \"ctrl+Enter\",\n                    \"mac+meta+Enter\",\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                proto.commitOrRemove\n            ],\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        -small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowLeft\",\n                    \"mac+shift+ArrowLeft\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        -big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowRight\",\n                    \"mac+shift+ArrowRight\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        -small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowUp\",\n                    \"mac+shift+ArrowUp\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        -big\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowDown\",\n                    \"mac+shift+ArrowDown\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        big\n                    ],\n                    checker: arrowChecker\n                }\n            ]\n        ]));\n    }\n    static{\n        this._type = \"freetext\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.FREETEXT;\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"freeTextEditor\"\n        });\n        this.#content = \"\";\n        this.#editorDivId = `${this.id}-editor`;\n        this.#editModeAC = null;\n        this.#color = params.color || FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor;\n        this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize;\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        const style = getComputedStyle(document.documentElement);\n        this._internalPadding = parseFloat(style.getPropertyValue(\"--freetext-padding\"));\n    }\n    static updateDefaultParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.FREETEXT_SIZE:\n                FreeTextEditor._defaultFontSize = value;\n                break;\n            case AnnotationEditorParamsType.FREETEXT_COLOR:\n                FreeTextEditor._defaultColor = value;\n                break;\n        }\n    }\n    updateParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.FREETEXT_SIZE:\n                this.#updateFontSize(value);\n                break;\n            case AnnotationEditorParamsType.FREETEXT_COLOR:\n                this.#updateColor(value);\n                break;\n        }\n    }\n    static get defaultPropertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.FREETEXT_SIZE,\n                FreeTextEditor._defaultFontSize\n            ],\n            [\n                AnnotationEditorParamsType.FREETEXT_COLOR,\n                FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor\n            ]\n        ];\n    }\n    get propertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.FREETEXT_SIZE,\n                this.#fontSize\n            ],\n            [\n                AnnotationEditorParamsType.FREETEXT_COLOR,\n                this.#color\n            ]\n        ];\n    }\n    #updateFontSize(fontSize) {\n        const setFontsize = (size)=>{\n            this.editorDiv.style.fontSize = `calc(${size}px * var(--scale-factor))`;\n            this.translate(0, -(size - this.#fontSize) * this.parentScale);\n            this.#fontSize = size;\n            this.#setEditorDimensions();\n        };\n        const savedFontsize = this.#fontSize;\n        this.addCommands({\n            cmd: setFontsize.bind(this, fontSize),\n            undo: setFontsize.bind(this, savedFontsize),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.FREETEXT_SIZE,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    #updateColor(color) {\n        const setColor = (col)=>{\n            this.#color = this.editorDiv.style.color = col;\n        };\n        const savedColor = this.#color;\n        this.addCommands({\n            cmd: setColor.bind(this, color),\n            undo: setColor.bind(this, savedColor),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.FREETEXT_COLOR,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    _translateEmpty(x, y) {\n        this._uiManager.translateSelectedEditors(x, y, true);\n    }\n    getInitialTranslation() {\n        const scale = this.parentScale;\n        return [\n            -FreeTextEditor._internalPadding * scale,\n            -(FreeTextEditor._internalPadding + this.#fontSize) * scale\n        ];\n    }\n    rebuild() {\n        if (!this.parent) {\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    enableEditMode() {\n        if (this.isInEditMode()) {\n            return;\n        }\n        this.parent.setEditingState(false);\n        this.parent.updateToolbar(AnnotationEditorType.FREETEXT);\n        super.enableEditMode();\n        this.overlayDiv.classList.remove(\"enabled\");\n        this.editorDiv.contentEditable = true;\n        this._isDraggable = false;\n        this.div.removeAttribute(\"aria-activedescendant\");\n        this.#editModeAC = new AbortController();\n        const signal = this._uiManager.combinedSignal(this.#editModeAC);\n        this.editorDiv.addEventListener(\"keydown\", this.editorDivKeydown.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"focus\", this.editorDivFocus.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"blur\", this.editorDivBlur.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"input\", this.editorDivInput.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"paste\", this.editorDivPaste.bind(this), {\n            signal\n        });\n    }\n    disableEditMode() {\n        if (!this.isInEditMode()) {\n            return;\n        }\n        this.parent.setEditingState(true);\n        super.disableEditMode();\n        this.overlayDiv.classList.add(\"enabled\");\n        this.editorDiv.contentEditable = false;\n        this.div.setAttribute(\"aria-activedescendant\", this.#editorDivId);\n        this._isDraggable = true;\n        this.#editModeAC?.abort();\n        this.#editModeAC = null;\n        this.div.focus({\n            preventScroll: true\n        });\n        this.isEditing = false;\n        this.parent.div.classList.add(\"freetextEditing\");\n    }\n    focusin(event) {\n        if (!this._focusEventsAllowed) {\n            return;\n        }\n        super.focusin(event);\n        if (event.target !== this.editorDiv) {\n            this.editorDiv.focus();\n        }\n    }\n    onceAdded(focus) {\n        if (this.width) {\n            return;\n        }\n        this.enableEditMode();\n        if (focus) {\n            this.editorDiv.focus();\n        }\n        if (this._initialOptions?.isCentered) {\n            this.center();\n        }\n        this._initialOptions = null;\n    }\n    isEmpty() {\n        return !this.editorDiv || this.editorDiv.innerText.trim() === \"\";\n    }\n    remove() {\n        this.isEditing = false;\n        if (this.parent) {\n            this.parent.setEditingState(true);\n            this.parent.div.classList.add(\"freetextEditing\");\n        }\n        super.remove();\n    }\n    #extractText() {\n        const buffer = [];\n        this.editorDiv.normalize();\n        let prevChild = null;\n        for (const child of this.editorDiv.childNodes){\n            if (prevChild?.nodeType === Node.TEXT_NODE && child.nodeName === \"BR\") {\n                continue;\n            }\n            buffer.push(FreeTextEditor.#getNodeContent(child));\n            prevChild = child;\n        }\n        return buffer.join(\"\\n\");\n    }\n    #setEditorDimensions() {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        let rect;\n        if (this.isAttachedToDOM) {\n            rect = this.div.getBoundingClientRect();\n        } else {\n            const { currentLayer, div } = this;\n            const savedDisplay = div.style.display;\n            const savedVisibility = div.classList.contains(\"hidden\");\n            div.classList.remove(\"hidden\");\n            div.style.display = \"hidden\";\n            currentLayer.div.append(this.div);\n            rect = div.getBoundingClientRect();\n            div.remove();\n            div.style.display = savedDisplay;\n            div.classList.toggle(\"hidden\", savedVisibility);\n        }\n        if (this.rotation % 180 === this.parentRotation % 180) {\n            this.width = rect.width / parentWidth;\n            this.height = rect.height / parentHeight;\n        } else {\n            this.width = rect.height / parentWidth;\n            this.height = rect.width / parentHeight;\n        }\n        this.fixAndSetPosition();\n    }\n    commit() {\n        if (!this.isInEditMode()) {\n            return;\n        }\n        super.commit();\n        this.disableEditMode();\n        const savedText = this.#content;\n        const newText = this.#content = this.#extractText().trimEnd();\n        if (savedText === newText) {\n            return;\n        }\n        const setText = (text)=>{\n            this.#content = text;\n            if (!text) {\n                this.remove();\n                return;\n            }\n            this.#setContent();\n            this._uiManager.rebuild(this);\n            this.#setEditorDimensions();\n        };\n        this.addCommands({\n            cmd: ()=>{\n                setText(newText);\n            },\n            undo: ()=>{\n                setText(savedText);\n            },\n            mustExec: false\n        });\n        this.#setEditorDimensions();\n    }\n    shouldGetKeyboardEvents() {\n        return this.isInEditMode();\n    }\n    enterInEditMode() {\n        this.enableEditMode();\n        this.editorDiv.focus();\n    }\n    dblclick(event) {\n        this.enterInEditMode();\n    }\n    keydown(event) {\n        if (event.target === this.div && event.key === \"Enter\") {\n            this.enterInEditMode();\n            event.preventDefault();\n        }\n    }\n    editorDivKeydown(event) {\n        FreeTextEditor._keyboardManager.exec(this, event);\n    }\n    editorDivFocus(event) {\n        this.isEditing = true;\n    }\n    editorDivBlur(event) {\n        this.isEditing = false;\n    }\n    editorDivInput(event) {\n        this.parent.div.classList.toggle(\"freetextEditing\", this.isEmpty());\n    }\n    disableEditing() {\n        this.editorDiv.setAttribute(\"role\", \"comment\");\n        this.editorDiv.removeAttribute(\"aria-multiline\");\n    }\n    enableEditing() {\n        this.editorDiv.setAttribute(\"role\", \"textbox\");\n        this.editorDiv.setAttribute(\"aria-multiline\", true);\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        if (this.width) {\n            baseX = this.x;\n            baseY = this.y;\n        }\n        super.render();\n        this.editorDiv = document.createElement(\"div\");\n        this.editorDiv.className = \"internal\";\n        this.editorDiv.setAttribute(\"id\", this.#editorDivId);\n        this.editorDiv.setAttribute(\"data-l10n-id\", \"pdfjs-free-text2\");\n        this.editorDiv.setAttribute(\"data-l10n-attrs\", \"default-content\");\n        this.enableEditing();\n        this.editorDiv.contentEditable = true;\n        const { style } = this.editorDiv;\n        style.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`;\n        style.color = this.#color;\n        this.div.append(this.editorDiv);\n        this.overlayDiv = document.createElement(\"div\");\n        this.overlayDiv.classList.add(\"overlay\", \"enabled\");\n        this.div.append(this.overlayDiv);\n        bindEvents(this, this.div, [\n            \"dblclick\",\n            \"keydown\"\n        ]);\n        if (this.width) {\n            const [parentWidth, parentHeight] = this.parentDimensions;\n            if (this.annotationElementId) {\n                const { position } = this._initialData;\n                let [tx, ty] = this.getInitialTranslation();\n                [tx, ty] = this.pageTranslationToScreen(tx, ty);\n                const [pageWidth, pageHeight] = this.pageDimensions;\n                const [pageX, pageY] = this.pageTranslation;\n                let posX, posY;\n                switch(this.rotation){\n                    case 0:\n                        posX = baseX + (position[0] - pageX) / pageWidth;\n                        posY = baseY + this.height - (position[1] - pageY) / pageHeight;\n                        break;\n                    case 90:\n                        posX = baseX + (position[0] - pageX) / pageWidth;\n                        posY = baseY - (position[1] - pageY) / pageHeight;\n                        [tx, ty] = [\n                            ty,\n                            -tx\n                        ];\n                        break;\n                    case 180:\n                        posX = baseX - this.width + (position[0] - pageX) / pageWidth;\n                        posY = baseY - (position[1] - pageY) / pageHeight;\n                        [tx, ty] = [\n                            -tx,\n                            -ty\n                        ];\n                        break;\n                    case 270:\n                        posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;\n                        posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;\n                        [tx, ty] = [\n                            -ty,\n                            tx\n                        ];\n                        break;\n                }\n                this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);\n            } else {\n                this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n            }\n            this.#setContent();\n            this._isDraggable = true;\n            this.editorDiv.contentEditable = false;\n        } else {\n            this._isDraggable = false;\n            this.editorDiv.contentEditable = true;\n        }\n        return this.div;\n    }\n    static #getNodeContent(node) {\n        return (node.nodeType === Node.TEXT_NODE ? node.nodeValue : node.innerText).replaceAll(EOL_PATTERN, \"\");\n    }\n    editorDivPaste(event) {\n        const clipboardData = event.clipboardData || window.clipboardData;\n        const { types } = clipboardData;\n        if (types.length === 1 && types[0] === \"text/plain\") {\n            return;\n        }\n        event.preventDefault();\n        const paste = FreeTextEditor.#deserializeContent(clipboardData.getData(\"text\") || \"\").replaceAll(EOL_PATTERN, \"\\n\");\n        if (!paste) {\n            return;\n        }\n        const selection = window.getSelection();\n        if (!selection.rangeCount) {\n            return;\n        }\n        this.editorDiv.normalize();\n        selection.deleteFromDocument();\n        const range = selection.getRangeAt(0);\n        if (!paste.includes(\"\\n\")) {\n            range.insertNode(document.createTextNode(paste));\n            this.editorDiv.normalize();\n            selection.collapseToStart();\n            return;\n        }\n        const { startContainer, startOffset } = range;\n        const bufferBefore = [];\n        const bufferAfter = [];\n        if (startContainer.nodeType === Node.TEXT_NODE) {\n            const parent = startContainer.parentElement;\n            bufferAfter.push(startContainer.nodeValue.slice(startOffset).replaceAll(EOL_PATTERN, \"\"));\n            if (parent !== this.editorDiv) {\n                let buffer = bufferBefore;\n                for (const child of this.editorDiv.childNodes){\n                    if (child === parent) {\n                        buffer = bufferAfter;\n                        continue;\n                    }\n                    buffer.push(FreeTextEditor.#getNodeContent(child));\n                }\n            }\n            bufferBefore.push(startContainer.nodeValue.slice(0, startOffset).replaceAll(EOL_PATTERN, \"\"));\n        } else if (startContainer === this.editorDiv) {\n            let buffer = bufferBefore;\n            let i = 0;\n            for (const child of this.editorDiv.childNodes){\n                if (i++ === startOffset) {\n                    buffer = bufferAfter;\n                }\n                buffer.push(FreeTextEditor.#getNodeContent(child));\n            }\n        }\n        this.#content = `${bufferBefore.join(\"\\n\")}${paste}${bufferAfter.join(\"\\n\")}`;\n        this.#setContent();\n        const newRange = new Range();\n        let beforeLength = bufferBefore.reduce((acc, line)=>acc + line.length, 0);\n        for (const { firstChild } of this.editorDiv.childNodes){\n            if (firstChild.nodeType === Node.TEXT_NODE) {\n                const length = firstChild.nodeValue.length;\n                if (beforeLength <= length) {\n                    newRange.setStart(firstChild, beforeLength);\n                    newRange.setEnd(firstChild, beforeLength);\n                    break;\n                }\n                beforeLength -= length;\n            }\n        }\n        selection.removeAllRanges();\n        selection.addRange(newRange);\n    }\n    #setContent() {\n        this.editorDiv.replaceChildren();\n        if (!this.#content) {\n            return;\n        }\n        for (const line of this.#content.split(\"\\n\")){\n            const div = document.createElement(\"div\");\n            div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n            this.editorDiv.append(div);\n        }\n    }\n    #serializeContent() {\n        return this.#content.replaceAll(\"\\xa0\", \" \");\n    }\n    static #deserializeContent(content) {\n        return content.replaceAll(\" \", \"\\xa0\");\n    }\n    get contentDiv() {\n        return this.editorDiv;\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof FreeTextAnnotationElement) {\n            const { data: { defaultAppearanceData: { fontSize, fontColor }, rect, rotation, id, popupRef }, textContent, textPosition, parent: { page: { pageNumber } } } = data;\n            if (!textContent || textContent.length === 0) {\n                return null;\n            }\n            initialData = data = {\n                annotationType: AnnotationEditorType.FREETEXT,\n                color: Array.from(fontColor),\n                fontSize,\n                value: textContent.join(\"\\n\"),\n                position: textPosition,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                id,\n                deleted: false,\n                popupRef\n            };\n        }\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.#fontSize = data.fontSize;\n        editor.#color = Util.makeHexColor(...data.color);\n        editor.#content = FreeTextEditor.#deserializeContent(data.value);\n        editor.annotationElementId = data.id || null;\n        editor._initialData = initialData;\n        return editor;\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const padding = FreeTextEditor._internalPadding * this.parentScale;\n        const rect = this.getRect(padding, padding);\n        const color = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.#color);\n        const serialized = {\n            annotationType: AnnotationEditorType.FREETEXT,\n            color,\n            fontSize: this.#fontSize,\n            value: this.#serializeContent(),\n            pageIndex: this.pageIndex,\n            rect,\n            rotation: this.rotation,\n            structTreeParentId: this._structTreeParentId\n        };\n        if (isForCopying) {\n            return serialized;\n        }\n        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n            return null;\n        }\n        serialized.id = this.annotationElementId;\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { value, fontSize, color, pageIndex } = this._initialData;\n        return this._hasBeenMoved || serialized.value !== value || serialized.fontSize !== fontSize || serialized.color.some((c, i)=>c !== color[i]) || serialized.pageIndex !== pageIndex;\n    }\n    renderAnnotationElement(annotation) {\n        const content = super.renderAnnotationElement(annotation);\n        if (this.deleted) {\n            return content;\n        }\n        const { style } = content;\n        style.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`;\n        style.color = this.#color;\n        content.replaceChildren();\n        for (const line of this.#content.split(\"\\n\")){\n            const div = document.createElement(\"div\");\n            div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n            content.append(div);\n        }\n        const padding = FreeTextEditor._internalPadding * this.parentScale;\n        annotation.updateEdited({\n            rect: this.getRect(padding, padding),\n            popupContent: this.#content\n        });\n        return content;\n    }\n    resetAnnotationElement(annotation) {\n        super.resetAnnotationElement(annotation);\n        annotation.resetEdited();\n    }\n}\n; // ./src/display/editor/drawers/outline.js\nclass Outline {\n    static{\n        this.PRECISION = 1e-4;\n    }\n    toSVGPath() {\n        unreachable(\"Abstract method `toSVGPath` must be implemented.\");\n    }\n    get box() {\n        unreachable(\"Abstract getter `box` must be implemented.\");\n    }\n    serialize(_bbox, _rotation) {\n        unreachable(\"Abstract method `serialize` must be implemented.\");\n    }\n    static _rescale(src, tx, ty, sx, sy, dest) {\n        dest ||= new Float32Array(src.length);\n        for(let i = 0, ii = src.length; i < ii; i += 2){\n            dest[i] = tx + src[i] * sx;\n            dest[i + 1] = ty + src[i + 1] * sy;\n        }\n        return dest;\n    }\n    static _rescaleAndSwap(src, tx, ty, sx, sy, dest) {\n        dest ||= new Float32Array(src.length);\n        for(let i = 0, ii = src.length; i < ii; i += 2){\n            dest[i] = tx + src[i + 1] * sx;\n            dest[i + 1] = ty + src[i] * sy;\n        }\n        return dest;\n    }\n    static _translate(src, tx, ty, dest) {\n        dest ||= new Float32Array(src.length);\n        for(let i = 0, ii = src.length; i < ii; i += 2){\n            dest[i] = tx + src[i];\n            dest[i + 1] = ty + src[i + 1];\n        }\n        return dest;\n    }\n    static svgRound(x) {\n        return Math.round(x * 10000);\n    }\n    static _normalizePoint(x, y, parentWidth, parentHeight, rotation) {\n        switch(rotation){\n            case 90:\n                return [\n                    1 - y / parentWidth,\n                    x / parentHeight\n                ];\n            case 180:\n                return [\n                    1 - x / parentWidth,\n                    1 - y / parentHeight\n                ];\n            case 270:\n                return [\n                    y / parentWidth,\n                    1 - x / parentHeight\n                ];\n            default:\n                return [\n                    x / parentWidth,\n                    y / parentHeight\n                ];\n        }\n    }\n    static _normalizePagePoint(x, y, rotation) {\n        switch(rotation){\n            case 90:\n                return [\n                    1 - y,\n                    x\n                ];\n            case 180:\n                return [\n                    1 - x,\n                    1 - y\n                ];\n            case 270:\n                return [\n                    y,\n                    1 - x\n                ];\n            default:\n                return [\n                    x,\n                    y\n                ];\n        }\n    }\n    static createBezierPoints(x1, y1, x2, y2, x3, y3) {\n        return [\n            (x1 + 5 * x2) / 6,\n            (y1 + 5 * y2) / 6,\n            (5 * x2 + x3) / 6,\n            (5 * y2 + y3) / 6,\n            (x2 + x3) / 2,\n            (y2 + y3) / 2\n        ];\n    }\n}\n; // ./src/display/editor/drawers/freedraw.js\nclass FreeDrawOutliner {\n    #box;\n    #bottom;\n    #innerMargin;\n    #isLTR;\n    #top;\n    #last;\n    #lastX;\n    #lastY;\n    #min;\n    #min_dist;\n    #scaleFactor;\n    #thickness;\n    #points;\n    static #MIN_DIST = 8;\n    static #MIN_DIFF = 2;\n    static #MIN = FreeDrawOutliner.#MIN_DIST + FreeDrawOutliner.#MIN_DIFF;\n    constructor({ x, y }, box, scaleFactor, thickness, isLTR, innerMargin = 0){\n        this.#bottom = [];\n        this.#top = [];\n        this.#last = new Float32Array(18);\n        this.#points = [];\n        this.#box = box;\n        this.#thickness = thickness * scaleFactor;\n        this.#isLTR = isLTR;\n        this.#last.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            x,\n            y\n        ], 6);\n        this.#innerMargin = innerMargin;\n        this.#min_dist = FreeDrawOutliner.#MIN_DIST * scaleFactor;\n        this.#min = FreeDrawOutliner.#MIN * scaleFactor;\n        this.#scaleFactor = scaleFactor;\n        this.#points.push(x, y);\n    }\n    isEmpty() {\n        return isNaN(this.#last[8]);\n    }\n    #getLastCoords() {\n        const lastTop = this.#last.subarray(4, 6);\n        const lastBottom = this.#last.subarray(16, 18);\n        const [x, y, width, height] = this.#box;\n        return [\n            (this.#lastX + (lastTop[0] - lastBottom[0]) / 2 - x) / width,\n            (this.#lastY + (lastTop[1] - lastBottom[1]) / 2 - y) / height,\n            (this.#lastX + (lastBottom[0] - lastTop[0]) / 2 - x) / width,\n            (this.#lastY + (lastBottom[1] - lastTop[1]) / 2 - y) / height\n        ];\n    }\n    add({ x, y }) {\n        this.#lastX = x;\n        this.#lastY = y;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        let [x1, y1, x2, y2] = this.#last.subarray(8, 12);\n        const diffX = x - x2;\n        const diffY = y - y2;\n        const d = Math.hypot(diffX, diffY);\n        if (d < this.#min) {\n            return false;\n        }\n        const diffD = d - this.#min_dist;\n        const K = diffD / d;\n        const shiftX = K * diffX;\n        const shiftY = K * diffY;\n        let x0 = x1;\n        let y0 = y1;\n        x1 = x2;\n        y1 = y2;\n        x2 += shiftX;\n        y2 += shiftY;\n        this.#points?.push(x, y);\n        const nX = -shiftY / diffD;\n        const nY = shiftX / diffD;\n        const thX = nX * this.#thickness;\n        const thY = nY * this.#thickness;\n        this.#last.set(this.#last.subarray(2, 8), 0);\n        this.#last.set([\n            x2 + thX,\n            y2 + thY\n        ], 4);\n        this.#last.set(this.#last.subarray(14, 18), 12);\n        this.#last.set([\n            x2 - thX,\n            y2 - thY\n        ], 16);\n        if (isNaN(this.#last[6])) {\n            if (this.#top.length === 0) {\n                this.#last.set([\n                    x1 + thX,\n                    y1 + thY\n                ], 2);\n                this.#top.push(NaN, NaN, NaN, NaN, (x1 + thX - layerX) / layerWidth, (y1 + thY - layerY) / layerHeight);\n                this.#last.set([\n                    x1 - thX,\n                    y1 - thY\n                ], 14);\n                this.#bottom.push(NaN, NaN, NaN, NaN, (x1 - thX - layerX) / layerWidth, (y1 - thY - layerY) / layerHeight);\n            }\n            this.#last.set([\n                x0,\n                y0,\n                x1,\n                y1,\n                x2,\n                y2\n            ], 6);\n            return !this.isEmpty();\n        }\n        this.#last.set([\n            x0,\n            y0,\n            x1,\n            y1,\n            x2,\n            y2\n        ], 6);\n        const angle = Math.abs(Math.atan2(y0 - y1, x0 - x1) - Math.atan2(shiftY, shiftX));\n        if (angle < Math.PI / 2) {\n            [x1, y1, x2, y2] = this.#last.subarray(2, 6);\n            this.#top.push(NaN, NaN, NaN, NaN, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n            [x1, y1, x0, y0] = this.#last.subarray(14, 18);\n            this.#bottom.push(NaN, NaN, NaN, NaN, ((x0 + x1) / 2 - layerX) / layerWidth, ((y0 + y1) / 2 - layerY) / layerHeight);\n            return true;\n        }\n        [x0, y0, x1, y1, x2, y2] = this.#last.subarray(0, 6);\n        this.#top.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n        [x2, y2, x1, y1, x0, y0] = this.#last.subarray(12, 18);\n        this.#bottom.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n        return true;\n    }\n    toSVGPath() {\n        if (this.isEmpty()) {\n            return \"\";\n        }\n        const top = this.#top;\n        const bottom = this.#bottom;\n        if (isNaN(this.#last[6]) && !this.isEmpty()) {\n            return this.#toSVGPathTwoPoints();\n        }\n        const buffer = [];\n        buffer.push(`M${top[4]} ${top[5]}`);\n        for(let i = 6; i < top.length; i += 6){\n            if (isNaN(top[i])) {\n                buffer.push(`L${top[i + 4]} ${top[i + 5]}`);\n            } else {\n                buffer.push(`C${top[i]} ${top[i + 1]} ${top[i + 2]} ${top[i + 3]} ${top[i + 4]} ${top[i + 5]}`);\n            }\n        }\n        this.#toSVGPathEnd(buffer);\n        for(let i = bottom.length - 6; i >= 6; i -= 6){\n            if (isNaN(bottom[i])) {\n                buffer.push(`L${bottom[i + 4]} ${bottom[i + 5]}`);\n            } else {\n                buffer.push(`C${bottom[i]} ${bottom[i + 1]} ${bottom[i + 2]} ${bottom[i + 3]} ${bottom[i + 4]} ${bottom[i + 5]}`);\n            }\n        }\n        this.#toSVGPathStart(buffer);\n        return buffer.join(\" \");\n    }\n    #toSVGPathTwoPoints() {\n        const [x, y, width, height] = this.#box;\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        return `M${(this.#last[2] - x) / width} ${(this.#last[3] - y) / height} L${(this.#last[4] - x) / width} ${(this.#last[5] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(this.#last[16] - x) / width} ${(this.#last[17] - y) / height} L${(this.#last[14] - x) / width} ${(this.#last[15] - y) / height} Z`;\n    }\n    #toSVGPathStart(buffer) {\n        const bottom = this.#bottom;\n        buffer.push(`L${bottom[4]} ${bottom[5]} Z`);\n    }\n    #toSVGPathEnd(buffer) {\n        const [x, y, width, height] = this.#box;\n        const lastTop = this.#last.subarray(4, 6);\n        const lastBottom = this.#last.subarray(16, 18);\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        buffer.push(`L${(lastTop[0] - x) / width} ${(lastTop[1] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(lastBottom[0] - x) / width} ${(lastBottom[1] - y) / height}`);\n    }\n    newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {\n        return new FreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR);\n    }\n    getOutlines() {\n        const top = this.#top;\n        const bottom = this.#bottom;\n        const last = this.#last;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const points = new Float32Array((this.#points?.length ?? 0) + 2);\n        for(let i = 0, ii = points.length - 2; i < ii; i += 2){\n            points[i] = (this.#points[i] - layerX) / layerWidth;\n            points[i + 1] = (this.#points[i + 1] - layerY) / layerHeight;\n        }\n        points[points.length - 2] = (this.#lastX - layerX) / layerWidth;\n        points[points.length - 1] = (this.#lastY - layerY) / layerHeight;\n        if (isNaN(last[6]) && !this.isEmpty()) {\n            return this.#getOutlineTwoPoints(points);\n        }\n        const outline = new Float32Array(this.#top.length + 24 + this.#bottom.length);\n        let N = top.length;\n        for(let i = 0; i < N; i += 2){\n            if (isNaN(top[i])) {\n                outline[i] = outline[i + 1] = NaN;\n                continue;\n            }\n            outline[i] = top[i];\n            outline[i + 1] = top[i + 1];\n        }\n        N = this.#getOutlineEnd(outline, N);\n        for(let i = bottom.length - 6; i >= 6; i -= 6){\n            for(let j = 0; j < 6; j += 2){\n                if (isNaN(bottom[i + j])) {\n                    outline[N] = outline[N + 1] = NaN;\n                    N += 2;\n                    continue;\n                }\n                outline[N] = bottom[i + j];\n                outline[N + 1] = bottom[i + j + 1];\n                N += 2;\n            }\n        }\n        this.#getOutlineStart(outline, N);\n        return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);\n    }\n    #getOutlineTwoPoints(points) {\n        const last = this.#last;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        const outline = new Float32Array(36);\n        outline.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[2] - layerX) / layerWidth,\n            (last[3] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[4] - layerX) / layerWidth,\n            (last[5] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastTopX,\n            lastTopY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastBottomX,\n            lastBottomY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[16] - layerX) / layerWidth,\n            (last[17] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[14] - layerX) / layerWidth,\n            (last[15] - layerY) / layerHeight\n        ], 0);\n        return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);\n    }\n    #getOutlineStart(outline, pos) {\n        const bottom = this.#bottom;\n        outline.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            bottom[4],\n            bottom[5]\n        ], pos);\n        return pos += 6;\n    }\n    #getOutlineEnd(outline, pos) {\n        const lastTop = this.#last.subarray(4, 6);\n        const lastBottom = this.#last.subarray(16, 18);\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        outline.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (lastTop[0] - layerX) / layerWidth,\n            (lastTop[1] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastTopX,\n            lastTopY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastBottomX,\n            lastBottomY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (lastBottom[0] - layerX) / layerWidth,\n            (lastBottom[1] - layerY) / layerHeight\n        ], pos);\n        return pos += 24;\n    }\n}\nclass FreeDrawOutline extends Outline {\n    #box;\n    #bbox;\n    #innerMargin;\n    #isLTR;\n    #points;\n    #scaleFactor;\n    #outline;\n    constructor(outline, points, box, scaleFactor, innerMargin, isLTR){\n        super();\n        this.#bbox = new Float32Array(4);\n        this.#outline = outline;\n        this.#points = points;\n        this.#box = box;\n        this.#scaleFactor = scaleFactor;\n        this.#innerMargin = innerMargin;\n        this.#isLTR = isLTR;\n        this.lastPoint = [\n            NaN,\n            NaN\n        ];\n        this.#computeMinMax(isLTR);\n        const [x, y, width, height] = this.#bbox;\n        for(let i = 0, ii = outline.length; i < ii; i += 2){\n            outline[i] = (outline[i] - x) / width;\n            outline[i + 1] = (outline[i + 1] - y) / height;\n        }\n        for(let i = 0, ii = points.length; i < ii; i += 2){\n            points[i] = (points[i] - x) / width;\n            points[i + 1] = (points[i + 1] - y) / height;\n        }\n    }\n    toSVGPath() {\n        const buffer = [\n            `M${this.#outline[4]} ${this.#outline[5]}`\n        ];\n        for(let i = 6, ii = this.#outline.length; i < ii; i += 6){\n            if (isNaN(this.#outline[i])) {\n                buffer.push(`L${this.#outline[i + 4]} ${this.#outline[i + 5]}`);\n                continue;\n            }\n            buffer.push(`C${this.#outline[i]} ${this.#outline[i + 1]} ${this.#outline[i + 2]} ${this.#outline[i + 3]} ${this.#outline[i + 4]} ${this.#outline[i + 5]}`);\n        }\n        buffer.push(\"Z\");\n        return buffer.join(\" \");\n    }\n    serialize([blX, blY, trX, trY], rotation) {\n        const width = trX - blX;\n        const height = trY - blY;\n        let outline;\n        let points;\n        switch(rotation){\n            case 0:\n                outline = Outline._rescale(this.#outline, blX, trY, width, -height);\n                points = Outline._rescale(this.#points, blX, trY, width, -height);\n                break;\n            case 90:\n                outline = Outline._rescaleAndSwap(this.#outline, blX, blY, width, height);\n                points = Outline._rescaleAndSwap(this.#points, blX, blY, width, height);\n                break;\n            case 180:\n                outline = Outline._rescale(this.#outline, trX, blY, -width, height);\n                points = Outline._rescale(this.#points, trX, blY, -width, height);\n                break;\n            case 270:\n                outline = Outline._rescaleAndSwap(this.#outline, trX, trY, -width, -height);\n                points = Outline._rescaleAndSwap(this.#points, trX, trY, -width, -height);\n                break;\n        }\n        return {\n            outline: Array.from(outline),\n            points: [\n                Array.from(points)\n            ]\n        };\n    }\n    #computeMinMax(isLTR) {\n        const outline = this.#outline;\n        let lastX = outline[4];\n        let lastY = outline[5];\n        let minX = lastX;\n        let minY = lastY;\n        let maxX = lastX;\n        let maxY = lastY;\n        let lastPointX = lastX;\n        let lastPointY = lastY;\n        const ltrCallback = isLTR ? Math.max : Math.min;\n        for(let i = 6, ii = outline.length; i < ii; i += 6){\n            if (isNaN(outline[i])) {\n                minX = Math.min(minX, outline[i + 4]);\n                minY = Math.min(minY, outline[i + 5]);\n                maxX = Math.max(maxX, outline[i + 4]);\n                maxY = Math.max(maxY, outline[i + 5]);\n                if (lastPointY < outline[i + 5]) {\n                    lastPointX = outline[i + 4];\n                    lastPointY = outline[i + 5];\n                } else if (lastPointY === outline[i + 5]) {\n                    lastPointX = ltrCallback(lastPointX, outline[i + 4]);\n                }\n            } else {\n                const bbox = Util.bezierBoundingBox(lastX, lastY, ...outline.slice(i, i + 6));\n                minX = Math.min(minX, bbox[0]);\n                minY = Math.min(minY, bbox[1]);\n                maxX = Math.max(maxX, bbox[2]);\n                maxY = Math.max(maxY, bbox[3]);\n                if (lastPointY < bbox[3]) {\n                    lastPointX = bbox[2];\n                    lastPointY = bbox[3];\n                } else if (lastPointY === bbox[3]) {\n                    lastPointX = ltrCallback(lastPointX, bbox[2]);\n                }\n            }\n            lastX = outline[i + 4];\n            lastY = outline[i + 5];\n        }\n        const bbox = this.#bbox;\n        bbox[0] = minX - this.#innerMargin;\n        bbox[1] = minY - this.#innerMargin;\n        bbox[2] = maxX - minX + 2 * this.#innerMargin;\n        bbox[3] = maxY - minY + 2 * this.#innerMargin;\n        this.lastPoint = [\n            lastPointX,\n            lastPointY\n        ];\n    }\n    get box() {\n        return this.#bbox;\n    }\n    newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {\n        return new FreeDrawOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);\n    }\n    getNewOutline(thickness, innerMargin) {\n        const [x, y, width, height] = this.#bbox;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const sx = width * layerWidth;\n        const sy = height * layerHeight;\n        const tx = x * layerWidth + layerX;\n        const ty = y * layerHeight + layerY;\n        const outliner = this.newOutliner({\n            x: this.#points[0] * sx + tx,\n            y: this.#points[1] * sy + ty\n        }, this.#box, this.#scaleFactor, thickness, this.#isLTR, innerMargin ?? this.#innerMargin);\n        for(let i = 2; i < this.#points.length; i += 2){\n            outliner.add({\n                x: this.#points[i] * sx + tx,\n                y: this.#points[i + 1] * sy + ty\n            });\n        }\n        return outliner.getOutlines();\n    }\n}\n; // ./src/display/editor/drawers/highlight.js\nclass HighlightOutliner {\n    #box;\n    #lastPoint;\n    #verticalEdges;\n    #intervals;\n    constructor(boxes, borderWidth = 0, innerMargin = 0, isLTR = true){\n        this.#verticalEdges = [];\n        this.#intervals = [];\n        let minX = Infinity;\n        let maxX = -Infinity;\n        let minY = Infinity;\n        let maxY = -Infinity;\n        const NUMBER_OF_DIGITS = 4;\n        const EPSILON = 10 ** -NUMBER_OF_DIGITS;\n        for (const { x, y, width, height } of boxes){\n            const x1 = Math.floor((x - borderWidth) / EPSILON) * EPSILON;\n            const x2 = Math.ceil((x + width + borderWidth) / EPSILON) * EPSILON;\n            const y1 = Math.floor((y - borderWidth) / EPSILON) * EPSILON;\n            const y2 = Math.ceil((y + height + borderWidth) / EPSILON) * EPSILON;\n            const left = [\n                x1,\n                y1,\n                y2,\n                true\n            ];\n            const right = [\n                x2,\n                y1,\n                y2,\n                false\n            ];\n            this.#verticalEdges.push(left, right);\n            minX = Math.min(minX, x1);\n            maxX = Math.max(maxX, x2);\n            minY = Math.min(minY, y1);\n            maxY = Math.max(maxY, y2);\n        }\n        const bboxWidth = maxX - minX + 2 * innerMargin;\n        const bboxHeight = maxY - minY + 2 * innerMargin;\n        const shiftedMinX = minX - innerMargin;\n        const shiftedMinY = minY - innerMargin;\n        const lastEdge = this.#verticalEdges.at(isLTR ? -1 : -2);\n        const lastPoint = [\n            lastEdge[0],\n            lastEdge[2]\n        ];\n        for (const edge of this.#verticalEdges){\n            const [x, y1, y2] = edge;\n            edge[0] = (x - shiftedMinX) / bboxWidth;\n            edge[1] = (y1 - shiftedMinY) / bboxHeight;\n            edge[2] = (y2 - shiftedMinY) / bboxHeight;\n        }\n        this.#box = new Float32Array([\n            shiftedMinX,\n            shiftedMinY,\n            bboxWidth,\n            bboxHeight\n        ]);\n        this.#lastPoint = lastPoint;\n    }\n    getOutlines() {\n        this.#verticalEdges.sort((a, b)=>a[0] - b[0] || a[1] - b[1] || a[2] - b[2]);\n        const outlineVerticalEdges = [];\n        for (const edge of this.#verticalEdges){\n            if (edge[3]) {\n                outlineVerticalEdges.push(...this.#breakEdge(edge));\n                this.#insert(edge);\n            } else {\n                this.#remove(edge);\n                outlineVerticalEdges.push(...this.#breakEdge(edge));\n            }\n        }\n        return this.#getOutlines(outlineVerticalEdges);\n    }\n    #getOutlines(outlineVerticalEdges) {\n        const edges = [];\n        const allEdges = new Set();\n        for (const edge of outlineVerticalEdges){\n            const [x, y1, y2] = edge;\n            edges.push([\n                x,\n                y1,\n                edge\n            ], [\n                x,\n                y2,\n                edge\n            ]);\n        }\n        edges.sort((a, b)=>a[1] - b[1] || a[0] - b[0]);\n        for(let i = 0, ii = edges.length; i < ii; i += 2){\n            const edge1 = edges[i][2];\n            const edge2 = edges[i + 1][2];\n            edge1.push(edge2);\n            edge2.push(edge1);\n            allEdges.add(edge1);\n            allEdges.add(edge2);\n        }\n        const outlines = [];\n        let outline;\n        while(allEdges.size > 0){\n            const edge = allEdges.values().next().value;\n            let [x, y1, y2, edge1, edge2] = edge;\n            allEdges.delete(edge);\n            let lastPointX = x;\n            let lastPointY = y1;\n            outline = [\n                x,\n                y2\n            ];\n            outlines.push(outline);\n            while(true){\n                let e;\n                if (allEdges.has(edge1)) {\n                    e = edge1;\n                } else if (allEdges.has(edge2)) {\n                    e = edge2;\n                } else {\n                    break;\n                }\n                allEdges.delete(e);\n                [x, y1, y2, edge1, edge2] = e;\n                if (lastPointX !== x) {\n                    outline.push(lastPointX, lastPointY, x, lastPointY === y1 ? y1 : y2);\n                    lastPointX = x;\n                }\n                lastPointY = lastPointY === y1 ? y2 : y1;\n            }\n            outline.push(lastPointX, lastPointY);\n        }\n        return new HighlightOutline(outlines, this.#box, this.#lastPoint);\n    }\n    #binarySearch(y) {\n        const array = this.#intervals;\n        let start = 0;\n        let end = array.length - 1;\n        while(start <= end){\n            const middle = start + end >> 1;\n            const y1 = array[middle][0];\n            if (y1 === y) {\n                return middle;\n            }\n            if (y1 < y) {\n                start = middle + 1;\n            } else {\n                end = middle - 1;\n            }\n        }\n        return end + 1;\n    }\n    #insert([, y1, y2]) {\n        const index = this.#binarySearch(y1);\n        this.#intervals.splice(index, 0, [\n            y1,\n            y2\n        ]);\n    }\n    #remove([, y1, y2]) {\n        const index = this.#binarySearch(y1);\n        for(let i = index; i < this.#intervals.length; i++){\n            const [start, end] = this.#intervals[i];\n            if (start !== y1) {\n                break;\n            }\n            if (start === y1 && end === y2) {\n                this.#intervals.splice(i, 1);\n                return;\n            }\n        }\n        for(let i = index - 1; i >= 0; i--){\n            const [start, end] = this.#intervals[i];\n            if (start !== y1) {\n                break;\n            }\n            if (start === y1 && end === y2) {\n                this.#intervals.splice(i, 1);\n                return;\n            }\n        }\n    }\n    #breakEdge(edge) {\n        const [x, y1, y2] = edge;\n        const results = [\n            [\n                x,\n                y1,\n                y2\n            ]\n        ];\n        const index = this.#binarySearch(y2);\n        for(let i = 0; i < index; i++){\n            const [start, end] = this.#intervals[i];\n            for(let j = 0, jj = results.length; j < jj; j++){\n                const [, y3, y4] = results[j];\n                if (end <= y3 || y4 <= start) {\n                    continue;\n                }\n                if (y3 >= start) {\n                    if (y4 > end) {\n                        results[j][1] = end;\n                    } else {\n                        if (jj === 1) {\n                            return [];\n                        }\n                        results.splice(j, 1);\n                        j--;\n                        jj--;\n                    }\n                    continue;\n                }\n                results[j][2] = start;\n                if (y4 > end) {\n                    results.push([\n                        x,\n                        end,\n                        y4\n                    ]);\n                }\n            }\n        }\n        return results;\n    }\n}\nclass HighlightOutline extends Outline {\n    #box;\n    #outlines;\n    constructor(outlines, box, lastPoint){\n        super();\n        this.#outlines = outlines;\n        this.#box = box;\n        this.lastPoint = lastPoint;\n    }\n    toSVGPath() {\n        const buffer = [];\n        for (const polygon of this.#outlines){\n            let [prevX, prevY] = polygon;\n            buffer.push(`M${prevX} ${prevY}`);\n            for(let i = 2; i < polygon.length; i += 2){\n                const x = polygon[i];\n                const y = polygon[i + 1];\n                if (x === prevX) {\n                    buffer.push(`V${y}`);\n                    prevY = y;\n                } else if (y === prevY) {\n                    buffer.push(`H${x}`);\n                    prevX = x;\n                }\n            }\n            buffer.push(\"Z\");\n        }\n        return buffer.join(\" \");\n    }\n    serialize([blX, blY, trX, trY], _rotation) {\n        const outlines = [];\n        const width = trX - blX;\n        const height = trY - blY;\n        for (const outline of this.#outlines){\n            const points = new Array(outline.length);\n            for(let i = 0; i < outline.length; i += 2){\n                points[i] = blX + outline[i] * width;\n                points[i + 1] = trY - outline[i + 1] * height;\n            }\n            outlines.push(points);\n        }\n        return outlines;\n    }\n    get box() {\n        return this.#box;\n    }\n    get classNamesForOutlining() {\n        return [\n            \"highlightOutline\"\n        ];\n    }\n}\nclass FreeHighlightOutliner extends FreeDrawOutliner {\n    newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {\n        return new FreeHighlightOutline(outline, points, box, scaleFactor, innerMargin, isLTR);\n    }\n}\nclass FreeHighlightOutline extends FreeDrawOutline {\n    newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {\n        return new FreeHighlightOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);\n    }\n}\n; // ./src/display/editor/color_picker.js\nclass ColorPicker {\n    #button;\n    #buttonSwatch;\n    #defaultColor;\n    #dropdown;\n    #dropdownWasFromKeyboard;\n    #isMainColorPicker;\n    #editor;\n    #eventBus;\n    #openDropdownAC;\n    #uiManager;\n    #type;\n    static #l10nColor = null;\n    static get _keyboardManager() {\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                ColorPicker.prototype._hideDropdownFromKeyboard\n            ],\n            [\n                [\n                    \" \",\n                    \"mac+ \"\n                ],\n                ColorPicker.prototype._colorSelectFromKeyboard\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"ArrowRight\",\n                    \"mac+ArrowDown\",\n                    \"mac+ArrowRight\"\n                ],\n                ColorPicker.prototype._moveToNext\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"ArrowLeft\",\n                    \"mac+ArrowUp\",\n                    \"mac+ArrowLeft\"\n                ],\n                ColorPicker.prototype._moveToPrevious\n            ],\n            [\n                [\n                    \"Home\",\n                    \"mac+Home\"\n                ],\n                ColorPicker.prototype._moveToBeginning\n            ],\n            [\n                [\n                    \"End\",\n                    \"mac+End\"\n                ],\n                ColorPicker.prototype._moveToEnd\n            ]\n        ]));\n    }\n    constructor({ editor = null, uiManager = null }){\n        this.#button = null;\n        this.#buttonSwatch = null;\n        this.#dropdown = null;\n        this.#dropdownWasFromKeyboard = false;\n        this.#isMainColorPicker = false;\n        this.#editor = null;\n        this.#openDropdownAC = null;\n        this.#uiManager = null;\n        if (editor) {\n            this.#isMainColorPicker = false;\n            this.#type = AnnotationEditorParamsType.HIGHLIGHT_COLOR;\n            this.#editor = editor;\n        } else {\n            this.#isMainColorPicker = true;\n            this.#type = AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR;\n        }\n        this.#uiManager = editor?._uiManager || uiManager;\n        this.#eventBus = this.#uiManager._eventBus;\n        this.#defaultColor = editor?.color || this.#uiManager?.highlightColors.values().next().value || \"#FFFF98\";\n        ColorPicker.#l10nColor ||= Object.freeze({\n            blue: \"pdfjs-editor-colorpicker-blue\",\n            green: \"pdfjs-editor-colorpicker-green\",\n            pink: \"pdfjs-editor-colorpicker-pink\",\n            red: \"pdfjs-editor-colorpicker-red\",\n            yellow: \"pdfjs-editor-colorpicker-yellow\"\n        });\n    }\n    renderButton() {\n        const button = this.#button = document.createElement(\"button\");\n        button.className = \"colorPicker\";\n        button.tabIndex = \"0\";\n        button.setAttribute(\"data-l10n-id\", \"pdfjs-editor-colorpicker-button\");\n        button.setAttribute(\"aria-haspopup\", true);\n        const signal = this.#uiManager._signal;\n        button.addEventListener(\"click\", this.#openDropdown.bind(this), {\n            signal\n        });\n        button.addEventListener(\"keydown\", this.#keyDown.bind(this), {\n            signal\n        });\n        const swatch = this.#buttonSwatch = document.createElement(\"span\");\n        swatch.className = \"swatch\";\n        swatch.setAttribute(\"aria-hidden\", true);\n        swatch.style.backgroundColor = this.#defaultColor;\n        button.append(swatch);\n        return button;\n    }\n    renderMainDropdown() {\n        const dropdown = this.#dropdown = this.#getDropdownRoot();\n        dropdown.setAttribute(\"aria-orientation\", \"horizontal\");\n        dropdown.setAttribute(\"aria-labelledby\", \"highlightColorPickerLabel\");\n        return dropdown;\n    }\n    #getDropdownRoot() {\n        const div = document.createElement(\"div\");\n        const signal = this.#uiManager._signal;\n        div.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        div.className = \"dropdown\";\n        div.role = \"listbox\";\n        div.setAttribute(\"aria-multiselectable\", false);\n        div.setAttribute(\"aria-orientation\", \"vertical\");\n        div.setAttribute(\"data-l10n-id\", \"pdfjs-editor-colorpicker-dropdown\");\n        for (const [name, color] of this.#uiManager.highlightColors){\n            const button = document.createElement(\"button\");\n            button.tabIndex = \"0\";\n            button.role = \"option\";\n            button.setAttribute(\"data-color\", color);\n            button.title = name;\n            button.setAttribute(\"data-l10n-id\", ColorPicker.#l10nColor[name]);\n            const swatch = document.createElement(\"span\");\n            button.append(swatch);\n            swatch.className = \"swatch\";\n            swatch.style.backgroundColor = color;\n            button.setAttribute(\"aria-selected\", color === this.#defaultColor);\n            button.addEventListener(\"click\", this.#colorSelect.bind(this, color), {\n                signal\n            });\n            div.append(button);\n        }\n        div.addEventListener(\"keydown\", this.#keyDown.bind(this), {\n            signal\n        });\n        return div;\n    }\n    #colorSelect(color, event) {\n        event.stopPropagation();\n        this.#eventBus.dispatch(\"switchannotationeditorparams\", {\n            source: this,\n            type: this.#type,\n            value: color\n        });\n    }\n    _colorSelectFromKeyboard(event) {\n        if (event.target === this.#button) {\n            this.#openDropdown(event);\n            return;\n        }\n        const color = event.target.getAttribute(\"data-color\");\n        if (!color) {\n            return;\n        }\n        this.#colorSelect(color, event);\n    }\n    _moveToNext(event) {\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n            return;\n        }\n        if (event.target === this.#button) {\n            this.#dropdown.firstChild?.focus();\n            return;\n        }\n        event.target.nextSibling?.focus();\n    }\n    _moveToPrevious(event) {\n        if (event.target === this.#dropdown?.firstChild || event.target === this.#button) {\n            if (this.#isDropdownVisible) {\n                this._hideDropdownFromKeyboard();\n            }\n            return;\n        }\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n        }\n        event.target.previousSibling?.focus();\n    }\n    _moveToBeginning(event) {\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n            return;\n        }\n        this.#dropdown.firstChild?.focus();\n    }\n    _moveToEnd(event) {\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n            return;\n        }\n        this.#dropdown.lastChild?.focus();\n    }\n    #keyDown(event) {\n        ColorPicker._keyboardManager.exec(this, event);\n    }\n    #openDropdown(event) {\n        if (this.#isDropdownVisible) {\n            this.hideDropdown();\n            return;\n        }\n        this.#dropdownWasFromKeyboard = event.detail === 0;\n        if (!this.#openDropdownAC) {\n            this.#openDropdownAC = new AbortController();\n            window.addEventListener(\"pointerdown\", this.#pointerDown.bind(this), {\n                signal: this.#uiManager.combinedSignal(this.#openDropdownAC)\n            });\n        }\n        if (this.#dropdown) {\n            this.#dropdown.classList.remove(\"hidden\");\n            return;\n        }\n        const root = this.#dropdown = this.#getDropdownRoot();\n        this.#button.append(root);\n    }\n    #pointerDown(event) {\n        if (this.#dropdown?.contains(event.target)) {\n            return;\n        }\n        this.hideDropdown();\n    }\n    hideDropdown() {\n        this.#dropdown?.classList.add(\"hidden\");\n        this.#openDropdownAC?.abort();\n        this.#openDropdownAC = null;\n    }\n    get #isDropdownVisible() {\n        return this.#dropdown && !this.#dropdown.classList.contains(\"hidden\");\n    }\n    _hideDropdownFromKeyboard() {\n        if (this.#isMainColorPicker) {\n            return;\n        }\n        if (!this.#isDropdownVisible) {\n            this.#editor?.unselect();\n            return;\n        }\n        this.hideDropdown();\n        this.#button.focus({\n            preventScroll: true,\n            focusVisible: this.#dropdownWasFromKeyboard\n        });\n    }\n    updateColor(color) {\n        if (this.#buttonSwatch) {\n            this.#buttonSwatch.style.backgroundColor = color;\n        }\n        if (!this.#dropdown) {\n            return;\n        }\n        const i = this.#uiManager.highlightColors.values();\n        for (const child of this.#dropdown.children){\n            child.setAttribute(\"aria-selected\", i.next().value === color);\n        }\n    }\n    destroy() {\n        this.#button?.remove();\n        this.#button = null;\n        this.#buttonSwatch = null;\n        this.#dropdown?.remove();\n        this.#dropdown = null;\n    }\n}\n; // ./src/display/editor/highlight.js\nclass HighlightEditor extends AnnotationEditor {\n    #anchorNode;\n    #anchorOffset;\n    #boxes;\n    #clipPathId;\n    #colorPicker;\n    #focusOutlines;\n    #focusNode;\n    #focusOffset;\n    #highlightDiv;\n    #highlightOutlines;\n    #id;\n    #isFreeHighlight;\n    #lastPoint;\n    #opacity;\n    #outlineId;\n    #text;\n    #thickness;\n    #methodOfCreation;\n    static{\n        this._defaultColor = null;\n    }\n    static{\n        this._defaultOpacity = 1;\n    }\n    static{\n        this._defaultThickness = 12;\n    }\n    static{\n        this._type = \"highlight\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.HIGHLIGHT;\n    }\n    static{\n        this._freeHighlightId = -1;\n    }\n    static{\n        this._freeHighlight = null;\n    }\n    static{\n        this._freeHighlightClipId = \"\";\n    }\n    static get _keyboardManager() {\n        const proto = HighlightEditor.prototype;\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        1\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        2\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        3\n                    ]\n                }\n            ]\n        ]));\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"highlightEditor\"\n        });\n        this.#anchorNode = null;\n        this.#anchorOffset = 0;\n        this.#clipPathId = null;\n        this.#colorPicker = null;\n        this.#focusOutlines = null;\n        this.#focusNode = null;\n        this.#focusOffset = 0;\n        this.#highlightDiv = null;\n        this.#highlightOutlines = null;\n        this.#id = null;\n        this.#isFreeHighlight = false;\n        this.#lastPoint = null;\n        this.#outlineId = null;\n        this.#text = \"\";\n        this.#methodOfCreation = \"\";\n        this.color = params.color || HighlightEditor._defaultColor;\n        this.#thickness = params.thickness || HighlightEditor._defaultThickness;\n        this.#opacity = params.opacity || HighlightEditor._defaultOpacity;\n        this.#boxes = params.boxes || null;\n        this.#methodOfCreation = params.methodOfCreation || \"\";\n        this.#text = params.text || \"\";\n        this._isDraggable = false;\n        if (params.highlightId > -1) {\n            this.#isFreeHighlight = true;\n            this.#createFreeOutlines(params);\n            this.#addToDrawLayer();\n        } else if (this.#boxes) {\n            this.#anchorNode = params.anchorNode;\n            this.#anchorOffset = params.anchorOffset;\n            this.#focusNode = params.focusNode;\n            this.#focusOffset = params.focusOffset;\n            this.#createOutlines();\n            this.#addToDrawLayer();\n            this.rotate(this.rotation);\n        }\n    }\n    get telemetryInitialData() {\n        return {\n            action: \"added\",\n            type: this.#isFreeHighlight ? \"free_highlight\" : \"highlight\",\n            color: this._uiManager.highlightColorNames.get(this.color),\n            thickness: this.#thickness,\n            methodOfCreation: this.#methodOfCreation\n        };\n    }\n    get telemetryFinalData() {\n        return {\n            type: \"highlight\",\n            color: this._uiManager.highlightColorNames.get(this.color)\n        };\n    }\n    static computeTelemetryFinalData(data) {\n        return {\n            numberOfColors: data.get(\"color\").size\n        };\n    }\n    #createOutlines() {\n        const outliner = new HighlightOutliner(this.#boxes, 0.001);\n        this.#highlightOutlines = outliner.getOutlines();\n        [this.x, this.y, this.width, this.height] = this.#highlightOutlines.box;\n        const outlinerForOutline = new HighlightOutliner(this.#boxes, 0.0025, 0.001, this._uiManager.direction === \"ltr\");\n        this.#focusOutlines = outlinerForOutline.getOutlines();\n        const { lastPoint } = this.#focusOutlines;\n        this.#lastPoint = [\n            (lastPoint[0] - this.x) / this.width,\n            (lastPoint[1] - this.y) / this.height\n        ];\n    }\n    #createFreeOutlines({ highlightOutlines, highlightId, clipPathId }) {\n        this.#highlightOutlines = highlightOutlines;\n        const extraThickness = 1.5;\n        this.#focusOutlines = highlightOutlines.getNewOutline(this.#thickness / 2 + extraThickness, 0.0025);\n        if (highlightId >= 0) {\n            this.#id = highlightId;\n            this.#clipPathId = clipPathId;\n            this.parent.drawLayer.finalizeDraw(highlightId, {\n                bbox: highlightOutlines.box,\n                path: {\n                    d: highlightOutlines.toSVGPath()\n                }\n            });\n            this.#outlineId = this.parent.drawLayer.drawOutline({\n                rootClass: {\n                    highlightOutline: true,\n                    free: true\n                },\n                bbox: this.#focusOutlines.box,\n                path: {\n                    d: this.#focusOutlines.toSVGPath()\n                }\n            }, true);\n        } else if (this.parent) {\n            const angle = this.parent.viewport.rotation;\n            this.parent.drawLayer.updateProperties(this.#id, {\n                bbox: HighlightEditor.#rotateBbox(this.#highlightOutlines.box, (angle - this.rotation + 360) % 360),\n                path: {\n                    d: highlightOutlines.toSVGPath()\n                }\n            });\n            this.parent.drawLayer.updateProperties(this.#outlineId, {\n                bbox: HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),\n                path: {\n                    d: this.#focusOutlines.toSVGPath()\n                }\n            });\n        }\n        const [x, y, width, height] = highlightOutlines.box;\n        switch(this.rotation){\n            case 0:\n                this.x = x;\n                this.y = y;\n                this.width = width;\n                this.height = height;\n                break;\n            case 90:\n                {\n                    const [pageWidth, pageHeight] = this.parentDimensions;\n                    this.x = y;\n                    this.y = 1 - x;\n                    this.width = width * pageHeight / pageWidth;\n                    this.height = height * pageWidth / pageHeight;\n                    break;\n                }\n            case 180:\n                this.x = 1 - x;\n                this.y = 1 - y;\n                this.width = width;\n                this.height = height;\n                break;\n            case 270:\n                {\n                    const [pageWidth, pageHeight] = this.parentDimensions;\n                    this.x = 1 - y;\n                    this.y = x;\n                    this.width = width * pageHeight / pageWidth;\n                    this.height = height * pageWidth / pageHeight;\n                    break;\n                }\n        }\n        const { lastPoint } = this.#focusOutlines;\n        this.#lastPoint = [\n            (lastPoint[0] - x) / width,\n            (lastPoint[1] - y) / height\n        ];\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        HighlightEditor._defaultColor ||= uiManager.highlightColors?.values().next().value || \"#fff066\";\n    }\n    static updateDefaultParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR:\n                HighlightEditor._defaultColor = value;\n                break;\n            case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:\n                HighlightEditor._defaultThickness = value;\n                break;\n        }\n    }\n    translateInPage(x, y) {}\n    get toolbarPosition() {\n        return this.#lastPoint;\n    }\n    updateParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.HIGHLIGHT_COLOR:\n                this.#updateColor(value);\n                break;\n            case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:\n                this.#updateThickness(value);\n                break;\n        }\n    }\n    static get defaultPropertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR,\n                HighlightEditor._defaultColor\n            ],\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,\n                HighlightEditor._defaultThickness\n            ]\n        ];\n    }\n    get propertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n                this.color || HighlightEditor._defaultColor\n            ],\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,\n                this.#thickness || HighlightEditor._defaultThickness\n            ],\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_FREE,\n                this.#isFreeHighlight\n            ]\n        ];\n    }\n    #updateColor(color) {\n        const setColorAndOpacity = (col, opa)=>{\n            this.color = col;\n            this.#opacity = opa;\n            this.parent?.drawLayer.updateProperties(this.#id, {\n                root: {\n                    fill: col,\n                    \"fill-opacity\": opa\n                }\n            });\n            this.#colorPicker?.updateColor(col);\n        };\n        const savedColor = this.color;\n        const savedOpacity = this.#opacity;\n        this.addCommands({\n            cmd: setColorAndOpacity.bind(this, color, HighlightEditor._defaultOpacity),\n            undo: setColorAndOpacity.bind(this, savedColor, savedOpacity),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n        this._reportTelemetry({\n            action: \"color_changed\",\n            color: this._uiManager.highlightColorNames.get(color)\n        }, true);\n    }\n    #updateThickness(thickness) {\n        const savedThickness = this.#thickness;\n        const setThickness = (th)=>{\n            this.#thickness = th;\n            this.#changeThickness(th);\n        };\n        this.addCommands({\n            cmd: setThickness.bind(this, thickness),\n            undo: setThickness.bind(this, savedThickness),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.INK_THICKNESS,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n        this._reportTelemetry({\n            action: \"thickness_changed\",\n            thickness\n        }, true);\n    }\n    async addEditToolbar() {\n        const toolbar = await super.addEditToolbar();\n        if (!toolbar) {\n            return null;\n        }\n        if (this._uiManager.highlightColors) {\n            this.#colorPicker = new ColorPicker({\n                editor: this\n            });\n            toolbar.addColorPicker(this.#colorPicker);\n        }\n        return toolbar;\n    }\n    disableEditing() {\n        super.disableEditing();\n        this.div.classList.toggle(\"disabled\", true);\n    }\n    enableEditing() {\n        super.enableEditing();\n        this.div.classList.toggle(\"disabled\", false);\n    }\n    fixAndSetPosition() {\n        return super.fixAndSetPosition(this.#getRotation());\n    }\n    getBaseTranslation() {\n        return [\n            0,\n            0\n        ];\n    }\n    getRect(tx, ty) {\n        return super.getRect(tx, ty, this.#getRotation());\n    }\n    onceAdded(focus) {\n        if (!this.annotationElementId) {\n            this.parent.addUndoableEditor(this);\n        }\n        if (focus) {\n            this.div.focus();\n        }\n    }\n    remove() {\n        this.#cleanDrawLayer();\n        this._reportTelemetry({\n            action: \"deleted\"\n        });\n        super.remove();\n    }\n    rebuild() {\n        if (!this.parent) {\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        this.#addToDrawLayer();\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    setParent(parent) {\n        let mustBeSelected = false;\n        if (this.parent && !parent) {\n            this.#cleanDrawLayer();\n        } else if (parent) {\n            this.#addToDrawLayer(parent);\n            mustBeSelected = !this.parent && this.div?.classList.contains(\"selectedEditor\");\n        }\n        super.setParent(parent);\n        this.show(this._isVisible);\n        if (mustBeSelected) {\n            this.select();\n        }\n    }\n    #changeThickness(thickness) {\n        if (!this.#isFreeHighlight) {\n            return;\n        }\n        this.#createFreeOutlines({\n            highlightOutlines: this.#highlightOutlines.getNewOutline(thickness / 2)\n        });\n        this.fixAndSetPosition();\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setDims(this.width * parentWidth, this.height * parentHeight);\n    }\n    #cleanDrawLayer() {\n        if (this.#id === null || !this.parent) {\n            return;\n        }\n        this.parent.drawLayer.remove(this.#id);\n        this.#id = null;\n        this.parent.drawLayer.remove(this.#outlineId);\n        this.#outlineId = null;\n    }\n    #addToDrawLayer(parent = this.parent) {\n        if (this.#id !== null) {\n            return;\n        }\n        ({ id: this.#id, clipPathId: this.#clipPathId } = parent.drawLayer.draw({\n            bbox: this.#highlightOutlines.box,\n            root: {\n                viewBox: \"0 0 1 1\",\n                fill: this.color,\n                \"fill-opacity\": this.#opacity\n            },\n            rootClass: {\n                highlight: true,\n                free: this.#isFreeHighlight\n            },\n            path: {\n                d: this.#highlightOutlines.toSVGPath()\n            }\n        }, false, true));\n        this.#outlineId = parent.drawLayer.drawOutline({\n            rootClass: {\n                highlightOutline: true,\n                free: this.#isFreeHighlight\n            },\n            bbox: this.#focusOutlines.box,\n            path: {\n                d: this.#focusOutlines.toSVGPath()\n            }\n        }, this.#isFreeHighlight);\n        if (this.#highlightDiv) {\n            this.#highlightDiv.style.clipPath = this.#clipPathId;\n        }\n    }\n    static #rotateBbox([x, y, width, height], angle) {\n        switch(angle){\n            case 90:\n                return [\n                    1 - y - height,\n                    x,\n                    height,\n                    width\n                ];\n            case 180:\n                return [\n                    1 - x - width,\n                    1 - y - height,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    y,\n                    1 - x - width,\n                    height,\n                    width\n                ];\n        }\n        return [\n            x,\n            y,\n            width,\n            height\n        ];\n    }\n    rotate(angle) {\n        const { drawLayer } = this.parent;\n        let box;\n        if (this.#isFreeHighlight) {\n            angle = (angle - this.rotation + 360) % 360;\n            box = HighlightEditor.#rotateBbox(this.#highlightOutlines.box, angle);\n        } else {\n            box = HighlightEditor.#rotateBbox([\n                this.x,\n                this.y,\n                this.width,\n                this.height\n            ], angle);\n        }\n        drawLayer.updateProperties(this.#id, {\n            bbox: box,\n            root: {\n                \"data-main-rotation\": angle\n            }\n        });\n        drawLayer.updateProperties(this.#outlineId, {\n            bbox: HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),\n            root: {\n                \"data-main-rotation\": angle\n            }\n        });\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        const div = super.render();\n        if (this.#text) {\n            div.setAttribute(\"aria-label\", this.#text);\n            div.setAttribute(\"role\", \"mark\");\n        }\n        if (this.#isFreeHighlight) {\n            div.classList.add(\"free\");\n        } else {\n            this.div.addEventListener(\"keydown\", this.#keydown.bind(this), {\n                signal: this._uiManager._signal\n            });\n        }\n        const highlightDiv = this.#highlightDiv = document.createElement(\"div\");\n        div.append(highlightDiv);\n        highlightDiv.setAttribute(\"aria-hidden\", \"true\");\n        highlightDiv.className = \"internal\";\n        highlightDiv.style.clipPath = this.#clipPathId;\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setDims(this.width * parentWidth, this.height * parentHeight);\n        bindEvents(this, this.#highlightDiv, [\n            \"pointerover\",\n            \"pointerleave\"\n        ]);\n        this.enableEditing();\n        return div;\n    }\n    pointerover() {\n        if (!this.isSelected) {\n            this.parent?.drawLayer.updateProperties(this.#outlineId, {\n                rootClass: {\n                    hovered: true\n                }\n            });\n        }\n    }\n    pointerleave() {\n        if (!this.isSelected) {\n            this.parent?.drawLayer.updateProperties(this.#outlineId, {\n                rootClass: {\n                    hovered: false\n                }\n            });\n        }\n    }\n    #keydown(event) {\n        HighlightEditor._keyboardManager.exec(this, event);\n    }\n    _moveCaret(direction) {\n        this.parent.unselect(this);\n        switch(direction){\n            case 0:\n            case 2:\n                this.#setCaret(true);\n                break;\n            case 1:\n            case 3:\n                this.#setCaret(false);\n                break;\n        }\n    }\n    #setCaret(start) {\n        if (!this.#anchorNode) {\n            return;\n        }\n        const selection = window.getSelection();\n        if (start) {\n            selection.setPosition(this.#anchorNode, this.#anchorOffset);\n        } else {\n            selection.setPosition(this.#focusNode, this.#focusOffset);\n        }\n    }\n    select() {\n        super.select();\n        if (!this.#outlineId) {\n            return;\n        }\n        this.parent?.drawLayer.updateProperties(this.#outlineId, {\n            rootClass: {\n                hovered: false,\n                selected: true\n            }\n        });\n    }\n    unselect() {\n        super.unselect();\n        if (!this.#outlineId) {\n            return;\n        }\n        this.parent?.drawLayer.updateProperties(this.#outlineId, {\n            rootClass: {\n                selected: false\n            }\n        });\n        if (!this.#isFreeHighlight) {\n            this.#setCaret(false);\n        }\n    }\n    get _mustFixPosition() {\n        return !this.#isFreeHighlight;\n    }\n    show(visible = this._isVisible) {\n        super.show(visible);\n        if (this.parent) {\n            this.parent.drawLayer.updateProperties(this.#id, {\n                rootClass: {\n                    hidden: !visible\n                }\n            });\n            this.parent.drawLayer.updateProperties(this.#outlineId, {\n                rootClass: {\n                    hidden: !visible\n                }\n            });\n        }\n    }\n    #getRotation() {\n        return this.#isFreeHighlight ? this.rotation : 0;\n    }\n    #serializeBoxes() {\n        if (this.#isFreeHighlight) {\n            return null;\n        }\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const [pageX, pageY] = this.pageTranslation;\n        const boxes = this.#boxes;\n        const quadPoints = new Float32Array(boxes.length * 8);\n        let i = 0;\n        for (const { x, y, width, height } of boxes){\n            const sx = x * pageWidth + pageX;\n            const sy = (1 - y) * pageHeight + pageY;\n            quadPoints[i] = quadPoints[i + 4] = sx;\n            quadPoints[i + 1] = quadPoints[i + 3] = sy;\n            quadPoints[i + 2] = quadPoints[i + 6] = sx + width * pageWidth;\n            quadPoints[i + 5] = quadPoints[i + 7] = sy - height * pageHeight;\n            i += 8;\n        }\n        return quadPoints;\n    }\n    #serializeOutlines(rect) {\n        return this.#highlightOutlines.serialize(rect, this.#getRotation());\n    }\n    static startHighlighting(parent, isLTR, { target: textLayer, x, y }) {\n        const { x: layerX, y: layerY, width: parentWidth, height: parentHeight } = textLayer.getBoundingClientRect();\n        const ac = new AbortController();\n        const signal = parent.combinedSignal(ac);\n        const pointerUpCallback = (e)=>{\n            ac.abort();\n            this.#endHighlight(parent, e);\n        };\n        window.addEventListener(\"blur\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"pointerup\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"pointerdown\", stopEvent, {\n            capture: true,\n            passive: false,\n            signal\n        });\n        window.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        textLayer.addEventListener(\"pointermove\", this.#highlightMove.bind(this, parent), {\n            signal\n        });\n        this._freeHighlight = new FreeHighlightOutliner({\n            x,\n            y\n        }, [\n            layerX,\n            layerY,\n            parentWidth,\n            parentHeight\n        ], parent.scale, this._defaultThickness / 2, isLTR, 0.001);\n        ({ id: this._freeHighlightId, clipPathId: this._freeHighlightClipId } = parent.drawLayer.draw({\n            bbox: [\n                0,\n                0,\n                1,\n                1\n            ],\n            root: {\n                viewBox: \"0 0 1 1\",\n                fill: this._defaultColor,\n                \"fill-opacity\": this._defaultOpacity\n            },\n            rootClass: {\n                highlight: true,\n                free: true\n            },\n            path: {\n                d: this._freeHighlight.toSVGPath()\n            }\n        }, true, true));\n    }\n    static #highlightMove(parent, event) {\n        if (this._freeHighlight.add(event)) {\n            parent.drawLayer.updateProperties(this._freeHighlightId, {\n                path: {\n                    d: this._freeHighlight.toSVGPath()\n                }\n            });\n        }\n    }\n    static #endHighlight(parent, event) {\n        if (!this._freeHighlight.isEmpty()) {\n            parent.createAndAddNewEditor(event, false, {\n                highlightId: this._freeHighlightId,\n                highlightOutlines: this._freeHighlight.getOutlines(),\n                clipPathId: this._freeHighlightClipId,\n                methodOfCreation: \"main_toolbar\"\n            });\n        } else {\n            parent.drawLayer.remove(this._freeHighlightId);\n        }\n        this._freeHighlightId = -1;\n        this._freeHighlight = null;\n        this._freeHighlightClipId = \"\";\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof HighlightAnnotationElement) {\n            const { data: { quadPoints, rect, rotation, id, color, opacity, popupRef }, parent: { page: { pageNumber } } } = data;\n            initialData = data = {\n                annotationType: AnnotationEditorType.HIGHLIGHT,\n                color: Array.from(color),\n                opacity,\n                quadPoints,\n                boxes: null,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                id,\n                deleted: false,\n                popupRef\n            };\n        } else if (data instanceof InkAnnotationElement) {\n            const { data: { inkLists, rect, rotation, id, color, borderStyle: { rawWidth: thickness }, popupRef }, parent: { page: { pageNumber } } } = data;\n            initialData = data = {\n                annotationType: AnnotationEditorType.HIGHLIGHT,\n                color: Array.from(color),\n                thickness,\n                inkLists,\n                boxes: null,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                id,\n                deleted: false,\n                popupRef\n            };\n        }\n        const { color, quadPoints, inkLists, opacity } = data;\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.color = Util.makeHexColor(...color);\n        editor.#opacity = opacity || 1;\n        if (inkLists) {\n            editor.#thickness = data.thickness;\n        }\n        editor.annotationElementId = data.id || null;\n        editor._initialData = initialData;\n        const [pageWidth, pageHeight] = editor.pageDimensions;\n        const [pageX, pageY] = editor.pageTranslation;\n        if (quadPoints) {\n            const boxes = editor.#boxes = [];\n            for(let i = 0; i < quadPoints.length; i += 8){\n                boxes.push({\n                    x: (quadPoints[i] - pageX) / pageWidth,\n                    y: 1 - (quadPoints[i + 1] - pageY) / pageHeight,\n                    width: (quadPoints[i + 2] - quadPoints[i]) / pageWidth,\n                    height: (quadPoints[i + 1] - quadPoints[i + 5]) / pageHeight\n                });\n            }\n            editor.#createOutlines();\n            editor.#addToDrawLayer();\n            editor.rotate(editor.rotation);\n        } else if (inkLists) {\n            editor.#isFreeHighlight = true;\n            const points = inkLists[0];\n            const point = {\n                x: points[0] - pageX,\n                y: pageHeight - (points[1] - pageY)\n            };\n            const outliner = new FreeHighlightOutliner(point, [\n                0,\n                0,\n                pageWidth,\n                pageHeight\n            ], 1, editor.#thickness / 2, true, 0.001);\n            for(let i = 0, ii = points.length; i < ii; i += 2){\n                point.x = points[i] - pageX;\n                point.y = pageHeight - (points[i + 1] - pageY);\n                outliner.add(point);\n            }\n            const { id, clipPathId } = parent.drawLayer.draw({\n                bbox: [\n                    0,\n                    0,\n                    1,\n                    1\n                ],\n                root: {\n                    viewBox: \"0 0 1 1\",\n                    fill: editor.color,\n                    \"fill-opacity\": editor._defaultOpacity\n                },\n                rootClass: {\n                    highlight: true,\n                    free: true\n                },\n                path: {\n                    d: outliner.toSVGPath()\n                }\n            }, true, true);\n            editor.#createFreeOutlines({\n                highlightOutlines: outliner.getOutlines(),\n                highlightId: id,\n                clipPathId\n            });\n            editor.#addToDrawLayer();\n        }\n        return editor;\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty() || isForCopying) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const rect = this.getRect(0, 0);\n        const color = AnnotationEditor._colorManager.convert(this.color);\n        const serialized = {\n            annotationType: AnnotationEditorType.HIGHLIGHT,\n            color,\n            opacity: this.#opacity,\n            thickness: this.#thickness,\n            quadPoints: this.#serializeBoxes(),\n            outlines: this.#serializeOutlines(rect),\n            pageIndex: this.pageIndex,\n            rect,\n            rotation: this.#getRotation(),\n            structTreeParentId: this._structTreeParentId\n        };\n        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n            return null;\n        }\n        serialized.id = this.annotationElementId;\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { color } = this._initialData;\n        return serialized.color.some((c, i)=>c !== color[i]);\n    }\n    renderAnnotationElement(annotation) {\n        annotation.updateEdited({\n            rect: this.getRect(0, 0)\n        });\n        return null;\n    }\n    static canCreateNewEmptyEditor() {\n        return false;\n    }\n}\n; // ./src/display/editor/draw.js\nclass DrawingOptions {\n    #svgProperties;\n    updateProperty(name, value) {\n        this[name] = value;\n        this.updateSVGProperty(name, value);\n    }\n    updateProperties(properties) {\n        if (!properties) {\n            return;\n        }\n        for (const [name, value] of Object.entries(properties)){\n            this.updateProperty(name, value);\n        }\n    }\n    updateSVGProperty(name, value) {\n        this.#svgProperties[name] = value;\n    }\n    toSVGProperties() {\n        const root = this.#svgProperties;\n        this.#svgProperties = Object.create(null);\n        return {\n            root\n        };\n    }\n    reset() {\n        this.#svgProperties = Object.create(null);\n    }\n    updateAll(options = this) {\n        this.updateProperties(options);\n    }\n    clone() {\n        unreachable(\"Not implemented\");\n    }\n    constructor(){\n        this.#svgProperties = Object.create(null);\n    }\n}\nclass DrawingEditor extends AnnotationEditor {\n    #drawOutlines;\n    #mustBeCommitted;\n    static{\n        this._currentDrawId = -1;\n    }\n    static{\n        this._currentParent = null;\n    }\n    static #currentDraw = null;\n    static #currentDrawingAC = null;\n    static #currentDrawingOptions = null;\n    static #currentPointerId = NaN;\n    static #currentPointerType = null;\n    static #currentPointerIds = null;\n    static #currentMoveTimestamp = NaN;\n    static{\n        this._INNER_MARGIN = 3;\n    }\n    constructor(params){\n        super(params);\n        this.#drawOutlines = null;\n        this._drawId = null;\n        this.#mustBeCommitted = params.mustBeCommitted || false;\n        if (params.drawOutlines) {\n            this.#createDrawOutlines(params);\n            this.#addToDrawLayer();\n        }\n    }\n    #createDrawOutlines({ drawOutlines, drawId, drawingOptions }) {\n        this.#drawOutlines = drawOutlines;\n        this._drawingOptions ||= drawingOptions;\n        if (drawId >= 0) {\n            this._drawId = drawId;\n            this.parent.drawLayer.finalizeDraw(drawId, drawOutlines.defaultProperties);\n        } else {\n            this._drawId = this.#createDrawing(drawOutlines, this.parent);\n        }\n        this.#updateBbox(drawOutlines.box);\n    }\n    #createDrawing(drawOutlines, parent) {\n        const { id } = parent.drawLayer.draw(DrawingEditor._mergeSVGProperties(this._drawingOptions.toSVGProperties(), drawOutlines.defaultSVGProperties), false, false);\n        return id;\n    }\n    static _mergeSVGProperties(p1, p2) {\n        const p1Keys = new Set(Object.keys(p1));\n        for (const [key, value] of Object.entries(p2)){\n            if (p1Keys.has(key)) {\n                Object.assign(p1[key], value);\n            } else {\n                p1[key] = value;\n            }\n        }\n        return p1;\n    }\n    static getDefaultDrawingOptions(_options) {\n        unreachable(\"Not implemented\");\n    }\n    static get typesMap() {\n        unreachable(\"Not implemented\");\n    }\n    static get isDrawer() {\n        return true;\n    }\n    static get supportMultipleDrawings() {\n        return false;\n    }\n    static updateDefaultParams(type, value) {\n        const propertyName = this.typesMap.get(type);\n        if (propertyName) {\n            this._defaultDrawingOptions.updateProperty(propertyName, value);\n        }\n        if (this._currentParent) {\n            DrawingEditor.#currentDraw.updateProperty(propertyName, value);\n            this._currentParent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());\n        }\n    }\n    updateParams(type, value) {\n        const propertyName = this.constructor.typesMap.get(type);\n        if (propertyName) {\n            this._updateProperty(type, propertyName, value);\n        }\n    }\n    static get defaultPropertiesToUpdate() {\n        const properties = [];\n        const options = this._defaultDrawingOptions;\n        for (const [type, name] of this.typesMap){\n            properties.push([\n                type,\n                options[name]\n            ]);\n        }\n        return properties;\n    }\n    get propertiesToUpdate() {\n        const properties = [];\n        const { _drawingOptions } = this;\n        for (const [type, name] of this.constructor.typesMap){\n            properties.push([\n                type,\n                _drawingOptions[name]\n            ]);\n        }\n        return properties;\n    }\n    _updateProperty(type, name, value) {\n        const options = this._drawingOptions;\n        const savedValue = options[name];\n        const setter = (val)=>{\n            options.updateProperty(name, val);\n            const bbox = this.#drawOutlines.updateProperty(name, val);\n            if (bbox) {\n                this.#updateBbox(bbox);\n            }\n            this.parent?.drawLayer.updateProperties(this._drawId, options.toSVGProperties());\n        };\n        this.addCommands({\n            cmd: setter.bind(this, value),\n            undo: setter.bind(this, savedValue),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    _onResizing() {\n        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizingSVGProperties(this.#convertToDrawSpace()), {\n            bbox: this.#rotateBox()\n        }));\n    }\n    _onResized() {\n        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizedSVGProperties(this.#convertToDrawSpace()), {\n            bbox: this.#rotateBox()\n        }));\n    }\n    _onTranslating(x, y) {\n        this.parent?.drawLayer.updateProperties(this._drawId, {\n            bbox: this.#rotateBox(x, y)\n        });\n    }\n    _onTranslated() {\n        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathTranslatedSVGProperties(this.#convertToDrawSpace(), this.parentDimensions), {\n            bbox: this.#rotateBox()\n        }));\n    }\n    _onStartDragging() {\n        this.parent?.drawLayer.updateProperties(this._drawId, {\n            rootClass: {\n                moving: true\n            }\n        });\n    }\n    _onStopDragging() {\n        this.parent?.drawLayer.updateProperties(this._drawId, {\n            rootClass: {\n                moving: false\n            }\n        });\n    }\n    commit() {\n        super.commit();\n        this.disableEditMode();\n        this.disableEditing();\n    }\n    disableEditing() {\n        super.disableEditing();\n        this.div.classList.toggle(\"disabled\", true);\n    }\n    enableEditing() {\n        super.enableEditing();\n        this.div.classList.toggle(\"disabled\", false);\n    }\n    getBaseTranslation() {\n        return [\n            0,\n            0\n        ];\n    }\n    get isResizable() {\n        return true;\n    }\n    onceAdded(focus) {\n        if (!this.annotationElementId) {\n            this.parent.addUndoableEditor(this);\n        }\n        this._isDraggable = true;\n        if (this.#mustBeCommitted) {\n            this.#mustBeCommitted = false;\n            this.commit();\n            this.parent.setSelected(this);\n            if (focus && this.isOnScreen) {\n                this.div.focus();\n            }\n        }\n    }\n    remove() {\n        this.#cleanDrawLayer();\n        super.remove();\n    }\n    rebuild() {\n        if (!this.parent) {\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        this.#addToDrawLayer();\n        this.#updateBbox(this.#drawOutlines.box);\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    setParent(parent) {\n        let mustBeSelected = false;\n        if (this.parent && !parent) {\n            this._uiManager.removeShouldRescale(this);\n            this.#cleanDrawLayer();\n        } else if (parent) {\n            this._uiManager.addShouldRescale(this);\n            this.#addToDrawLayer(parent);\n            mustBeSelected = !this.parent && this.div?.classList.contains(\"selectedEditor\");\n        }\n        super.setParent(parent);\n        if (mustBeSelected) {\n            this.select();\n        }\n    }\n    #cleanDrawLayer() {\n        if (this._drawId === null || !this.parent) {\n            return;\n        }\n        this.parent.drawLayer.remove(this._drawId);\n        this._drawId = null;\n        this._drawingOptions.reset();\n    }\n    #addToDrawLayer(parent = this.parent) {\n        if (this._drawId !== null && this.parent === parent) {\n            return;\n        }\n        if (this._drawId !== null) {\n            this.parent.drawLayer.updateParent(this._drawId, parent.drawLayer);\n            return;\n        }\n        this._drawingOptions.updateAll();\n        this._drawId = this.#createDrawing(this.#drawOutlines, parent);\n    }\n    #convertToParentSpace([x, y, width, height]) {\n        const { parentDimensions: [pW, pH], rotation } = this;\n        switch(rotation){\n            case 90:\n                return [\n                    y,\n                    1 - x,\n                    width * (pH / pW),\n                    height * (pW / pH)\n                ];\n            case 180:\n                return [\n                    1 - x,\n                    1 - y,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    1 - y,\n                    x,\n                    width * (pH / pW),\n                    height * (pW / pH)\n                ];\n            default:\n                return [\n                    x,\n                    y,\n                    width,\n                    height\n                ];\n        }\n    }\n    #convertToDrawSpace() {\n        const { x, y, width, height, parentDimensions: [pW, pH], rotation } = this;\n        switch(rotation){\n            case 90:\n                return [\n                    1 - y,\n                    x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 180:\n                return [\n                    1 - x,\n                    1 - y,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    y,\n                    1 - x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            default:\n                return [\n                    x,\n                    y,\n                    width,\n                    height\n                ];\n        }\n    }\n    #updateBbox(bbox) {\n        [this.x, this.y, this.width, this.height] = this.#convertToParentSpace(bbox);\n        if (this.div) {\n            this.fixAndSetPosition();\n            const [parentWidth, parentHeight] = this.parentDimensions;\n            this.setDims(this.width * parentWidth, this.height * parentHeight);\n        }\n        this._onResized();\n    }\n    #rotateBox() {\n        const { x, y, width, height, rotation, parentRotation, parentDimensions: [pW, pH] } = this;\n        switch((rotation * 4 + parentRotation) / 90){\n            case 1:\n                return [\n                    1 - y - height,\n                    x,\n                    height,\n                    width\n                ];\n            case 2:\n                return [\n                    1 - x - width,\n                    1 - y - height,\n                    width,\n                    height\n                ];\n            case 3:\n                return [\n                    y,\n                    1 - x - width,\n                    height,\n                    width\n                ];\n            case 4:\n                return [\n                    x,\n                    y - width * (pW / pH),\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 5:\n                return [\n                    1 - y,\n                    x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 6:\n                return [\n                    1 - x - height * (pH / pW),\n                    1 - y,\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 7:\n                return [\n                    y - width * (pW / pH),\n                    1 - x - height * (pH / pW),\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 8:\n                return [\n                    x - width,\n                    y - height,\n                    width,\n                    height\n                ];\n            case 9:\n                return [\n                    1 - y,\n                    x - width,\n                    height,\n                    width\n                ];\n            case 10:\n                return [\n                    1 - x,\n                    1 - y,\n                    width,\n                    height\n                ];\n            case 11:\n                return [\n                    y - height,\n                    1 - x,\n                    height,\n                    width\n                ];\n            case 12:\n                return [\n                    x - height * (pH / pW),\n                    y,\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 13:\n                return [\n                    1 - y - width * (pW / pH),\n                    x - height * (pH / pW),\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 14:\n                return [\n                    1 - x,\n                    1 - y - width * (pW / pH),\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 15:\n                return [\n                    y,\n                    1 - x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            default:\n                return [\n                    x,\n                    y,\n                    width,\n                    height\n                ];\n        }\n    }\n    rotate() {\n        if (!this.parent) {\n            return;\n        }\n        this.parent.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties({\n            bbox: this.#rotateBox()\n        }, this.#drawOutlines.updateRotation((this.parentRotation - this.rotation + 360) % 360)));\n    }\n    onScaleChanging() {\n        if (!this.parent) {\n            return;\n        }\n        this.#updateBbox(this.#drawOutlines.updateParentDimensions(this.parentDimensions, this.parent.scale));\n    }\n    static onScaleChangingWhenDrawing() {}\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        const div = super.render();\n        div.classList.add(\"draw\");\n        const drawDiv = document.createElement(\"div\");\n        div.append(drawDiv);\n        drawDiv.setAttribute(\"aria-hidden\", \"true\");\n        drawDiv.className = \"internal\";\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setDims(this.width * parentWidth, this.height * parentHeight);\n        this._uiManager.addShouldRescale(this);\n        this.disableEditing();\n        return div;\n    }\n    static createDrawerInstance(_x, _y, _parentWidth, _parentHeight, _rotation) {\n        unreachable(\"Not implemented\");\n    }\n    static startDrawing(parent, uiManager, _isLTR, event) {\n        const { target, offsetX: x, offsetY: y, pointerId, pointerType } = event;\n        if (DrawingEditor.#currentPointerType && DrawingEditor.#currentPointerType !== pointerType) {\n            return;\n        }\n        const { viewport: { rotation } } = parent;\n        const { width: parentWidth, height: parentHeight } = target.getBoundingClientRect();\n        const ac = DrawingEditor.#currentDrawingAC = new AbortController();\n        const signal = parent.combinedSignal(ac);\n        DrawingEditor.#currentPointerId ||= pointerId;\n        DrawingEditor.#currentPointerType ??= pointerType;\n        window.addEventListener(\"pointerup\", (e)=>{\n            if (DrawingEditor.#currentPointerId === e.pointerId) {\n                this._endDraw(e);\n            } else {\n                DrawingEditor.#currentPointerIds?.delete(e.pointerId);\n            }\n        }, {\n            signal\n        });\n        window.addEventListener(\"pointercancel\", (e)=>{\n            if (DrawingEditor.#currentPointerId === e.pointerId) {\n                this._currentParent.endDrawingSession();\n            } else {\n                DrawingEditor.#currentPointerIds?.delete(e.pointerId);\n            }\n        }, {\n            signal\n        });\n        window.addEventListener(\"pointerdown\", (e)=>{\n            if (DrawingEditor.#currentPointerType !== e.pointerType) {\n                return;\n            }\n            (DrawingEditor.#currentPointerIds ||= new Set()).add(e.pointerId);\n            if (DrawingEditor.#currentDraw.isCancellable()) {\n                DrawingEditor.#currentDraw.removeLastElement();\n                if (DrawingEditor.#currentDraw.isEmpty()) {\n                    this._currentParent.endDrawingSession(true);\n                } else {\n                    this._endDraw(null);\n                }\n            }\n        }, {\n            capture: true,\n            passive: false,\n            signal\n        });\n        window.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        target.addEventListener(\"pointermove\", this._drawMove.bind(this), {\n            signal\n        });\n        target.addEventListener(\"touchmove\", (e)=>{\n            if (e.timeStamp === DrawingEditor.#currentMoveTimestamp) {\n                stopEvent(e);\n            }\n        }, {\n            signal\n        });\n        parent.toggleDrawing();\n        uiManager._editorUndoBar?.hide();\n        if (DrawingEditor.#currentDraw) {\n            parent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.startNew(x, y, parentWidth, parentHeight, rotation));\n            return;\n        }\n        uiManager.updateUIForDefaultProperties(this);\n        DrawingEditor.#currentDraw = this.createDrawerInstance(x, y, parentWidth, parentHeight, rotation);\n        DrawingEditor.#currentDrawingOptions = this.getDefaultDrawingOptions();\n        this._currentParent = parent;\n        ({ id: this._currentDrawId } = parent.drawLayer.draw(this._mergeSVGProperties(DrawingEditor.#currentDrawingOptions.toSVGProperties(), DrawingEditor.#currentDraw.defaultSVGProperties), true, false));\n    }\n    static _drawMove(event) {\n        DrawingEditor.#currentMoveTimestamp = -1;\n        if (!DrawingEditor.#currentDraw) {\n            return;\n        }\n        const { offsetX, offsetY, pointerId } = event;\n        if (DrawingEditor.#currentPointerId !== pointerId) {\n            return;\n        }\n        if (DrawingEditor.#currentPointerIds?.size >= 1) {\n            this._endDraw(event);\n            return;\n        }\n        this._currentParent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.add(offsetX, offsetY));\n        DrawingEditor.#currentMoveTimestamp = event.timeStamp;\n        stopEvent(event);\n    }\n    static _cleanup(all) {\n        if (all) {\n            this._currentDrawId = -1;\n            this._currentParent = null;\n            DrawingEditor.#currentDraw = null;\n            DrawingEditor.#currentDrawingOptions = null;\n            DrawingEditor.#currentPointerType = null;\n            DrawingEditor.#currentMoveTimestamp = NaN;\n        }\n        if (DrawingEditor.#currentDrawingAC) {\n            DrawingEditor.#currentDrawingAC.abort();\n            DrawingEditor.#currentDrawingAC = null;\n            DrawingEditor.#currentPointerId = NaN;\n            DrawingEditor.#currentPointerIds = null;\n        }\n    }\n    static _endDraw(event) {\n        const parent = this._currentParent;\n        if (!parent) {\n            return;\n        }\n        parent.toggleDrawing(true);\n        this._cleanup(false);\n        if (event) {\n            parent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.end(event.offsetX, event.offsetY));\n        }\n        if (this.supportMultipleDrawings) {\n            const draw = DrawingEditor.#currentDraw;\n            const drawId = this._currentDrawId;\n            const lastElement = draw.getLastElement();\n            parent.addCommands({\n                cmd: ()=>{\n                    parent.drawLayer.updateProperties(drawId, draw.setLastElement(lastElement));\n                },\n                undo: ()=>{\n                    parent.drawLayer.updateProperties(drawId, draw.removeLastElement());\n                },\n                mustExec: false,\n                type: AnnotationEditorParamsType.DRAW_STEP\n            });\n            return;\n        }\n        this.endDrawing(false);\n    }\n    static endDrawing(isAborted) {\n        const parent = this._currentParent;\n        if (!parent) {\n            return null;\n        }\n        parent.toggleDrawing(true);\n        parent.cleanUndoStack(AnnotationEditorParamsType.DRAW_STEP);\n        if (!DrawingEditor.#currentDraw.isEmpty()) {\n            const { pageDimensions: [pageWidth, pageHeight], scale } = parent;\n            const editor = parent.createAndAddNewEditor({\n                offsetX: 0,\n                offsetY: 0\n            }, false, {\n                drawId: this._currentDrawId,\n                drawOutlines: DrawingEditor.#currentDraw.getOutlines(pageWidth * scale, pageHeight * scale, scale, this._INNER_MARGIN),\n                drawingOptions: DrawingEditor.#currentDrawingOptions,\n                mustBeCommitted: !isAborted\n            });\n            this._cleanup(true);\n            return editor;\n        }\n        parent.drawLayer.remove(this._currentDrawId);\n        this._cleanup(true);\n        return null;\n    }\n    createDrawingOptions(_data) {}\n    static deserializeDraw(_pageX, _pageY, _pageWidth, _pageHeight, _innerWidth, _data) {\n        unreachable(\"Not implemented\");\n    }\n    static async deserialize(data, parent, uiManager) {\n        const { rawDims: { pageWidth, pageHeight, pageX, pageY } } = parent.viewport;\n        const drawOutlines = this.deserializeDraw(pageX, pageY, pageWidth, pageHeight, this._INNER_MARGIN, data);\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.createDrawingOptions(data);\n        editor.#createDrawOutlines({\n            drawOutlines\n        });\n        editor.#addToDrawLayer();\n        editor.onScaleChanging();\n        editor.rotate();\n        return editor;\n    }\n    serializeDraw(isForCopying) {\n        const [pageX, pageY] = this.pageTranslation;\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        return this.#drawOutlines.serialize([\n            pageX,\n            pageY,\n            pageWidth,\n            pageHeight\n        ], isForCopying);\n    }\n    renderAnnotationElement(annotation) {\n        annotation.updateEdited({\n            rect: this.getRect(0, 0)\n        });\n        return null;\n    }\n    static canCreateNewEmptyEditor() {\n        return false;\n    }\n}\n; // ./src/display/editor/drawers/inkdraw.js\nclass InkDrawOutliner {\n    #last;\n    #line;\n    #lines;\n    #rotation;\n    #thickness;\n    #points;\n    #lastSVGPath;\n    #lastIndex;\n    #outlines;\n    #parentWidth;\n    #parentHeight;\n    constructor(x, y, parentWidth, parentHeight, rotation, thickness){\n        this.#last = new Float64Array(6);\n        this.#lastSVGPath = \"\";\n        this.#lastIndex = 0;\n        this.#outlines = new InkDrawOutline();\n        this.#parentWidth = parentWidth;\n        this.#parentHeight = parentHeight;\n        this.#rotation = rotation;\n        this.#thickness = thickness;\n        [x, y] = this.#normalizePoint(x, y);\n        const line = this.#line = [\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            x,\n            y\n        ];\n        this.#points = [\n            x,\n            y\n        ];\n        this.#lines = [\n            {\n                line,\n                points: this.#points\n            }\n        ];\n        this.#last.set(line, 0);\n    }\n    updateProperty(name, value) {\n        if (name === \"stroke-width\") {\n            this.#thickness = value;\n        }\n    }\n    #normalizePoint(x, y) {\n        return Outline._normalizePoint(x, y, this.#parentWidth, this.#parentHeight, this.#rotation);\n    }\n    isEmpty() {\n        return !this.#lines || this.#lines.length === 0;\n    }\n    isCancellable() {\n        return this.#points.length <= 10;\n    }\n    add(x, y) {\n        [x, y] = this.#normalizePoint(x, y);\n        const [x1, y1, x2, y2] = this.#last.subarray(2, 6);\n        const diffX = x - x2;\n        const diffY = y - y2;\n        const d = Math.hypot(this.#parentWidth * diffX, this.#parentHeight * diffY);\n        if (d <= 2) {\n            return null;\n        }\n        this.#points.push(x, y);\n        if (isNaN(x1)) {\n            this.#last.set([\n                x2,\n                y2,\n                x,\n                y\n            ], 2);\n            this.#line.push(NaN, NaN, NaN, NaN, x, y);\n            return {\n                path: {\n                    d: this.toSVGPath()\n                }\n            };\n        }\n        if (isNaN(this.#last[0])) {\n            this.#line.splice(6, 6);\n        }\n        this.#last.set([\n            x1,\n            y1,\n            x2,\n            y2,\n            x,\n            y\n        ], 0);\n        this.#line.push(...Outline.createBezierPoints(x1, y1, x2, y2, x, y));\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    end(x, y) {\n        const change = this.add(x, y);\n        if (change) {\n            return change;\n        }\n        if (this.#points.length === 2) {\n            return {\n                path: {\n                    d: this.toSVGPath()\n                }\n            };\n        }\n        return null;\n    }\n    startNew(x, y, parentWidth, parentHeight, rotation) {\n        this.#parentWidth = parentWidth;\n        this.#parentHeight = parentHeight;\n        this.#rotation = rotation;\n        [x, y] = this.#normalizePoint(x, y);\n        const line = this.#line = [\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            x,\n            y\n        ];\n        this.#points = [\n            x,\n            y\n        ];\n        const last = this.#lines.at(-1);\n        if (last) {\n            last.line = new Float32Array(last.line);\n            last.points = new Float32Array(last.points);\n        }\n        this.#lines.push({\n            line,\n            points: this.#points\n        });\n        this.#last.set(line, 0);\n        this.#lastIndex = 0;\n        this.toSVGPath();\n        return null;\n    }\n    getLastElement() {\n        return this.#lines.at(-1);\n    }\n    setLastElement(element) {\n        if (!this.#lines) {\n            return this.#outlines.setLastElement(element);\n        }\n        this.#lines.push(element);\n        this.#line = element.line;\n        this.#points = element.points;\n        this.#lastIndex = 0;\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    removeLastElement() {\n        if (!this.#lines) {\n            return this.#outlines.removeLastElement();\n        }\n        this.#lines.pop();\n        this.#lastSVGPath = \"\";\n        for(let i = 0, ii = this.#lines.length; i < ii; i++){\n            const { line, points } = this.#lines[i];\n            this.#line = line;\n            this.#points = points;\n            this.#lastIndex = 0;\n            this.toSVGPath();\n        }\n        return {\n            path: {\n                d: this.#lastSVGPath\n            }\n        };\n    }\n    toSVGPath() {\n        const firstX = Outline.svgRound(this.#line[4]);\n        const firstY = Outline.svgRound(this.#line[5]);\n        if (this.#points.length === 2) {\n            this.#lastSVGPath = `${this.#lastSVGPath} M ${firstX} ${firstY} Z`;\n            return this.#lastSVGPath;\n        }\n        if (this.#points.length <= 6) {\n            const i = this.#lastSVGPath.lastIndexOf(\"M\");\n            this.#lastSVGPath = `${this.#lastSVGPath.slice(0, i)} M ${firstX} ${firstY}`;\n            this.#lastIndex = 6;\n        }\n        if (this.#points.length === 4) {\n            const secondX = Outline.svgRound(this.#line[10]);\n            const secondY = Outline.svgRound(this.#line[11]);\n            this.#lastSVGPath = `${this.#lastSVGPath} L ${secondX} ${secondY}`;\n            this.#lastIndex = 12;\n            return this.#lastSVGPath;\n        }\n        const buffer = [];\n        if (this.#lastIndex === 0) {\n            buffer.push(`M ${firstX} ${firstY}`);\n            this.#lastIndex = 6;\n        }\n        for(let i = this.#lastIndex, ii = this.#line.length; i < ii; i += 6){\n            const [c1x, c1y, c2x, c2y, x, y] = this.#line.slice(i, i + 6).map(Outline.svgRound);\n            buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);\n        }\n        this.#lastSVGPath += buffer.join(\" \");\n        this.#lastIndex = this.#line.length;\n        return this.#lastSVGPath;\n    }\n    getOutlines(parentWidth, parentHeight, scale, innerMargin) {\n        const last = this.#lines.at(-1);\n        last.line = new Float32Array(last.line);\n        last.points = new Float32Array(last.points);\n        this.#outlines.build(this.#lines, parentWidth, parentHeight, scale, this.#rotation, this.#thickness, innerMargin);\n        this.#last = null;\n        this.#line = null;\n        this.#lines = null;\n        this.#lastSVGPath = null;\n        return this.#outlines;\n    }\n    get defaultSVGProperties() {\n        return {\n            root: {\n                viewBox: \"0 0 10000 10000\"\n            },\n            rootClass: {\n                draw: true\n            },\n            bbox: [\n                0,\n                0,\n                1,\n                1\n            ]\n        };\n    }\n}\nclass InkDrawOutline extends Outline {\n    #bbox;\n    #currentRotation;\n    #innerMargin;\n    #lines;\n    #parentWidth;\n    #parentHeight;\n    #parentScale;\n    #rotation;\n    #thickness;\n    build(lines, parentWidth, parentHeight, parentScale, rotation, thickness, innerMargin) {\n        this.#parentWidth = parentWidth;\n        this.#parentHeight = parentHeight;\n        this.#parentScale = parentScale;\n        this.#rotation = rotation;\n        this.#thickness = thickness;\n        this.#innerMargin = innerMargin ?? 0;\n        this.#lines = lines;\n        this.#computeBbox();\n    }\n    setLastElement(element) {\n        this.#lines.push(element);\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    removeLastElement() {\n        this.#lines.pop();\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    toSVGPath() {\n        const buffer = [];\n        for (const { line } of this.#lines){\n            buffer.push(`M${Outline.svgRound(line[4])} ${Outline.svgRound(line[5])}`);\n            if (line.length === 6) {\n                buffer.push(\"Z\");\n                continue;\n            }\n            if (line.length === 12) {\n                buffer.push(`L${Outline.svgRound(line[10])} ${Outline.svgRound(line[11])}`);\n                continue;\n            }\n            for(let i = 6, ii = line.length; i < ii; i += 6){\n                const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6).map(Outline.svgRound);\n                buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);\n            }\n        }\n        return buffer.join(\"\");\n    }\n    serialize([pageX, pageY, pageWidth, pageHeight], isForCopying) {\n        const serializedLines = [];\n        const serializedPoints = [];\n        const [x, y, width, height] = this.#getBBoxWithNoMargin();\n        let tx, ty, sx, sy, x1, y1, x2, y2, rescaleFn;\n        switch(this.#rotation){\n            case 0:\n                rescaleFn = Outline._rescale;\n                tx = pageX;\n                ty = pageY + pageHeight;\n                sx = pageWidth;\n                sy = -pageHeight;\n                x1 = pageX + x * pageWidth;\n                y1 = pageY + (1 - y - height) * pageHeight;\n                x2 = pageX + (x + width) * pageWidth;\n                y2 = pageY + (1 - y) * pageHeight;\n                break;\n            case 90:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = pageX;\n                ty = pageY;\n                sx = pageWidth;\n                sy = pageHeight;\n                x1 = pageX + y * pageWidth;\n                y1 = pageY + x * pageHeight;\n                x2 = pageX + (y + height) * pageWidth;\n                y2 = pageY + (x + width) * pageHeight;\n                break;\n            case 180:\n                rescaleFn = Outline._rescale;\n                tx = pageX + pageWidth;\n                ty = pageY;\n                sx = -pageWidth;\n                sy = pageHeight;\n                x1 = pageX + (1 - x - width) * pageWidth;\n                y1 = pageY + y * pageHeight;\n                x2 = pageX + (1 - x) * pageWidth;\n                y2 = pageY + (y + height) * pageHeight;\n                break;\n            case 270:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = pageX + pageWidth;\n                ty = pageY + pageHeight;\n                sx = -pageWidth;\n                sy = -pageHeight;\n                x1 = pageX + (1 - y - height) * pageWidth;\n                y1 = pageY + (1 - x - width) * pageHeight;\n                x2 = pageX + (1 - y) * pageWidth;\n                y2 = pageY + (1 - x) * pageHeight;\n                break;\n        }\n        for (const { line, points } of this.#lines){\n            serializedLines.push(rescaleFn(line, tx, ty, sx, sy, isForCopying ? new Array(line.length) : null));\n            serializedPoints.push(rescaleFn(points, tx, ty, sx, sy, isForCopying ? new Array(points.length) : null));\n        }\n        return {\n            lines: serializedLines,\n            points: serializedPoints,\n            rect: [\n                x1,\n                y1,\n                x2,\n                y2\n            ]\n        };\n    }\n    static deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, { paths: { lines, points }, rotation, thickness }) {\n        const newLines = [];\n        let tx, ty, sx, sy, rescaleFn;\n        switch(rotation){\n            case 0:\n                rescaleFn = Outline._rescale;\n                tx = -pageX / pageWidth;\n                ty = pageY / pageHeight + 1;\n                sx = 1 / pageWidth;\n                sy = -1 / pageHeight;\n                break;\n            case 90:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = -pageY / pageHeight;\n                ty = -pageX / pageWidth;\n                sx = 1 / pageHeight;\n                sy = 1 / pageWidth;\n                break;\n            case 180:\n                rescaleFn = Outline._rescale;\n                tx = pageX / pageWidth + 1;\n                ty = -pageY / pageHeight;\n                sx = -1 / pageWidth;\n                sy = 1 / pageHeight;\n                break;\n            case 270:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = pageY / pageHeight + 1;\n                ty = pageX / pageWidth + 1;\n                sx = -1 / pageHeight;\n                sy = -1 / pageWidth;\n                break;\n        }\n        if (!lines) {\n            lines = [];\n            for (const point of points){\n                const len = point.length;\n                if (len === 2) {\n                    lines.push(new Float32Array([\n                        NaN,\n                        NaN,\n                        NaN,\n                        NaN,\n                        point[0],\n                        point[1]\n                    ]));\n                    continue;\n                }\n                if (len === 4) {\n                    lines.push(new Float32Array([\n                        NaN,\n                        NaN,\n                        NaN,\n                        NaN,\n                        point[0],\n                        point[1],\n                        NaN,\n                        NaN,\n                        NaN,\n                        NaN,\n                        point[2],\n                        point[3]\n                    ]));\n                    continue;\n                }\n                const line = new Float32Array(3 * (len - 2));\n                lines.push(line);\n                let [x1, y1, x2, y2] = point.subarray(0, 4);\n                line.set([\n                    NaN,\n                    NaN,\n                    NaN,\n                    NaN,\n                    x1,\n                    y1\n                ], 0);\n                for(let i = 4; i < len; i += 2){\n                    const x = point[i];\n                    const y = point[i + 1];\n                    line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);\n                    [x1, y1, x2, y2] = [\n                        x2,\n                        y2,\n                        x,\n                        y\n                    ];\n                }\n            }\n        }\n        for(let i = 0, ii = lines.length; i < ii; i++){\n            newLines.push({\n                line: rescaleFn(lines[i].map((x)=>x ?? NaN), tx, ty, sx, sy),\n                points: rescaleFn(points[i].map((x)=>x ?? NaN), tx, ty, sx, sy)\n            });\n        }\n        const outlines = new InkDrawOutline();\n        outlines.build(newLines, pageWidth, pageHeight, 1, rotation, thickness, innerMargin);\n        return outlines;\n    }\n    #getMarginComponents(thickness = this.#thickness) {\n        const margin = this.#innerMargin + thickness / 2 * this.#parentScale;\n        return this.#rotation % 180 === 0 ? [\n            margin / this.#parentWidth,\n            margin / this.#parentHeight\n        ] : [\n            margin / this.#parentHeight,\n            margin / this.#parentWidth\n        ];\n    }\n    #getBBoxWithNoMargin() {\n        const [x, y, width, height] = this.#bbox;\n        const [marginX, marginY] = this.#getMarginComponents(0);\n        return [\n            x + marginX,\n            y + marginY,\n            width - 2 * marginX,\n            height - 2 * marginY\n        ];\n    }\n    #computeBbox() {\n        const bbox = this.#bbox = new Float32Array([\n            Infinity,\n            Infinity,\n            -Infinity,\n            -Infinity\n        ]);\n        for (const { line } of this.#lines){\n            if (line.length <= 12) {\n                for(let i = 4, ii = line.length; i < ii; i += 6){\n                    const [x, y] = line.subarray(i, i + 2);\n                    bbox[0] = Math.min(bbox[0], x);\n                    bbox[1] = Math.min(bbox[1], y);\n                    bbox[2] = Math.max(bbox[2], x);\n                    bbox[3] = Math.max(bbox[3], y);\n                }\n                continue;\n            }\n            let lastX = line[4], lastY = line[5];\n            for(let i = 6, ii = line.length; i < ii; i += 6){\n                const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6);\n                Util.bezierBoundingBox(lastX, lastY, c1x, c1y, c2x, c2y, x, y, bbox);\n                lastX = x;\n                lastY = y;\n            }\n        }\n        const [marginX, marginY] = this.#getMarginComponents();\n        bbox[0] = Math.min(1, Math.max(0, bbox[0] - marginX));\n        bbox[1] = Math.min(1, Math.max(0, bbox[1] - marginY));\n        bbox[2] = Math.min(1, Math.max(0, bbox[2] + marginX));\n        bbox[3] = Math.min(1, Math.max(0, bbox[3] + marginY));\n        bbox[2] -= bbox[0];\n        bbox[3] -= bbox[1];\n    }\n    get box() {\n        return this.#bbox;\n    }\n    updateProperty(name, value) {\n        if (name === \"stroke-width\") {\n            return this.#updateThickness(value);\n        }\n        return null;\n    }\n    #updateThickness(thickness) {\n        const [oldMarginX, oldMarginY] = this.#getMarginComponents();\n        this.#thickness = thickness;\n        const [newMarginX, newMarginY] = this.#getMarginComponents();\n        const [diffMarginX, diffMarginY] = [\n            newMarginX - oldMarginX,\n            newMarginY - oldMarginY\n        ];\n        const bbox = this.#bbox;\n        bbox[0] -= diffMarginX;\n        bbox[1] -= diffMarginY;\n        bbox[2] += 2 * diffMarginX;\n        bbox[3] += 2 * diffMarginY;\n        return bbox;\n    }\n    updateParentDimensions([width, height], scale) {\n        const [oldMarginX, oldMarginY] = this.#getMarginComponents();\n        this.#parentWidth = width;\n        this.#parentHeight = height;\n        this.#parentScale = scale;\n        const [newMarginX, newMarginY] = this.#getMarginComponents();\n        const diffMarginX = newMarginX - oldMarginX;\n        const diffMarginY = newMarginY - oldMarginY;\n        const bbox = this.#bbox;\n        bbox[0] -= diffMarginX;\n        bbox[1] -= diffMarginY;\n        bbox[2] += 2 * diffMarginX;\n        bbox[3] += 2 * diffMarginY;\n        return bbox;\n    }\n    updateRotation(rotation) {\n        this.#currentRotation = rotation;\n        return {\n            path: {\n                transform: this.rotationTransform\n            }\n        };\n    }\n    get viewBox() {\n        return this.#bbox.map(Outline.svgRound).join(\" \");\n    }\n    get defaultProperties() {\n        const [x, y] = this.#bbox;\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            path: {\n                \"transform-origin\": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`\n            }\n        };\n    }\n    get rotationTransform() {\n        const [, , width, height] = this.#bbox;\n        let a = 0, b = 0, c = 0, d = 0, e = 0, f = 0;\n        switch(this.#currentRotation){\n            case 90:\n                b = height / width;\n                c = -width / height;\n                e = width;\n                break;\n            case 180:\n                a = -1;\n                d = -1;\n                e = width;\n                f = height;\n                break;\n            case 270:\n                b = -height / width;\n                c = width / height;\n                f = height;\n                break;\n            default:\n                return \"\";\n        }\n        return `matrix(${a} ${b} ${c} ${d} ${Outline.svgRound(e)} ${Outline.svgRound(f)})`;\n    }\n    getPathResizingSVGProperties([newX, newY, newWidth, newHeight]) {\n        const [marginX, marginY] = this.#getMarginComponents();\n        const [x, y, width, height] = this.#bbox;\n        if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {\n            const tx = newX + newWidth / 2 - (x + width / 2);\n            const ty = newY + newHeight / 2 - (y + height / 2);\n            return {\n                path: {\n                    \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n                    transform: `${this.rotationTransform} translate(${tx} ${ty})`\n                }\n            };\n        }\n        const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);\n        const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);\n        const s2x = width / newWidth;\n        const s2y = height / newHeight;\n        return {\n            path: {\n                \"transform-origin\": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`,\n                transform: `${this.rotationTransform} scale(${s2x} ${s2y}) ` + `translate(${Outline.svgRound(marginX)} ${Outline.svgRound(marginY)}) scale(${s1x} ${s1y}) ` + `translate(${Outline.svgRound(-marginX)} ${Outline.svgRound(-marginY)})`\n            }\n        };\n    }\n    getPathResizedSVGProperties([newX, newY, newWidth, newHeight]) {\n        const [marginX, marginY] = this.#getMarginComponents();\n        const bbox = this.#bbox;\n        const [x, y, width, height] = bbox;\n        bbox[0] = newX;\n        bbox[1] = newY;\n        bbox[2] = newWidth;\n        bbox[3] = newHeight;\n        if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {\n            const tx = newX + newWidth / 2 - (x + width / 2);\n            const ty = newY + newHeight / 2 - (y + height / 2);\n            for (const { line, points } of this.#lines){\n                Outline._translate(line, tx, ty, line);\n                Outline._translate(points, tx, ty, points);\n            }\n            return {\n                root: {\n                    viewBox: this.viewBox\n                },\n                path: {\n                    \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n                    transform: this.rotationTransform || null,\n                    d: this.toSVGPath()\n                }\n            };\n        }\n        const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);\n        const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);\n        const tx = -s1x * (x + marginX) + newX + marginX;\n        const ty = -s1y * (y + marginY) + newY + marginY;\n        if (s1x !== 1 || s1y !== 1 || tx !== 0 || ty !== 0) {\n            for (const { line, points } of this.#lines){\n                Outline._rescale(line, tx, ty, s1x, s1y, line);\n                Outline._rescale(points, tx, ty, s1x, s1y, points);\n            }\n        }\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            path: {\n                \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n                transform: this.rotationTransform || null,\n                d: this.toSVGPath()\n            }\n        };\n    }\n    getPathTranslatedSVGProperties([newX, newY], parentDimensions) {\n        const [newParentWidth, newParentHeight] = parentDimensions;\n        const bbox = this.#bbox;\n        const tx = newX - bbox[0];\n        const ty = newY - bbox[1];\n        if (this.#parentWidth === newParentWidth && this.#parentHeight === newParentHeight) {\n            for (const { line, points } of this.#lines){\n                Outline._translate(line, tx, ty, line);\n                Outline._translate(points, tx, ty, points);\n            }\n        } else {\n            const sx = this.#parentWidth / newParentWidth;\n            const sy = this.#parentHeight / newParentHeight;\n            this.#parentWidth = newParentWidth;\n            this.#parentHeight = newParentHeight;\n            for (const { line, points } of this.#lines){\n                Outline._rescale(line, tx, ty, sx, sy, line);\n                Outline._rescale(points, tx, ty, sx, sy, points);\n            }\n            bbox[2] *= sx;\n            bbox[3] *= sy;\n        }\n        bbox[0] = newX;\n        bbox[1] = newY;\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            path: {\n                d: this.toSVGPath(),\n                \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`\n            }\n        };\n    }\n    get defaultSVGProperties() {\n        const bbox = this.#bbox;\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            rootClass: {\n                draw: true\n            },\n            path: {\n                d: this.toSVGPath(),\n                \"transform-origin\": `${Outline.svgRound(bbox[0])} ${Outline.svgRound(bbox[1])}`,\n                transform: this.rotationTransform || null\n            },\n            bbox\n        };\n    }\n    constructor(...args){\n        super(...args);\n        this.#currentRotation = 0;\n    }\n}\n; // ./src/display/editor/ink.js\nclass InkDrawingOptions extends DrawingOptions {\n    #viewParameters;\n    constructor(viewerParameters){\n        super();\n        this.#viewParameters = viewerParameters;\n        super.updateProperties({\n            fill: \"none\",\n            stroke: AnnotationEditor._defaultLineColor,\n            \"stroke-opacity\": 1,\n            \"stroke-width\": 1,\n            \"stroke-linecap\": \"round\",\n            \"stroke-linejoin\": \"round\",\n            \"stroke-miterlimit\": 10\n        });\n    }\n    updateSVGProperty(name, value) {\n        if (name === \"stroke-width\") {\n            value ??= this[\"stroke-width\"];\n            value *= this.#viewParameters.realScale;\n        }\n        super.updateSVGProperty(name, value);\n    }\n    clone() {\n        const clone = new InkDrawingOptions(this.#viewParameters);\n        clone.updateAll(this);\n        return clone;\n    }\n}\nclass InkEditor extends DrawingEditor {\n    static{\n        this._type = \"ink\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.INK;\n    }\n    static{\n        this._defaultDrawingOptions = null;\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"inkEditor\"\n        });\n        this._willKeepAspectRatio = true;\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        this._defaultDrawingOptions = new InkDrawingOptions(uiManager.viewParameters);\n    }\n    static getDefaultDrawingOptions(options) {\n        const clone = this._defaultDrawingOptions.clone();\n        clone.updateProperties(options);\n        return clone;\n    }\n    static get supportMultipleDrawings() {\n        return true;\n    }\n    static get typesMap() {\n        return shadow(this, \"typesMap\", new Map([\n            [\n                AnnotationEditorParamsType.INK_THICKNESS,\n                \"stroke-width\"\n            ],\n            [\n                AnnotationEditorParamsType.INK_COLOR,\n                \"stroke\"\n            ],\n            [\n                AnnotationEditorParamsType.INK_OPACITY,\n                \"stroke-opacity\"\n            ]\n        ]));\n    }\n    static createDrawerInstance(x, y, parentWidth, parentHeight, rotation) {\n        return new InkDrawOutliner(x, y, parentWidth, parentHeight, rotation, this._defaultDrawingOptions[\"stroke-width\"]);\n    }\n    static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {\n        return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof InkAnnotationElement) {\n            const { data: { inkLists, rect, rotation, id, color, opacity, borderStyle: { rawWidth: thickness }, popupRef }, parent: { page: { pageNumber } } } = data;\n            initialData = data = {\n                annotationType: AnnotationEditorType.INK,\n                color: Array.from(color),\n                thickness,\n                opacity,\n                paths: {\n                    points: inkLists\n                },\n                boxes: null,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                id,\n                deleted: false,\n                popupRef\n            };\n        }\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.annotationElementId = data.id || null;\n        editor._initialData = initialData;\n        return editor;\n    }\n    onScaleChanging() {\n        if (!this.parent) {\n            return;\n        }\n        super.onScaleChanging();\n        const { _drawId, _drawingOptions, parent } = this;\n        _drawingOptions.updateSVGProperty(\"stroke-width\");\n        parent.drawLayer.updateProperties(_drawId, _drawingOptions.toSVGProperties());\n    }\n    static onScaleChangingWhenDrawing() {\n        const parent = this._currentParent;\n        if (!parent) {\n            return;\n        }\n        super.onScaleChangingWhenDrawing();\n        this._defaultDrawingOptions.updateSVGProperty(\"stroke-width\");\n        parent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());\n    }\n    createDrawingOptions({ color, thickness, opacity }) {\n        this._drawingOptions = InkEditor.getDefaultDrawingOptions({\n            stroke: Util.makeHexColor(...color),\n            \"stroke-width\": thickness,\n            \"stroke-opacity\": opacity\n        });\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const { lines, points, rect } = this.serializeDraw(isForCopying);\n        const { _drawingOptions: { stroke, \"stroke-opacity\": opacity, \"stroke-width\": thickness } } = this;\n        const serialized = {\n            annotationType: AnnotationEditorType.INK,\n            color: AnnotationEditor._colorManager.convert(stroke),\n            opacity,\n            thickness,\n            paths: {\n                lines,\n                points\n            },\n            pageIndex: this.pageIndex,\n            rect,\n            rotation: this.rotation,\n            structTreeParentId: this._structTreeParentId\n        };\n        if (isForCopying) {\n            return serialized;\n        }\n        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n            return null;\n        }\n        serialized.id = this.annotationElementId;\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { color, thickness, opacity, pageIndex } = this._initialData;\n        return this._hasBeenMoved || this._hasBeenResized || serialized.color.some((c, i)=>c !== color[i]) || serialized.thickness !== thickness || serialized.opacity !== opacity || serialized.pageIndex !== pageIndex;\n    }\n    renderAnnotationElement(annotation) {\n        const { points, rect } = this.serializeDraw(false);\n        annotation.updateEdited({\n            rect,\n            thickness: this._drawingOptions[\"stroke-width\"],\n            points\n        });\n        return null;\n    }\n}\n; // ./src/display/editor/stamp.js\nclass StampEditor extends AnnotationEditor {\n    #bitmap;\n    #bitmapId;\n    #bitmapPromise;\n    #bitmapUrl;\n    #bitmapFile;\n    #bitmapFileName;\n    #canvas;\n    #resizeTimeoutId;\n    #isSvg;\n    #hasBeenAddedInUndoStack;\n    static{\n        this._type = \"stamp\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.STAMP;\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"stampEditor\"\n        });\n        this.#bitmap = null;\n        this.#bitmapId = null;\n        this.#bitmapPromise = null;\n        this.#bitmapUrl = null;\n        this.#bitmapFile = null;\n        this.#bitmapFileName = \"\";\n        this.#canvas = null;\n        this.#resizeTimeoutId = null;\n        this.#isSvg = false;\n        this.#hasBeenAddedInUndoStack = false;\n        this.#bitmapUrl = params.bitmapUrl;\n        this.#bitmapFile = params.bitmapFile;\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n    }\n    static get supportedTypes() {\n        const types = [\n            \"apng\",\n            \"avif\",\n            \"bmp\",\n            \"gif\",\n            \"jpeg\",\n            \"png\",\n            \"svg+xml\",\n            \"webp\",\n            \"x-icon\"\n        ];\n        return shadow(this, \"supportedTypes\", types.map((type)=>`image/${type}`));\n    }\n    static get supportedTypesStr() {\n        return shadow(this, \"supportedTypesStr\", this.supportedTypes.join(\",\"));\n    }\n    static isHandlingMimeForPasting(mime) {\n        return this.supportedTypes.includes(mime);\n    }\n    static paste(item, parent) {\n        parent.pasteEditor(AnnotationEditorType.STAMP, {\n            bitmapFile: item.getAsFile()\n        });\n    }\n    altTextFinish() {\n        if (this._uiManager.useNewAltTextFlow) {\n            this.div.hidden = false;\n        }\n        super.altTextFinish();\n    }\n    get telemetryFinalData() {\n        return {\n            type: \"stamp\",\n            hasAltText: !!this.altTextData?.altText\n        };\n    }\n    static computeTelemetryFinalData(data) {\n        const hasAltTextStats = data.get(\"hasAltText\");\n        return {\n            hasAltText: hasAltTextStats.get(true) ?? 0,\n            hasNoAltText: hasAltTextStats.get(false) ?? 0\n        };\n    }\n    #getBitmapFetched(data, fromId = false) {\n        if (!data) {\n            this.remove();\n            return;\n        }\n        this.#bitmap = data.bitmap;\n        if (!fromId) {\n            this.#bitmapId = data.id;\n            this.#isSvg = data.isSvg;\n        }\n        if (data.file) {\n            this.#bitmapFileName = data.file.name;\n        }\n        this.#createCanvas();\n    }\n    #getBitmapDone() {\n        this.#bitmapPromise = null;\n        this._uiManager.enableWaiting(false);\n        if (!this.#canvas) {\n            return;\n        }\n        if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {\n            this._editToolbar.hide();\n            this._uiManager.editAltText(this, true);\n            return;\n        }\n        if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {\n            this._reportTelemetry({\n                action: \"pdfjs.image.image_added\",\n                data: {\n                    alt_text_modal: false,\n                    alt_text_type: \"empty\"\n                }\n            });\n            try {\n                this.mlGuessAltText();\n            } catch  {}\n        }\n        this.div.focus();\n    }\n    async mlGuessAltText(imageData = null, updateAltTextData = true) {\n        if (this.hasAltTextData()) {\n            return null;\n        }\n        const { mlManager } = this._uiManager;\n        if (!mlManager) {\n            throw new Error(\"No ML.\");\n        }\n        if (!await mlManager.isEnabledFor(\"altText\")) {\n            throw new Error(\"ML isn't enabled for alt text.\");\n        }\n        const { data, width, height } = imageData || this.copyCanvas(null, null, true).imageData;\n        const response = await mlManager.guess({\n            name: \"altText\",\n            request: {\n                data,\n                width,\n                height,\n                channels: data.length / (width * height)\n            }\n        });\n        if (!response) {\n            throw new Error(\"No response from the AI service.\");\n        }\n        if (response.error) {\n            throw new Error(\"Error from the AI service.\");\n        }\n        if (response.cancel) {\n            return null;\n        }\n        if (!response.output) {\n            throw new Error(\"No valid response from the AI service.\");\n        }\n        const altText = response.output;\n        await this.setGuessedAltText(altText);\n        if (updateAltTextData && !this.hasAltTextData()) {\n            this.altTextData = {\n                alt: altText,\n                decorative: false\n            };\n        }\n        return altText;\n    }\n    #getBitmap() {\n        if (this.#bitmapId) {\n            this._uiManager.enableWaiting(true);\n            this._uiManager.imageManager.getFromId(this.#bitmapId).then((data)=>this.#getBitmapFetched(data, true)).finally(()=>this.#getBitmapDone());\n            return;\n        }\n        if (this.#bitmapUrl) {\n            const url = this.#bitmapUrl;\n            this.#bitmapUrl = null;\n            this._uiManager.enableWaiting(true);\n            this.#bitmapPromise = this._uiManager.imageManager.getFromUrl(url).then((data)=>this.#getBitmapFetched(data)).finally(()=>this.#getBitmapDone());\n            return;\n        }\n        if (this.#bitmapFile) {\n            const file = this.#bitmapFile;\n            this.#bitmapFile = null;\n            this._uiManager.enableWaiting(true);\n            this.#bitmapPromise = this._uiManager.imageManager.getFromFile(file).then((data)=>this.#getBitmapFetched(data)).finally(()=>this.#getBitmapDone());\n            return;\n        }\n        const input = document.createElement(\"input\");\n        input.type = \"file\";\n        input.accept = StampEditor.supportedTypesStr;\n        const signal = this._uiManager._signal;\n        this.#bitmapPromise = new Promise((resolve)=>{\n            input.addEventListener(\"change\", async ()=>{\n                if (!input.files || input.files.length === 0) {\n                    this.remove();\n                } else {\n                    this._uiManager.enableWaiting(true);\n                    const data = await this._uiManager.imageManager.getFromFile(input.files[0]);\n                    this._reportTelemetry({\n                        action: \"pdfjs.image.image_selected\",\n                        data: {\n                            alt_text_modal: this._uiManager.useNewAltTextFlow\n                        }\n                    });\n                    this.#getBitmapFetched(data);\n                }\n                resolve();\n            }, {\n                signal\n            });\n            input.addEventListener(\"cancel\", ()=>{\n                this.remove();\n                resolve();\n            }, {\n                signal\n            });\n        }).finally(()=>this.#getBitmapDone());\n        input.click();\n    }\n    remove() {\n        if (this.#bitmapId) {\n            this.#bitmap = null;\n            this._uiManager.imageManager.deleteId(this.#bitmapId);\n            this.#canvas?.remove();\n            this.#canvas = null;\n            if (this.#resizeTimeoutId) {\n                clearTimeout(this.#resizeTimeoutId);\n                this.#resizeTimeoutId = null;\n            }\n        }\n        super.remove();\n    }\n    rebuild() {\n        if (!this.parent) {\n            if (this.#bitmapId) {\n                this.#getBitmap();\n            }\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        if (this.#bitmapId && this.#canvas === null) {\n            this.#getBitmap();\n        }\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    onceAdded(focus) {\n        this._isDraggable = true;\n        if (focus) {\n            this.div.focus();\n        }\n    }\n    isEmpty() {\n        return !(this.#bitmapPromise || this.#bitmap || this.#bitmapUrl || this.#bitmapFile || this.#bitmapId);\n    }\n    get isResizable() {\n        return true;\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        if (this.width) {\n            baseX = this.x;\n            baseY = this.y;\n        }\n        super.render();\n        this.div.hidden = true;\n        this.div.setAttribute(\"role\", \"figure\");\n        this.addAltTextButton();\n        if (this.#bitmap) {\n            this.#createCanvas();\n        } else {\n            this.#getBitmap();\n        }\n        if (this.width && !this.annotationElementId) {\n            const [parentWidth, parentHeight] = this.parentDimensions;\n            this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n        }\n        this._uiManager.addShouldRescale(this);\n        return this.div;\n    }\n    _onResized() {\n        this.onScaleChanging();\n    }\n    onScaleChanging() {\n        if (!this.parent) {\n            return;\n        }\n        if (this.#resizeTimeoutId !== null) {\n            clearTimeout(this.#resizeTimeoutId);\n        }\n        const TIME_TO_WAIT = 200;\n        this.#resizeTimeoutId = setTimeout(()=>{\n            this.#resizeTimeoutId = null;\n            this.#drawBitmap();\n        }, TIME_TO_WAIT);\n    }\n    #createCanvas() {\n        const { div } = this;\n        let { width, height } = this.#bitmap;\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const MAX_RATIO = 0.75;\n        if (this.width) {\n            width = this.width * pageWidth;\n            height = this.height * pageHeight;\n        } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {\n            const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);\n            width *= factor;\n            height *= factor;\n        }\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setDims(width * parentWidth / pageWidth, height * parentHeight / pageHeight);\n        this._uiManager.enableWaiting(false);\n        const canvas = this.#canvas = document.createElement(\"canvas\");\n        canvas.setAttribute(\"role\", \"img\");\n        this.addContainer(canvas);\n        this.width = width / pageWidth;\n        this.height = height / pageHeight;\n        if (this._initialOptions?.isCentered) {\n            this.center();\n        } else {\n            this.fixAndSetPosition();\n        }\n        this._initialOptions = null;\n        if (!this._uiManager.useNewAltTextWhenAddingImage || !this._uiManager.useNewAltTextFlow || this.annotationElementId) {\n            div.hidden = false;\n        }\n        this.#drawBitmap();\n        if (!this.#hasBeenAddedInUndoStack) {\n            this.parent.addUndoableEditor(this);\n            this.#hasBeenAddedInUndoStack = true;\n        }\n        this._reportTelemetry({\n            action: \"inserted_image\"\n        });\n        if (this.#bitmapFileName) {\n            canvas.setAttribute(\"aria-label\", this.#bitmapFileName);\n        }\n    }\n    copyCanvas(maxDataDimension, maxPreviewDimension, createImageData = false) {\n        if (!maxDataDimension) {\n            maxDataDimension = 224;\n        }\n        const { width: bitmapWidth, height: bitmapHeight } = this.#bitmap;\n        const outputScale = new OutputScale();\n        let bitmap = this.#bitmap;\n        let width = bitmapWidth, height = bitmapHeight;\n        let canvas = null;\n        if (maxPreviewDimension) {\n            if (bitmapWidth > maxPreviewDimension || bitmapHeight > maxPreviewDimension) {\n                const ratio = Math.min(maxPreviewDimension / bitmapWidth, maxPreviewDimension / bitmapHeight);\n                width = Math.floor(bitmapWidth * ratio);\n                height = Math.floor(bitmapHeight * ratio);\n            }\n            canvas = document.createElement(\"canvas\");\n            const scaledWidth = canvas.width = Math.ceil(width * outputScale.sx);\n            const scaledHeight = canvas.height = Math.ceil(height * outputScale.sy);\n            if (!this.#isSvg) {\n                bitmap = this.#scaleBitmap(scaledWidth, scaledHeight);\n            }\n            const ctx = canvas.getContext(\"2d\");\n            ctx.filter = this._uiManager.hcmFilter;\n            let white = \"white\", black = \"#cfcfd8\";\n            if (this._uiManager.hcmFilter !== \"none\") {\n                black = \"black\";\n            } else if (window.matchMedia?.(\"(prefers-color-scheme: dark)\").matches) {\n                white = \"#8f8f9d\";\n                black = \"#42414d\";\n            }\n            const boxDim = 15;\n            const boxDimWidth = boxDim * outputScale.sx;\n            const boxDimHeight = boxDim * outputScale.sy;\n            const pattern = new OffscreenCanvas(boxDimWidth * 2, boxDimHeight * 2);\n            const patternCtx = pattern.getContext(\"2d\");\n            patternCtx.fillStyle = white;\n            patternCtx.fillRect(0, 0, boxDimWidth * 2, boxDimHeight * 2);\n            patternCtx.fillStyle = black;\n            patternCtx.fillRect(0, 0, boxDimWidth, boxDimHeight);\n            patternCtx.fillRect(boxDimWidth, boxDimHeight, boxDimWidth, boxDimHeight);\n            ctx.fillStyle = ctx.createPattern(pattern, \"repeat\");\n            ctx.fillRect(0, 0, scaledWidth, scaledHeight);\n            ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);\n        }\n        let imageData = null;\n        if (createImageData) {\n            let dataWidth, dataHeight;\n            if (outputScale.symmetric && bitmap.width < maxDataDimension && bitmap.height < maxDataDimension) {\n                dataWidth = bitmap.width;\n                dataHeight = bitmap.height;\n            } else {\n                bitmap = this.#bitmap;\n                if (bitmapWidth > maxDataDimension || bitmapHeight > maxDataDimension) {\n                    const ratio = Math.min(maxDataDimension / bitmapWidth, maxDataDimension / bitmapHeight);\n                    dataWidth = Math.floor(bitmapWidth * ratio);\n                    dataHeight = Math.floor(bitmapHeight * ratio);\n                    if (!this.#isSvg) {\n                        bitmap = this.#scaleBitmap(dataWidth, dataHeight);\n                    }\n                }\n            }\n            const offscreen = new OffscreenCanvas(dataWidth, dataHeight);\n            const offscreenCtx = offscreen.getContext(\"2d\", {\n                willReadFrequently: true\n            });\n            offscreenCtx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, dataWidth, dataHeight);\n            imageData = {\n                width: dataWidth,\n                height: dataHeight,\n                data: offscreenCtx.getImageData(0, 0, dataWidth, dataHeight).data\n            };\n        }\n        return {\n            canvas,\n            width,\n            height,\n            imageData\n        };\n    }\n    #scaleBitmap(width, height) {\n        const { width: bitmapWidth, height: bitmapHeight } = this.#bitmap;\n        let newWidth = bitmapWidth;\n        let newHeight = bitmapHeight;\n        let bitmap = this.#bitmap;\n        while(newWidth > 2 * width || newHeight > 2 * height){\n            const prevWidth = newWidth;\n            const prevHeight = newHeight;\n            if (newWidth > 2 * width) {\n                newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);\n            }\n            if (newHeight > 2 * height) {\n                newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);\n            }\n            const offscreen = new OffscreenCanvas(newWidth, newHeight);\n            const ctx = offscreen.getContext(\"2d\");\n            ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);\n            bitmap = offscreen.transferToImageBitmap();\n        }\n        return bitmap;\n    }\n    #drawBitmap() {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const { width, height } = this;\n        const outputScale = new OutputScale();\n        const scaledWidth = Math.ceil(width * parentWidth * outputScale.sx);\n        const scaledHeight = Math.ceil(height * parentHeight * outputScale.sy);\n        const canvas = this.#canvas;\n        if (!canvas || canvas.width === scaledWidth && canvas.height === scaledHeight) {\n            return;\n        }\n        canvas.width = scaledWidth;\n        canvas.height = scaledHeight;\n        const bitmap = this.#isSvg ? this.#bitmap : this.#scaleBitmap(scaledWidth, scaledHeight);\n        const ctx = canvas.getContext(\"2d\");\n        ctx.filter = this._uiManager.hcmFilter;\n        ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);\n    }\n    getImageForAltText() {\n        return this.#canvas;\n    }\n    #serializeBitmap(toUrl) {\n        if (toUrl) {\n            if (this.#isSvg) {\n                const url = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);\n                if (url) {\n                    return url;\n                }\n            }\n            const canvas = document.createElement(\"canvas\");\n            ({ width: canvas.width, height: canvas.height } = this.#bitmap);\n            const ctx = canvas.getContext(\"2d\");\n            ctx.drawImage(this.#bitmap, 0, 0);\n            return canvas.toDataURL();\n        }\n        if (this.#isSvg) {\n            const [pageWidth, pageHeight] = this.pageDimensions;\n            const width = Math.round(this.width * pageWidth * PixelsPerInch.PDF_TO_CSS_UNITS);\n            const height = Math.round(this.height * pageHeight * PixelsPerInch.PDF_TO_CSS_UNITS);\n            const offscreen = new OffscreenCanvas(width, height);\n            const ctx = offscreen.getContext(\"2d\");\n            ctx.drawImage(this.#bitmap, 0, 0, this.#bitmap.width, this.#bitmap.height, 0, 0, width, height);\n            return offscreen.transferToImageBitmap();\n        }\n        return structuredClone(this.#bitmap);\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof StampAnnotationElement) {\n            const { data: { rect, rotation, id, structParent, popupRef }, container, parent: { page: { pageNumber } } } = data;\n            const canvas = container.querySelector(\"canvas\");\n            const imageData = uiManager.imageManager.getFromCanvas(container.id, canvas);\n            canvas.remove();\n            const altText = (await parent._structTree.getAriaAttributes(`${AnnotationPrefix}${id}`))?.get(\"aria-label\") || \"\";\n            initialData = data = {\n                annotationType: AnnotationEditorType.STAMP,\n                bitmapId: imageData.id,\n                bitmap: imageData.bitmap,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                id,\n                deleted: false,\n                accessibilityData: {\n                    decorative: false,\n                    altText\n                },\n                isSvg: false,\n                structParent,\n                popupRef\n            };\n        }\n        const editor = await super.deserialize(data, parent, uiManager);\n        const { rect, bitmap, bitmapUrl, bitmapId, isSvg, accessibilityData } = data;\n        if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {\n            editor.#bitmapId = bitmapId;\n            if (bitmap) {\n                editor.#bitmap = bitmap;\n            }\n        } else {\n            editor.#bitmapUrl = bitmapUrl;\n        }\n        editor.#isSvg = isSvg;\n        const [parentWidth, parentHeight] = editor.pageDimensions;\n        editor.width = (rect[2] - rect[0]) / parentWidth;\n        editor.height = (rect[3] - rect[1]) / parentHeight;\n        editor.annotationElementId = data.id || null;\n        if (accessibilityData) {\n            editor.altTextData = accessibilityData;\n        }\n        editor._initialData = initialData;\n        editor.#hasBeenAddedInUndoStack = !!initialData;\n        return editor;\n    }\n    serialize(isForCopying = false, context = null) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const serialized = {\n            annotationType: AnnotationEditorType.STAMP,\n            bitmapId: this.#bitmapId,\n            pageIndex: this.pageIndex,\n            rect: this.getRect(0, 0),\n            rotation: this.rotation,\n            isSvg: this.#isSvg,\n            structTreeParentId: this._structTreeParentId\n        };\n        if (isForCopying) {\n            serialized.bitmapUrl = this.#serializeBitmap(true);\n            serialized.accessibilityData = this.serializeAltText(true);\n            return serialized;\n        }\n        const { decorative, altText } = this.serializeAltText(false);\n        if (!decorative && altText) {\n            serialized.accessibilityData = {\n                type: \"Figure\",\n                alt: altText\n            };\n        }\n        if (this.annotationElementId) {\n            const changes = this.#hasElementChanged(serialized);\n            if (changes.isSame) {\n                return null;\n            }\n            if (changes.isSameAltText) {\n                delete serialized.accessibilityData;\n            } else {\n                serialized.accessibilityData.structParent = this._initialData.structParent ?? -1;\n            }\n        }\n        serialized.id = this.annotationElementId;\n        if (context === null) {\n            return serialized;\n        }\n        context.stamps ||= new Map();\n        const area = this.#isSvg ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;\n        if (!context.stamps.has(this.#bitmapId)) {\n            context.stamps.set(this.#bitmapId, {\n                area,\n                serialized\n            });\n            serialized.bitmap = this.#serializeBitmap(false);\n        } else if (this.#isSvg) {\n            const prevData = context.stamps.get(this.#bitmapId);\n            if (area > prevData.area) {\n                prevData.area = area;\n                prevData.serialized.bitmap.close();\n                prevData.serialized.bitmap = this.#serializeBitmap(false);\n            }\n        }\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { pageIndex, accessibilityData: { altText } } = this._initialData;\n        const isSamePageIndex = serialized.pageIndex === pageIndex;\n        const isSameAltText = (serialized.accessibilityData?.alt || \"\") === altText;\n        return {\n            isSame: !this._hasBeenMoved && !this._hasBeenResized && isSamePageIndex && isSameAltText,\n            isSameAltText\n        };\n    }\n    renderAnnotationElement(annotation) {\n        annotation.updateEdited({\n            rect: this.getRect(0, 0)\n        });\n        return null;\n    }\n}\n; // ./src/display/editor/annotation_editor_layer.js\nclass AnnotationEditorLayer {\n    #accessibilityManager;\n    #allowClick;\n    #annotationLayer;\n    #clickAC;\n    #editorFocusTimeoutId;\n    #editors;\n    #hadPointerDown;\n    #isDisabling;\n    #isEnabling;\n    #drawingAC;\n    #focusedElement;\n    #textLayer;\n    #textSelectionAC;\n    #uiManager;\n    static{\n        this._initialized = false;\n    }\n    static #editorTypes = new Map([\n        FreeTextEditor,\n        InkEditor,\n        StampEditor,\n        HighlightEditor\n    ].map((type)=>[\n            type._editorType,\n            type\n        ]));\n    constructor({ uiManager, pageIndex, div, structTreeLayer, accessibilityManager, annotationLayer, drawLayer, textLayer, viewport, l10n }){\n        this.#allowClick = false;\n        this.#annotationLayer = null;\n        this.#clickAC = null;\n        this.#editorFocusTimeoutId = null;\n        this.#editors = new Map();\n        this.#hadPointerDown = false;\n        this.#isDisabling = false;\n        this.#isEnabling = false;\n        this.#drawingAC = null;\n        this.#focusedElement = null;\n        this.#textLayer = null;\n        this.#textSelectionAC = null;\n        const editorTypes = [\n            ...AnnotationEditorLayer.#editorTypes.values()\n        ];\n        if (!AnnotationEditorLayer._initialized) {\n            AnnotationEditorLayer._initialized = true;\n            for (const editorType of editorTypes){\n                editorType.initialize(l10n, uiManager);\n            }\n        }\n        uiManager.registerEditorTypes(editorTypes);\n        this.#uiManager = uiManager;\n        this.pageIndex = pageIndex;\n        this.div = div;\n        this.#accessibilityManager = accessibilityManager;\n        this.#annotationLayer = annotationLayer;\n        this.viewport = viewport;\n        this.#textLayer = textLayer;\n        this.drawLayer = drawLayer;\n        this._structTree = structTreeLayer;\n        this.#uiManager.addLayer(this);\n    }\n    get isEmpty() {\n        return this.#editors.size === 0;\n    }\n    get isInvisible() {\n        return this.isEmpty && this.#uiManager.getMode() === AnnotationEditorType.NONE;\n    }\n    updateToolbar(mode) {\n        this.#uiManager.updateToolbar(mode);\n    }\n    updateMode(mode = this.#uiManager.getMode()) {\n        this.#cleanup();\n        switch(mode){\n            case AnnotationEditorType.NONE:\n                this.disableTextSelection();\n                this.togglePointerEvents(false);\n                this.toggleAnnotationLayerPointerEvents(true);\n                this.disableClick();\n                return;\n            case AnnotationEditorType.INK:\n                this.disableTextSelection();\n                this.togglePointerEvents(true);\n                this.enableClick();\n                break;\n            case AnnotationEditorType.HIGHLIGHT:\n                this.enableTextSelection();\n                this.togglePointerEvents(false);\n                this.disableClick();\n                break;\n            default:\n                this.disableTextSelection();\n                this.togglePointerEvents(true);\n                this.enableClick();\n        }\n        this.toggleAnnotationLayerPointerEvents(false);\n        const { classList } = this.div;\n        for (const editorType of AnnotationEditorLayer.#editorTypes.values()){\n            classList.toggle(`${editorType._type}Editing`, mode === editorType._editorType);\n        }\n        this.div.hidden = false;\n    }\n    hasTextLayer(textLayer) {\n        return textLayer === this.#textLayer?.div;\n    }\n    setEditingState(isEditing) {\n        this.#uiManager.setEditingState(isEditing);\n    }\n    addCommands(params) {\n        this.#uiManager.addCommands(params);\n    }\n    cleanUndoStack(type) {\n        this.#uiManager.cleanUndoStack(type);\n    }\n    toggleDrawing(enabled = false) {\n        this.div.classList.toggle(\"drawing\", !enabled);\n    }\n    togglePointerEvents(enabled = false) {\n        this.div.classList.toggle(\"disabled\", !enabled);\n    }\n    toggleAnnotationLayerPointerEvents(enabled = false) {\n        this.#annotationLayer?.div.classList.toggle(\"disabled\", !enabled);\n    }\n    async enable() {\n        this.#isEnabling = true;\n        this.div.tabIndex = 0;\n        this.togglePointerEvents(true);\n        const annotationElementIds = new Set();\n        for (const editor of this.#editors.values()){\n            editor.enableEditing();\n            editor.show(true);\n            if (editor.annotationElementId) {\n                this.#uiManager.removeChangedExistingAnnotation(editor);\n                annotationElementIds.add(editor.annotationElementId);\n            }\n        }\n        if (!this.#annotationLayer) {\n            this.#isEnabling = false;\n            return;\n        }\n        const editables = this.#annotationLayer.getEditableAnnotations();\n        for (const editable of editables){\n            editable.hide();\n            if (this.#uiManager.isDeletedAnnotationElement(editable.data.id)) {\n                continue;\n            }\n            if (annotationElementIds.has(editable.data.id)) {\n                continue;\n            }\n            const editor = await this.deserialize(editable);\n            if (!editor) {\n                continue;\n            }\n            this.addOrRebuild(editor);\n            editor.enableEditing();\n        }\n        this.#isEnabling = false;\n    }\n    disable() {\n        this.#isDisabling = true;\n        this.div.tabIndex = -1;\n        this.togglePointerEvents(false);\n        const changedAnnotations = new Map();\n        const resetAnnotations = new Map();\n        for (const editor of this.#editors.values()){\n            editor.disableEditing();\n            if (!editor.annotationElementId) {\n                continue;\n            }\n            if (editor.serialize() !== null) {\n                changedAnnotations.set(editor.annotationElementId, editor);\n                continue;\n            } else {\n                resetAnnotations.set(editor.annotationElementId, editor);\n            }\n            this.getEditableAnnotation(editor.annotationElementId)?.show();\n            editor.remove();\n        }\n        if (this.#annotationLayer) {\n            const editables = this.#annotationLayer.getEditableAnnotations();\n            for (const editable of editables){\n                const { id } = editable.data;\n                if (this.#uiManager.isDeletedAnnotationElement(id)) {\n                    continue;\n                }\n                let editor = resetAnnotations.get(id);\n                if (editor) {\n                    editor.resetAnnotationElement(editable);\n                    editor.show(false);\n                    editable.show();\n                    continue;\n                }\n                editor = changedAnnotations.get(id);\n                if (editor) {\n                    this.#uiManager.addChangedExistingAnnotation(editor);\n                    if (editor.renderAnnotationElement(editable)) {\n                        editor.show(false);\n                    }\n                }\n                editable.show();\n            }\n        }\n        this.#cleanup();\n        if (this.isEmpty) {\n            this.div.hidden = true;\n        }\n        const { classList } = this.div;\n        for (const editorType of AnnotationEditorLayer.#editorTypes.values()){\n            classList.remove(`${editorType._type}Editing`);\n        }\n        this.disableTextSelection();\n        this.toggleAnnotationLayerPointerEvents(true);\n        this.#isDisabling = false;\n    }\n    getEditableAnnotation(id) {\n        return this.#annotationLayer?.getEditableAnnotation(id) || null;\n    }\n    setActiveEditor(editor) {\n        const currentActive = this.#uiManager.getActive();\n        if (currentActive === editor) {\n            return;\n        }\n        this.#uiManager.setActiveEditor(editor);\n    }\n    enableTextSelection() {\n        this.div.tabIndex = -1;\n        if (this.#textLayer?.div && !this.#textSelectionAC) {\n            this.#textSelectionAC = new AbortController();\n            const signal = this.#uiManager.combinedSignal(this.#textSelectionAC);\n            this.#textLayer.div.addEventListener(\"pointerdown\", this.#textLayerPointerDown.bind(this), {\n                signal\n            });\n            this.#textLayer.div.classList.add(\"highlighting\");\n        }\n    }\n    disableTextSelection() {\n        this.div.tabIndex = 0;\n        if (this.#textLayer?.div && this.#textSelectionAC) {\n            this.#textSelectionAC.abort();\n            this.#textSelectionAC = null;\n            this.#textLayer.div.classList.remove(\"highlighting\");\n        }\n    }\n    #textLayerPointerDown(event) {\n        this.#uiManager.unselectAll();\n        const { target } = event;\n        if (target === this.#textLayer.div || (target.getAttribute(\"role\") === \"img\" || target.classList.contains(\"endOfContent\")) && this.#textLayer.div.contains(target)) {\n            const { isMac } = util_FeatureTest.platform;\n            if (event.button !== 0 || event.ctrlKey && isMac) {\n                return;\n            }\n            this.#uiManager.showAllEditors(\"highlight\", true, true);\n            this.#textLayer.div.classList.add(\"free\");\n            this.toggleDrawing();\n            HighlightEditor.startHighlighting(this, this.#uiManager.direction === \"ltr\", {\n                target: this.#textLayer.div,\n                x: event.x,\n                y: event.y\n            });\n            this.#textLayer.div.addEventListener(\"pointerup\", ()=>{\n                this.#textLayer.div.classList.remove(\"free\");\n                this.toggleDrawing(true);\n            }, {\n                once: true,\n                signal: this.#uiManager._signal\n            });\n            event.preventDefault();\n        }\n    }\n    enableClick() {\n        if (this.#clickAC) {\n            return;\n        }\n        this.#clickAC = new AbortController();\n        const signal = this.#uiManager.combinedSignal(this.#clickAC);\n        this.div.addEventListener(\"pointerdown\", this.pointerdown.bind(this), {\n            signal\n        });\n        const pointerup = this.pointerup.bind(this);\n        this.div.addEventListener(\"pointerup\", pointerup, {\n            signal\n        });\n        this.div.addEventListener(\"pointercancel\", pointerup, {\n            signal\n        });\n    }\n    disableClick() {\n        this.#clickAC?.abort();\n        this.#clickAC = null;\n    }\n    attach(editor) {\n        this.#editors.set(editor.id, editor);\n        const { annotationElementId } = editor;\n        if (annotationElementId && this.#uiManager.isDeletedAnnotationElement(annotationElementId)) {\n            this.#uiManager.removeDeletedAnnotationElement(editor);\n        }\n    }\n    detach(editor) {\n        this.#editors.delete(editor.id);\n        this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n        if (!this.#isDisabling && editor.annotationElementId) {\n            this.#uiManager.addDeletedAnnotationElement(editor);\n        }\n    }\n    remove(editor) {\n        this.detach(editor);\n        this.#uiManager.removeEditor(editor);\n        editor.div.remove();\n        editor.isAttachedToDOM = false;\n    }\n    changeParent(editor) {\n        if (editor.parent === this) {\n            return;\n        }\n        if (editor.parent && editor.annotationElementId) {\n            this.#uiManager.addDeletedAnnotationElement(editor.annotationElementId);\n            AnnotationEditor.deleteAnnotationElement(editor);\n            editor.annotationElementId = null;\n        }\n        this.attach(editor);\n        editor.parent?.detach(editor);\n        editor.setParent(this);\n        if (editor.div && editor.isAttachedToDOM) {\n            editor.div.remove();\n            this.div.append(editor.div);\n        }\n    }\n    add(editor) {\n        if (editor.parent === this && editor.isAttachedToDOM) {\n            return;\n        }\n        this.changeParent(editor);\n        this.#uiManager.addEditor(editor);\n        this.attach(editor);\n        if (!editor.isAttachedToDOM) {\n            const div = editor.render();\n            this.div.append(div);\n            editor.isAttachedToDOM = true;\n        }\n        editor.fixAndSetPosition();\n        editor.onceAdded(!this.#isEnabling);\n        this.#uiManager.addToAnnotationStorage(editor);\n        editor._reportTelemetry(editor.telemetryInitialData);\n    }\n    moveEditorInDOM(editor) {\n        if (!editor.isAttachedToDOM) {\n            return;\n        }\n        const { activeElement } = document;\n        if (editor.div.contains(activeElement) && !this.#editorFocusTimeoutId) {\n            editor._focusEventsAllowed = false;\n            this.#editorFocusTimeoutId = setTimeout(()=>{\n                this.#editorFocusTimeoutId = null;\n                if (!editor.div.contains(document.activeElement)) {\n                    editor.div.addEventListener(\"focusin\", ()=>{\n                        editor._focusEventsAllowed = true;\n                    }, {\n                        once: true,\n                        signal: this.#uiManager._signal\n                    });\n                    activeElement.focus();\n                } else {\n                    editor._focusEventsAllowed = true;\n                }\n            }, 0);\n        }\n        editor._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);\n    }\n    addOrRebuild(editor) {\n        if (editor.needsToBeRebuilt()) {\n            editor.parent ||= this;\n            editor.rebuild();\n            editor.show();\n        } else {\n            this.add(editor);\n        }\n    }\n    addUndoableEditor(editor) {\n        const cmd = ()=>editor._uiManager.rebuild(editor);\n        const undo = ()=>{\n            editor.remove();\n        };\n        this.addCommands({\n            cmd,\n            undo,\n            mustExec: false\n        });\n    }\n    getNextId() {\n        return this.#uiManager.getId();\n    }\n    get #currentEditorType() {\n        return AnnotationEditorLayer.#editorTypes.get(this.#uiManager.getMode());\n    }\n    combinedSignal(ac) {\n        return this.#uiManager.combinedSignal(ac);\n    }\n    #createNewEditor(params) {\n        const editorType = this.#currentEditorType;\n        return editorType ? new editorType.prototype.constructor(params) : null;\n    }\n    canCreateNewEmptyEditor() {\n        return this.#currentEditorType?.canCreateNewEmptyEditor();\n    }\n    pasteEditor(mode, params) {\n        this.#uiManager.updateToolbar(mode);\n        this.#uiManager.updateMode(mode);\n        const { offsetX, offsetY } = this.#getCenterPoint();\n        const id = this.getNextId();\n        const editor = this.#createNewEditor({\n            parent: this,\n            id,\n            x: offsetX,\n            y: offsetY,\n            uiManager: this.#uiManager,\n            isCentered: true,\n            ...params\n        });\n        if (editor) {\n            this.add(editor);\n        }\n    }\n    async deserialize(data) {\n        return await AnnotationEditorLayer.#editorTypes.get(data.annotationType ?? data.annotationEditorType)?.deserialize(data, this, this.#uiManager) || null;\n    }\n    createAndAddNewEditor(event, isCentered, data = {}) {\n        const id = this.getNextId();\n        const editor = this.#createNewEditor({\n            parent: this,\n            id,\n            x: event.offsetX,\n            y: event.offsetY,\n            uiManager: this.#uiManager,\n            isCentered,\n            ...data\n        });\n        if (editor) {\n            this.add(editor);\n        }\n        return editor;\n    }\n    #getCenterPoint() {\n        const { x, y, width, height } = this.div.getBoundingClientRect();\n        const tlX = Math.max(0, x);\n        const tlY = Math.max(0, y);\n        const brX = Math.min(window.innerWidth, x + width);\n        const brY = Math.min(window.innerHeight, y + height);\n        const centerX = (tlX + brX) / 2 - x;\n        const centerY = (tlY + brY) / 2 - y;\n        const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [\n            centerX,\n            centerY\n        ] : [\n            centerY,\n            centerX\n        ];\n        return {\n            offsetX,\n            offsetY\n        };\n    }\n    addNewEditor() {\n        this.createAndAddNewEditor(this.#getCenterPoint(), true);\n    }\n    setSelected(editor) {\n        this.#uiManager.setSelected(editor);\n    }\n    toggleSelected(editor) {\n        this.#uiManager.toggleSelected(editor);\n    }\n    unselect(editor) {\n        this.#uiManager.unselect(editor);\n    }\n    pointerup(event) {\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            return;\n        }\n        if (event.target !== this.div) {\n            return;\n        }\n        if (!this.#hadPointerDown) {\n            return;\n        }\n        this.#hadPointerDown = false;\n        if (this.#currentEditorType?.isDrawer && this.#currentEditorType.supportMultipleDrawings) {\n            return;\n        }\n        if (!this.#allowClick) {\n            this.#allowClick = true;\n            return;\n        }\n        if (this.#uiManager.getMode() === AnnotationEditorType.STAMP) {\n            this.#uiManager.unselectAll();\n            return;\n        }\n        this.createAndAddNewEditor(event, false);\n    }\n    pointerdown(event) {\n        if (this.#uiManager.getMode() === AnnotationEditorType.HIGHLIGHT) {\n            this.enableTextSelection();\n        }\n        if (this.#hadPointerDown) {\n            this.#hadPointerDown = false;\n            return;\n        }\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            return;\n        }\n        if (event.target !== this.div) {\n            return;\n        }\n        this.#hadPointerDown = true;\n        if (this.#currentEditorType?.isDrawer) {\n            this.startDrawingSession(event);\n            return;\n        }\n        const editor = this.#uiManager.getActive();\n        this.#allowClick = !editor || editor.isEmpty();\n    }\n    startDrawingSession(event) {\n        this.div.focus();\n        if (this.#drawingAC) {\n            this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);\n            return;\n        }\n        this.#uiManager.setCurrentDrawingSession(this);\n        this.#drawingAC = new AbortController();\n        const signal = this.#uiManager.combinedSignal(this.#drawingAC);\n        this.div.addEventListener(\"blur\", ({ relatedTarget })=>{\n            if (relatedTarget && !this.div.contains(relatedTarget)) {\n                this.#focusedElement = null;\n                this.commitOrRemove();\n            }\n        }, {\n            signal\n        });\n        this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);\n    }\n    pause(on) {\n        if (on) {\n            const { activeElement } = document;\n            if (this.div.contains(activeElement)) {\n                this.#focusedElement = activeElement;\n            }\n            return;\n        }\n        if (this.#focusedElement) {\n            setTimeout(()=>{\n                this.#focusedElement?.focus();\n                this.#focusedElement = null;\n            }, 0);\n        }\n    }\n    endDrawingSession(isAborted = false) {\n        if (!this.#drawingAC) {\n            return null;\n        }\n        this.#uiManager.setCurrentDrawingSession(null);\n        this.#drawingAC.abort();\n        this.#drawingAC = null;\n        this.#focusedElement = null;\n        return this.#currentEditorType.endDrawing(isAborted);\n    }\n    findNewParent(editor, x, y) {\n        const layer = this.#uiManager.findParent(x, y);\n        if (layer === null || layer === this) {\n            return false;\n        }\n        layer.changeParent(editor);\n        return true;\n    }\n    commitOrRemove() {\n        if (this.#drawingAC) {\n            this.endDrawingSession();\n            return true;\n        }\n        return false;\n    }\n    onScaleChanging() {\n        if (!this.#drawingAC) {\n            return;\n        }\n        this.#currentEditorType.onScaleChangingWhenDrawing(this);\n    }\n    destroy() {\n        this.commitOrRemove();\n        if (this.#uiManager.getActive()?.parent === this) {\n            this.#uiManager.commitOrRemove();\n            this.#uiManager.setActiveEditor(null);\n        }\n        if (this.#editorFocusTimeoutId) {\n            clearTimeout(this.#editorFocusTimeoutId);\n            this.#editorFocusTimeoutId = null;\n        }\n        for (const editor of this.#editors.values()){\n            this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n            editor.setParent(null);\n            editor.isAttachedToDOM = false;\n            editor.div.remove();\n        }\n        this.div = null;\n        this.#editors.clear();\n        this.#uiManager.removeLayer(this);\n    }\n    #cleanup() {\n        for (const editor of this.#editors.values()){\n            if (editor.isEmpty()) {\n                editor.remove();\n            }\n        }\n    }\n    render({ viewport }) {\n        this.viewport = viewport;\n        setLayerDimensions(this.div, viewport);\n        for (const editor of this.#uiManager.getEditors(this.pageIndex)){\n            this.add(editor);\n            editor.rebuild();\n        }\n        this.updateMode();\n    }\n    update({ viewport }) {\n        this.#uiManager.commitOrRemove();\n        this.#cleanup();\n        const oldRotation = this.viewport.rotation;\n        const rotation = viewport.rotation;\n        this.viewport = viewport;\n        setLayerDimensions(this.div, {\n            rotation\n        });\n        if (oldRotation !== rotation) {\n            for (const editor of this.#editors.values()){\n                editor.rotate(rotation);\n            }\n        }\n    }\n    get pageDimensions() {\n        const { pageWidth, pageHeight } = this.viewport.rawDims;\n        return [\n            pageWidth,\n            pageHeight\n        ];\n    }\n    get scale() {\n        return this.#uiManager.viewParameters.realScale;\n    }\n}\n; // ./src/display/draw_layer.js\nclass DrawLayer {\n    #parent;\n    #id;\n    #mapping;\n    #toUpdate;\n    constructor({ pageIndex }){\n        this.#parent = null;\n        this.#id = 0;\n        this.#mapping = new Map();\n        this.#toUpdate = new Map();\n        this.pageIndex = pageIndex;\n    }\n    setParent(parent) {\n        if (!this.#parent) {\n            this.#parent = parent;\n            return;\n        }\n        if (this.#parent !== parent) {\n            if (this.#mapping.size > 0) {\n                for (const root of this.#mapping.values()){\n                    root.remove();\n                    parent.append(root);\n                }\n            }\n            this.#parent = parent;\n        }\n    }\n    static get _svgFactory() {\n        return shadow(this, \"_svgFactory\", new DOMSVGFactory());\n    }\n    static #setBox(element, [x, y, width, height]) {\n        const { style } = element;\n        style.top = `${100 * y}%`;\n        style.left = `${100 * x}%`;\n        style.width = `${100 * width}%`;\n        style.height = `${100 * height}%`;\n    }\n    #createSVG() {\n        const svg = DrawLayer._svgFactory.create(1, 1, true);\n        this.#parent.append(svg);\n        svg.setAttribute(\"aria-hidden\", true);\n        return svg;\n    }\n    #createClipPath(defs, pathId) {\n        const clipPath = DrawLayer._svgFactory.createElement(\"clipPath\");\n        defs.append(clipPath);\n        const clipPathId = `clip_${pathId}`;\n        clipPath.setAttribute(\"id\", clipPathId);\n        clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n        const clipPathUse = DrawLayer._svgFactory.createElement(\"use\");\n        clipPath.append(clipPathUse);\n        clipPathUse.setAttribute(\"href\", `#${pathId}`);\n        clipPathUse.classList.add(\"clip\");\n        return clipPathId;\n    }\n    #updateProperties(element, properties) {\n        for (const [key, value] of Object.entries(properties)){\n            if (value === null) {\n                element.removeAttribute(key);\n            } else {\n                element.setAttribute(key, value);\n            }\n        }\n    }\n    draw(properties, isPathUpdatable = false, hasClip = false) {\n        const id = this.#id++;\n        const root = this.#createSVG();\n        const defs = DrawLayer._svgFactory.createElement(\"defs\");\n        root.append(defs);\n        const path = DrawLayer._svgFactory.createElement(\"path\");\n        defs.append(path);\n        const pathId = `path_p${this.pageIndex}_${id}`;\n        path.setAttribute(\"id\", pathId);\n        path.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\n        if (isPathUpdatable) {\n            this.#toUpdate.set(id, path);\n        }\n        const clipPathId = hasClip ? this.#createClipPath(defs, pathId) : null;\n        const use = DrawLayer._svgFactory.createElement(\"use\");\n        root.append(use);\n        use.setAttribute(\"href\", `#${pathId}`);\n        this.updateProperties(root, properties);\n        this.#mapping.set(id, root);\n        return {\n            id,\n            clipPathId: `url(#${clipPathId})`\n        };\n    }\n    drawOutline(properties, mustRemoveSelfIntersections) {\n        const id = this.#id++;\n        const root = this.#createSVG();\n        const defs = DrawLayer._svgFactory.createElement(\"defs\");\n        root.append(defs);\n        const path = DrawLayer._svgFactory.createElement(\"path\");\n        defs.append(path);\n        const pathId = `path_p${this.pageIndex}_${id}`;\n        path.setAttribute(\"id\", pathId);\n        path.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\n        let maskId;\n        if (mustRemoveSelfIntersections) {\n            const mask = DrawLayer._svgFactory.createElement(\"mask\");\n            defs.append(mask);\n            maskId = `mask_p${this.pageIndex}_${id}`;\n            mask.setAttribute(\"id\", maskId);\n            mask.setAttribute(\"maskUnits\", \"objectBoundingBox\");\n            const rect = DrawLayer._svgFactory.createElement(\"rect\");\n            mask.append(rect);\n            rect.setAttribute(\"width\", \"1\");\n            rect.setAttribute(\"height\", \"1\");\n            rect.setAttribute(\"fill\", \"white\");\n            const use = DrawLayer._svgFactory.createElement(\"use\");\n            mask.append(use);\n            use.setAttribute(\"href\", `#${pathId}`);\n            use.setAttribute(\"stroke\", \"none\");\n            use.setAttribute(\"fill\", \"black\");\n            use.setAttribute(\"fill-rule\", \"nonzero\");\n            use.classList.add(\"mask\");\n        }\n        const use1 = DrawLayer._svgFactory.createElement(\"use\");\n        root.append(use1);\n        use1.setAttribute(\"href\", `#${pathId}`);\n        if (maskId) {\n            use1.setAttribute(\"mask\", `url(#${maskId})`);\n        }\n        const use2 = use1.cloneNode();\n        root.append(use2);\n        use1.classList.add(\"mainOutline\");\n        use2.classList.add(\"secondaryOutline\");\n        this.updateProperties(root, properties);\n        this.#mapping.set(id, root);\n        return id;\n    }\n    finalizeDraw(id, properties) {\n        this.#toUpdate.delete(id);\n        this.updateProperties(id, properties);\n    }\n    updateProperties(elementOrId, properties) {\n        if (!properties) {\n            return;\n        }\n        const { root, bbox, rootClass, path } = properties;\n        const element = typeof elementOrId === \"number\" ? this.#mapping.get(elementOrId) : elementOrId;\n        if (!element) {\n            return;\n        }\n        if (root) {\n            this.#updateProperties(element, root);\n        }\n        if (bbox) {\n            DrawLayer.#setBox(element, bbox);\n        }\n        if (rootClass) {\n            const { classList } = element;\n            for (const [className, value] of Object.entries(rootClass)){\n                classList.toggle(className, value);\n            }\n        }\n        if (path) {\n            const defs = element.firstChild;\n            const pathElement = defs.firstChild;\n            this.#updateProperties(pathElement, path);\n        }\n    }\n    updateParent(id, layer) {\n        if (layer === this) {\n            return;\n        }\n        const root = this.#mapping.get(id);\n        if (!root) {\n            return;\n        }\n        layer.#parent.append(root);\n        this.#mapping.delete(id);\n        layer.#mapping.set(id, root);\n    }\n    remove(id) {\n        this.#toUpdate.delete(id);\n        if (this.#parent === null) {\n            return;\n        }\n        this.#mapping.get(id).remove();\n        this.#mapping.delete(id);\n    }\n    destroy() {\n        this.#parent = null;\n        for (const root of this.#mapping.values()){\n            root.remove();\n        }\n        this.#mapping.clear();\n        this.#toUpdate.clear();\n    }\n}\n; // ./src/pdf.js\nconst pdfjsVersion = \"4.10.38\";\nconst pdfjsBuild = \"f9bea397f\";\n{\n    globalThis.pdfjsTestingUtils = {\n        HighlightOutliner: HighlightOutliner\n    };\n}var __webpack_exports__AbortException = __nested_webpack_exports__.AbortException;\nvar __webpack_exports__AnnotationEditorLayer = __nested_webpack_exports__.AnnotationEditorLayer;\nvar __webpack_exports__AnnotationEditorParamsType = __nested_webpack_exports__.AnnotationEditorParamsType;\nvar __webpack_exports__AnnotationEditorType = __nested_webpack_exports__.AnnotationEditorType;\nvar __webpack_exports__AnnotationEditorUIManager = __nested_webpack_exports__.AnnotationEditorUIManager;\nvar __webpack_exports__AnnotationLayer = __nested_webpack_exports__.AnnotationLayer;\nvar __webpack_exports__AnnotationMode = __nested_webpack_exports__.AnnotationMode;\nvar __webpack_exports__ColorPicker = __nested_webpack_exports__.ColorPicker;\nvar __webpack_exports__DOMSVGFactory = __nested_webpack_exports__.DOMSVGFactory;\nvar __webpack_exports__DrawLayer = __nested_webpack_exports__.DrawLayer;\nvar __webpack_exports__FeatureTest = __nested_webpack_exports__.FeatureTest;\nvar __webpack_exports__GlobalWorkerOptions = __nested_webpack_exports__.GlobalWorkerOptions;\nvar __webpack_exports__ImageKind = __nested_webpack_exports__.ImageKind;\nvar __webpack_exports__InvalidPDFException = __nested_webpack_exports__.InvalidPDFException;\nvar __webpack_exports__MissingPDFException = __nested_webpack_exports__.MissingPDFException;\nvar __webpack_exports__OPS = __nested_webpack_exports__.OPS;\nvar __webpack_exports__OutputScale = __nested_webpack_exports__.OutputScale;\nvar __webpack_exports__PDFDataRangeTransport = __nested_webpack_exports__.PDFDataRangeTransport;\nvar __webpack_exports__PDFDateString = __nested_webpack_exports__.PDFDateString;\nvar __webpack_exports__PDFWorker = __nested_webpack_exports__.PDFWorker;\nvar __webpack_exports__PasswordResponses = __nested_webpack_exports__.PasswordResponses;\nvar __webpack_exports__PermissionFlag = __nested_webpack_exports__.PermissionFlag;\nvar __webpack_exports__PixelsPerInch = __nested_webpack_exports__.PixelsPerInch;\nvar __webpack_exports__RenderingCancelledException = __nested_webpack_exports__.RenderingCancelledException;\nvar __webpack_exports__TextLayer = __nested_webpack_exports__.TextLayer;\nvar __webpack_exports__TouchManager = __nested_webpack_exports__.TouchManager;\nvar __webpack_exports__UnexpectedResponseException = __nested_webpack_exports__.UnexpectedResponseException;\nvar __webpack_exports__Util = __nested_webpack_exports__.Util;\nvar __webpack_exports__VerbosityLevel = __nested_webpack_exports__.VerbosityLevel;\nvar __webpack_exports__XfaLayer = __nested_webpack_exports__.XfaLayer;\nvar __webpack_exports__build = __nested_webpack_exports__.build;\nvar __webpack_exports__createValidAbsoluteUrl = __nested_webpack_exports__.createValidAbsoluteUrl;\nvar __webpack_exports__fetchData = __nested_webpack_exports__.fetchData;\nvar __webpack_exports__getDocument = __nested_webpack_exports__.getDocument;\nvar __webpack_exports__getFilenameFromUrl = __nested_webpack_exports__.getFilenameFromUrl;\nvar __webpack_exports__getPdfFilenameFromUrl = __nested_webpack_exports__.getPdfFilenameFromUrl;\nvar __webpack_exports__getXfaPageViewport = __nested_webpack_exports__.getXfaPageViewport;\nvar __webpack_exports__isDataScheme = __nested_webpack_exports__.isDataScheme;\nvar __webpack_exports__isPdfFile = __nested_webpack_exports__.isPdfFile;\nvar __webpack_exports__noContextMenu = __nested_webpack_exports__.noContextMenu;\nvar __webpack_exports__normalizeUnicode = __nested_webpack_exports__.normalizeUnicode;\nvar __webpack_exports__setLayerDimensions = __nested_webpack_exports__.setLayerDimensions;\nvar __webpack_exports__shadow = __nested_webpack_exports__.shadow;\nvar __webpack_exports__stopEvent = __nested_webpack_exports__.stopEvent;\nvar __webpack_exports__version = __nested_webpack_exports__.version;\n //# sourceMappingURL=pdf.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGRmanMtZGlzdC9idWlsZC9wZGYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CQyxHQUVELE1BQU0sR0FBRyxvQkFBb0I7QUFDN0IsTUFBTSxHQUFHLElBQUlBLDhCQUFtQkEsR0FBRyxDQUFDO0FBQ3BDLE1BQU0sR0FDTix3RUFBd0UsR0FDeEUsTUFBTSxHQUFHLDJDQUEyQyxHQUNwRCxNQUFNLEdBQUk7SUFDVixNQUFNLEdBQUksOENBQThDO0lBQ3hELE1BQU0sR0FBSUEsOEJBQW1CQSxDQUFDQyxDQUFDLEdBQUcsQ0FBQ0MsU0FBU0M7UUFDNUMsTUFBTSxHQUFLLElBQUksSUFBSUMsT0FBT0QsV0FBWTtZQUN0QyxNQUFNLEdBQU0sSUFBR0gsOEJBQW1CQSxDQUFDSyxDQUFDLENBQUNGLFlBQVlDLFFBQVEsQ0FBQ0osOEJBQW1CQSxDQUFDSyxDQUFDLENBQUNILFNBQVNFLE1BQU07Z0JBQy9GLE1BQU0sR0FBT0UsT0FBT0MsY0FBYyxDQUFDTCxTQUFTRSxLQUFLO29CQUFFSSxZQUFZO29CQUFNQyxLQUFLTixVQUFVLENBQUNDLElBQUk7Z0JBQUM7WUFDMUYsTUFBTSxHQUFNO1FBQ1osTUFBTSxHQUFLO0lBQ1gsTUFBTSxHQUFJO0FBQ1YsTUFBTSxHQUFHO0FBQ1QsTUFBTSxHQUNOLE1BQU0sR0FBRyw0Q0FBNEMsR0FDckQsTUFBTSxHQUFJO0lBQ1YsTUFBTSxHQUFJSiw4QkFBbUJBLENBQUNLLENBQUMsR0FBRyxDQUFDSyxLQUFLQyxPQUFVTCxPQUFPTSxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixLQUFLQztBQUM1RixNQUFNLEdBQUc7QUFDVCxNQUFNLEdBQ04sd0VBQXdFLEdBQ3hFLElBQUlJLDBCQUFtQkEsR0FBR0MsV0FBV0MsUUFBUSxHQUFHLENBQUM7QUFFakQsVUFBVTtBQUNW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ekJ1TCxNQUFNLENBQUMsRUFBRSxJQUFJdkwsU0FBUyxDQUFDLEVBQUU7SUFDM0I7SUFDQSxPQUFPQSxVQUFVeUwsRUFBRSxFQUFFQyxFQUFFLEVBQUU7UUFDdkIsT0FBTztZQUFDRCxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRSxHQUFHRCxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRTtZQUFFRCxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRSxHQUFHRCxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRTtZQUFFRCxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRSxHQUFHRCxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRTtZQUFFRCxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRSxHQUFHRCxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRTtZQUFFRCxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRSxHQUFHRCxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRSxHQUFHRCxFQUFFLENBQUMsRUFBRTtZQUFFQSxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRSxHQUFHRCxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRSxHQUFHRCxFQUFFLENBQUMsRUFBRTtTQUFDO0lBQ25OO0lBQ0EsT0FBT0UsZUFBZUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDMUIsTUFBTUMsS0FBS0YsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUU7UUFDM0MsTUFBTUUsS0FBS0gsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFD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LENBQUNnQyxJQUFJO0FBQ3RELElBQUk0akgsb0NBQW9DNWxILDBCQUFtQkEsQ0FBQ2lDLGNBQWM7QUFDMUUsSUFBSTRqSCw4QkFBOEI3bEgsMEJBQW1CQSxDQUFDa0MsUUFBUTtBQUM5RCxJQUFJNGpILDJCQUEyQjlsSCwwQkFBbUJBLENBQUNtQyxLQUFLO0FBQ3hELElBQUk0akgsNENBQTRDL2xILDBCQUFtQkEsQ0FBQ29DLHNCQUFzQjtBQUMxRixJQUFJNGpILCtCQUErQmhtSCwwQkFBbUJBLENBQUNxQyxTQUFTO0FBQ2hFLElBQUk0akgsaUNBQWlDam1ILDBCQUFtQkEsQ0FBQ3NDLFdBQVc7QUFDcEUsSUFBSTRqSCx3Q0FBd0NsbUgsMEJBQW1CQSxDQUFDdUMsa0JBQWtCO0FBQ2xGLElBQUk0akgsMkNBQTJDbm1ILDBCQUFtQkEsQ0FBQ3dDLHFCQUFxQjtBQUN4RixJQUFJNGpILHdDQUF3Q3BtSCwwQkFBbUJBLENBQUN5QyxrQkFBa0I7QUFDbEYsSUFBSTRqSCxrQ0FBa0NybUgsMEJBQW1CQSxDQUFDMEMsWUFBWTtBQUN0RSxJQUFJNGpILCtCQUErQnRtSCwwQkFBbUJBLENBQUMyQyxTQUFTO0FBQ2hFLElBQUk0akgsbUNBQW1Ddm1ILDBCQUFtQkEsQ0FBQzRDLGFBQWE7QUFDeEUsSUFBSTRqSCxzQ0FBc0N4bUgsMEJBQW1CQSxDQUFDNkMsZ0JBQWdCO0FBQzlFLElBQUk0akgsd0NBQXdDem1ILDBCQUFtQkEsQ0FBQzhDLGtCQUFrQjtBQUNsRixJQUFJNGpILDRCQUE0QjFtSCwwQkFBbUJBLENBQUMrQyxNQUFNO0FBQzFELElBQUk0akgsK0JBQStCM21ILDBCQUFtQkEsQ0FBQ2dELFNBQVM7QUFDaEUsSUFBSTRqSCw2QkFBNkI1bUgsMEJBQW1CQSxDQUFDaUQsT0FBTztBQUNxekUsQ0FFajNFLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLWNvbnN0cnVjdGlvbi1hc3Npc3RhbnQvLi9ub2RlX21vZHVsZXMvcGRmanMtZGlzdC9idWlsZC9wZGYubWpzPzgzZTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljc3RhcnQgVGhlIGZvbGxvd2luZyBpcyB0aGUgZW50aXJlIGxpY2Vuc2Ugbm90aWNlIGZvciB0aGVcbiAqIEphdmFTY3JpcHQgY29kZSBpbiB0aGlzIHBhZ2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAyNCBNb3ppbGxhIEZvdW5kYXRpb25cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQGxpY2VuZCBUaGUgYWJvdmUgaXMgdGhlIGVudGlyZSBsaWNlbnNlIG5vdGljZSBmb3IgdGhlXG4gKiBKYXZhU2NyaXB0IGNvZGUgaW4gdGhpcyBwYWdlXG4gKi9cblxuLyoqKioqKi8gLy8gVGhlIHJlcXVpcmUgc2NvcGVcbi8qKioqKiovIHZhciBfX3dlYnBhY2tfcmVxdWlyZV9fID0ge307XG4vKioqKioqLyBcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbi8qKioqKiovICgoKSA9PiB7XG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcbi8qKioqKiovIFx0XHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcbi8qKioqKiovIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqLyB9KSgpO1xuLyoqKioqKi8gXG4vKioqKioqLyAvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4vKioqKioqLyAoKCkgPT4ge1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpXG4vKioqKioqLyB9KSgpO1xuLyoqKioqKi8gXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBnbG9iYWxUaGlzLnBkZmpzTGliID0ge307XG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4gIEFib3J0RXhjZXB0aW9uOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQWJvcnRFeGNlcHRpb24pLFxuICBBbm5vdGF0aW9uRWRpdG9yTGF5ZXI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIpLFxuICBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlKSxcbiAgQW5ub3RhdGlvbkVkaXRvclR5cGU6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBbm5vdGF0aW9uRWRpdG9yVHlwZSksXG4gIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyKSxcbiAgQW5ub3RhdGlvbkxheWVyOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQW5ub3RhdGlvbkxheWVyKSxcbiAgQW5ub3RhdGlvbk1vZGU6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBbm5vdGF0aW9uTW9kZSksXG4gIENvbG9yUGlja2VyOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29sb3JQaWNrZXIpLFxuICBET01TVkdGYWN0b3J5OiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRE9NU1ZHRmFjdG9yeSksXG4gIERyYXdMYXllcjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIERyYXdMYXllciksXG4gIEZlYXR1cmVUZXN0OiAoKSA9PiAoLyogcmVleHBvcnQgKi8gdXRpbF9GZWF0dXJlVGVzdCksXG4gIEdsb2JhbFdvcmtlck9wdGlvbnM6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBHbG9iYWxXb3JrZXJPcHRpb25zKSxcbiAgSW1hZ2VLaW5kOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gdXRpbF9JbWFnZUtpbmQpLFxuICBJbnZhbGlkUERGRXhjZXB0aW9uOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gSW52YWxpZFBERkV4Y2VwdGlvbiksXG4gIE1pc3NpbmdQREZFeGNlcHRpb246ICgpID0+ICgvKiByZWV4cG9ydCAqLyBNaXNzaW5nUERGRXhjZXB0aW9uKSxcbiAgT1BTOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gT1BTKSxcbiAgT3V0cHV0U2NhbGU6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBPdXRwdXRTY2FsZSksXG4gIFBERkRhdGFSYW5nZVRyYW5zcG9ydDogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFBERkRhdGFSYW5nZVRyYW5zcG9ydCksXG4gIFBERkRhdGVTdHJpbmc6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQREZEYXRlU3RyaW5nKSxcbiAgUERGV29ya2VyOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUERGV29ya2VyKSxcbiAgUGFzc3dvcmRSZXNwb25zZXM6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQYXNzd29yZFJlc3BvbnNlcyksXG4gIFBlcm1pc3Npb25GbGFnOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUGVybWlzc2lvbkZsYWcpLFxuICBQaXhlbHNQZXJJbmNoOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUGl4ZWxzUGVySW5jaCksXG4gIFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiksXG4gIFRleHRMYXllcjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFRleHRMYXllciksXG4gIFRvdWNoTWFuYWdlcjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFRvdWNoTWFuYWdlciksXG4gIFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiksXG4gIFV0aWw6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBVdGlsKSxcbiAgVmVyYm9zaXR5TGV2ZWw6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBWZXJib3NpdHlMZXZlbCksXG4gIFhmYUxheWVyOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gWGZhTGF5ZXIpLFxuICBidWlsZDogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGJ1aWxkKSxcbiAgY3JlYXRlVmFsaWRBYnNvbHV0ZVVybDogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwpLFxuICBmZXRjaERhdGE6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBmZXRjaERhdGEpLFxuICBnZXREb2N1bWVudDogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGdldERvY3VtZW50KSxcbiAgZ2V0RmlsZW5hbWVGcm9tVXJsOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gZ2V0RmlsZW5hbWVGcm9tVXJsKSxcbiAgZ2V0UGRmRmlsZW5hbWVGcm9tVXJsOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gZ2V0UGRmRmlsZW5hbWVGcm9tVXJsKSxcbiAgZ2V0WGZhUGFnZVZpZXdwb3J0OiAoKSA9PiAoLyogcmVleHBvcnQgKi8gZ2V0WGZhUGFnZVZpZXdwb3J0KSxcbiAgaXNEYXRhU2NoZW1lOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gaXNEYXRhU2NoZW1lKSxcbiAgaXNQZGZGaWxlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gaXNQZGZGaWxlKSxcbiAgbm9Db250ZXh0TWVudTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIG5vQ29udGV4dE1lbnUpLFxuICBub3JtYWxpemVVbmljb2RlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gbm9ybWFsaXplVW5pY29kZSksXG4gIHNldExheWVyRGltZW5zaW9uczogKCkgPT4gKC8qIHJlZXhwb3J0ICovIHNldExheWVyRGltZW5zaW9ucyksXG4gIHNoYWRvdzogKCkgPT4gKC8qIHJlZXhwb3J0ICovIHNoYWRvdyksXG4gIHN0b3BFdmVudDogKCkgPT4gKC8qIHJlZXhwb3J0ICovIHN0b3BFdmVudCksXG4gIHZlcnNpb246ICgpID0+ICgvKiByZWV4cG9ydCAqLyB2ZXJzaW9uKVxufSk7XG5cbjsvLyAuL3NyYy9zaGFyZWQvdXRpbC5qc1xuY29uc3QgaXNOb2RlSlMgPSB0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzICsgXCJcIiA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIgJiYgIXByb2Nlc3MudmVyc2lvbnMubncgJiYgIShwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uICYmIHByb2Nlc3MudHlwZSAmJiBwcm9jZXNzLnR5cGUgIT09IFwiYnJvd3NlclwiKTtcbmNvbnN0IElERU5USVRZX01BVFJJWCA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbmNvbnN0IEZPTlRfSURFTlRJVFlfTUFUUklYID0gWzAuMDAxLCAwLCAwLCAwLjAwMSwgMCwgMF07XG5jb25zdCBNQVhfSU1BR0VfU0laRV9UT19DQUNIRSA9IDEwZTY7XG5jb25zdCBMSU5FX0ZBQ1RPUiA9IDEuMzU7XG5jb25zdCBMSU5FX0RFU0NFTlRfRkFDVE9SID0gMC4zNTtcbmNvbnN0IEJBU0VMSU5FX0ZBQ1RPUiA9IExJTkVfREVTQ0VOVF9GQUNUT1IgLyBMSU5FX0ZBQ1RPUjtcbmNvbnN0IFJlbmRlcmluZ0ludGVudEZsYWcgPSB7XG4gIEFOWTogMHgwMSxcbiAgRElTUExBWTogMHgwMixcbiAgUFJJTlQ6IDB4MDQsXG4gIFNBVkU6IDB4MDgsXG4gIEFOTk9UQVRJT05TX0ZPUk1TOiAweDEwLFxuICBBTk5PVEFUSU9OU19TVE9SQUdFOiAweDIwLFxuICBBTk5PVEFUSU9OU19ESVNBQkxFOiAweDQwLFxuICBJU19FRElUSU5HOiAweDgwLFxuICBPUExJU1Q6IDB4MTAwXG59O1xuY29uc3QgQW5ub3RhdGlvbk1vZGUgPSB7XG4gIERJU0FCTEU6IDAsXG4gIEVOQUJMRTogMSxcbiAgRU5BQkxFX0ZPUk1TOiAyLFxuICBFTkFCTEVfU1RPUkFHRTogM1xufTtcbmNvbnN0IEFubm90YXRpb25FZGl0b3JQcmVmaXggPSBcInBkZmpzX2ludGVybmFsX2VkaXRvcl9cIjtcbmNvbnN0IEFubm90YXRpb25FZGl0b3JUeXBlID0ge1xuICBESVNBQkxFOiAtMSxcbiAgTk9ORTogMCxcbiAgRlJFRVRFWFQ6IDMsXG4gIEhJR0hMSUdIVDogOSxcbiAgU1RBTVA6IDEzLFxuICBJTks6IDE1XG59O1xuY29uc3QgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUgPSB7XG4gIFJFU0laRTogMSxcbiAgQ1JFQVRFOiAyLFxuICBGUkVFVEVYVF9TSVpFOiAxMSxcbiAgRlJFRVRFWFRfQ09MT1I6IDEyLFxuICBGUkVFVEVYVF9PUEFDSVRZOiAxMyxcbiAgSU5LX0NPTE9SOiAyMSxcbiAgSU5LX1RISUNLTkVTUzogMjIsXG4gIElOS19PUEFDSVRZOiAyMyxcbiAgSElHSExJR0hUX0NPTE9SOiAzMSxcbiAgSElHSExJR0hUX0RFRkFVTFRfQ09MT1I6IDMyLFxuICBISUdITElHSFRfVEhJQ0tORVNTOiAzMyxcbiAgSElHSExJR0hUX0ZSRUU6IDM0LFxuICBISUdITElHSFRfU0hPV19BTEw6IDM1LFxuICBEUkFXX1NURVA6IDQxXG59O1xuY29uc3QgUGVybWlzc2lvbkZsYWcgPSB7XG4gIFBSSU5UOiAweDA0LFxuICBNT0RJRllfQ09OVEVOVFM6IDB4MDgsXG4gIENPUFk6IDB4MTAsXG4gIE1PRElGWV9BTk5PVEFUSU9OUzogMHgyMCxcbiAgRklMTF9JTlRFUkFDVElWRV9GT1JNUzogMHgxMDAsXG4gIENPUFlfRk9SX0FDQ0VTU0lCSUxJVFk6IDB4MjAwLFxuICBBU1NFTUJMRTogMHg0MDAsXG4gIFBSSU5UX0hJR0hfUVVBTElUWTogMHg4MDBcbn07XG5jb25zdCBUZXh0UmVuZGVyaW5nTW9kZSA9IHtcbiAgRklMTDogMCxcbiAgU1RST0tFOiAxLFxuICBGSUxMX1NUUk9LRTogMixcbiAgSU5WSVNJQkxFOiAzLFxuICBGSUxMX0FERF9UT19QQVRIOiA0LFxuICBTVFJPS0VfQUREX1RPX1BBVEg6IDUsXG4gIEZJTExfU1RST0tFX0FERF9UT19QQVRIOiA2LFxuICBBRERfVE9fUEFUSDogNyxcbiAgRklMTF9TVFJPS0VfTUFTSzogMyxcbiAgQUREX1RPX1BBVEhfRkxBRzogNFxufTtcbmNvbnN0IHV0aWxfSW1hZ2VLaW5kID0ge1xuICBHUkFZU0NBTEVfMUJQUDogMSxcbiAgUkdCXzI0QlBQOiAyLFxuICBSR0JBXzMyQlBQOiAzXG59O1xuY29uc3QgQW5ub3RhdGlvblR5cGUgPSB7XG4gIFRFWFQ6IDEsXG4gIExJTks6IDIsXG4gIEZSRUVURVhUOiAzLFxuICBMSU5FOiA0LFxuICBTUVVBUkU6IDUsXG4gIENJUkNMRTogNixcbiAgUE9MWUdPTjogNyxcbiAgUE9MWUxJTkU6IDgsXG4gIEhJR0hMSUdIVDogOSxcbiAgVU5ERVJMSU5FOiAxMCxcbiAgU1FVSUdHTFk6IDExLFxuICBTVFJJS0VPVVQ6IDEyLFxuICBTVEFNUDogMTMsXG4gIENBUkVUOiAxNCxcbiAgSU5LOiAxNSxcbiAgUE9QVVA6IDE2LFxuICBGSUxFQVRUQUNITUVOVDogMTcsXG4gIFNPVU5EOiAxOCxcbiAgTU9WSUU6IDE5LFxuICBXSURHRVQ6IDIwLFxuICBTQ1JFRU46IDIxLFxuICBQUklOVEVSTUFSSzogMjIsXG4gIFRSQVBORVQ6IDIzLFxuICBXQVRFUk1BUks6IDI0LFxuICBUSFJFRUQ6IDI1LFxuICBSRURBQ1Q6IDI2XG59O1xuY29uc3QgQW5ub3RhdGlvblJlcGx5VHlwZSA9IHtcbiAgR1JPVVA6IFwiR3JvdXBcIixcbiAgUkVQTFk6IFwiUlwiXG59O1xuY29uc3QgQW5ub3RhdGlvbkZsYWcgPSB7XG4gIElOVklTSUJMRTogMHgwMSxcbiAgSElEREVOOiAweDAyLFxuICBQUklOVDogMHgwNCxcbiAgTk9aT09NOiAweDA4LFxuICBOT1JPVEFURTogMHgxMCxcbiAgTk9WSUVXOiAweDIwLFxuICBSRUFET05MWTogMHg0MCxcbiAgTE9DS0VEOiAweDgwLFxuICBUT0dHTEVOT1ZJRVc6IDB4MTAwLFxuICBMT0NLRURDT05URU5UUzogMHgyMDBcbn07XG5jb25zdCBBbm5vdGF0aW9uRmllbGRGbGFnID0ge1xuICBSRUFET05MWTogMHgwMDAwMDAxLFxuICBSRVFVSVJFRDogMHgwMDAwMDAyLFxuICBOT0VYUE9SVDogMHgwMDAwMDA0LFxuICBNVUxUSUxJTkU6IDB4MDAwMTAwMCxcbiAgUEFTU1dPUkQ6IDB4MDAwMjAwMCxcbiAgTk9UT0dHTEVUT09GRjogMHgwMDA0MDAwLFxuICBSQURJTzogMHgwMDA4MDAwLFxuICBQVVNIQlVUVE9OOiAweDAwMTAwMDAsXG4gIENPTUJPOiAweDAwMjAwMDAsXG4gIEVESVQ6IDB4MDA0MDAwMCxcbiAgU09SVDogMHgwMDgwMDAwLFxuICBGSUxFU0VMRUNUOiAweDAxMDAwMDAsXG4gIE1VTFRJU0VMRUNUOiAweDAyMDAwMDAsXG4gIERPTk9UU1BFTExDSEVDSzogMHgwNDAwMDAwLFxuICBET05PVFNDUk9MTDogMHgwODAwMDAwLFxuICBDT01COiAweDEwMDAwMDAsXG4gIFJJQ0hURVhUOiAweDIwMDAwMDAsXG4gIFJBRElPU0lOVU5JU09OOiAweDIwMDAwMDAsXG4gIENPTU1JVE9OU0VMQ0hBTkdFOiAweDQwMDAwMDBcbn07XG5jb25zdCBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlID0ge1xuICBTT0xJRDogMSxcbiAgREFTSEVEOiAyLFxuICBCRVZFTEVEOiAzLFxuICBJTlNFVDogNCxcbiAgVU5ERVJMSU5FOiA1XG59O1xuY29uc3QgQW5ub3RhdGlvbkFjdGlvbkV2ZW50VHlwZSA9IHtcbiAgRTogXCJNb3VzZSBFbnRlclwiLFxuICBYOiBcIk1vdXNlIEV4aXRcIixcbiAgRDogXCJNb3VzZSBEb3duXCIsXG4gIFU6IFwiTW91c2UgVXBcIixcbiAgRm86IFwiRm9jdXNcIixcbiAgQmw6IFwiQmx1clwiLFxuICBQTzogXCJQYWdlT3BlblwiLFxuICBQQzogXCJQYWdlQ2xvc2VcIixcbiAgUFY6IFwiUGFnZVZpc2libGVcIixcbiAgUEk6IFwiUGFnZUludmlzaWJsZVwiLFxuICBLOiBcIktleXN0cm9rZVwiLFxuICBGOiBcIkZvcm1hdFwiLFxuICBWOiBcIlZhbGlkYXRlXCIsXG4gIEM6IFwiQ2FsY3VsYXRlXCJcbn07XG5jb25zdCBEb2N1bWVudEFjdGlvbkV2ZW50VHlwZSA9IHtcbiAgV0M6IFwiV2lsbENsb3NlXCIsXG4gIFdTOiBcIldpbGxTYXZlXCIsXG4gIERTOiBcIkRpZFNhdmVcIixcbiAgV1A6IFwiV2lsbFByaW50XCIsXG4gIERQOiBcIkRpZFByaW50XCJcbn07XG5jb25zdCBQYWdlQWN0aW9uRXZlbnRUeXBlID0ge1xuICBPOiBcIlBhZ2VPcGVuXCIsXG4gIEM6IFwiUGFnZUNsb3NlXCJcbn07XG5jb25zdCBWZXJib3NpdHlMZXZlbCA9IHtcbiAgRVJST1JTOiAwLFxuICBXQVJOSU5HUzogMSxcbiAgSU5GT1M6IDVcbn07XG5jb25zdCBPUFMgPSB7XG4gIGRlcGVuZGVuY3k6IDEsXG4gIHNldExpbmVXaWR0aDogMixcbiAgc2V0TGluZUNhcDogMyxcbiAgc2V0TGluZUpvaW46IDQsXG4gIHNldE1pdGVyTGltaXQ6IDUsXG4gIHNldERhc2g6IDYsXG4gIHNldFJlbmRlcmluZ0ludGVudDogNyxcbiAgc2V0RmxhdG5lc3M6IDgsXG4gIHNldEdTdGF0ZTogOSxcbiAgc2F2ZTogMTAsXG4gIHJlc3RvcmU6IDExLFxuICB0cmFuc2Zvcm06IDEyLFxuICBtb3ZlVG86IDEzLFxuICBsaW5lVG86IDE0LFxuICBjdXJ2ZVRvOiAxNSxcbiAgY3VydmVUbzI6IDE2LFxuICBjdXJ2ZVRvMzogMTcsXG4gIGNsb3NlUGF0aDogMTgsXG4gIHJlY3RhbmdsZTogMTksXG4gIHN0cm9rZTogMjAsXG4gIGNsb3NlU3Ryb2tlOiAyMSxcbiAgZmlsbDogMjIsXG4gIGVvRmlsbDogMjMsXG4gIGZpbGxTdHJva2U6IDI0LFxuICBlb0ZpbGxTdHJva2U6IDI1LFxuICBjbG9zZUZpbGxTdHJva2U6IDI2LFxuICBjbG9zZUVPRmlsbFN0cm9rZTogMjcsXG4gIGVuZFBhdGg6IDI4LFxuICBjbGlwOiAyOSxcbiAgZW9DbGlwOiAzMCxcbiAgYmVnaW5UZXh0OiAzMSxcbiAgZW5kVGV4dDogMzIsXG4gIHNldENoYXJTcGFjaW5nOiAzMyxcbiAgc2V0V29yZFNwYWNpbmc6IDM0LFxuICBzZXRIU2NhbGU6IDM1LFxuICBzZXRMZWFkaW5nOiAzNixcbiAgc2V0Rm9udDogMzcsXG4gIHNldFRleHRSZW5kZXJpbmdNb2RlOiAzOCxcbiAgc2V0VGV4dFJpc2U6IDM5LFxuICBtb3ZlVGV4dDogNDAsXG4gIHNldExlYWRpbmdNb3ZlVGV4dDogNDEsXG4gIHNldFRleHRNYXRyaXg6IDQyLFxuICBuZXh0TGluZTogNDMsXG4gIHNob3dUZXh0OiA0NCxcbiAgc2hvd1NwYWNlZFRleHQ6IDQ1LFxuICBuZXh0TGluZVNob3dUZXh0OiA0NixcbiAgbmV4dExpbmVTZXRTcGFjaW5nU2hvd1RleHQ6IDQ3LFxuICBzZXRDaGFyV2lkdGg6IDQ4LFxuICBzZXRDaGFyV2lkdGhBbmRCb3VuZHM6IDQ5LFxuICBzZXRTdHJva2VDb2xvclNwYWNlOiA1MCxcbiAgc2V0RmlsbENvbG9yU3BhY2U6IDUxLFxuICBzZXRTdHJva2VDb2xvcjogNTIsXG4gIHNldFN0cm9rZUNvbG9yTjogNTMsXG4gIHNldEZpbGxDb2xvcjogNTQsXG4gIHNldEZpbGxDb2xvck46IDU1LFxuICBzZXRTdHJva2VHcmF5OiA1NixcbiAgc2V0RmlsbEdyYXk6IDU3LFxuICBzZXRTdHJva2VSR0JDb2xvcjogNTgsXG4gIHNldEZpbGxSR0JDb2xvcjogNTksXG4gIHNldFN0cm9rZUNNWUtDb2xvcjogNjAsXG4gIHNldEZpbGxDTVlLQ29sb3I6IDYxLFxuICBzaGFkaW5nRmlsbDogNjIsXG4gIGJlZ2luSW5saW5lSW1hZ2U6IDYzLFxuICBiZWdpbkltYWdlRGF0YTogNjQsXG4gIGVuZElubGluZUltYWdlOiA2NSxcbiAgcGFpbnRYT2JqZWN0OiA2NixcbiAgbWFya1BvaW50OiA2NyxcbiAgbWFya1BvaW50UHJvcHM6IDY4LFxuICBiZWdpbk1hcmtlZENvbnRlbnQ6IDY5LFxuICBiZWdpbk1hcmtlZENvbnRlbnRQcm9wczogNzAsXG4gIGVuZE1hcmtlZENvbnRlbnQ6IDcxLFxuICBiZWdpbkNvbXBhdDogNzIsXG4gIGVuZENvbXBhdDogNzMsXG4gIHBhaW50Rm9ybVhPYmplY3RCZWdpbjogNzQsXG4gIHBhaW50Rm9ybVhPYmplY3RFbmQ6IDc1LFxuICBiZWdpbkdyb3VwOiA3NixcbiAgZW5kR3JvdXA6IDc3LFxuICBiZWdpbkFubm90YXRpb246IDgwLFxuICBlbmRBbm5vdGF0aW9uOiA4MSxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0OiA4MyxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0R3JvdXA6IDg0LFxuICBwYWludEltYWdlWE9iamVjdDogODUsXG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0OiA4NixcbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cDogODcsXG4gIHBhaW50SW1hZ2VYT2JqZWN0UmVwZWF0OiA4OCxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0UmVwZWF0OiA4OSxcbiAgcGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrOiA5MCxcbiAgY29uc3RydWN0UGF0aDogOTEsXG4gIHNldFN0cm9rZVRyYW5zcGFyZW50OiA5MixcbiAgc2V0RmlsbFRyYW5zcGFyZW50OiA5M1xufTtcbmNvbnN0IFBhc3N3b3JkUmVzcG9uc2VzID0ge1xuICBORUVEX1BBU1NXT1JEOiAxLFxuICBJTkNPUlJFQ1RfUEFTU1dPUkQ6IDJcbn07XG5sZXQgdmVyYm9zaXR5ID0gVmVyYm9zaXR5TGV2ZWwuV0FSTklOR1M7XG5mdW5jdGlvbiBzZXRWZXJib3NpdHlMZXZlbChsZXZlbCkge1xuICBpZiAoTnVtYmVyLmlzSW50ZWdlcihsZXZlbCkpIHtcbiAgICB2ZXJib3NpdHkgPSBsZXZlbDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VmVyYm9zaXR5TGV2ZWwoKSB7XG4gIHJldHVybiB2ZXJib3NpdHk7XG59XG5mdW5jdGlvbiBpbmZvKG1zZykge1xuICBpZiAodmVyYm9zaXR5ID49IFZlcmJvc2l0eUxldmVsLklORk9TKSB7XG4gICAgY29uc29sZS5sb2coYEluZm86ICR7bXNnfWApO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuKG1zZykge1xuICBpZiAodmVyYm9zaXR5ID49IFZlcmJvc2l0eUxldmVsLldBUk5JTkdTKSB7XG4gICAgY29uc29sZS5sb2coYFdhcm5pbmc6ICR7bXNnfWApO1xuICB9XG59XG5mdW5jdGlvbiB1bnJlYWNoYWJsZShtc2cpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG59XG5mdW5jdGlvbiBhc3NlcnQoY29uZCwgbXNnKSB7XG4gIGlmICghY29uZCkge1xuICAgIHVucmVhY2hhYmxlKG1zZyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9pc1ZhbGlkUHJvdG9jb2wodXJsKSB7XG4gIHN3aXRjaCAodXJsPy5wcm90b2NvbCkge1xuICAgIGNhc2UgXCJodHRwOlwiOlxuICAgIGNhc2UgXCJodHRwczpcIjpcbiAgICBjYXNlIFwiZnRwOlwiOlxuICAgIGNhc2UgXCJtYWlsdG86XCI6XG4gICAgY2FzZSBcInRlbDpcIjpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwodXJsLCBiYXNlVXJsID0gbnVsbCwgb3B0aW9ucyA9IG51bGwpIHtcbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChvcHRpb25zLmFkZERlZmF1bHRQcm90b2NvbCAmJiB1cmwuc3RhcnRzV2l0aChcInd3dy5cIikpIHtcbiAgICAgICAgY29uc3QgZG90cyA9IHVybC5tYXRjaCgvXFwuL2cpO1xuICAgICAgICBpZiAoZG90cz8ubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICB1cmwgPSBgaHR0cDovLyR7dXJsfWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnRyeUNvbnZlcnRFbmNvZGluZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHVybCA9IHN0cmluZ1RvVVRGOFN0cmluZyh1cmwpO1xuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFic29sdXRlVXJsID0gYmFzZVVybCA/IG5ldyBVUkwodXJsLCBiYXNlVXJsKSA6IG5ldyBVUkwodXJsKTtcbiAgICBpZiAoX2lzVmFsaWRQcm90b2NvbChhYnNvbHV0ZVVybCkpIHtcbiAgICAgIHJldHVybiBhYnNvbHV0ZVVybDtcbiAgICB9XG4gIH0gY2F0Y2gge31cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzaGFkb3cob2JqLCBwcm9wLCB2YWx1ZSwgbm9uU2VyaWFsaXphYmxlID0gZmFsc2UpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuICAgIHZhbHVlLFxuICAgIGVudW1lcmFibGU6ICFub25TZXJpYWxpemFibGUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgQmFzZUV4Y2VwdGlvbiA9IGZ1bmN0aW9uIEJhc2VFeGNlcHRpb25DbG9zdXJlKCkge1xuICBmdW5jdGlvbiBCYXNlRXhjZXB0aW9uKG1lc3NhZ2UsIG5hbWUpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cbiAgQmFzZUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgQmFzZUV4Y2VwdGlvbi5jb25zdHJ1Y3RvciA9IEJhc2VFeGNlcHRpb247XG4gIHJldHVybiBCYXNlRXhjZXB0aW9uO1xufSgpO1xuY2xhc3MgUGFzc3dvcmRFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnLCBjb2RlKSB7XG4gICAgc3VwZXIobXNnLCBcIlBhc3N3b3JkRXhjZXB0aW9uXCIpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gIH1cbn1cbmNsYXNzIFVua25vd25FcnJvckV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIGRldGFpbHMpIHtcbiAgICBzdXBlcihtc2csIFwiVW5rbm93bkVycm9yRXhjZXB0aW9uXCIpO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gIH1cbn1cbmNsYXNzIEludmFsaWRQREZFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgc3VwZXIobXNnLCBcIkludmFsaWRQREZFeGNlcHRpb25cIik7XG4gIH1cbn1cbmNsYXNzIE1pc3NpbmdQREZFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgc3VwZXIobXNnLCBcIk1pc3NpbmdQREZFeGNlcHRpb25cIik7XG4gIH1cbn1cbmNsYXNzIFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIHN0YXR1cykge1xuICAgIHN1cGVyKG1zZywgXCJVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb25cIik7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gIH1cbn1cbmNsYXNzIEZvcm1hdEVycm9yIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZykge1xuICAgIHN1cGVyKG1zZywgXCJGb3JtYXRFcnJvclwiKTtcbiAgfVxufVxuY2xhc3MgQWJvcnRFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgc3VwZXIobXNnLCBcIkFib3J0RXhjZXB0aW9uXCIpO1xuICB9XG59XG5mdW5jdGlvbiBieXRlc1RvU3RyaW5nKGJ5dGVzKSB7XG4gIGlmICh0eXBlb2YgYnl0ZXMgIT09IFwib2JqZWN0XCIgfHwgYnl0ZXM/Lmxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdW5yZWFjaGFibGUoXCJJbnZhbGlkIGFyZ3VtZW50IGZvciBieXRlc1RvU3RyaW5nXCIpO1xuICB9XG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgY29uc3QgTUFYX0FSR1VNRU5UX0NPVU5UID0gODE5MjtcbiAgaWYgKGxlbmd0aCA8IE1BWF9BUkdVTUVOVF9DT1VOVCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVzKTtcbiAgfVxuICBjb25zdCBzdHJCdWYgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gTUFYX0FSR1VNRU5UX0NPVU5UKSB7XG4gICAgY29uc3QgY2h1bmtFbmQgPSBNYXRoLm1pbihpICsgTUFYX0FSR1VNRU5UX0NPVU5ULCBsZW5ndGgpO1xuICAgIGNvbnN0IGNodW5rID0gYnl0ZXMuc3ViYXJyYXkoaSwgY2h1bmtFbmQpO1xuICAgIHN0ckJ1Zi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY2h1bmspKTtcbiAgfVxuICByZXR1cm4gc3RyQnVmLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gXCJzdHJpbmdcIikge1xuICAgIHVucmVhY2hhYmxlKFwiSW52YWxpZCBhcmd1bWVudCBmb3Igc3RyaW5nVG9CeXRlc1wiKTtcbiAgfVxuICBjb25zdCBsZW5ndGggPSBzdHIubGVuZ3RoO1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBieXRlc1tpXSA9IHN0ci5jaGFyQ29kZUF0KGkpICYgMHhmZjtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBzdHJpbmczMih2YWx1ZSkge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh2YWx1ZSA+PiAyNCAmIDB4ZmYsIHZhbHVlID4+IDE2ICYgMHhmZiwgdmFsdWUgPj4gOCAmIDB4ZmYsIHZhbHVlICYgMHhmZik7XG59XG5mdW5jdGlvbiBvYmplY3RTaXplKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGg7XG59XG5mdW5jdGlvbiBvYmplY3RGcm9tTWFwKG1hcCkge1xuICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXApIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBpc0xpdHRsZUVuZGlhbigpIHtcbiAgY29uc3QgYnVmZmVyOCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICBidWZmZXI4WzBdID0gMTtcbiAgY29uc3QgdmlldzMyID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcjguYnVmZmVyLCAwLCAxKTtcbiAgcmV0dXJuIHZpZXczMlswXSA9PT0gMTtcbn1cbmZ1bmN0aW9uIGlzRXZhbFN1cHBvcnRlZCgpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oXCJcIik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuY2xhc3MgdXRpbF9GZWF0dXJlVGVzdCB7XG4gIHN0YXRpYyBnZXQgaXNMaXR0bGVFbmRpYW4oKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzTGl0dGxlRW5kaWFuXCIsIGlzTGl0dGxlRW5kaWFuKCkpO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNFdmFsU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0V2YWxTdXBwb3J0ZWRcIiwgaXNFdmFsU3VwcG9ydGVkKCkpO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkXCIsIHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09IFwidW5kZWZpbmVkXCIpO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNJbWFnZURlY29kZXJTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkXCIsIHR5cGVvZiBJbWFnZURlY29kZXIgIT09IFwidW5kZWZpbmVkXCIpO1xuICB9XG4gIHN0YXRpYyBnZXQgcGxhdGZvcm0oKSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIG5hdmlnYXRvcj8ucGxhdGZvcm0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBzaGFkb3codGhpcywgXCJwbGF0Zm9ybVwiLCB7XG4gICAgICAgIGlzTWFjOiBuYXZpZ2F0b3IucGxhdGZvcm0uaW5jbHVkZXMoXCJNYWNcIiksXG4gICAgICAgIGlzV2luZG93czogbmF2aWdhdG9yLnBsYXRmb3JtLmluY2x1ZGVzKFwiV2luXCIpLFxuICAgICAgICBpc0ZpcmVmb3g6IHR5cGVvZiBuYXZpZ2F0b3I/LnVzZXJBZ2VudCA9PT0gXCJzdHJpbmdcIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiRmlyZWZveFwiKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJwbGF0Zm9ybVwiLCB7XG4gICAgICBpc01hYzogZmFsc2UsXG4gICAgICBpc1dpbmRvd3M6IGZhbHNlLFxuICAgICAgaXNGaXJlZm94OiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNDU1NSb3VuZFN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNDU1NSb3VuZFN1cHBvcnRlZFwiLCBnbG9iYWxUaGlzLkNTUz8uc3VwcG9ydHM/LihcIndpZHRoOiByb3VuZCgxLjVweCwgMXB4KVwiKSk7XG4gIH1cbn1cbmNvbnN0IGhleE51bWJlcnMgPSBBcnJheS5mcm9tKEFycmF5KDI1Nikua2V5cygpLCBuID0+IG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSk7XG5jbGFzcyBVdGlsIHtcbiAgc3RhdGljIG1ha2VIZXhDb2xvcihyLCBnLCBiKSB7XG4gICAgcmV0dXJuIGAjJHtoZXhOdW1iZXJzW3JdfSR7aGV4TnVtYmVyc1tnXX0ke2hleE51bWJlcnNbYl19YDtcbiAgfVxuICBzdGF0aWMgc2NhbGVNaW5NYXgodHJhbnNmb3JtLCBtaW5NYXgpIHtcbiAgICBsZXQgdGVtcDtcbiAgICBpZiAodHJhbnNmb3JtWzBdKSB7XG4gICAgICBpZiAodHJhbnNmb3JtWzBdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzBdO1xuICAgICAgICBtaW5NYXhbMF0gPSBtaW5NYXhbMl07XG4gICAgICAgIG1pbk1heFsyXSA9IHRlbXA7XG4gICAgICB9XG4gICAgICBtaW5NYXhbMF0gKj0gdHJhbnNmb3JtWzBdO1xuICAgICAgbWluTWF4WzJdICo9IHRyYW5zZm9ybVswXTtcbiAgICAgIGlmICh0cmFuc2Zvcm1bM10gPCAwKSB7XG4gICAgICAgIHRlbXAgPSBtaW5NYXhbMV07XG4gICAgICAgIG1pbk1heFsxXSA9IG1pbk1heFszXTtcbiAgICAgICAgbWluTWF4WzNdID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIG1pbk1heFsxXSAqPSB0cmFuc2Zvcm1bM107XG4gICAgICBtaW5NYXhbM10gKj0gdHJhbnNmb3JtWzNdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZW1wID0gbWluTWF4WzBdO1xuICAgICAgbWluTWF4WzBdID0gbWluTWF4WzFdO1xuICAgICAgbWluTWF4WzFdID0gdGVtcDtcbiAgICAgIHRlbXAgPSBtaW5NYXhbMl07XG4gICAgICBtaW5NYXhbMl0gPSBtaW5NYXhbM107XG4gICAgICBtaW5NYXhbM10gPSB0ZW1wO1xuICAgICAgaWYgKHRyYW5zZm9ybVsxXSA8IDApIHtcbiAgICAgICAgdGVtcCA9IG1pbk1heFsxXTtcbiAgICAgICAgbWluTWF4WzFdID0gbWluTWF4WzNdO1xuICAgICAgICBtaW5NYXhbM10gPSB0ZW1wO1xuICAgICAgfVxuICAgICAgbWluTWF4WzFdICo9IHRyYW5zZm9ybVsxXTtcbiAgICAgIG1pbk1heFszXSAqPSB0cmFuc2Zvcm1bMV07XG4gICAgICBpZiAodHJhbnNmb3JtWzJdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzBdO1xuICAgICAgICBtaW5NYXhbMF0gPSBtaW5NYXhbMl07XG4gICAgICAgIG1pbk1heFsyXSA9IHRlbXA7XG4gICAgICB9XG4gICAgICBtaW5NYXhbMF0gKj0gdHJhbnNmb3JtWzJdO1xuICAgICAgbWluTWF4WzJdICo9IHRyYW5zZm9ybVsyXTtcbiAgICB9XG4gICAgbWluTWF4WzBdICs9IHRyYW5zZm9ybVs0XTtcbiAgICBtaW5NYXhbMV0gKz0gdHJhbnNmb3JtWzVdO1xuICAgIG1pbk1heFsyXSArPSB0cmFuc2Zvcm1bNF07XG4gICAgbWluTWF4WzNdICs9IHRyYW5zZm9ybVs1XTtcbiAgfVxuICBzdGF0aWMgdHJhbnNmb3JtKG0xLCBtMikge1xuICAgIHJldHVybiBbbTFbMF0gKiBtMlswXSArIG0xWzJdICogbTJbMV0sIG0xWzFdICogbTJbMF0gKyBtMVszXSAqIG0yWzFdLCBtMVswXSAqIG0yWzJdICsgbTFbMl0gKiBtMlszXSwgbTFbMV0gKiBtMlsyXSArIG0xWzNdICogbTJbM10sIG0xWzBdICogbTJbNF0gKyBtMVsyXSAqIG0yWzVdICsgbTFbNF0sIG0xWzFdICogbTJbNF0gKyBtMVszXSAqIG0yWzVdICsgbTFbNV1dO1xuICB9XG4gIHN0YXRpYyBhcHBseVRyYW5zZm9ybShwLCBtKSB7XG4gICAgY29uc3QgeHQgPSBwWzBdICogbVswXSArIHBbMV0gKiBtWzJdICsgbVs0XTtcbiAgICBjb25zdCB5dCA9IHBbMF0gKiBtWzFdICsgcFsxXSAqIG1bM10gKyBtWzVdO1xuICAgIHJldHVybiBbeHQsIHl0XTtcbiAgfVxuICBzdGF0aWMgYXBwbHlJbnZlcnNlVHJhbnNmb3JtKHAsIG0pIHtcbiAgICBjb25zdCBkID0gbVswXSAqIG1bM10gLSBtWzFdICogbVsyXTtcbiAgICBjb25zdCB4dCA9IChwWzBdICogbVszXSAtIHBbMV0gKiBtWzJdICsgbVsyXSAqIG1bNV0gLSBtWzRdICogbVszXSkgLyBkO1xuICAgIGNvbnN0IHl0ID0gKC1wWzBdICogbVsxXSArIHBbMV0gKiBtWzBdICsgbVs0XSAqIG1bMV0gLSBtWzVdICogbVswXSkgLyBkO1xuICAgIHJldHVybiBbeHQsIHl0XTtcbiAgfVxuICBzdGF0aWMgZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3gociwgbSkge1xuICAgIGNvbnN0IHAxID0gdGhpcy5hcHBseVRyYW5zZm9ybShyLCBtKTtcbiAgICBjb25zdCBwMiA9IHRoaXMuYXBwbHlUcmFuc2Zvcm0oci5zbGljZSgyLCA0KSwgbSk7XG4gICAgY29uc3QgcDMgPSB0aGlzLmFwcGx5VHJhbnNmb3JtKFtyWzBdLCByWzNdXSwgbSk7XG4gICAgY29uc3QgcDQgPSB0aGlzLmFwcGx5VHJhbnNmb3JtKFtyWzJdLCByWzFdXSwgbSk7XG4gICAgcmV0dXJuIFtNYXRoLm1pbihwMVswXSwgcDJbMF0sIHAzWzBdLCBwNFswXSksIE1hdGgubWluKHAxWzFdLCBwMlsxXSwgcDNbMV0sIHA0WzFdKSwgTWF0aC5tYXgocDFbMF0sIHAyWzBdLCBwM1swXSwgcDRbMF0pLCBNYXRoLm1heChwMVsxXSwgcDJbMV0sIHAzWzFdLCBwNFsxXSldO1xuICB9XG4gIHN0YXRpYyBpbnZlcnNlVHJhbnNmb3JtKG0pIHtcbiAgICBjb25zdCBkID0gbVswXSAqIG1bM10gLSBtWzFdICogbVsyXTtcbiAgICByZXR1cm4gW21bM10gLyBkLCAtbVsxXSAvIGQsIC1tWzJdIC8gZCwgbVswXSAvIGQsIChtWzJdICogbVs1XSAtIG1bNF0gKiBtWzNdKSAvIGQsIChtWzRdICogbVsxXSAtIG1bNV0gKiBtWzBdKSAvIGRdO1xuICB9XG4gIHN0YXRpYyBzaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShtKSB7XG4gICAgY29uc3QgdHJhbnNwb3NlID0gW21bMF0sIG1bMl0sIG1bMV0sIG1bM11dO1xuICAgIGNvbnN0IGEgPSBtWzBdICogdHJhbnNwb3NlWzBdICsgbVsxXSAqIHRyYW5zcG9zZVsyXTtcbiAgICBjb25zdCBiID0gbVswXSAqIHRyYW5zcG9zZVsxXSArIG1bMV0gKiB0cmFuc3Bvc2VbM107XG4gICAgY29uc3QgYyA9IG1bMl0gKiB0cmFuc3Bvc2VbMF0gKyBtWzNdICogdHJhbnNwb3NlWzJdO1xuICAgIGNvbnN0IGQgPSBtWzJdICogdHJhbnNwb3NlWzFdICsgbVszXSAqIHRyYW5zcG9zZVszXTtcbiAgICBjb25zdCBmaXJzdCA9IChhICsgZCkgLyAyO1xuICAgIGNvbnN0IHNlY29uZCA9IE1hdGguc3FydCgoYSArIGQpICoqIDIgLSA0ICogKGEgKiBkIC0gYyAqIGIpKSAvIDI7XG4gICAgY29uc3Qgc3ggPSBmaXJzdCArIHNlY29uZCB8fCAxO1xuICAgIGNvbnN0IHN5ID0gZmlyc3QgLSBzZWNvbmQgfHwgMTtcbiAgICByZXR1cm4gW01hdGguc3FydChzeCksIE1hdGguc3FydChzeSldO1xuICB9XG4gIHN0YXRpYyBub3JtYWxpemVSZWN0KHJlY3QpIHtcbiAgICBjb25zdCByID0gcmVjdC5zbGljZSgwKTtcbiAgICBpZiAocmVjdFswXSA+IHJlY3RbMl0pIHtcbiAgICAgIHJbMF0gPSByZWN0WzJdO1xuICAgICAgclsyXSA9IHJlY3RbMF07XG4gICAgfVxuICAgIGlmIChyZWN0WzFdID4gcmVjdFszXSkge1xuICAgICAgclsxXSA9IHJlY3RbM107XG4gICAgICByWzNdID0gcmVjdFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgc3RhdGljIGludGVyc2VjdChyZWN0MSwgcmVjdDIpIHtcbiAgICBjb25zdCB4TG93ID0gTWF0aC5tYXgoTWF0aC5taW4ocmVjdDFbMF0sIHJlY3QxWzJdKSwgTWF0aC5taW4ocmVjdDJbMF0sIHJlY3QyWzJdKSk7XG4gICAgY29uc3QgeEhpZ2ggPSBNYXRoLm1pbihNYXRoLm1heChyZWN0MVswXSwgcmVjdDFbMl0pLCBNYXRoLm1heChyZWN0MlswXSwgcmVjdDJbMl0pKTtcbiAgICBpZiAoeExvdyA+IHhIaWdoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeUxvdyA9IE1hdGgubWF4KE1hdGgubWluKHJlY3QxWzFdLCByZWN0MVszXSksIE1hdGgubWluKHJlY3QyWzFdLCByZWN0MlszXSkpO1xuICAgIGNvbnN0IHlIaWdoID0gTWF0aC5taW4oTWF0aC5tYXgocmVjdDFbMV0sIHJlY3QxWzNdKSwgTWF0aC5tYXgocmVjdDJbMV0sIHJlY3QyWzNdKSk7XG4gICAgaWYgKHlMb3cgPiB5SGlnaCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBbeExvdywgeUxvdywgeEhpZ2gsIHlIaWdoXTtcbiAgfVxuICBzdGF0aWMgI2dldEV4dHJlbXVtT25DdXJ2ZSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsIHQsIG1pbk1heCkge1xuICAgIGlmICh0IDw9IDAgfHwgdCA+PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG10ID0gMSAtIHQ7XG4gICAgY29uc3QgdHQgPSB0ICogdDtcbiAgICBjb25zdCB0dHQgPSB0dCAqIHQ7XG4gICAgY29uc3QgeCA9IG10ICogKG10ICogKG10ICogeDAgKyAzICogdCAqIHgxKSArIDMgKiB0dCAqIHgyKSArIHR0dCAqIHgzO1xuICAgIGNvbnN0IHkgPSBtdCAqIChtdCAqIChtdCAqIHkwICsgMyAqIHQgKiB5MSkgKyAzICogdHQgKiB5MikgKyB0dHQgKiB5MztcbiAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIHgpO1xuICAgIG1pbk1heFsxXSA9IE1hdGgubWluKG1pbk1heFsxXSwgeSk7XG4gICAgbWluTWF4WzJdID0gTWF0aC5tYXgobWluTWF4WzJdLCB4KTtcbiAgICBtaW5NYXhbM10gPSBNYXRoLm1heChtaW5NYXhbM10sIHkpO1xuICB9XG4gIHN0YXRpYyAjZ2V0RXh0cmVtdW0oeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCBhLCBiLCBjLCBtaW5NYXgpIHtcbiAgICBpZiAoTWF0aC5hYnMoYSkgPCAxZS0xMikge1xuICAgICAgaWYgKE1hdGguYWJzKGIpID49IDFlLTEyKSB7XG4gICAgICAgIHRoaXMuI2dldEV4dHJlbXVtT25DdXJ2ZSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsIC1jIC8gYiwgbWluTWF4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVsdGEgPSBiICoqIDIgLSA0ICogYyAqIGE7XG4gICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzcXJ0RGVsdGEgPSBNYXRoLnNxcnQoZGVsdGEpO1xuICAgIGNvbnN0IGEyID0gMiAqIGE7XG4gICAgdGhpcy4jZ2V0RXh0cmVtdW1PbkN1cnZlKHgwLCB4MSwgeDIsIHgzLCB5MCwgeTEsIHkyLCB5MywgKC1iICsgc3FydERlbHRhKSAvIGEyLCBtaW5NYXgpO1xuICAgIHRoaXMuI2dldEV4dHJlbXVtT25DdXJ2ZSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsICgtYiAtIHNxcnREZWx0YSkgLyBhMiwgbWluTWF4KTtcbiAgfVxuICBzdGF0aWMgYmV6aWVyQm91bmRpbmdCb3goeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBtaW5NYXgpIHtcbiAgICBpZiAobWluTWF4KSB7XG4gICAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIHgwLCB4Myk7XG4gICAgICBtaW5NYXhbMV0gPSBNYXRoLm1pbihtaW5NYXhbMV0sIHkwLCB5Myk7XG4gICAgICBtaW5NYXhbMl0gPSBNYXRoLm1heChtaW5NYXhbMl0sIHgwLCB4Myk7XG4gICAgICBtaW5NYXhbM10gPSBNYXRoLm1heChtaW5NYXhbM10sIHkwLCB5Myk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pbk1heCA9IFtNYXRoLm1pbih4MCwgeDMpLCBNYXRoLm1pbih5MCwgeTMpLCBNYXRoLm1heCh4MCwgeDMpLCBNYXRoLm1heCh5MCwgeTMpXTtcbiAgICB9XG4gICAgdGhpcy4jZ2V0RXh0cmVtdW0oeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCAzICogKC14MCArIDMgKiAoeDEgLSB4MikgKyB4MyksIDYgKiAoeDAgLSAyICogeDEgKyB4MiksIDMgKiAoeDEgLSB4MCksIG1pbk1heCk7XG4gICAgdGhpcy4jZ2V0RXh0cmVtdW0oeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCAzICogKC15MCArIDMgKiAoeTEgLSB5MikgKyB5MyksIDYgKiAoeTAgLSAyICogeTEgKyB5MiksIDMgKiAoeTEgLSB5MCksIG1pbk1heCk7XG4gICAgcmV0dXJuIG1pbk1heDtcbiAgfVxufVxuY29uc3QgUERGU3RyaW5nVHJhbnNsYXRlVGFibGUgPSAoLyogdW51c2VkIHB1cmUgZXhwcmVzc2lvbiBvciBzdXBlciAqLyBudWxsICYmIChbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMHgyZDgsIDB4MmM3LCAweDJjNiwgMHgyZDksIDB4MmRkLCAweDJkYiwgMHgyZGEsIDB4MmRjLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAweDIwMjIsIDB4MjAyMCwgMHgyMDIxLCAweDIwMjYsIDB4MjAxNCwgMHgyMDEzLCAweDE5MiwgMHgyMDQ0LCAweDIwMzksIDB4MjAzYSwgMHgyMjEyLCAweDIwMzAsIDB4MjAxZSwgMHgyMDFjLCAweDIwMWQsIDB4MjAxOCwgMHgyMDE5LCAweDIwMWEsIDB4MjEyMiwgMHhmYjAxLCAweGZiMDIsIDB4MTQxLCAweDE1MiwgMHgxNjAsIDB4MTc4LCAweDE3ZCwgMHgxMzEsIDB4MTQyLCAweDE1MywgMHgxNjEsIDB4MTdlLCAwLCAweDIwYWNdKSk7XG5mdW5jdGlvbiBzdHJpbmdUb1BERlN0cmluZyhzdHIpIHtcbiAgaWYgKHN0clswXSA+PSBcIlxceEVGXCIpIHtcbiAgICBsZXQgZW5jb2Rpbmc7XG4gICAgaWYgKHN0clswXSA9PT0gXCJcXHhGRVwiICYmIHN0clsxXSA9PT0gXCJcXHhGRlwiKSB7XG4gICAgICBlbmNvZGluZyA9IFwidXRmLTE2YmVcIjtcbiAgICAgIGlmIChzdHIubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RyWzBdID09PSBcIlxceEZGXCIgJiYgc3RyWzFdID09PSBcIlxceEZFXCIpIHtcbiAgICAgIGVuY29kaW5nID0gXCJ1dGYtMTZsZVwiO1xuICAgICAgaWYgKHN0ci5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdHJbMF0gPT09IFwiXFx4RUZcIiAmJiBzdHJbMV0gPT09IFwiXFx4QkJcIiAmJiBzdHJbMl0gPT09IFwiXFx4QkZcIikge1xuICAgICAgZW5jb2RpbmcgPSBcInV0Zi04XCI7XG4gICAgfVxuICAgIGlmIChlbmNvZGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihlbmNvZGluZywge1xuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBzdHJpbmdUb0J5dGVzKHN0cik7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIpO1xuICAgICAgICBpZiAoIWRlY29kZWQuaW5jbHVkZXMoXCJcXHgxYlwiKSkge1xuICAgICAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWNvZGVkLnJlcGxhY2VBbGwoL1xceDFiW15cXHgxYl0qKD86XFx4MWJ8JCkvZywgXCJcIik7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICB3YXJuKGBzdHJpbmdUb1BERlN0cmluZzogXCIke2V4fVwiLmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBzdHJCdWYgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3RyLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICBjb25zdCBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjaGFyQ29kZSA9PT0gMHgxYikge1xuICAgICAgd2hpbGUgKCsraSA8IGlpICYmIHN0ci5jaGFyQ29kZUF0KGkpICE9PSAweDFiKSB7fVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGNvZGUgPSBQREZTdHJpbmdUcmFuc2xhdGVUYWJsZVtjaGFyQ29kZV07XG4gICAgc3RyQnVmLnB1c2goY29kZSA/IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgOiBzdHIuY2hhckF0KGkpKTtcbiAgfVxuICByZXR1cm4gc3RyQnVmLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBzdHJpbmdUb1VURjhTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHN0cikpO1xufVxuZnVuY3Rpb24gdXRmOFN0cmluZ1RvU3RyaW5nKHN0cikge1xuICByZXR1cm4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpO1xufVxuZnVuY3Rpb24gaXNBcnJheUVxdWFsKGFycjEsIGFycjIpIHtcbiAgaWYgKGFycjEubGVuZ3RoICE9PSBhcnIyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMCwgaWkgPSBhcnIxLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICBpZiAoYXJyMVtpXSAhPT0gYXJyMltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldE1vZGlmaWNhdGlvbkRhdGUoZGF0ZSA9IG5ldyBEYXRlKCkpIHtcbiAgY29uc3QgYnVmZmVyID0gW2RhdGUuZ2V0VVRDRnVsbFllYXIoKS50b1N0cmluZygpLCAoZGF0ZS5nZXRVVENNb250aCgpICsgMSkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDRGF0ZSgpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ0hvdXJzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDTWludXRlcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ1NlY29uZHMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKV07XG4gIHJldHVybiBidWZmZXIuam9pbihcIlwiKTtcbn1cbmxldCBOb3JtYWxpemVSZWdleCA9IG51bGw7XG5sZXQgTm9ybWFsaXphdGlvbk1hcCA9IG51bGw7XG5mdW5jdGlvbiBub3JtYWxpemVVbmljb2RlKHN0cikge1xuICBpZiAoIU5vcm1hbGl6ZVJlZ2V4KSB7XG4gICAgTm9ybWFsaXplUmVnZXggPSAvKFtcXHUwMGEwXFx1MDBiNVxcdTAzN2VcXHUwZWIzXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIxMjZcXHVmYjAwLVxcdWZiMDRcXHVmYjA2XFx1ZmIyMC1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDAtXFx1ZmI0MVxcdWZiNDMtXFx1ZmI0NFxcdWZiNDYtXFx1ZmJhMVxcdWZiYTQtXFx1ZmJhOVxcdWZiYWUtXFx1ZmJiMVxcdWZiZDMtXFx1ZmJkY1xcdWZiZGUtXFx1ZmJlN1xcdWZiZWEtXFx1ZmJmOFxcdWZiZmMtXFx1ZmJmZFxcdWZjMDAtXFx1ZmM1ZFxcdWZjNjQtXFx1ZmNmMVxcdWZjZjUtXFx1ZmQzZFxcdWZkODhcXHVmZGY0XFx1ZmRmYS1cXHVmZGZiXFx1ZmU3MVxcdWZlNzdcXHVmZTc5XFx1ZmU3YlxcdWZlN2RdKyl8KFxcdWZiMDUrKS9ndTtcbiAgICBOb3JtYWxpemF0aW9uTWFwID0gbmV3IE1hcChbW1wi76yFXCIsIFwixb90XCJdXSk7XG4gIH1cbiAgcmV0dXJuIHN0ci5yZXBsYWNlQWxsKE5vcm1hbGl6ZVJlZ2V4LCAoXywgcDEsIHAyKSA9PiBwMSA/IHAxLm5vcm1hbGl6ZShcIk5GS0NcIikgOiBOb3JtYWxpemF0aW9uTWFwLmdldChwMikpO1xufVxuZnVuY3Rpb24gZ2V0VXVpZCgpIHtcbiAgaWYgKHR5cGVvZiBjcnlwdG8ucmFuZG9tVVVJRCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGNyeXB0by5yYW5kb21VVUlEKCk7XG4gIH1cbiAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ1Zik7XG4gIHJldHVybiBieXRlc1RvU3RyaW5nKGJ1Zik7XG59XG5jb25zdCBBbm5vdGF0aW9uUHJlZml4ID0gXCJwZGZqc19pbnRlcm5hbF9pZF9cIjtcbmZ1bmN0aW9uIHRvSGV4VXRpbChhcnIpIHtcbiAgaWYgKFVpbnQ4QXJyYXkucHJvdG90eXBlLnRvSGV4KSB7XG4gICAgcmV0dXJuIGFyci50b0hleCgpO1xuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKGFyciwgbnVtID0+IGhleE51bWJlcnNbbnVtXSkuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIHRvQmFzZTY0VXRpbChhcnIpIHtcbiAgaWYgKFVpbnQ4QXJyYXkucHJvdG90eXBlLnRvQmFzZTY0KSB7XG4gICAgcmV0dXJuIGFyci50b0Jhc2U2NCgpO1xuICB9XG4gIHJldHVybiBidG9hKGJ5dGVzVG9TdHJpbmcoYXJyKSk7XG59XG5mdW5jdGlvbiBmcm9tQmFzZTY0VXRpbChzdHIpIHtcbiAgaWYgKFVpbnQ4QXJyYXkuZnJvbUJhc2U2NCkge1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb21CYXNlNjQoc3RyKTtcbiAgfVxuICByZXR1cm4gc3RyaW5nVG9CeXRlcyhhdG9iKHN0cikpO1xufVxuaWYgKHR5cGVvZiBQcm9taXNlLnRyeSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gIFByb21pc2UudHJ5ID0gZnVuY3Rpb24gKGZuLCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgfSk7XG4gIH07XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2Rpc3BsYXlfdXRpbHMuanNcblxuY29uc3QgU1ZHX05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuY2xhc3MgUGl4ZWxzUGVySW5jaCB7XG4gIHN0YXRpYyBDU1MgPSA5Ni4wO1xuICBzdGF0aWMgUERGID0gNzIuMDtcbiAgc3RhdGljIFBERl9UT19DU1NfVU5JVFMgPSB0aGlzLkNTUyAvIHRoaXMuUERGO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hEYXRhKHVybCwgdHlwZSA9IFwidGV4dFwiKSB7XG4gIGlmIChpc1ZhbGlkRmV0Y2hVcmwodXJsLCBkb2N1bWVudC5iYXNlVVJJKSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcImFycmF5YnVmZmVyXCI6XG4gICAgICAgIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgY2FzZSBcImJsb2JcIjpcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgIGNhc2UgXCJqc29uXCI6XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgcmVxdWVzdC5vcGVuKFwiR0VUXCIsIHVybCwgdHJ1ZSk7XG4gICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSB0eXBlO1xuICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuRE9ORSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDIwMCB8fCByZXF1ZXN0LnN0YXR1cyA9PT0gMCkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiYXJyYXlidWZmZXJcIjpcbiAgICAgICAgICBjYXNlIFwiYmxvYlwiOlxuICAgICAgICAgIGNhc2UgXCJqc29uXCI6XG4gICAgICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUocmVxdWVzdC5yZXNwb25zZVRleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZWplY3QobmV3IEVycm9yKHJlcXVlc3Quc3RhdHVzVGV4dCkpO1xuICAgIH07XG4gICAgcmVxdWVzdC5zZW5kKG51bGwpO1xuICB9KTtcbn1cbmNsYXNzIFBhZ2VWaWV3cG9ydCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB2aWV3Qm94LFxuICAgIHVzZXJVbml0LFxuICAgIHNjYWxlLFxuICAgIHJvdGF0aW9uLFxuICAgIG9mZnNldFggPSAwLFxuICAgIG9mZnNldFkgPSAwLFxuICAgIGRvbnRGbGlwID0gZmFsc2VcbiAgfSkge1xuICAgIHRoaXMudmlld0JveCA9IHZpZXdCb3g7XG4gICAgdGhpcy51c2VyVW5pdCA9IHVzZXJVbml0O1xuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb247XG4gICAgdGhpcy5vZmZzZXRYID0gb2Zmc2V0WDtcbiAgICB0aGlzLm9mZnNldFkgPSBvZmZzZXRZO1xuICAgIHNjYWxlICo9IHVzZXJVbml0O1xuICAgIGNvbnN0IGNlbnRlclggPSAodmlld0JveFsyXSArIHZpZXdCb3hbMF0pIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gKHZpZXdCb3hbM10gKyB2aWV3Qm94WzFdKSAvIDI7XG4gICAgbGV0IHJvdGF0ZUEsIHJvdGF0ZUIsIHJvdGF0ZUMsIHJvdGF0ZUQ7XG4gICAgcm90YXRpb24gJT0gMzYwO1xuICAgIGlmIChyb3RhdGlvbiA8IDApIHtcbiAgICAgIHJvdGF0aW9uICs9IDM2MDtcbiAgICB9XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJvdGF0ZUEgPSAtMTtcbiAgICAgICAgcm90YXRlQiA9IDA7XG4gICAgICAgIHJvdGF0ZUMgPSAwO1xuICAgICAgICByb3RhdGVEID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByb3RhdGVBID0gMDtcbiAgICAgICAgcm90YXRlQiA9IDE7XG4gICAgICAgIHJvdGF0ZUMgPSAxO1xuICAgICAgICByb3RhdGVEID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcm90YXRlQSA9IDA7XG4gICAgICAgIHJvdGF0ZUIgPSAtMTtcbiAgICAgICAgcm90YXRlQyA9IC0xO1xuICAgICAgICByb3RhdGVEID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJvdGF0ZUEgPSAxO1xuICAgICAgICByb3RhdGVCID0gMDtcbiAgICAgICAgcm90YXRlQyA9IDA7XG4gICAgICAgIHJvdGF0ZUQgPSAtMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYWdlVmlld3BvcnQ6IEludmFsaWQgcm90YXRpb24sIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA5MCBkZWdyZWVzLlwiKTtcbiAgICB9XG4gICAgaWYgKGRvbnRGbGlwKSB7XG4gICAgICByb3RhdGVDID0gLXJvdGF0ZUM7XG4gICAgICByb3RhdGVEID0gLXJvdGF0ZUQ7XG4gICAgfVxuICAgIGxldCBvZmZzZXRDYW52YXNYLCBvZmZzZXRDYW52YXNZO1xuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuICAgIGlmIChyb3RhdGVBID09PSAwKSB7XG4gICAgICBvZmZzZXRDYW52YXNYID0gTWF0aC5hYnMoY2VudGVyWSAtIHZpZXdCb3hbMV0pICogc2NhbGUgKyBvZmZzZXRYO1xuICAgICAgb2Zmc2V0Q2FudmFzWSA9IE1hdGguYWJzKGNlbnRlclggLSB2aWV3Qm94WzBdKSAqIHNjYWxlICsgb2Zmc2V0WTtcbiAgICAgIHdpZHRoID0gKHZpZXdCb3hbM10gLSB2aWV3Qm94WzFdKSAqIHNjYWxlO1xuICAgICAgaGVpZ2h0ID0gKHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdKSAqIHNjYWxlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXRDYW52YXNYID0gTWF0aC5hYnMoY2VudGVyWCAtIHZpZXdCb3hbMF0pICogc2NhbGUgKyBvZmZzZXRYO1xuICAgICAgb2Zmc2V0Q2FudmFzWSA9IE1hdGguYWJzKGNlbnRlclkgLSB2aWV3Qm94WzFdKSAqIHNjYWxlICsgb2Zmc2V0WTtcbiAgICAgIHdpZHRoID0gKHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdKSAqIHNjYWxlO1xuICAgICAgaGVpZ2h0ID0gKHZpZXdCb3hbM10gLSB2aWV3Qm94WzFdKSAqIHNjYWxlO1xuICAgIH1cbiAgICB0aGlzLnRyYW5zZm9ybSA9IFtyb3RhdGVBICogc2NhbGUsIHJvdGF0ZUIgKiBzY2FsZSwgcm90YXRlQyAqIHNjYWxlLCByb3RhdGVEICogc2NhbGUsIG9mZnNldENhbnZhc1ggLSByb3RhdGVBICogc2NhbGUgKiBjZW50ZXJYIC0gcm90YXRlQyAqIHNjYWxlICogY2VudGVyWSwgb2Zmc2V0Q2FudmFzWSAtIHJvdGF0ZUIgKiBzY2FsZSAqIGNlbnRlclggLSByb3RhdGVEICogc2NhbGUgKiBjZW50ZXJZXTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgZ2V0IHJhd0RpbXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdXNlclVuaXQsXG4gICAgICB2aWV3Qm94XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgZGltcyA9IHZpZXdCb3gubWFwKHggPT4geCAqIHVzZXJVbml0KTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwicmF3RGltc1wiLCB7XG4gICAgICBwYWdlV2lkdGg6IGRpbXNbMl0gLSBkaW1zWzBdLFxuICAgICAgcGFnZUhlaWdodDogZGltc1szXSAtIGRpbXNbMV0sXG4gICAgICBwYWdlWDogZGltc1swXSxcbiAgICAgIHBhZ2VZOiBkaW1zWzFdXG4gICAgfSk7XG4gIH1cbiAgY2xvbmUoe1xuICAgIHNjYWxlID0gdGhpcy5zY2FsZSxcbiAgICByb3RhdGlvbiA9IHRoaXMucm90YXRpb24sXG4gICAgb2Zmc2V0WCA9IHRoaXMub2Zmc2V0WCxcbiAgICBvZmZzZXRZID0gdGhpcy5vZmZzZXRZLFxuICAgIGRvbnRGbGlwID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQYWdlVmlld3BvcnQoe1xuICAgICAgdmlld0JveDogdGhpcy52aWV3Qm94LnNsaWNlKCksXG4gICAgICB1c2VyVW5pdDogdGhpcy51c2VyVW5pdCxcbiAgICAgIHNjYWxlLFxuICAgICAgcm90YXRpb24sXG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WSxcbiAgICAgIGRvbnRGbGlwXG4gICAgfSk7XG4gIH1cbiAgY29udmVydFRvVmlld3BvcnRQb2ludCh4LCB5KSB7XG4gICAgcmV0dXJuIFV0aWwuYXBwbHlUcmFuc2Zvcm0oW3gsIHldLCB0aGlzLnRyYW5zZm9ybSk7XG4gIH1cbiAgY29udmVydFRvVmlld3BvcnRSZWN0YW5nbGUocmVjdCkge1xuICAgIGNvbnN0IHRvcExlZnQgPSBVdGlsLmFwcGx5VHJhbnNmb3JtKFtyZWN0WzBdLCByZWN0WzFdXSwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIGNvbnN0IGJvdHRvbVJpZ2h0ID0gVXRpbC5hcHBseVRyYW5zZm9ybShbcmVjdFsyXSwgcmVjdFszXV0sIHRoaXMudHJhbnNmb3JtKTtcbiAgICByZXR1cm4gW3RvcExlZnRbMF0sIHRvcExlZnRbMV0sIGJvdHRvbVJpZ2h0WzBdLCBib3R0b21SaWdodFsxXV07XG4gIH1cbiAgY29udmVydFRvUGRmUG9pbnQoeCwgeSkge1xuICAgIHJldHVybiBVdGlsLmFwcGx5SW52ZXJzZVRyYW5zZm9ybShbeCwgeV0sIHRoaXMudHJhbnNmb3JtKTtcbiAgfVxufVxuY2xhc3MgUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZywgZXh0cmFEZWxheSA9IDApIHtcbiAgICBzdXBlcihtc2csIFwiUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uXCIpO1xuICAgIHRoaXMuZXh0cmFEZWxheSA9IGV4dHJhRGVsYXk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzRGF0YVNjaGVtZSh1cmwpIHtcbiAgY29uc3QgaWkgPSB1cmwubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgaWkgJiYgdXJsW2ldLnRyaW0oKSA9PT0gXCJcIikge1xuICAgIGkrKztcbiAgfVxuICByZXR1cm4gdXJsLnN1YnN0cmluZyhpLCBpICsgNSkudG9Mb3dlckNhc2UoKSA9PT0gXCJkYXRhOlwiO1xufVxuZnVuY3Rpb24gaXNQZGZGaWxlKGZpbGVuYW1lKSB7XG4gIHJldHVybiB0eXBlb2YgZmlsZW5hbWUgPT09IFwic3RyaW5nXCIgJiYgL1xcLnBkZiQvaS50ZXN0KGZpbGVuYW1lKTtcbn1cbmZ1bmN0aW9uIGdldEZpbGVuYW1lRnJvbVVybCh1cmwpIHtcbiAgW3VybF0gPSB1cmwuc3BsaXQoL1sjP10vLCAxKTtcbiAgcmV0dXJuIHVybC5zdWJzdHJpbmcodXJsLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpO1xufVxuZnVuY3Rpb24gZ2V0UGRmRmlsZW5hbWVGcm9tVXJsKHVybCwgZGVmYXVsdEZpbGVuYW1lID0gXCJkb2N1bWVudC5wZGZcIikge1xuICBpZiAodHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBkZWZhdWx0RmlsZW5hbWU7XG4gIH1cbiAgaWYgKGlzRGF0YVNjaGVtZSh1cmwpKSB7XG4gICAgd2FybignZ2V0UGRmRmlsZW5hbWVGcm9tVXJsOiBpZ25vcmUgXCJkYXRhOlwiLVVSTCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4nKTtcbiAgICByZXR1cm4gZGVmYXVsdEZpbGVuYW1lO1xuICB9XG4gIGNvbnN0IHJlVVJJID0gL14oPzooPzpbXjpdKzopP1xcL1xcL1teL10rKT8oW14/I10qKShcXD9bXiNdKik/KCMuKik/JC87XG4gIGNvbnN0IHJlRmlsZW5hbWUgPSAvW14vPyM9XStcXC5wZGZcXGIoPyEuKlxcLnBkZlxcYikvaTtcbiAgY29uc3Qgc3BsaXRVUkkgPSByZVVSSS5leGVjKHVybCk7XG4gIGxldCBzdWdnZXN0ZWRGaWxlbmFtZSA9IHJlRmlsZW5hbWUuZXhlYyhzcGxpdFVSSVsxXSkgfHwgcmVGaWxlbmFtZS5leGVjKHNwbGl0VVJJWzJdKSB8fCByZUZpbGVuYW1lLmV4ZWMoc3BsaXRVUklbM10pO1xuICBpZiAoc3VnZ2VzdGVkRmlsZW5hbWUpIHtcbiAgICBzdWdnZXN0ZWRGaWxlbmFtZSA9IHN1Z2dlc3RlZEZpbGVuYW1lWzBdO1xuICAgIGlmIChzdWdnZXN0ZWRGaWxlbmFtZS5pbmNsdWRlcyhcIiVcIikpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN1Z2dlc3RlZEZpbGVuYW1lID0gcmVGaWxlbmFtZS5leGVjKGRlY29kZVVSSUNvbXBvbmVudChzdWdnZXN0ZWRGaWxlbmFtZSkpWzBdO1xuICAgICAgfSBjYXRjaCB7fVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3VnZ2VzdGVkRmlsZW5hbWUgfHwgZGVmYXVsdEZpbGVuYW1lO1xufVxuY2xhc3MgU3RhdFRpbWVyIHtcbiAgc3RhcnRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRpbWVzID0gW107XG4gIHRpbWUobmFtZSkge1xuICAgIGlmIChuYW1lIGluIHRoaXMuc3RhcnRlZCkge1xuICAgICAgd2FybihgVGltZXIgaXMgYWxyZWFkeSBydW5uaW5nIGZvciAke25hbWV9YCk7XG4gICAgfVxuICAgIHRoaXMuc3RhcnRlZFtuYW1lXSA9IERhdGUubm93KCk7XG4gIH1cbiAgdGltZUVuZChuYW1lKSB7XG4gICAgaWYgKCEobmFtZSBpbiB0aGlzLnN0YXJ0ZWQpKSB7XG4gICAgICB3YXJuKGBUaW1lciBoYXMgbm90IGJlZW4gc3RhcnRlZCBmb3IgJHtuYW1lfWApO1xuICAgIH1cbiAgICB0aGlzLnRpbWVzLnB1c2goe1xuICAgICAgbmFtZSxcbiAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0ZWRbbmFtZV0sXG4gICAgICBlbmQ6IERhdGUubm93KClcbiAgICB9KTtcbiAgICBkZWxldGUgdGhpcy5zdGFydGVkW25hbWVdO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IG91dEJ1ZiA9IFtdO1xuICAgIGxldCBsb25nZXN0ID0gMDtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIG5hbWVcbiAgICB9IG9mIHRoaXMudGltZXMpIHtcbiAgICAgIGxvbmdlc3QgPSBNYXRoLm1heChuYW1lLmxlbmd0aCwgbG9uZ2VzdCk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kXG4gICAgfSBvZiB0aGlzLnRpbWVzKSB7XG4gICAgICBvdXRCdWYucHVzaChgJHtuYW1lLnBhZEVuZChsb25nZXN0KX0gJHtlbmQgLSBzdGFydH1tc1xcbmApO1xuICAgIH1cbiAgICByZXR1cm4gb3V0QnVmLmpvaW4oXCJcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVmFsaWRGZXRjaFVybCh1cmwsIGJhc2VVcmwpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7XG4gICAgICBwcm90b2NvbFxuICAgIH0gPSBiYXNlVXJsID8gbmV3IFVSTCh1cmwsIGJhc2VVcmwpIDogbmV3IFVSTCh1cmwpO1xuICAgIHJldHVybiBwcm90b2NvbCA9PT0gXCJodHRwOlwiIHx8IHByb3RvY29sID09PSBcImh0dHBzOlwiO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vQ29udGV4dE1lbnUoZSkge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG59XG5mdW5jdGlvbiBzdG9wRXZlbnQoZSkge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5mdW5jdGlvbiBkZXByZWNhdGVkKGRldGFpbHMpIHtcbiAgY29uc29sZS5sb2coXCJEZXByZWNhdGVkIEFQSSB1c2FnZTogXCIgKyBkZXRhaWxzKTtcbn1cbmNsYXNzIFBERkRhdGVTdHJpbmcge1xuICBzdGF0aWMgI3JlZ2V4O1xuICBzdGF0aWMgdG9EYXRlT2JqZWN0KGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCB8fCB0eXBlb2YgaW5wdXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNyZWdleCB8fD0gbmV3IFJlZ0V4cChcIl5EOlwiICsgXCIoXFxcXGR7NH0pXCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihbWnwrfC1dKT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiJz9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiJz9cIik7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMuI3JlZ2V4LmV4ZWMoaW5wdXQpO1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHllYXIgPSBwYXJzZUludChtYXRjaGVzWzFdLCAxMCk7XG4gICAgbGV0IG1vbnRoID0gcGFyc2VJbnQobWF0Y2hlc1syXSwgMTApO1xuICAgIG1vbnRoID0gbW9udGggPj0gMSAmJiBtb250aCA8PSAxMiA/IG1vbnRoIC0gMSA6IDA7XG4gICAgbGV0IGRheSA9IHBhcnNlSW50KG1hdGNoZXNbM10sIDEwKTtcbiAgICBkYXkgPSBkYXkgPj0gMSAmJiBkYXkgPD0gMzEgPyBkYXkgOiAxO1xuICAgIGxldCBob3VyID0gcGFyc2VJbnQobWF0Y2hlc1s0XSwgMTApO1xuICAgIGhvdXIgPSBob3VyID49IDAgJiYgaG91ciA8PSAyMyA/IGhvdXIgOiAwO1xuICAgIGxldCBtaW51dGUgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG4gICAgbWludXRlID0gbWludXRlID49IDAgJiYgbWludXRlIDw9IDU5ID8gbWludXRlIDogMDtcbiAgICBsZXQgc2Vjb25kID0gcGFyc2VJbnQobWF0Y2hlc1s2XSwgMTApO1xuICAgIHNlY29uZCA9IHNlY29uZCA+PSAwICYmIHNlY29uZCA8PSA1OSA/IHNlY29uZCA6IDA7XG4gICAgY29uc3QgdW5pdmVyc2FsVGltZVJlbGF0aW9uID0gbWF0Y2hlc1s3XSB8fCBcIlpcIjtcbiAgICBsZXQgb2Zmc2V0SG91ciA9IHBhcnNlSW50KG1hdGNoZXNbOF0sIDEwKTtcbiAgICBvZmZzZXRIb3VyID0gb2Zmc2V0SG91ciA+PSAwICYmIG9mZnNldEhvdXIgPD0gMjMgPyBvZmZzZXRIb3VyIDogMDtcbiAgICBsZXQgb2Zmc2V0TWludXRlID0gcGFyc2VJbnQobWF0Y2hlc1s5XSwgMTApIHx8IDA7XG4gICAgb2Zmc2V0TWludXRlID0gb2Zmc2V0TWludXRlID49IDAgJiYgb2Zmc2V0TWludXRlIDw9IDU5ID8gb2Zmc2V0TWludXRlIDogMDtcbiAgICBpZiAodW5pdmVyc2FsVGltZVJlbGF0aW9uID09PSBcIi1cIikge1xuICAgICAgaG91ciArPSBvZmZzZXRIb3VyO1xuICAgICAgbWludXRlICs9IG9mZnNldE1pbnV0ZTtcbiAgICB9IGVsc2UgaWYgKHVuaXZlcnNhbFRpbWVSZWxhdGlvbiA9PT0gXCIrXCIpIHtcbiAgICAgIGhvdXIgLT0gb2Zmc2V0SG91cjtcbiAgICAgIG1pbnV0ZSAtPSBvZmZzZXRNaW51dGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCkpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRYZmFQYWdlVmlld3BvcnQoeGZhUGFnZSwge1xuICBzY2FsZSA9IDEsXG4gIHJvdGF0aW9uID0gMFxufSkge1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gPSB4ZmFQYWdlLmF0dHJpYnV0ZXMuc3R5bGU7XG4gIGNvbnN0IHZpZXdCb3ggPSBbMCwgMCwgcGFyc2VJbnQod2lkdGgpLCBwYXJzZUludChoZWlnaHQpXTtcbiAgcmV0dXJuIG5ldyBQYWdlVmlld3BvcnQoe1xuICAgIHZpZXdCb3gsXG4gICAgdXNlclVuaXQ6IDEsXG4gICAgc2NhbGUsXG4gICAgcm90YXRpb25cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRSR0IoY29sb3IpIHtcbiAgaWYgKGNvbG9yLnN0YXJ0c1dpdGgoXCIjXCIpKSB7XG4gICAgY29uc3QgY29sb3JSR0IgPSBwYXJzZUludChjb2xvci5zbGljZSgxKSwgMTYpO1xuICAgIHJldHVybiBbKGNvbG9yUkdCICYgMHhmZjAwMDApID4+IDE2LCAoY29sb3JSR0IgJiAweDAwZmYwMCkgPj4gOCwgY29sb3JSR0IgJiAweDAwMDBmZl07XG4gIH1cbiAgaWYgKGNvbG9yLnN0YXJ0c1dpdGgoXCJyZ2IoXCIpKSB7XG4gICAgcmV0dXJuIGNvbG9yLnNsaWNlKDQsIC0xKS5zcGxpdChcIixcIikubWFwKHggPT4gcGFyc2VJbnQoeCkpO1xuICB9XG4gIGlmIChjb2xvci5zdGFydHNXaXRoKFwicmdiYShcIikpIHtcbiAgICByZXR1cm4gY29sb3Iuc2xpY2UoNSwgLTEpLnNwbGl0KFwiLFwiKS5tYXAoeCA9PiBwYXJzZUludCh4KSkuc2xpY2UoMCwgMyk7XG4gIH1cbiAgd2FybihgTm90IGEgdmFsaWQgY29sb3IgZm9ybWF0OiBcIiR7Y29sb3J9XCJgKTtcbiAgcmV0dXJuIFswLCAwLCAwXTtcbn1cbmZ1bmN0aW9uIGdldENvbG9yVmFsdWVzKGNvbG9ycykge1xuICBjb25zdCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gIHNwYW4uc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kKHNwYW4pO1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgY29sb3JzLmtleXMoKSkge1xuICAgIHNwYW4uc3R5bGUuY29sb3IgPSBuYW1lO1xuICAgIGNvbnN0IGNvbXB1dGVkQ29sb3IgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzcGFuKS5jb2xvcjtcbiAgICBjb2xvcnMuc2V0KG5hbWUsIGdldFJHQihjb21wdXRlZENvbG9yKSk7XG4gIH1cbiAgc3Bhbi5yZW1vdmUoKTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KSB7XG4gIGNvbnN0IHtcbiAgICBhLFxuICAgIGIsXG4gICAgYyxcbiAgICBkLFxuICAgIGUsXG4gICAgZlxuICB9ID0gY3R4LmdldFRyYW5zZm9ybSgpO1xuICByZXR1cm4gW2EsIGIsIGMsIGQsIGUsIGZdO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSB7XG4gIGNvbnN0IHtcbiAgICBhLFxuICAgIGIsXG4gICAgYyxcbiAgICBkLFxuICAgIGUsXG4gICAgZlxuICB9ID0gY3R4LmdldFRyYW5zZm9ybSgpLmludmVydFNlbGYoKTtcbiAgcmV0dXJuIFthLCBiLCBjLCBkLCBlLCBmXTtcbn1cbmZ1bmN0aW9uIHNldExheWVyRGltZW5zaW9ucyhkaXYsIHZpZXdwb3J0LCBtdXN0RmxpcCA9IGZhbHNlLCBtdXN0Um90YXRlID0gdHJ1ZSkge1xuICBpZiAodmlld3BvcnQgaW5zdGFuY2VvZiBQYWdlVmlld3BvcnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0XG4gICAgfSA9IHZpZXdwb3J0LnJhd0RpbXM7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gZGl2O1xuICAgIGNvbnN0IHVzZVJvdW5kID0gdXRpbF9GZWF0dXJlVGVzdC5pc0NTU1JvdW5kU3VwcG9ydGVkO1xuICAgIGNvbnN0IHcgPSBgdmFyKC0tc2NhbGUtZmFjdG9yKSAqICR7cGFnZVdpZHRofXB4YCxcbiAgICAgIGggPSBgdmFyKC0tc2NhbGUtZmFjdG9yKSAqICR7cGFnZUhlaWdodH1weGA7XG4gICAgY29uc3Qgd2lkdGhTdHIgPSB1c2VSb3VuZCA/IGByb3VuZChkb3duLCAke3d9LCB2YXIoLS1zY2FsZS1yb3VuZC14LCAxcHgpKWAgOiBgY2FsYygke3d9KWAsXG4gICAgICBoZWlnaHRTdHIgPSB1c2VSb3VuZCA/IGByb3VuZChkb3duLCAke2h9LCB2YXIoLS1zY2FsZS1yb3VuZC15LCAxcHgpKWAgOiBgY2FsYygke2h9KWA7XG4gICAgaWYgKCFtdXN0RmxpcCB8fCB2aWV3cG9ydC5yb3RhdGlvbiAlIDE4MCA9PT0gMCkge1xuICAgICAgc3R5bGUud2lkdGggPSB3aWR0aFN0cjtcbiAgICAgIHN0eWxlLmhlaWdodCA9IGhlaWdodFN0cjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUud2lkdGggPSBoZWlnaHRTdHI7XG4gICAgICBzdHlsZS5oZWlnaHQgPSB3aWR0aFN0cjtcbiAgICB9XG4gIH1cbiAgaWYgKG11c3RSb3RhdGUpIHtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1tYWluLXJvdGF0aW9uXCIsIHZpZXdwb3J0LnJvdGF0aW9uKTtcbiAgfVxufVxuY2xhc3MgT3V0cHV0U2NhbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zdCBwaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICB0aGlzLnN4ID0gcGl4ZWxSYXRpbztcbiAgICB0aGlzLnN5ID0gcGl4ZWxSYXRpbztcbiAgfVxuICBnZXQgc2NhbGVkKCkge1xuICAgIHJldHVybiB0aGlzLnN4ICE9PSAxIHx8IHRoaXMuc3kgIT09IDE7XG4gIH1cbiAgZ2V0IHN5bW1ldHJpYygpIHtcbiAgICByZXR1cm4gdGhpcy5zeCA9PT0gdGhpcy5zeTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvdG9vbGJhci5qc1xuXG5jbGFzcyBFZGl0b3JUb29sYmFyIHtcbiAgI3Rvb2xiYXIgPSBudWxsO1xuICAjY29sb3JQaWNrZXIgPSBudWxsO1xuICAjZWRpdG9yO1xuICAjYnV0dG9ucyA9IG51bGw7XG4gICNhbHRUZXh0ID0gbnVsbDtcbiAgc3RhdGljICNsMTBuUmVtb3ZlID0gbnVsbDtcbiAgY29uc3RydWN0b3IoZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9yID0gZWRpdG9yO1xuICAgIEVkaXRvclRvb2xiYXIuI2wxMG5SZW1vdmUgfHw9IE9iamVjdC5mcmVlemUoe1xuICAgICAgZnJlZXRleHQ6IFwicGRmanMtZWRpdG9yLXJlbW92ZS1mcmVldGV4dC1idXR0b25cIixcbiAgICAgIGhpZ2hsaWdodDogXCJwZGZqcy1lZGl0b3ItcmVtb3ZlLWhpZ2hsaWdodC1idXR0b25cIixcbiAgICAgIGluazogXCJwZGZqcy1lZGl0b3ItcmVtb3ZlLWluay1idXR0b25cIixcbiAgICAgIHN0YW1wOiBcInBkZmpzLWVkaXRvci1yZW1vdmUtc3RhbXAtYnV0dG9uXCJcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgZWRpdFRvb2xiYXIgPSB0aGlzLiN0b29sYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBlZGl0VG9vbGJhci5jbGFzc0xpc3QuYWRkKFwiZWRpdFRvb2xiYXJcIiwgXCJoaWRkZW5cIik7XG4gICAgZWRpdFRvb2xiYXIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRvb2xiYXJcIik7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBlZGl0VG9vbGJhci5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZWRpdFRvb2xiYXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIEVkaXRvclRvb2xiYXIuI3BvaW50ZXJEb3duLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCBidXR0b25zID0gdGhpcy4jYnV0dG9ucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgYnV0dG9ucy5jbGFzc05hbWUgPSBcImJ1dHRvbnNcIjtcbiAgICBlZGl0VG9vbGJhci5hcHBlbmQoYnV0dG9ucyk7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLiNlZGl0b3IudG9vbGJhclBvc2l0aW9uO1xuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdHlsZVxuICAgICAgfSA9IGVkaXRUb29sYmFyO1xuICAgICAgY29uc3QgeCA9IHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLmRpcmVjdGlvbiA9PT0gXCJsdHJcIiA/IDEgLSBwb3NpdGlvblswXSA6IHBvc2l0aW9uWzBdO1xuICAgICAgc3R5bGUuaW5zZXRJbmxpbmVFbmQgPSBgJHsxMDAgKiB4fSVgO1xuICAgICAgc3R5bGUudG9wID0gYGNhbGMoJHsxMDAgKiBwb3NpdGlvblsxXX0lICsgdmFyKC0tZWRpdG9yLXRvb2xiYXItdmVydC1vZmZzZXQpKWA7XG4gICAgfVxuICAgIHRoaXMuI2FkZERlbGV0ZUJ1dHRvbigpO1xuICAgIHJldHVybiBlZGl0VG9vbGJhcjtcbiAgfVxuICBnZXQgZGl2KCkge1xuICAgIHJldHVybiB0aGlzLiN0b29sYmFyO1xuICB9XG4gIHN0YXRpYyAjcG9pbnRlckRvd24oZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgI2ZvY3VzSW4oZSkge1xuICAgIHRoaXMuI2VkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gZmFsc2U7XG4gICAgc3RvcEV2ZW50KGUpO1xuICB9XG4gICNmb2N1c091dChlKSB7XG4gICAgdGhpcy4jZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSB0cnVlO1xuICAgIHN0b3BFdmVudChlKTtcbiAgfVxuICAjYWRkTGlzdGVuZXJzVG9FbGVtZW50KGVsZW1lbnQpIHtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgdGhpcy4jZm9jdXNJbi5iaW5kKHRoaXMpLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgdGhpcy4jZm9jdXNPdXQuYmluZCh0aGlzKSwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgdGhpcy4jdG9vbGJhci5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xuICAgIHRoaXMuI2NvbG9yUGlja2VyPy5oaWRlRHJvcGRvd24oKTtcbiAgfVxuICBzaG93KCkge1xuICAgIHRoaXMuI3Rvb2xiYXIuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcbiAgICB0aGlzLiNhbHRUZXh0Py5zaG93bigpO1xuICB9XG4gICNhZGREZWxldGVCdXR0b24oKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWRpdG9yVHlwZSxcbiAgICAgIF91aU1hbmFnZXJcbiAgICB9ID0gdGhpcy4jZWRpdG9yO1xuICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYnV0dG9uLmNsYXNzTmFtZSA9IFwiZGVsZXRlXCI7XG4gICAgYnV0dG9uLnRhYkluZGV4ID0gMDtcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEVkaXRvclRvb2xiYXIuI2wxMG5SZW1vdmVbZWRpdG9yVHlwZV0pO1xuICAgIHRoaXMuI2FkZExpc3RlbmVyc1RvRWxlbWVudChidXR0b24pO1xuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZSA9PiB7XG4gICAgICBfdWlNYW5hZ2VyLmRlbGV0ZSgpO1xuICAgIH0sIHtcbiAgICAgIHNpZ25hbDogX3VpTWFuYWdlci5fc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy4jYnV0dG9ucy5hcHBlbmQoYnV0dG9uKTtcbiAgfVxuICBnZXQgI2RpdmlkZXIoKSB7XG4gICAgY29uc3QgZGl2aWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2aWRlci5jbGFzc05hbWUgPSBcImRpdmlkZXJcIjtcbiAgICByZXR1cm4gZGl2aWRlcjtcbiAgfVxuICBhc3luYyBhZGRBbHRUZXh0KGFsdFRleHQpIHtcbiAgICBjb25zdCBidXR0b24gPSBhd2FpdCBhbHRUZXh0LnJlbmRlcigpO1xuICAgIHRoaXMuI2FkZExpc3RlbmVyc1RvRWxlbWVudChidXR0b24pO1xuICAgIHRoaXMuI2J1dHRvbnMucHJlcGVuZChidXR0b24sIHRoaXMuI2RpdmlkZXIpO1xuICAgIHRoaXMuI2FsdFRleHQgPSBhbHRUZXh0O1xuICB9XG4gIGFkZENvbG9yUGlja2VyKGNvbG9yUGlja2VyKSB7XG4gICAgdGhpcy4jY29sb3JQaWNrZXIgPSBjb2xvclBpY2tlcjtcbiAgICBjb25zdCBidXR0b24gPSBjb2xvclBpY2tlci5yZW5kZXJCdXR0b24oKTtcbiAgICB0aGlzLiNhZGRMaXN0ZW5lcnNUb0VsZW1lbnQoYnV0dG9uKTtcbiAgICB0aGlzLiNidXR0b25zLnByZXBlbmQoYnV0dG9uLCB0aGlzLiNkaXZpZGVyKTtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy4jdG9vbGJhci5yZW1vdmUoKTtcbiAgICB0aGlzLiNjb2xvclBpY2tlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuI2NvbG9yUGlja2VyID0gbnVsbDtcbiAgfVxufVxuY2xhc3MgSGlnaGxpZ2h0VG9vbGJhciB7XG4gICNidXR0b25zID0gbnVsbDtcbiAgI3Rvb2xiYXIgPSBudWxsO1xuICAjdWlNYW5hZ2VyO1xuICBjb25zdHJ1Y3Rvcih1aU1hbmFnZXIpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIgPSB1aU1hbmFnZXI7XG4gIH1cbiAgI3JlbmRlcigpIHtcbiAgICBjb25zdCBlZGl0VG9vbGJhciA9IHRoaXMuI3Rvb2xiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGVkaXRUb29sYmFyLmNsYXNzTmFtZSA9IFwiZWRpdFRvb2xiYXJcIjtcbiAgICBlZGl0VG9vbGJhci5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwidG9vbGJhclwiKTtcbiAgICBlZGl0VG9vbGJhci5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsOiB0aGlzLiN1aU1hbmFnZXIuX3NpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IGJ1dHRvbnMgPSB0aGlzLiNidXR0b25zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBidXR0b25zLmNsYXNzTmFtZSA9IFwiYnV0dG9uc1wiO1xuICAgIGVkaXRUb29sYmFyLmFwcGVuZChidXR0b25zKTtcbiAgICB0aGlzLiNhZGRIaWdobGlnaHRCdXR0b24oKTtcbiAgICByZXR1cm4gZWRpdFRvb2xiYXI7XG4gIH1cbiAgI2dldExhc3RQb2ludChib3hlcywgaXNMVFIpIHtcbiAgICBsZXQgbGFzdFkgPSAwO1xuICAgIGxldCBsYXN0WCA9IDA7XG4gICAgZm9yIChjb25zdCBib3ggb2YgYm94ZXMpIHtcbiAgICAgIGNvbnN0IHkgPSBib3gueSArIGJveC5oZWlnaHQ7XG4gICAgICBpZiAoeSA8IGxhc3RZKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgeCA9IGJveC54ICsgKGlzTFRSID8gYm94LndpZHRoIDogMCk7XG4gICAgICBpZiAoeSA+IGxhc3RZKSB7XG4gICAgICAgIGxhc3RYID0geDtcbiAgICAgICAgbGFzdFkgPSB5O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xUUikge1xuICAgICAgICBpZiAoeCA+IGxhc3RYKSB7XG4gICAgICAgICAgbGFzdFggPSB4O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHggPCBsYXN0WCkge1xuICAgICAgICBsYXN0WCA9IHg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbaXNMVFIgPyAxIC0gbGFzdFggOiBsYXN0WCwgbGFzdFldO1xuICB9XG4gIHNob3cocGFyZW50LCBib3hlcywgaXNMVFIpIHtcbiAgICBjb25zdCBbeCwgeV0gPSB0aGlzLiNnZXRMYXN0UG9pbnQoYm94ZXMsIGlzTFRSKTtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLiN0b29sYmFyIHx8PSB0aGlzLiNyZW5kZXIoKTtcbiAgICBwYXJlbnQuYXBwZW5kKHRoaXMuI3Rvb2xiYXIpO1xuICAgIHN0eWxlLmluc2V0SW5saW5lRW5kID0gYCR7MTAwICogeH0lYDtcbiAgICBzdHlsZS50b3AgPSBgY2FsYygkezEwMCAqIHl9JSArIHZhcigtLWVkaXRvci10b29sYmFyLXZlcnQtb2Zmc2V0KSlgO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgdGhpcy4jdG9vbGJhci5yZW1vdmUoKTtcbiAgfVxuICAjYWRkSGlnaGxpZ2h0QnV0dG9uKCkge1xuICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYnV0dG9uLmNsYXNzTmFtZSA9IFwiaGlnaGxpZ2h0QnV0dG9uXCI7XG4gICAgYnV0dG9uLnRhYkluZGV4ID0gMDtcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIGBwZGZqcy1oaWdobGlnaHQtZmxvYXRpbmctYnV0dG9uMWApO1xuICAgIGNvbnN0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBidXR0b24uYXBwZW5kKHNwYW4pO1xuICAgIHNwYW4uY2xhc3NOYW1lID0gXCJ2aXN1YWxseUhpZGRlblwiO1xuICAgIHNwYW4uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtaGlnaGxpZ2h0LWZsb2F0aW5nLWJ1dHRvbi1sYWJlbFwiKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiN1aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmhpZ2hsaWdodFNlbGVjdGlvbihcImZsb2F0aW5nX2J1dHRvblwiKTtcbiAgICB9LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLiNidXR0b25zLmFwcGVuZChidXR0b24pO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci90b29scy5qc1xuXG5cblxuZnVuY3Rpb24gYmluZEV2ZW50cyhvYmosIGVsZW1lbnQsIG5hbWVzKSB7XG4gIGZvciAoY29uc3QgbmFtZSBvZiBuYW1lcykge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBvYmpbbmFtZV0uYmluZChvYmopKTtcbiAgfVxufVxuZnVuY3Rpb24gb3BhY2l0eVRvSGV4KG9wYWNpdHkpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5taW4oMjU1LCBNYXRoLm1heCgxLCAyNTUgKiBvcGFjaXR5KSkpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIik7XG59XG5jbGFzcyBJZE1hbmFnZXIge1xuICAjaWQgPSAwO1xuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIGAke0Fubm90YXRpb25FZGl0b3JQcmVmaXh9JHt0aGlzLiNpZCsrfWA7XG4gIH1cbn1cbmNsYXNzIEltYWdlTWFuYWdlciB7XG4gICNiYXNlSWQgPSBnZXRVdWlkKCk7XG4gICNpZCA9IDA7XG4gICNjYWNoZSA9IG51bGw7XG4gIHN0YXRpYyBnZXQgX2lzU1ZHRml0dGluZ0NhbnZhcygpIHtcbiAgICBjb25zdCBzdmcgPSBgZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9VVRGLTgsPHN2ZyB2aWV3Qm94PVwiMCAwIDEgMVwiIHdpZHRoPVwiMVwiIGhlaWdodD1cIjFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHJlY3Qgd2lkdGg9XCIxXCIgaGVpZ2h0PVwiMVwiIHN0eWxlPVwiZmlsbDpyZWQ7XCIvPjwvc3ZnPmA7XG4gICAgY29uc3QgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcygxLCAzKTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgaW1hZ2Uuc3JjID0gc3ZnO1xuICAgIGNvbnN0IHByb21pc2UgPSBpbWFnZS5kZWNvZGUoKS50aGVuKCgpID0+IHtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIDEsIDEsIDAsIDAsIDEsIDMpO1xuICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGEuYnVmZmVyKVswXSA9PT0gMDtcbiAgICB9KTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2lzU1ZHRml0dGluZ0NhbnZhc1wiLCBwcm9taXNlKTtcbiAgfVxuICBhc3luYyAjZ2V0KGtleSwgcmF3RGF0YSkge1xuICAgIHRoaXMuI2NhY2hlIHx8PSBuZXcgTWFwKCk7XG4gICAgbGV0IGRhdGEgPSB0aGlzLiNjYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChkYXRhPy5iaXRtYXApIHtcbiAgICAgIGRhdGEucmVmQ291bnRlciArPSAxO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBkYXRhIHx8PSB7XG4gICAgICAgIGJpdG1hcDogbnVsbCxcbiAgICAgICAgaWQ6IGBpbWFnZV8ke3RoaXMuI2Jhc2VJZH1fJHt0aGlzLiNpZCsrfWAsXG4gICAgICAgIHJlZkNvdW50ZXI6IDAsXG4gICAgICAgIGlzU3ZnOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGxldCBpbWFnZTtcbiAgICAgIGlmICh0eXBlb2YgcmF3RGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkYXRhLnVybCA9IHJhd0RhdGE7XG4gICAgICAgIGltYWdlID0gYXdhaXQgZmV0Y2hEYXRhKHJhd0RhdGEsIFwiYmxvYlwiKTtcbiAgICAgIH0gZWxzZSBpZiAocmF3RGF0YSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgaW1hZ2UgPSBkYXRhLmZpbGUgPSByYXdEYXRhO1xuICAgICAgfSBlbHNlIGlmIChyYXdEYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICBpbWFnZSA9IHJhd0RhdGE7XG4gICAgICB9XG4gICAgICBpZiAoaW1hZ2UudHlwZSA9PT0gXCJpbWFnZS9zdmcreG1sXCIpIHtcbiAgICAgICAgY29uc3QgbXVzdFJlbW92ZUFzcGVjdFJhdGlvUHJvbWlzZSA9IEltYWdlTWFuYWdlci5faXNTVkdGaXR0aW5nQ2FudmFzO1xuICAgICAgICBjb25zdCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgY29uc3QgaW1hZ2VFbGVtZW50ID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGNvbnN0IGltYWdlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBpbWFnZUVsZW1lbnQub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgZGF0YS5iaXRtYXAgPSBpbWFnZUVsZW1lbnQ7XG4gICAgICAgICAgICBkYXRhLmlzU3ZnID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gZGF0YS5zdmdVcmwgPSBmaWxlUmVhZGVyLnJlc3VsdDtcbiAgICAgICAgICAgIGltYWdlRWxlbWVudC5zcmMgPSAoYXdhaXQgbXVzdFJlbW92ZUFzcGVjdFJhdGlvUHJvbWlzZSkgPyBgJHt1cmx9I3N2Z1ZpZXcocHJlc2VydmVBc3BlY3RSYXRpbyhub25lKSlgIDogdXJsO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaW1hZ2VFbGVtZW50Lm9uZXJyb3IgPSBmaWxlUmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkwoaW1hZ2UpO1xuICAgICAgICBhd2FpdCBpbWFnZVByb21pc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhLmJpdG1hcCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGltYWdlKTtcbiAgICAgIH1cbiAgICAgIGRhdGEucmVmQ291bnRlciA9IDE7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FybihlKTtcbiAgICAgIGRhdGEgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNjYWNoZS5zZXQoa2V5LCBkYXRhKTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgdGhpcy4jY2FjaGUuc2V0KGRhdGEuaWQsIGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBhc3luYyBnZXRGcm9tRmlsZShmaWxlKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGFzdE1vZGlmaWVkLFxuICAgICAgbmFtZSxcbiAgICAgIHNpemUsXG4gICAgICB0eXBlXG4gICAgfSA9IGZpbGU7XG4gICAgcmV0dXJuIHRoaXMuI2dldChgJHtsYXN0TW9kaWZpZWR9XyR7bmFtZX1fJHtzaXplfV8ke3R5cGV9YCwgZmlsZSk7XG4gIH1cbiAgYXN5bmMgZ2V0RnJvbVVybCh1cmwpIHtcbiAgICByZXR1cm4gdGhpcy4jZ2V0KHVybCwgdXJsKTtcbiAgfVxuICBhc3luYyBnZXRGcm9tQmxvYihpZCwgYmxvYlByb21pc2UpIHtcbiAgICBjb25zdCBibG9iID0gYXdhaXQgYmxvYlByb21pc2U7XG4gICAgcmV0dXJuIHRoaXMuI2dldChpZCwgYmxvYik7XG4gIH1cbiAgYXN5bmMgZ2V0RnJvbUlkKGlkKSB7XG4gICAgdGhpcy4jY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZGF0YS5iaXRtYXApIHtcbiAgICAgIGRhdGEucmVmQ291bnRlciArPSAxO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmIChkYXRhLmZpbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEZyb21GaWxlKGRhdGEuZmlsZSk7XG4gICAgfVxuICAgIGlmIChkYXRhLmJsb2JQcm9taXNlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGJsb2JQcm9taXNlXG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGRlbGV0ZSBkYXRhLmJsb2JQcm9taXNlO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RnJvbUJsb2IoZGF0YS5pZCwgYmxvYlByb21pc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRGcm9tVXJsKGRhdGEudXJsKTtcbiAgfVxuICBnZXRGcm9tQ2FudmFzKGlkLCBjYW52YXMpIHtcbiAgICB0aGlzLiNjYWNoZSB8fD0gbmV3IE1hcCgpO1xuICAgIGxldCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoZGF0YT8uYml0bWFwKSB7XG4gICAgICBkYXRhLnJlZkNvdW50ZXIgKz0gMTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgY29uc3QgY3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBjdHguZHJhd0ltYWdlKGNhbnZhcywgMCwgMCk7XG4gICAgZGF0YSA9IHtcbiAgICAgIGJpdG1hcDogb2Zmc2NyZWVuLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpLFxuICAgICAgaWQ6IGBpbWFnZV8ke3RoaXMuI2Jhc2VJZH1fJHt0aGlzLiNpZCsrfWAsXG4gICAgICByZWZDb3VudGVyOiAxLFxuICAgICAgaXNTdmc6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLiNjYWNoZS5zZXQoaWQsIGRhdGEpO1xuICAgIHRoaXMuI2NhY2hlLnNldChkYXRhLmlkLCBkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBnZXRTdmdVcmwoaWQpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWRhdGE/LmlzU3ZnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGEuc3ZnVXJsO1xuICB9XG4gIGRlbGV0ZUlkKGlkKSB7XG4gICAgdGhpcy4jY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGF0YS5yZWZDb3VudGVyIC09IDE7XG4gICAgaWYgKGRhdGEucmVmQ291bnRlciAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBiaXRtYXBcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoIWRhdGEudXJsICYmICFkYXRhLmZpbGUpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoYml0bWFwLndpZHRoLCBiaXRtYXAuaGVpZ2h0KTtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiYml0bWFwcmVuZGVyZXJcIik7XG4gICAgICBjdHgudHJhbnNmZXJGcm9tSW1hZ2VCaXRtYXAoYml0bWFwKTtcbiAgICAgIGRhdGEuYmxvYlByb21pc2UgPSBjYW52YXMuY29udmVydFRvQmxvYigpO1xuICAgIH1cbiAgICBiaXRtYXAuY2xvc2U/LigpO1xuICAgIGRhdGEuYml0bWFwID0gbnVsbDtcbiAgfVxuICBpc1ZhbGlkSWQoaWQpIHtcbiAgICByZXR1cm4gaWQuc3RhcnRzV2l0aChgaW1hZ2VfJHt0aGlzLiNiYXNlSWR9X2ApO1xuICB9XG59XG5jbGFzcyBDb21tYW5kTWFuYWdlciB7XG4gICNjb21tYW5kcyA9IFtdO1xuICAjbG9ja2VkID0gZmFsc2U7XG4gICNtYXhTaXplO1xuICAjcG9zaXRpb24gPSAtMTtcbiAgY29uc3RydWN0b3IobWF4U2l6ZSA9IDEyOCkge1xuICAgIHRoaXMuI21heFNpemUgPSBtYXhTaXplO1xuICB9XG4gIGFkZCh7XG4gICAgY21kLFxuICAgIHVuZG8sXG4gICAgcG9zdCxcbiAgICBtdXN0RXhlYyxcbiAgICB0eXBlID0gTmFOLFxuICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGUgPSBmYWxzZSxcbiAgICBrZWVwVW5kbyA9IGZhbHNlXG4gIH0pIHtcbiAgICBpZiAobXVzdEV4ZWMpIHtcbiAgICAgIGNtZCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jbG9ja2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNhdmUgPSB7XG4gICAgICBjbWQsXG4gICAgICB1bmRvLFxuICAgICAgcG9zdCxcbiAgICAgIHR5cGVcbiAgICB9O1xuICAgIGlmICh0aGlzLiNwb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgIGlmICh0aGlzLiNjb21tYW5kcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuI2NvbW1hbmRzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLiNwb3NpdGlvbiA9IDA7XG4gICAgICB0aGlzLiNjb21tYW5kcy5wdXNoKHNhdmUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3ZlcndyaXRlSWZTYW1lVHlwZSAmJiB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl0udHlwZSA9PT0gdHlwZSkge1xuICAgICAgaWYgKGtlZXBVbmRvKSB7XG4gICAgICAgIHNhdmUudW5kbyA9IHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXS51bmRvO1xuICAgICAgfVxuICAgICAgdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dID0gc2F2ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuI3Bvc2l0aW9uICsgMTtcbiAgICBpZiAobmV4dCA9PT0gdGhpcy4jbWF4U2l6ZSkge1xuICAgICAgdGhpcy4jY29tbWFuZHMuc3BsaWNlKDAsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNwb3NpdGlvbiA9IG5leHQ7XG4gICAgICBpZiAobmV4dCA8IHRoaXMuI2NvbW1hbmRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLiNjb21tYW5kcy5zcGxpY2UobmV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2NvbW1hbmRzLnB1c2goc2F2ZSk7XG4gIH1cbiAgdW5kbygpIHtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2xvY2tlZCA9IHRydWU7XG4gICAgY29uc3Qge1xuICAgICAgdW5kbyxcbiAgICAgIHBvc3RcbiAgICB9ID0gdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dO1xuICAgIHVuZG8oKTtcbiAgICBwb3N0Py4oKTtcbiAgICB0aGlzLiNsb2NrZWQgPSBmYWxzZTtcbiAgICB0aGlzLiNwb3NpdGlvbiAtPSAxO1xuICB9XG4gIHJlZG8oKSB7XG4gICAgaWYgKHRoaXMuI3Bvc2l0aW9uIDwgdGhpcy4jY29tbWFuZHMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy4jcG9zaXRpb24gKz0gMTtcbiAgICAgIHRoaXMuI2xvY2tlZCA9IHRydWU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNtZCxcbiAgICAgICAgcG9zdFxuICAgICAgfSA9IHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXTtcbiAgICAgIGNtZCgpO1xuICAgICAgcG9zdD8uKCk7XG4gICAgICB0aGlzLiNsb2NrZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaGFzU29tZXRoaW5nVG9VbmRvKCkge1xuICAgIHJldHVybiB0aGlzLiNwb3NpdGlvbiAhPT0gLTE7XG4gIH1cbiAgaGFzU29tZXRoaW5nVG9SZWRvKCkge1xuICAgIHJldHVybiB0aGlzLiNwb3NpdGlvbiA8IHRoaXMuI2NvbW1hbmRzLmxlbmd0aCAtIDE7XG4gIH1cbiAgY2xlYW5UeXBlKHR5cGUpIHtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSB0aGlzLiNwb3NpdGlvbjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICh0aGlzLiNjb21tYW5kc1tpXS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgIHRoaXMuI2NvbW1hbmRzLnNwbGljZShpICsgMSwgdGhpcy4jcG9zaXRpb24gLSBpKTtcbiAgICAgICAgdGhpcy4jcG9zaXRpb24gPSBpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2NvbW1hbmRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy4jcG9zaXRpb24gPSAtMTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI2NvbW1hbmRzID0gbnVsbDtcbiAgfVxufVxuY2xhc3MgS2V5Ym9hcmRNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoY2FsbGJhY2tzKSB7XG4gICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmFsbEtleXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBmb3IgKGNvbnN0IFtrZXlzLCBjYWxsYmFjaywgb3B0aW9ucyA9IHt9XSBvZiBjYWxsYmFja3MpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgY29uc3QgaXNNYWNLZXkgPSBrZXkuc3RhcnRzV2l0aChcIm1hYytcIik7XG4gICAgICAgIGlmIChpc01hYyAmJiBpc01hY0tleSkge1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLnNldChrZXkuc2xpY2UoNCksIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuYWxsS2V5cy5hZGQoa2V5LnNwbGl0KFwiK1wiKS5hdCgtMSkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc01hYyAmJiAhaXNNYWNLZXkpIHtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5zZXQoa2V5LCB7XG4gICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmFsbEtleXMuYWRkKGtleS5zcGxpdChcIitcIikuYXQoLTEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAjc2VyaWFsaXplKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmFsdEtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcImFsdFwiKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpIHtcbiAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCJjdHJsXCIpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQubWV0YUtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcIm1ldGFcIik7XG4gICAgfVxuICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcInNoaWZ0XCIpO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlci5wdXNoKGV2ZW50LmtleSk7XG4gICAgY29uc3Qgc3RyID0gdGhpcy5idWZmZXIuam9pbihcIitcIik7XG4gICAgdGhpcy5idWZmZXIubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGV4ZWMoc2VsZiwgZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuYWxsS2V5cy5oYXMoZXZlbnQua2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbmZvID0gdGhpcy5jYWxsYmFja3MuZ2V0KHRoaXMuI3NlcmlhbGl6ZShldmVudCkpO1xuICAgIGlmICghaW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgYnViYmxlcyA9IGZhbHNlLFxuICAgICAgICBhcmdzID0gW10sXG4gICAgICAgIGNoZWNrZXIgPSBudWxsXG4gICAgICB9XG4gICAgfSA9IGluZm87XG4gICAgaWYgKGNoZWNrZXIgJiYgIWNoZWNrZXIoc2VsZiwgZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrLmJpbmQoc2VsZiwgLi4uYXJncywgZXZlbnQpKCk7XG4gICAgaWYgKCFidWJibGVzKSB7XG4gICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgQ29sb3JNYW5hZ2VyIHtcbiAgc3RhdGljIF9jb2xvcnNNYXBwaW5nID0gbmV3IE1hcChbW1wiQ2FudmFzVGV4dFwiLCBbMCwgMCwgMF1dLCBbXCJDYW52YXNcIiwgWzI1NSwgMjU1LCAyNTVdXV0pO1xuICBnZXQgX2NvbG9ycygpIHtcbiAgICBjb25zdCBjb2xvcnMgPSBuZXcgTWFwKFtbXCJDYW52YXNUZXh0XCIsIG51bGxdLCBbXCJDYW52YXNcIiwgbnVsbF1dKTtcbiAgICBnZXRDb2xvclZhbHVlcyhjb2xvcnMpO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfY29sb3JzXCIsIGNvbG9ycyk7XG4gIH1cbiAgY29udmVydChjb2xvcikge1xuICAgIGNvbnN0IHJnYiA9IGdldFJHQihjb2xvcik7XG4gICAgaWYgKCF3aW5kb3cubWF0Y2hNZWRpYShcIihmb3JjZWQtY29sb3JzOiBhY3RpdmUpXCIpLm1hdGNoZXMpIHtcbiAgICAgIHJldHVybiByZ2I7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW25hbWUsIFJHQl0gb2YgdGhpcy5fY29sb3JzKSB7XG4gICAgICBpZiAoUkdCLmV2ZXJ5KCh4LCBpKSA9PiB4ID09PSByZ2JbaV0pKSB7XG4gICAgICAgIHJldHVybiBDb2xvck1hbmFnZXIuX2NvbG9yc01hcHBpbmcuZ2V0KG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmdiO1xuICB9XG4gIGdldEhleENvZGUobmFtZSkge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuX2NvbG9ycy5nZXQobmFtZSk7XG4gICAgaWYgKCFyZ2IpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gVXRpbC5tYWtlSGV4Q29sb3IoLi4ucmdiKTtcbiAgfVxufVxuY2xhc3MgQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciB7XG4gICNhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICNhY3RpdmVFZGl0b3IgPSBudWxsO1xuICAjYWxsRWRpdG9ycyA9IG5ldyBNYXAoKTtcbiAgI2FsbExheWVycyA9IG5ldyBNYXAoKTtcbiAgI2FsdFRleHRNYW5hZ2VyID0gbnVsbDtcbiAgI2Fubm90YXRpb25TdG9yYWdlID0gbnVsbDtcbiAgI2NoYW5nZWRFeGlzdGluZ0Fubm90YXRpb25zID0gbnVsbDtcbiAgI2NvbW1hbmRNYW5hZ2VyID0gbmV3IENvbW1hbmRNYW5hZ2VyKCk7XG4gICNjb3B5UGFzdGVBQyA9IG51bGw7XG4gICNjdXJyZW50RHJhd2luZ1Nlc3Npb24gPSBudWxsO1xuICAjY3VycmVudFBhZ2VJbmRleCA9IDA7XG4gICNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzID0gbmV3IFNldCgpO1xuICAjZHJhZ2dpbmdFZGl0b3JzID0gbnVsbDtcbiAgI2VkaXRvclR5cGVzID0gbnVsbDtcbiAgI2VkaXRvcnNUb1Jlc2NhbGUgPSBuZXcgU2V0KCk7XG4gIF9lZGl0b3JVbmRvQmFyID0gbnVsbDtcbiAgI2VuYWJsZUhpZ2hsaWdodEZsb2F0aW5nQnV0dG9uID0gZmFsc2U7XG4gICNlbmFibGVVcGRhdGVkQWRkSW1hZ2UgPSBmYWxzZTtcbiAgI2VuYWJsZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UgPSBmYWxzZTtcbiAgI2ZpbHRlckZhY3RvcnkgPSBudWxsO1xuICAjZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkID0gbnVsbDtcbiAgI2ZvY3VzTWFuYWdlckFDID0gbnVsbDtcbiAgI2hpZ2hsaWdodENvbG9ycyA9IG51bGw7XG4gICNoaWdobGlnaHRXaGVuU2hpZnRVcCA9IGZhbHNlO1xuICAjaGlnaGxpZ2h0VG9vbGJhciA9IG51bGw7XG4gICNpZE1hbmFnZXIgPSBuZXcgSWRNYW5hZ2VyKCk7XG4gICNpc0VuYWJsZWQgPSBmYWxzZTtcbiAgI2lzV2FpdGluZyA9IGZhbHNlO1xuICAja2V5Ym9hcmRNYW5hZ2VyQUMgPSBudWxsO1xuICAjbGFzdEFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAjbWFpbkhpZ2hsaWdodENvbG9yUGlja2VyID0gbnVsbDtcbiAgI21sTWFuYWdlciA9IG51bGw7XG4gICNtb2RlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORTtcbiAgI3NlbGVjdGVkRWRpdG9ycyA9IG5ldyBTZXQoKTtcbiAgI3NlbGVjdGVkVGV4dE5vZGUgPSBudWxsO1xuICAjcGFnZUNvbG9ycyA9IG51bGw7XG4gICNzaG93QWxsU3RhdGVzID0gbnVsbDtcbiAgI3ByZXZpb3VzU3RhdGVzID0ge1xuICAgIGlzRWRpdGluZzogZmFsc2UsXG4gICAgaXNFbXB0eTogdHJ1ZSxcbiAgICBoYXNTb21ldGhpbmdUb1VuZG86IGZhbHNlLFxuICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogZmFsc2UsXG4gICAgaGFzU2VsZWN0ZWRFZGl0b3I6IGZhbHNlLFxuICAgIGhhc1NlbGVjdGVkVGV4dDogZmFsc2VcbiAgfTtcbiAgI3RyYW5zbGF0aW9uID0gWzAsIDBdO1xuICAjdHJhbnNsYXRpb25UaW1lb3V0SWQgPSBudWxsO1xuICAjY29udGFpbmVyID0gbnVsbDtcbiAgI3ZpZXdlciA9IG51bGw7XG4gICN1cGRhdGVNb2RlQ2FwYWJpbGl0eSA9IG51bGw7XG4gIHN0YXRpYyBUUkFOU0xBVEVfU01BTEwgPSAxO1xuICBzdGF0aWMgVFJBTlNMQVRFX0JJRyA9IDEwO1xuICBzdGF0aWMgZ2V0IF9rZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgY29uc3QgcHJvdG8gPSBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLnByb3RvdHlwZTtcbiAgICBjb25zdCBhcnJvd0NoZWNrZXIgPSBzZWxmID0+IHNlbGYuI2NvbnRhaW5lci5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LnRhZ05hbWUgIT09IFwiQlVUVE9OXCIgJiYgc2VsZi5oYXNTb21ldGhpbmdUb0NvbnRyb2woKTtcbiAgICBjb25zdCB0ZXh0SW5wdXRDaGVja2VyID0gKF9zZWxmLCB7XG4gICAgICB0YXJnZXQ6IGVsXG4gICAgfSkgPT4ge1xuICAgICAgaWYgKGVsIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdHlwZVxuICAgICAgICB9ID0gZWw7XG4gICAgICAgIHJldHVybiB0eXBlICE9PSBcInRleHRcIiAmJiB0eXBlICE9PSBcIm51bWJlclwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBzbWFsbCA9IHRoaXMuVFJBTlNMQVRFX1NNQUxMO1xuICAgIGNvbnN0IGJpZyA9IHRoaXMuVFJBTlNMQVRFX0JJRztcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2tleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiY3RybCthXCIsIFwibWFjK21ldGErYVwiXSwgcHJvdG8uc2VsZWN0QWxsLCB7XG4gICAgICBjaGVja2VyOiB0ZXh0SW5wdXRDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK3pcIiwgXCJtYWMrbWV0YSt6XCJdLCBwcm90by51bmRvLCB7XG4gICAgICBjaGVja2VyOiB0ZXh0SW5wdXRDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK3lcIiwgXCJjdHJsK3NoaWZ0K3pcIiwgXCJtYWMrbWV0YStzaGlmdCt6XCIsIFwiY3RybCtzaGlmdCtaXCIsIFwibWFjK21ldGErc2hpZnQrWlwiXSwgcHJvdG8ucmVkbywge1xuICAgICAgY2hlY2tlcjogdGV4dElucHV0Q2hlY2tlclxuICAgIH1dLCBbW1wiQmFja3NwYWNlXCIsIFwiYWx0K0JhY2tzcGFjZVwiLCBcImN0cmwrQmFja3NwYWNlXCIsIFwic2hpZnQrQmFja3NwYWNlXCIsIFwibWFjK0JhY2tzcGFjZVwiLCBcIm1hYythbHQrQmFja3NwYWNlXCIsIFwibWFjK2N0cmwrQmFja3NwYWNlXCIsIFwiRGVsZXRlXCIsIFwiY3RybCtEZWxldGVcIiwgXCJzaGlmdCtEZWxldGVcIiwgXCJtYWMrRGVsZXRlXCJdLCBwcm90by5kZWxldGUsIHtcbiAgICAgIGNoZWNrZXI6IHRleHRJbnB1dENoZWNrZXJcbiAgICB9XSwgW1tcIkVudGVyXCIsIFwibWFjK0VudGVyXCJdLCBwcm90by5hZGROZXdFZGl0b3JGcm9tS2V5Ym9hcmQsIHtcbiAgICAgIGNoZWNrZXI6IChzZWxmLCB7XG4gICAgICAgIHRhcmdldDogZWxcbiAgICAgIH0pID0+ICEoZWwgaW5zdGFuY2VvZiBIVE1MQnV0dG9uRWxlbWVudCkgJiYgc2VsZi4jY29udGFpbmVyLmNvbnRhaW5zKGVsKSAmJiAhc2VsZi5pc0VudGVySGFuZGxlZFxuICAgIH1dLCBbW1wiIFwiLCBcIm1hYysgXCJdLCBwcm90by5hZGROZXdFZGl0b3JGcm9tS2V5Ym9hcmQsIHtcbiAgICAgIGNoZWNrZXI6IChzZWxmLCB7XG4gICAgICAgIHRhcmdldDogZWxcbiAgICAgIH0pID0+ICEoZWwgaW5zdGFuY2VvZiBIVE1MQnV0dG9uRWxlbWVudCkgJiYgc2VsZi4jY29udGFpbmVyLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpXG4gICAgfV0sIFtbXCJFc2NhcGVcIiwgXCJtYWMrRXNjYXBlXCJdLCBwcm90by51bnNlbGVjdEFsbF0sIFtbXCJBcnJvd0xlZnRcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFstc21hbGwsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93TGVmdFwiLCBcIm1hYytzaGlmdCtBcnJvd0xlZnRcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWy1iaWcsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd1JpZ2h0XCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogW3NtYWxsLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1JpZ2h0XCIsIFwibWFjK3NoaWZ0K0Fycm93UmlnaHRcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogW2JpZywgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93VXBcIiwgXCJtYWMrQXJyb3dVcFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbMCwgLXNtYWxsXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1VwXCIsIFwibWFjK3NoaWZ0K0Fycm93VXBcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWzAsIC1iaWddLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd0Rvd25cIiwgXCJtYWMrQXJyb3dEb3duXCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFswLCBzbWFsbF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dEb3duXCIsIFwibWFjK3NoaWZ0K0Fycm93RG93blwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbMCwgYmlnXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dXSkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgdmlld2VyLCBhbHRUZXh0TWFuYWdlciwgZXZlbnRCdXMsIHBkZkRvY3VtZW50LCBwYWdlQ29sb3JzLCBoaWdobGlnaHRDb2xvcnMsIGVuYWJsZUhpZ2hsaWdodEZsb2F0aW5nQnV0dG9uLCBlbmFibGVVcGRhdGVkQWRkSW1hZ2UsIGVuYWJsZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UsIG1sTWFuYWdlciwgZWRpdG9yVW5kb0Jhciwgc3VwcG9ydHNQaW5jaFRvWm9vbSkge1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3NpZ25hbCA9IHRoaXMuI2Fib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgdGhpcy4jY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuI3ZpZXdlciA9IHZpZXdlcjtcbiAgICB0aGlzLiNhbHRUZXh0TWFuYWdlciA9IGFsdFRleHRNYW5hZ2VyO1xuICAgIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG4gICAgZXZlbnRCdXMuX29uKFwiZWRpdGluZ2FjdGlvblwiLCB0aGlzLm9uRWRpdGluZ0FjdGlvbi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBldmVudEJ1cy5fb24oXCJwYWdlY2hhbmdpbmdcIiwgdGhpcy5vblBhZ2VDaGFuZ2luZy5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBldmVudEJ1cy5fb24oXCJzY2FsZWNoYW5naW5nXCIsIHRoaXMub25TY2FsZUNoYW5naW5nLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGV2ZW50QnVzLl9vbihcInJvdGF0aW9uY2hhbmdpbmdcIiwgdGhpcy5vblJvdGF0aW9uQ2hhbmdpbmcuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZXZlbnRCdXMuX29uKFwic2V0cHJlZmVyZW5jZVwiLCB0aGlzLm9uU2V0UHJlZmVyZW5jZS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBldmVudEJ1cy5fb24oXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ycGFyYW1zXCIsIGV2dCA9PiB0aGlzLnVwZGF0ZVBhcmFtcyhldnQudHlwZSwgZXZ0LnZhbHVlKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy4jYWRkU2VsZWN0aW9uTGlzdGVuZXIoKTtcbiAgICB0aGlzLiNhZGREcmFnQW5kRHJvcExpc3RlbmVycygpO1xuICAgIHRoaXMuI2FkZEtleWJvYXJkTWFuYWdlcigpO1xuICAgIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlID0gcGRmRG9jdW1lbnQuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgdGhpcy4jZmlsdGVyRmFjdG9yeSA9IHBkZkRvY3VtZW50LmZpbHRlckZhY3Rvcnk7XG4gICAgdGhpcy4jcGFnZUNvbG9ycyA9IHBhZ2VDb2xvcnM7XG4gICAgdGhpcy4jaGlnaGxpZ2h0Q29sb3JzID0gaGlnaGxpZ2h0Q29sb3JzIHx8IG51bGw7XG4gICAgdGhpcy4jZW5hYmxlSGlnaGxpZ2h0RmxvYXRpbmdCdXR0b24gPSBlbmFibGVIaWdobGlnaHRGbG9hdGluZ0J1dHRvbjtcbiAgICB0aGlzLiNlbmFibGVVcGRhdGVkQWRkSW1hZ2UgPSBlbmFibGVVcGRhdGVkQWRkSW1hZ2U7XG4gICAgdGhpcy4jZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSA9IGVuYWJsZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2U7XG4gICAgdGhpcy4jbWxNYW5hZ2VyID0gbWxNYW5hZ2VyIHx8IG51bGw7XG4gICAgdGhpcy52aWV3UGFyYW1ldGVycyA9IHtcbiAgICAgIHJlYWxTY2FsZTogUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTLFxuICAgICAgcm90YXRpb246IDBcbiAgICB9O1xuICAgIHRoaXMuaXNTaGlmdEtleURvd24gPSBmYWxzZTtcbiAgICB0aGlzLl9lZGl0b3JVbmRvQmFyID0gZWRpdG9yVW5kb0JhciB8fCBudWxsO1xuICAgIHRoaXMuX3N1cHBvcnRzUGluY2hUb1pvb20gPSBzdXBwb3J0c1BpbmNoVG9ab29tICE9PSBmYWxzZTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5Py5yZXNvbHZlKCk7XG4gICAgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkgPSBudWxsO1xuICAgIHRoaXMuI2Fib3J0Q29udHJvbGxlcj8uYWJvcnQoKTtcbiAgICB0aGlzLiNhYm9ydENvbnRyb2xsZXIgPSBudWxsO1xuICAgIHRoaXMuX3NpZ25hbCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGxheWVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy4jYWxsTGF5ZXJzLmNsZWFyKCk7XG4gICAgdGhpcy4jYWxsRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI2VkaXRvcnNUb1Jlc2NhbGUuY2xlYXIoKTtcbiAgICB0aGlzLiNhY3RpdmVFZGl0b3IgPSBudWxsO1xuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLiNhbHRUZXh0TWFuYWdlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuI2hpZ2hsaWdodFRvb2xiYXI/LmhpZGUoKTtcbiAgICB0aGlzLiNoaWdobGlnaHRUb29sYmFyID0gbnVsbDtcbiAgICBpZiAodGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkKTtcbiAgICAgIHRoaXMuI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkKTtcbiAgICAgIHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fZWRpdG9yVW5kb0Jhcj8uZGVzdHJveSgpO1xuICB9XG4gIGNvbWJpbmVkU2lnbmFsKGFjKSB7XG4gICAgcmV0dXJuIEFib3J0U2lnbmFsLmFueShbdGhpcy5fc2lnbmFsLCBhYy5zaWduYWxdKTtcbiAgfVxuICBnZXQgbWxNYW5hZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLiNtbE1hbmFnZXI7XG4gIH1cbiAgZ2V0IHVzZU5ld0FsdFRleHRGbG93KCkge1xuICAgIHJldHVybiB0aGlzLiNlbmFibGVVcGRhdGVkQWRkSW1hZ2U7XG4gIH1cbiAgZ2V0IHVzZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2VuYWJsZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2U7XG4gIH1cbiAgZ2V0IGhjbUZpbHRlcigpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaGNtRmlsdGVyXCIsIHRoaXMuI3BhZ2VDb2xvcnMgPyB0aGlzLiNmaWx0ZXJGYWN0b3J5LmFkZEhDTUZpbHRlcih0aGlzLiNwYWdlQ29sb3JzLmZvcmVncm91bmQsIHRoaXMuI3BhZ2VDb2xvcnMuYmFja2dyb3VuZCkgOiBcIm5vbmVcIik7XG4gIH1cbiAgZ2V0IGRpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiZGlyZWN0aW9uXCIsIGdldENvbXB1dGVkU3R5bGUodGhpcy4jY29udGFpbmVyKS5kaXJlY3Rpb24pO1xuICB9XG4gIGdldCBoaWdobGlnaHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImhpZ2hsaWdodENvbG9yc1wiLCB0aGlzLiNoaWdobGlnaHRDb2xvcnMgPyBuZXcgTWFwKHRoaXMuI2hpZ2hsaWdodENvbG9ycy5zcGxpdChcIixcIikubWFwKHBhaXIgPT4gcGFpci5zcGxpdChcIj1cIikubWFwKHggPT4geC50cmltKCkpKSkgOiBudWxsKTtcbiAgfVxuICBnZXQgaGlnaGxpZ2h0Q29sb3JOYW1lcygpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaGlnaGxpZ2h0Q29sb3JOYW1lc1wiLCB0aGlzLmhpZ2hsaWdodENvbG9ycyA/IG5ldyBNYXAoQXJyYXkuZnJvbSh0aGlzLmhpZ2hsaWdodENvbG9ycywgZSA9PiBlLnJldmVyc2UoKSkpIDogbnVsbCk7XG4gIH1cbiAgc2V0Q3VycmVudERyYXdpbmdTZXNzaW9uKGxheWVyKSB7XG4gICAgaWYgKGxheWVyKSB7XG4gICAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG4gICAgICB0aGlzLmRpc2FibGVVc2VyU2VsZWN0KHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpc2FibGVVc2VyU2VsZWN0KGZhbHNlKTtcbiAgICB9XG4gICAgdGhpcy4jY3VycmVudERyYXdpbmdTZXNzaW9uID0gbGF5ZXI7XG4gIH1cbiAgc2V0TWFpbkhpZ2hsaWdodENvbG9yUGlja2VyKGNvbG9yUGlja2VyKSB7XG4gICAgdGhpcy4jbWFpbkhpZ2hsaWdodENvbG9yUGlja2VyID0gY29sb3JQaWNrZXI7XG4gIH1cbiAgZWRpdEFsdFRleHQoZWRpdG9yLCBmaXJzdFRpbWUgPSBmYWxzZSkge1xuICAgIHRoaXMuI2FsdFRleHRNYW5hZ2VyPy5lZGl0QWx0VGV4dCh0aGlzLCBlZGl0b3IsIGZpcnN0VGltZSk7XG4gIH1cbiAgc3dpdGNoVG9Nb2RlKG1vZGUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fZXZlbnRCdXMub24oXCJhbm5vdGF0aW9uZWRpdG9ybW9kZWNoYW5nZWRcIiwgY2FsbGJhY2ssIHtcbiAgICAgIG9uY2U6IHRydWUsXG4gICAgICBzaWduYWw6IHRoaXMuX3NpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwic2hvd2Fubm90YXRpb25lZGl0b3J1aVwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBtb2RlXG4gICAgfSk7XG4gIH1cbiAgc2V0UHJlZmVyZW5jZShuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwic2V0cHJlZmVyZW5jZVwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBuYW1lLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgfVxuICBvblNldFByZWZlcmVuY2Uoe1xuICAgIG5hbWUsXG4gICAgdmFsdWVcbiAgfSkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSBcImVuYWJsZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2VcIjpcbiAgICAgICAgdGhpcy4jZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgb25QYWdlQ2hhbmdpbmcoe1xuICAgIHBhZ2VOdW1iZXJcbiAgfSkge1xuICAgIHRoaXMuI2N1cnJlbnRQYWdlSW5kZXggPSBwYWdlTnVtYmVyIC0gMTtcbiAgfVxuICBmb2N1c01haW5Db250YWluZXIoKSB7XG4gICAgdGhpcy4jY29udGFpbmVyLmZvY3VzKCk7XG4gIH1cbiAgZmluZFBhcmVudCh4LCB5KSB7XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeDogbGF5ZXJYLFxuICAgICAgICB5OiBsYXllclksXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSBsYXllci5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAoeCA+PSBsYXllclggJiYgeCA8PSBsYXllclggKyB3aWR0aCAmJiB5ID49IGxheWVyWSAmJiB5IDw9IGxheWVyWSArIGhlaWdodCkge1xuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGRpc2FibGVVc2VyU2VsZWN0KHZhbHVlID0gZmFsc2UpIHtcbiAgICB0aGlzLiN2aWV3ZXIuY2xhc3NMaXN0LnRvZ2dsZShcIm5vVXNlclNlbGVjdFwiLCB2YWx1ZSk7XG4gIH1cbiAgYWRkU2hvdWxkUmVzY2FsZShlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3JzVG9SZXNjYWxlLmFkZChlZGl0b3IpO1xuICB9XG4gIHJlbW92ZVNob3VsZFJlc2NhbGUoZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9yc1RvUmVzY2FsZS5kZWxldGUoZWRpdG9yKTtcbiAgfVxuICBvblNjYWxlQ2hhbmdpbmcoe1xuICAgIHNjYWxlXG4gIH0pIHtcbiAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgdGhpcy52aWV3UGFyYW1ldGVycy5yZWFsU2NhbGUgPSBzY2FsZSAqIFBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUztcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzVG9SZXNjYWxlKSB7XG4gICAgICBlZGl0b3Iub25TY2FsZUNoYW5naW5nKCk7XG4gICAgfVxuICAgIHRoaXMuI2N1cnJlbnREcmF3aW5nU2Vzc2lvbj8ub25TY2FsZUNoYW5naW5nKCk7XG4gIH1cbiAgb25Sb3RhdGlvbkNoYW5naW5nKHtcbiAgICBwYWdlc1JvdGF0aW9uXG4gIH0pIHtcbiAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgdGhpcy52aWV3UGFyYW1ldGVycy5yb3RhdGlvbiA9IHBhZ2VzUm90YXRpb247XG4gIH1cbiAgI2dldEFuY2hvckVsZW1lbnRGb3JTZWxlY3Rpb24oe1xuICAgIGFuY2hvck5vZGVcbiAgfSkge1xuICAgIHJldHVybiBhbmNob3JOb2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSA/IGFuY2hvck5vZGUucGFyZW50RWxlbWVudCA6IGFuY2hvck5vZGU7XG4gIH1cbiAgI2dldExheWVyRm9yVGV4dExheWVyKHRleHRMYXllcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRMYXllclxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChjdXJyZW50TGF5ZXIuaGFzVGV4dExheWVyKHRleHRMYXllcikpIHtcbiAgICAgIHJldHVybiBjdXJyZW50TGF5ZXI7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICBpZiAobGF5ZXIuaGFzVGV4dExheWVyKHRleHRMYXllcikpIHtcbiAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBoaWdobGlnaHRTZWxlY3Rpb24obWV0aG9kT2ZDcmVhdGlvbiA9IFwiXCIpIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYW5jaG9yTm9kZSxcbiAgICAgIGFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0XG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICBjb25zdCB0ZXh0ID0gc2VsZWN0aW9uLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgYW5jaG9yRWxlbWVudCA9IHRoaXMuI2dldEFuY2hvckVsZW1lbnRGb3JTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICBjb25zdCB0ZXh0TGF5ZXIgPSBhbmNob3JFbGVtZW50LmNsb3Nlc3QoXCIudGV4dExheWVyXCIpO1xuICAgIGNvbnN0IGJveGVzID0gdGhpcy5nZXRTZWxlY3Rpb25Cb3hlcyh0ZXh0TGF5ZXIpO1xuICAgIGlmICghYm94ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2VsZWN0aW9uLmVtcHR5KCk7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLiNnZXRMYXllckZvclRleHRMYXllcih0ZXh0TGF5ZXIpO1xuICAgIGNvbnN0IGlzTm9uZU1vZGUgPSB0aGlzLiNtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgbGF5ZXI/LmNyZWF0ZUFuZEFkZE5ld0VkaXRvcih7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sIGZhbHNlLCB7XG4gICAgICAgIG1ldGhvZE9mQ3JlYXRpb24sXG4gICAgICAgIGJveGVzLFxuICAgICAgICBhbmNob3JOb2RlLFxuICAgICAgICBhbmNob3JPZmZzZXQsXG4gICAgICAgIGZvY3VzTm9kZSxcbiAgICAgICAgZm9jdXNPZmZzZXQsXG4gICAgICAgIHRleHRcbiAgICAgIH0pO1xuICAgICAgaWYgKGlzTm9uZU1vZGUpIHtcbiAgICAgICAgdGhpcy5zaG93QWxsRWRpdG9ycyhcImhpZ2hsaWdodFwiLCB0cnVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc05vbmVNb2RlKSB7XG4gICAgICB0aGlzLnN3aXRjaFRvTW9kZShBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuICAjZGlzcGxheUhpZ2hsaWdodFRvb2xiYXIoKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFuY2hvckVsZW1lbnQgPSB0aGlzLiNnZXRBbmNob3JFbGVtZW50Rm9yU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgY29uc3QgdGV4dExheWVyID0gYW5jaG9yRWxlbWVudC5jbG9zZXN0KFwiLnRleHRMYXllclwiKTtcbiAgICBjb25zdCBib3hlcyA9IHRoaXMuZ2V0U2VsZWN0aW9uQm94ZXModGV4dExheWVyKTtcbiAgICBpZiAoIWJveGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2hpZ2hsaWdodFRvb2xiYXIgfHw9IG5ldyBIaWdobGlnaHRUb29sYmFyKHRoaXMpO1xuICAgIHRoaXMuI2hpZ2hsaWdodFRvb2xiYXIuc2hvdyh0ZXh0TGF5ZXIsIGJveGVzLCB0aGlzLmRpcmVjdGlvbiA9PT0gXCJsdHJcIik7XG4gIH1cbiAgYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShlZGl0b3IpIHtcbiAgICBpZiAoIWVkaXRvci5pc0VtcHR5KCkgJiYgdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2UgJiYgIXRoaXMuI2Fubm90YXRpb25TdG9yYWdlLmhhcyhlZGl0b3IuaWQpKSB7XG4gICAgICB0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZShlZGl0b3IuaWQsIGVkaXRvcik7XG4gICAgfVxuICB9XG4gICNzZWxlY3Rpb25DaGFuZ2UoKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSB7XG4gICAgICBpZiAodGhpcy4jc2VsZWN0ZWRUZXh0Tm9kZSkge1xuICAgICAgICB0aGlzLiNoaWdobGlnaHRUb29sYmFyPy5oaWRlKCk7XG4gICAgICAgIHRoaXMuI3NlbGVjdGVkVGV4dE5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICAgICAgaGFzU2VsZWN0ZWRUZXh0OiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYW5jaG9yTm9kZVxuICAgIH0gPSBzZWxlY3Rpb247XG4gICAgaWYgKGFuY2hvck5vZGUgPT09IHRoaXMuI3NlbGVjdGVkVGV4dE5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYW5jaG9yRWxlbWVudCA9IHRoaXMuI2dldEFuY2hvckVsZW1lbnRGb3JTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICBjb25zdCB0ZXh0TGF5ZXIgPSBhbmNob3JFbGVtZW50LmNsb3Nlc3QoXCIudGV4dExheWVyXCIpO1xuICAgIGlmICghdGV4dExheWVyKSB7XG4gICAgICBpZiAodGhpcy4jc2VsZWN0ZWRUZXh0Tm9kZSkge1xuICAgICAgICB0aGlzLiNoaWdobGlnaHRUb29sYmFyPy5oaWRlKCk7XG4gICAgICAgIHRoaXMuI3NlbGVjdGVkVGV4dE5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICAgICAgaGFzU2VsZWN0ZWRUZXh0OiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaGlnaGxpZ2h0VG9vbGJhcj8uaGlkZSgpO1xuICAgIHRoaXMuI3NlbGVjdGVkVGV4dE5vZGUgPSBhbmNob3JOb2RlO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkVGV4dDogdHJ1ZVxuICAgIH0pO1xuICAgIGlmICh0aGlzLiNtb2RlICE9PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQgJiYgdGhpcy4jbW9kZSAhPT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUKSB7XG4gICAgICB0aGlzLnNob3dBbGxFZGl0b3JzKFwiaGlnaGxpZ2h0XCIsIHRydWUsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLiNoaWdobGlnaHRXaGVuU2hpZnRVcCA9IHRoaXMuaXNTaGlmdEtleURvd247XG4gICAgaWYgKCF0aGlzLmlzU2hpZnRLZXlEb3duKSB7XG4gICAgICBjb25zdCBhY3RpdmVMYXllciA9IHRoaXMuI21vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCA/IHRoaXMuI2dldExheWVyRm9yVGV4dExheWVyKHRleHRMYXllcikgOiBudWxsO1xuICAgICAgYWN0aXZlTGF5ZXI/LnRvZ2dsZURyYXdpbmcoKTtcbiAgICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3Qgc2lnbmFsID0gdGhpcy5jb21iaW5lZFNpZ25hbChhYyk7XG4gICAgICBjb25zdCBwb2ludGVydXAgPSBlID0+IHtcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJwb2ludGVydXBcIiAmJiBlLmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhYy5hYm9ydCgpO1xuICAgICAgICBhY3RpdmVMYXllcj8udG9nZ2xlRHJhd2luZyh0cnVlKTtcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJwb2ludGVydXBcIikge1xuICAgICAgICAgIHRoaXMuI29uU2VsZWN0RW5kKFwibWFpbl90b29sYmFyXCIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlcnVwLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgcG9pbnRlcnVwLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gICNvblNlbGVjdEVuZChtZXRob2RPZkNyZWF0aW9uID0gXCJcIikge1xuICAgIGlmICh0aGlzLiNtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQpIHtcbiAgICAgIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uKG1ldGhvZE9mQ3JlYXRpb24pO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jZW5hYmxlSGlnaGxpZ2h0RmxvYXRpbmdCdXR0b24pIHtcbiAgICAgIHRoaXMuI2Rpc3BsYXlIaWdobGlnaHRUb29sYmFyKCk7XG4gICAgfVxuICB9XG4gICNhZGRTZWxlY3Rpb25MaXN0ZW5lcigpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMuI3NlbGVjdGlvbkNoYW5nZS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWw6IHRoaXMuX3NpZ25hbFxuICAgIH0pO1xuICB9XG4gICNhZGRGb2N1c01hbmFnZXIoKSB7XG4gICAgaWYgKHRoaXMuI2ZvY3VzTWFuYWdlckFDKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2ZvY3VzTWFuYWdlckFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuY29tYmluZWRTaWduYWwodGhpcy4jZm9jdXNNYW5hZ2VyQUMpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5mb2N1cy5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5ibHVyLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gICNyZW1vdmVGb2N1c01hbmFnZXIoKSB7XG4gICAgdGhpcy4jZm9jdXNNYW5hZ2VyQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jZm9jdXNNYW5hZ2VyQUMgPSBudWxsO1xuICB9XG4gIGJsdXIoKSB7XG4gICAgdGhpcy5pc1NoaWZ0S2V5RG93biA9IGZhbHNlO1xuICAgIGlmICh0aGlzLiNoaWdobGlnaHRXaGVuU2hpZnRVcCkge1xuICAgICAgdGhpcy4jaGlnaGxpZ2h0V2hlblNoaWZ0VXAgPSBmYWxzZTtcbiAgICAgIHRoaXMuI29uU2VsZWN0RW5kKFwibWFpbl90b29sYmFyXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFjdGl2ZUVsZW1lbnRcbiAgICB9ID0gZG9jdW1lbnQ7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBpZiAoZWRpdG9yLmRpdi5jb250YWlucyhhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICB0aGlzLiNsYXN0QWN0aXZlRWxlbWVudCA9IFtlZGl0b3IsIGFjdGl2ZUVsZW1lbnRdO1xuICAgICAgICBlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9jdXMoKSB7XG4gICAgaWYgKCF0aGlzLiNsYXN0QWN0aXZlRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbbGFzdEVkaXRvciwgbGFzdEFjdGl2ZUVsZW1lbnRdID0gdGhpcy4jbGFzdEFjdGl2ZUVsZW1lbnQ7XG4gICAgdGhpcy4jbGFzdEFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgIGxhc3RBY3RpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsICgpID0+IHtcbiAgICAgIGxhc3RFZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gICAgfSwge1xuICAgICAgb25jZTogdHJ1ZSxcbiAgICAgIHNpZ25hbDogdGhpcy5fc2lnbmFsXG4gICAgfSk7XG4gICAgbGFzdEFjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgfVxuICAjYWRkS2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGlmICh0aGlzLiNrZXlib2FyZE1hbmFnZXJBQykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNrZXlib2FyZE1hbmFnZXJBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLmNvbWJpbmVkU2lnbmFsKHRoaXMuI2tleWJvYXJkTWFuYWdlckFDKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5rZXlkb3duLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5rZXl1cC5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICAjcmVtb3ZlS2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIHRoaXMuI2tleWJvYXJkTWFuYWdlckFDPy5hYm9ydCgpO1xuICAgIHRoaXMuI2tleWJvYXJkTWFuYWdlckFDID0gbnVsbDtcbiAgfVxuICAjYWRkQ29weVBhc3RlTGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLiNjb3B5UGFzdGVBQykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb3B5UGFzdGVBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLmNvbWJpbmVkU2lnbmFsKHRoaXMuI2NvcHlQYXN0ZUFDKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY29weVwiLCB0aGlzLmNvcHkuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImN1dFwiLCB0aGlzLmN1dC5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicGFzdGVcIiwgdGhpcy5wYXN0ZS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICAjcmVtb3ZlQ29weVBhc3RlTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuI2NvcHlQYXN0ZUFDPy5hYm9ydCgpO1xuICAgIHRoaXMuI2NvcHlQYXN0ZUFDID0gbnVsbDtcbiAgfVxuICAjYWRkRHJhZ0FuZERyb3BMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fc2lnbmFsO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLCB0aGlzLmRyYWdPdmVyLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIHRoaXMuZHJvcC5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICBhZGRFZGl0TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuI2FkZEtleWJvYXJkTWFuYWdlcigpO1xuICAgIHRoaXMuI2FkZENvcHlQYXN0ZUxpc3RlbmVycygpO1xuICB9XG4gIHJlbW92ZUVkaXRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy4jcmVtb3ZlS2V5Ym9hcmRNYW5hZ2VyKCk7XG4gICAgdGhpcy4jcmVtb3ZlQ29weVBhc3RlTGlzdGVuZXJzKCk7XG4gIH1cbiAgZHJhZ092ZXIoZXZlbnQpIHtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9IG9mIGV2ZW50LmRhdGFUcmFuc2Zlci5pdGVtcykge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICAgIGlmIChlZGl0b3JUeXBlLmlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyh0eXBlKSkge1xuICAgICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gXCJjb3B5XCI7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZHJvcChldmVudCkge1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBldmVudC5kYXRhVHJhbnNmZXIuaXRlbXMpIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiB0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgICBpZiAoZWRpdG9yVHlwZS5pc0hhbmRsaW5nTWltZUZvclBhc3RpbmcoaXRlbS50eXBlKSkge1xuICAgICAgICAgIGVkaXRvclR5cGUucGFzdGUoaXRlbSwgdGhpcy5jdXJyZW50TGF5ZXIpO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvcHkoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuI2FjdGl2ZUVkaXRvcj8uY29tbWl0T3JSZW1vdmUoKTtcbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBlZGl0b3Iuc2VyaWFsaXplKHRydWUpO1xuICAgICAgaWYgKHNlcmlhbGl6ZWQpIHtcbiAgICAgICAgZWRpdG9ycy5wdXNoKHNlcmlhbGl6ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZWRpdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXZlbnQuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwiYXBwbGljYXRpb24vcGRmanNcIiwgSlNPTi5zdHJpbmdpZnkoZWRpdG9ycykpO1xuICB9XG4gIGN1dChldmVudCkge1xuICAgIHRoaXMuY29weShldmVudCk7XG4gICAgdGhpcy5kZWxldGUoKTtcbiAgfVxuICBhc3luYyBwYXN0ZShldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3Qge1xuICAgICAgY2xpcGJvYXJkRGF0YVxuICAgIH0gPSBldmVudDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY2xpcGJvYXJkRGF0YS5pdGVtcykge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICAgIGlmIChlZGl0b3JUeXBlLmlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyhpdGVtLnR5cGUpKSB7XG4gICAgICAgICAgZWRpdG9yVHlwZS5wYXN0ZShpdGVtLCB0aGlzLmN1cnJlbnRMYXllcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBkYXRhID0gY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwiYXBwbGljYXRpb24vcGRmanNcIik7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgd2FybihgcGFzdGU6IFwiJHtleC5tZXNzYWdlfVwiLmApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5jdXJyZW50TGF5ZXI7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG5ld0VkaXRvcnMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGRhdGEpIHtcbiAgICAgICAgY29uc3QgZGVzZXJpYWxpemVkRWRpdG9yID0gYXdhaXQgbGF5ZXIuZGVzZXJpYWxpemUoZWRpdG9yKTtcbiAgICAgICAgaWYgKCFkZXNlcmlhbGl6ZWRFZGl0b3IpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbmV3RWRpdG9ycy5wdXNoKGRlc2VyaWFsaXplZEVkaXRvcik7XG4gICAgICB9XG4gICAgICBjb25zdCBjbWQgPSAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIG5ld0VkaXRvcnMpIHtcbiAgICAgICAgICB0aGlzLiNhZGRFZGl0b3JUb0xheWVyKGVkaXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jc2VsZWN0RWRpdG9ycyhuZXdFZGl0b3JzKTtcbiAgICAgIH07XG4gICAgICBjb25zdCB1bmRvID0gKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBuZXdFZGl0b3JzKSB7XG4gICAgICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICAgIGNtZCxcbiAgICAgICAgdW5kbyxcbiAgICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICB3YXJuKGBwYXN0ZTogXCIke2V4Lm1lc3NhZ2V9XCIuYCk7XG4gICAgfVxuICB9XG4gIGtleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuaXNTaGlmdEtleURvd24gJiYgZXZlbnQua2V5ID09PSBcIlNoaWZ0XCIpIHtcbiAgICAgIHRoaXMuaXNTaGlmdEtleURvd24gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy4jbW9kZSAhPT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSAmJiAhdGhpcy5pc0VkaXRvckhhbmRsaW5nS2V5Ym9hcmQpIHtcbiAgICAgIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIuX2tleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH1cbiAga2V5dXAoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5pc1NoaWZ0S2V5RG93biAmJiBldmVudC5rZXkgPT09IFwiU2hpZnRcIikge1xuICAgICAgdGhpcy5pc1NoaWZ0S2V5RG93biA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuI2hpZ2hsaWdodFdoZW5TaGlmdFVwKSB7XG4gICAgICAgIHRoaXMuI2hpZ2hsaWdodFdoZW5TaGlmdFVwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI29uU2VsZWN0RW5kKFwibWFpbl90b29sYmFyXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbkVkaXRpbmdBY3Rpb24oe1xuICAgIG5hbWVcbiAgfSkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSBcInVuZG9cIjpcbiAgICAgIGNhc2UgXCJyZWRvXCI6XG4gICAgICBjYXNlIFwiZGVsZXRlXCI6XG4gICAgICBjYXNlIFwic2VsZWN0QWxsXCI6XG4gICAgICAgIHRoaXNbbmFtZV0oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaGlnaGxpZ2h0U2VsZWN0aW9uXCI6XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uKFwiY29udGV4dF9tZW51XCIpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKGRldGFpbHMpIHtcbiAgICBjb25zdCBoYXNDaGFuZ2VkID0gT2JqZWN0LmVudHJpZXMoZGV0YWlscykuc29tZSgoW2tleSwgdmFsdWVdKSA9PiB0aGlzLiNwcmV2aW91c1N0YXRlc1trZXldICE9PSB2YWx1ZSk7XG4gICAgaWYgKGhhc0NoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwiYW5ub3RhdGlvbmVkaXRvcnN0YXRlc2NoYW5nZWRcIiwge1xuICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgIGRldGFpbHM6IE9iamVjdC5hc3NpZ24odGhpcy4jcHJldmlvdXNTdGF0ZXMsIGRldGFpbHMpXG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLiNtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQgJiYgZGV0YWlscy5oYXNTZWxlY3RlZEVkaXRvciA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShbW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9GUkVFLCB0cnVlXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjZGlzcGF0Y2hVcGRhdGVVSShkZXRhaWxzKSB7XG4gICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJhbm5vdGF0aW9uZWRpdG9ycGFyYW1zY2hhbmdlZFwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBkZXRhaWxzXG4gICAgfSk7XG4gIH1cbiAgc2V0RWRpdGluZ1N0YXRlKGlzRWRpdGluZykge1xuICAgIGlmIChpc0VkaXRpbmcpIHtcbiAgICAgIHRoaXMuI2FkZEZvY3VzTWFuYWdlcigpO1xuICAgICAgdGhpcy4jYWRkQ29weVBhc3RlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICAgIGlzRWRpdGluZzogdGhpcy4jbW9kZSAhPT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSxcbiAgICAgICAgaXNFbXB0eTogdGhpcy4jaXNFbXB0eSgpLFxuICAgICAgICBoYXNTb21ldGhpbmdUb1VuZG86IHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmhhc1NvbWV0aGluZ1RvVW5kbygpLFxuICAgICAgICBoYXNTb21ldGhpbmdUb1JlZG86IHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmhhc1NvbWV0aGluZ1RvUmVkbygpLFxuICAgICAgICBoYXNTZWxlY3RlZEVkaXRvcjogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNyZW1vdmVGb2N1c01hbmFnZXIoKTtcbiAgICAgIHRoaXMuI3JlbW92ZUNvcHlQYXN0ZUxpc3RlbmVycygpO1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICBpc0VkaXRpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QoZmFsc2UpO1xuICAgIH1cbiAgfVxuICByZWdpc3RlckVkaXRvclR5cGVzKHR5cGVzKSB7XG4gICAgaWYgKHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2VkaXRvclR5cGVzID0gdHlwZXM7XG4gICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvclR5cGUuZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgfVxuICB9XG4gIGdldElkKCkge1xuICAgIHJldHVybiB0aGlzLiNpZE1hbmFnZXIuaWQ7XG4gIH1cbiAgZ2V0IGN1cnJlbnRMYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy4jYWxsTGF5ZXJzLmdldCh0aGlzLiNjdXJyZW50UGFnZUluZGV4KTtcbiAgfVxuICBnZXRMYXllcihwYWdlSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWxsTGF5ZXJzLmdldChwYWdlSW5kZXgpO1xuICB9XG4gIGdldCBjdXJyZW50UGFnZUluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLiNjdXJyZW50UGFnZUluZGV4O1xuICB9XG4gIGFkZExheWVyKGxheWVyKSB7XG4gICAgdGhpcy4jYWxsTGF5ZXJzLnNldChsYXllci5wYWdlSW5kZXgsIGxheWVyKTtcbiAgICBpZiAodGhpcy4jaXNFbmFibGVkKSB7XG4gICAgICBsYXllci5lbmFibGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5ZXIuZGlzYWJsZSgpO1xuICAgIH1cbiAgfVxuICByZW1vdmVMYXllcihsYXllcikge1xuICAgIHRoaXMuI2FsbExheWVycy5kZWxldGUobGF5ZXIucGFnZUluZGV4KTtcbiAgfVxuICBhc3luYyB1cGRhdGVNb2RlKG1vZGUsIGVkaXRJZCA9IG51bGwsIGlzRnJvbUtleWJvYXJkID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy4jbW9kZSA9PT0gbW9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkpIHtcbiAgICAgIGF3YWl0IHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICBpZiAoIXRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLiNtb2RlID0gbW9kZTtcbiAgICBpZiAobW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSkge1xuICAgICAgdGhpcy5zZXRFZGl0aW5nU3RhdGUoZmFsc2UpO1xuICAgICAgdGhpcy4jZGlzYWJsZUFsbCgpO1xuICAgICAgdGhpcy5fZWRpdG9yVW5kb0Jhcj8uaGlkZSgpO1xuICAgICAgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldEVkaXRpbmdTdGF0ZSh0cnVlKTtcbiAgICBhd2FpdCB0aGlzLiNlbmFibGVBbGwoKTtcbiAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGxheWVyLnVwZGF0ZU1vZGUobW9kZSk7XG4gICAgfVxuICAgIGlmICghZWRpdElkKSB7XG4gICAgICBpZiAoaXNGcm9tS2V5Ym9hcmQpIHtcbiAgICAgICAgdGhpcy5hZGROZXdFZGl0b3JGcm9tS2V5Ym9hcmQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkID09PSBlZGl0SWQpIHtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3RlZChlZGl0b3IpO1xuICAgICAgICBlZGl0b3IuZW50ZXJJbkVkaXRNb2RlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIGFkZE5ld0VkaXRvckZyb21LZXlib2FyZCgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50TGF5ZXIuY2FuQ3JlYXRlTmV3RW1wdHlFZGl0b3IoKSkge1xuICAgICAgdGhpcy5jdXJyZW50TGF5ZXIuYWRkTmV3RWRpdG9yKCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVRvb2xiYXIobW9kZSkge1xuICAgIGlmIChtb2RlID09PSB0aGlzLiNtb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwic3dpdGNoYW5ub3RhdGlvbmVkaXRvcm1vZGVcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgbW9kZVxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICghdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkNSRUFURTpcbiAgICAgICAgdGhpcy5jdXJyZW50TGF5ZXIuYWRkTmV3RWRpdG9yKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0RFRkFVTFRfQ09MT1I6XG4gICAgICAgIHRoaXMuI21haW5IaWdobGlnaHRDb2xvclBpY2tlcj8udXBkYXRlQ29sb3IodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX1NIT1dfQUxMOlxuICAgICAgICB0aGlzLl9ldmVudEJ1cy5kaXNwYXRjaChcInJlcG9ydHRlbGVtZXRyeVwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZWRpdGluZ1wiLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICB0eXBlOiBcImhpZ2hsaWdodFwiLFxuICAgICAgICAgICAgICBhY3Rpb246IFwidG9nZ2xlX3Zpc2liaWxpdHlcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICh0aGlzLiNzaG93QWxsU3RhdGVzIHx8PSBuZXcgTWFwKCkpLnNldCh0eXBlLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2hvd0FsbEVkaXRvcnMoXCJoaWdobGlnaHRcIiwgdmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBlZGl0b3IudXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICBlZGl0b3JUeXBlLnVwZGF0ZURlZmF1bHRQYXJhbXModHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICBzaG93QWxsRWRpdG9ycyh0eXBlLCB2aXNpYmxlLCB1cGRhdGVCdXR0b24gPSBmYWxzZSkge1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlZGl0b3IuZWRpdG9yVHlwZSA9PT0gdHlwZSkge1xuICAgICAgICBlZGl0b3Iuc2hvdyh2aXNpYmxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLiNzaG93QWxsU3RhdGVzPy5nZXQoQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX1NIT1dfQUxMKSA/PyB0cnVlO1xuICAgIGlmIChzdGF0ZSAhPT0gdmlzaWJsZSkge1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShbW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9TSE9XX0FMTCwgdmlzaWJsZV1dKTtcbiAgICB9XG4gIH1cbiAgZW5hYmxlV2FpdGluZyhtdXN0V2FpdCA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuI2lzV2FpdGluZyA9PT0gbXVzdFdhaXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaXNXYWl0aW5nID0gbXVzdFdhaXQ7XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChtdXN0V2FpdCkge1xuICAgICAgICBsYXllci5kaXNhYmxlQ2xpY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxheWVyLmVuYWJsZUNsaWNrKCk7XG4gICAgICB9XG4gICAgICBsYXllci5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcIndhaXRpbmdcIiwgbXVzdFdhaXQpO1xuICAgIH1cbiAgfVxuICBhc3luYyAjZW5hYmxlQWxsKCkge1xuICAgIGlmICghdGhpcy4jaXNFbmFibGVkKSB7XG4gICAgICB0aGlzLiNpc0VuYWJsZWQgPSB0cnVlO1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2gobGF5ZXIuZW5hYmxlKCkpO1xuICAgICAgfVxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgICBlZGl0b3IuZW5hYmxlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNkaXNhYmxlQWxsKCkge1xuICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICBpZiAodGhpcy4jaXNFbmFibGVkKSB7XG4gICAgICB0aGlzLiNpc0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICAgIGxheWVyLmRpc2FibGUoKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgZWRpdG9yLmRpc2FibGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0RWRpdG9ycyhwYWdlSW5kZXgpIHtcbiAgICBjb25zdCBlZGl0b3JzID0gW107XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVkaXRvci5wYWdlSW5kZXggPT09IHBhZ2VJbmRleCkge1xuICAgICAgICBlZGl0b3JzLnB1c2goZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVkaXRvcnM7XG4gIH1cbiAgZ2V0RWRpdG9yKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsbEVkaXRvcnMuZ2V0KGlkKTtcbiAgfVxuICBhZGRFZGl0b3IoZWRpdG9yKSB7XG4gICAgdGhpcy4jYWxsRWRpdG9ycy5zZXQoZWRpdG9yLmlkLCBlZGl0b3IpO1xuICB9XG4gIHJlbW92ZUVkaXRvcihlZGl0b3IpIHtcbiAgICBpZiAoZWRpdG9yLmRpdi5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgaWYgKHRoaXMuI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmZvY3VzTWFpbkNvbnRhaW5lcigpO1xuICAgICAgICB0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICAgIHRoaXMuI2FsbEVkaXRvcnMuZGVsZXRlKGVkaXRvci5pZCk7XG4gICAgdGhpcy51bnNlbGVjdChlZGl0b3IpO1xuICAgIGlmICghZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgfHwgIXRoaXMuI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMuaGFzKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSkge1xuICAgICAgdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2U/LnJlbW92ZShlZGl0b3IuaWQpO1xuICAgIH1cbiAgfVxuICBhZGREZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKSB7XG4gICAgdGhpcy4jZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcy5hZGQoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgIHRoaXMuYWRkQ2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbihlZGl0b3IpO1xuICAgIGVkaXRvci5kZWxldGVkID0gdHJ1ZTtcbiAgfVxuICBpc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMuaGFzKGFubm90YXRpb25FbGVtZW50SWQpO1xuICB9XG4gIHJlbW92ZURlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpIHtcbiAgICB0aGlzLiNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzLmRlbGV0ZShlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgdGhpcy5yZW1vdmVDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKGVkaXRvcik7XG4gICAgZWRpdG9yLmRlbGV0ZWQgPSBmYWxzZTtcbiAgfVxuICAjYWRkRWRpdG9yVG9MYXllcihlZGl0b3IpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuI2FsbExheWVycy5nZXQoZWRpdG9yLnBhZ2VJbmRleCk7XG4gICAgaWYgKGxheWVyKSB7XG4gICAgICBsYXllci5hZGRPclJlYnVpbGQoZWRpdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRFZGl0b3IoZWRpdG9yKTtcbiAgICAgIHRoaXMuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBzZXRBY3RpdmVFZGl0b3IoZWRpdG9yKSB7XG4gICAgaWYgKHRoaXMuI2FjdGl2ZUVkaXRvciA9PT0gZWRpdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FjdGl2ZUVkaXRvciA9IGVkaXRvcjtcbiAgICBpZiAoZWRpdG9yKSB7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvci5wcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIH1cbiAgfVxuICBnZXQgI2xhc3RTZWxlY3RlZEVkaXRvcigpIHtcbiAgICBsZXQgZWQgPSBudWxsO1xuICAgIGZvciAoZWQgb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7fVxuICAgIHJldHVybiBlZDtcbiAgfVxuICB1cGRhdGVVSShlZGl0b3IpIHtcbiAgICBpZiAodGhpcy4jbGFzdFNlbGVjdGVkRWRpdG9yID09PSBlZGl0b3IpIHtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yLnByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVVJRm9yRGVmYXVsdFByb3BlcnRpZXMoZWRpdG9yVHlwZSkge1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yVHlwZS5kZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKTtcbiAgfVxuICB0b2dnbGVTZWxlY3RlZChlZGl0b3IpIHtcbiAgICBpZiAodGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmhhcyhlZGl0b3IpKSB7XG4gICAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuZGVsZXRlKGVkaXRvcik7XG4gICAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRoaXMuaGFzU2VsZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmFkZChlZGl0b3IpO1xuICAgIGVkaXRvci5zZWxlY3QoKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvci5wcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgc2V0U2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgdGhpcy4jY3VycmVudERyYXdpbmdTZXNzaW9uPy5jb21taXRPclJlbW92ZSgpO1xuICAgIGZvciAoY29uc3QgZWQgb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBpZiAoZWQgIT09IGVkaXRvcikge1xuICAgICAgICBlZC51bnNlbGVjdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuY2xlYXIoKTtcbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuYWRkKGVkaXRvcik7XG4gICAgZWRpdG9yLnNlbGVjdCgpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yLnByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRydWVcbiAgICB9KTtcbiAgfVxuICBpc1NlbGVjdGVkKGVkaXRvcikge1xuICAgIHJldHVybiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuaGFzKGVkaXRvcik7XG4gIH1cbiAgZ2V0IGZpcnN0U2VsZWN0ZWRFZGl0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG4gIH1cbiAgdW5zZWxlY3QoZWRpdG9yKSB7XG4gICAgZWRpdG9yLnVuc2VsZWN0KCk7XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmRlbGV0ZShlZGl0b3IpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0aGlzLmhhc1NlbGVjdGlvblxuICAgIH0pO1xuICB9XG4gIGdldCBoYXNTZWxlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5zaXplICE9PSAwO1xuICB9XG4gIGdldCBpc0VudGVySGFuZGxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLnNpemUgPT09IDEgJiYgdGhpcy5maXJzdFNlbGVjdGVkRWRpdG9yLmlzRW50ZXJIYW5kbGVkO1xuICB9XG4gIHVuZG8oKSB7XG4gICAgdGhpcy4jY29tbWFuZE1hbmFnZXIudW5kbygpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NvbWV0aGluZ1RvVW5kbzogdGhpcy4jY29tbWFuZE1hbmFnZXIuaGFzU29tZXRoaW5nVG9VbmRvKCksXG4gICAgICBoYXNTb21ldGhpbmdUb1JlZG86IHRydWUsXG4gICAgICBpc0VtcHR5OiB0aGlzLiNpc0VtcHR5KClcbiAgICB9KTtcbiAgICB0aGlzLl9lZGl0b3JVbmRvQmFyPy5oaWRlKCk7XG4gIH1cbiAgcmVkbygpIHtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci5yZWRvKCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0cnVlLFxuICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1JlZG8oKSxcbiAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKVxuICAgIH0pO1xuICB9XG4gIGFkZENvbW1hbmRzKHBhcmFtcykge1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmFkZChwYXJhbXMpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NvbWV0aGluZ1RvVW5kbzogdHJ1ZSxcbiAgICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogZmFsc2UsXG4gICAgICBpc0VtcHR5OiB0aGlzLiNpc0VtcHR5KClcbiAgICB9KTtcbiAgfVxuICBjbGVhblVuZG9TdGFjayh0eXBlKSB7XG4gICAgdGhpcy4jY29tbWFuZE1hbmFnZXIuY2xlYW5UeXBlKHR5cGUpO1xuICB9XG4gICNpc0VtcHR5KCkge1xuICAgIGlmICh0aGlzLiNhbGxFZGl0b3JzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5zaXplID09PSAxKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICAgIHJldHVybiBlZGl0b3IuaXNFbXB0eSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZGVsZXRlKCkge1xuICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICBjb25zdCBkcmF3aW5nRWRpdG9yID0gdGhpcy5jdXJyZW50TGF5ZXI/LmVuZERyYXdpbmdTZXNzaW9uKHRydWUpO1xuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24gJiYgIWRyYXdpbmdFZGl0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9ycyA9IGRyYXdpbmdFZGl0b3IgPyBbZHJhd2luZ0VkaXRvcl0gOiBbLi4udGhpcy4jc2VsZWN0ZWRFZGl0b3JzXTtcbiAgICBjb25zdCBjbWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9lZGl0b3JVbmRvQmFyPy5zaG93KHVuZG8sIGVkaXRvcnMubGVuZ3RoID09PSAxID8gZWRpdG9yc1swXS5lZGl0b3JUeXBlIDogZWRpdG9ycy5sZW5ndGgpO1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB1bmRvID0gKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgICB0aGlzLiNhZGRFZGl0b3JUb0xheWVyKGVkaXRvcik7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZCxcbiAgICAgIHVuZG8sXG4gICAgICBtdXN0RXhlYzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGNvbW1pdE9yUmVtb3ZlKCkge1xuICAgIHRoaXMuI2FjdGl2ZUVkaXRvcj8uY29tbWl0T3JSZW1vdmUoKTtcbiAgfVxuICBoYXNTb21ldGhpbmdUb0NvbnRyb2woKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FjdGl2ZUVkaXRvciB8fCB0aGlzLmhhc1NlbGVjdGlvbjtcbiAgfVxuICAjc2VsZWN0RWRpdG9ycyhlZGl0b3JzKSB7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgaWYgKGVkaXRvci5pc0VtcHR5KCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuYWRkKGVkaXRvcik7XG4gICAgICBlZGl0b3Iuc2VsZWN0KCk7XG4gICAgfVxuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0aGlzLmhhc1NlbGVjdGlvblxuICAgIH0pO1xuICB9XG4gIHNlbGVjdEFsbCgpIHtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci5jb21taXQoKTtcbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0RWRpdG9ycyh0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKTtcbiAgfVxuICB1bnNlbGVjdEFsbCgpIHtcbiAgICBpZiAodGhpcy4jYWN0aXZlRWRpdG9yKSB7XG4gICAgICB0aGlzLiNhY3RpdmVFZGl0b3IuY29tbWl0T3JSZW1vdmUoKTtcbiAgICAgIGlmICh0aGlzLiNtb2RlICE9PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuI2N1cnJlbnREcmF3aW5nU2Vzc2lvbj8uY29tbWl0T3JSZW1vdmUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgZWRpdG9yLnVuc2VsZWN0KCk7XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIHRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycyh4LCB5LCBub0NvbW1pdCA9IGZhbHNlKSB7XG4gICAgaWYgKCFub0NvbW1pdCkge1xuICAgICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3RyYW5zbGF0aW9uWzBdICs9IHg7XG4gICAgdGhpcy4jdHJhbnNsYXRpb25bMV0gKz0geTtcbiAgICBjb25zdCBbdG90YWxYLCB0b3RhbFldID0gdGhpcy4jdHJhbnNsYXRpb247XG4gICAgY29uc3QgZWRpdG9ycyA9IFsuLi50aGlzLiNzZWxlY3RlZEVkaXRvcnNdO1xuICAgIGNvbnN0IFRJTUVfVE9fV0FJVCA9IDEwMDA7XG4gICAgaWYgKHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQpO1xuICAgIH1cbiAgICB0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQgPSBudWxsO1xuICAgICAgdGhpcy4jdHJhbnNsYXRpb25bMF0gPSB0aGlzLiN0cmFuc2xhdGlvblsxXSA9IDA7XG4gICAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgICAgICAgICAgZWRpdG9yLnRyYW5zbGF0ZUluUGFnZSh0b3RhbFgsIHRvdGFsWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgICAgICAgICAgZWRpdG9yLnRyYW5zbGF0ZUluUGFnZSgtdG90YWxYLCAtdG90YWxZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG11c3RFeGVjOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSwgVElNRV9UT19XQUlUKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICBlZGl0b3IudHJhbnNsYXRlSW5QYWdlKHgsIHkpO1xuICAgIH1cbiAgfVxuICBzZXRVcERyYWdTZXNzaW9uKCkge1xuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kaXNhYmxlVXNlclNlbGVjdCh0cnVlKTtcbiAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMuc2V0KGVkaXRvciwge1xuICAgICAgICBzYXZlZFg6IGVkaXRvci54LFxuICAgICAgICBzYXZlZFk6IGVkaXRvci55LFxuICAgICAgICBzYXZlZFBhZ2VJbmRleDogZWRpdG9yLnBhZ2VJbmRleCxcbiAgICAgICAgbmV3WDogMCxcbiAgICAgICAgbmV3WTogMCxcbiAgICAgICAgbmV3UGFnZUluZGV4OiAtMVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGVuZERyYWdTZXNzaW9uKCkge1xuICAgIGlmICghdGhpcy4jZHJhZ2dpbmdFZGl0b3JzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QoZmFsc2UpO1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuI2RyYWdnaW5nRWRpdG9ycztcbiAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMgPSBudWxsO1xuICAgIGxldCBtdXN0QmVBZGRlZEluVW5kb1N0YWNrID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBbe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBwYWdlSW5kZXhcbiAgICB9LCB2YWx1ZV0gb2YgbWFwKSB7XG4gICAgICB2YWx1ZS5uZXdYID0geDtcbiAgICAgIHZhbHVlLm5ld1kgPSB5O1xuICAgICAgdmFsdWUubmV3UGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgICAgbXVzdEJlQWRkZWRJblVuZG9TdGFjayB8fD0geCAhPT0gdmFsdWUuc2F2ZWRYIHx8IHkgIT09IHZhbHVlLnNhdmVkWSB8fCBwYWdlSW5kZXggIT09IHZhbHVlLnNhdmVkUGFnZUluZGV4O1xuICAgIH1cbiAgICBpZiAoIW11c3RCZUFkZGVkSW5VbmRvU3RhY2spIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbW92ZSA9IChlZGl0b3IsIHgsIHksIHBhZ2VJbmRleCkgPT4ge1xuICAgICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy4jYWxsTGF5ZXJzLmdldChwYWdlSW5kZXgpO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgZWRpdG9yLl9zZXRQYXJlbnRBbmRQb3NpdGlvbihwYXJlbnQsIHgsIHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkaXRvci5wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgICAgICAgZWRpdG9yLnggPSB4O1xuICAgICAgICAgIGVkaXRvci55ID0geTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBbZWRpdG9yLCB7XG4gICAgICAgICAgbmV3WCxcbiAgICAgICAgICBuZXdZLFxuICAgICAgICAgIG5ld1BhZ2VJbmRleFxuICAgICAgICB9XSBvZiBtYXApIHtcbiAgICAgICAgICBtb3ZlKGVkaXRvciwgbmV3WCwgbmV3WSwgbmV3UGFnZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBbZWRpdG9yLCB7XG4gICAgICAgICAgc2F2ZWRYLFxuICAgICAgICAgIHNhdmVkWSxcbiAgICAgICAgICBzYXZlZFBhZ2VJbmRleFxuICAgICAgICB9XSBvZiBtYXApIHtcbiAgICAgICAgICBtb3ZlKGVkaXRvciwgc2F2ZWRYLCBzYXZlZFksIHNhdmVkUGFnZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZHJhZ1NlbGVjdGVkRWRpdG9ycyh0eCwgdHkpIHtcbiAgICBpZiAoIXRoaXMuI2RyYWdnaW5nRWRpdG9ycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMua2V5cygpKSB7XG4gICAgICBlZGl0b3IuZHJhZyh0eCwgdHkpO1xuICAgIH1cbiAgfVxuICByZWJ1aWxkKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IucGFyZW50ID09PSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldExheWVyKGVkaXRvci5wYWdlSW5kZXgpO1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuY2hhbmdlUGFyZW50KGVkaXRvcik7XG4gICAgICAgIHBhcmVudC5hZGRPclJlYnVpbGQoZWRpdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkRWRpdG9yKGVkaXRvcik7XG4gICAgICAgIHRoaXMuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShlZGl0b3IpO1xuICAgICAgICBlZGl0b3IucmVidWlsZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlZGl0b3IucGFyZW50LmFkZE9yUmVidWlsZChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBnZXQgaXNFZGl0b3JIYW5kbGluZ0tleWJvYXJkKCkge1xuICAgIHJldHVybiB0aGlzLmdldEFjdGl2ZSgpPy5zaG91bGRHZXRLZXlib2FyZEV2ZW50cygpIHx8IHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5zaXplID09PSAxICYmIHRoaXMuZmlyc3RTZWxlY3RlZEVkaXRvci5zaG91bGRHZXRLZXlib2FyZEV2ZW50cygpO1xuICB9XG4gIGlzQWN0aXZlKGVkaXRvcikge1xuICAgIHJldHVybiB0aGlzLiNhY3RpdmVFZGl0b3IgPT09IGVkaXRvcjtcbiAgfVxuICBnZXRBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FjdGl2ZUVkaXRvcjtcbiAgfVxuICBnZXRNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLiNtb2RlO1xuICB9XG4gIGdldCBpbWFnZU1hbmFnZXIoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImltYWdlTWFuYWdlclwiLCBuZXcgSW1hZ2VNYW5hZ2VyKCkpO1xuICB9XG4gIGdldFNlbGVjdGlvbkJveGVzKHRleHRMYXllcikge1xuICAgIGlmICghdGV4dExheWVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc2VsZWN0aW9uLnJhbmdlQ291bnQ7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBpZiAoIXRleHRMYXllci5jb250YWlucyhzZWxlY3Rpb24uZ2V0UmFuZ2VBdChpKS5jb21tb25BbmNlc3RvckNvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHg6IGxheWVyWCxcbiAgICAgIHk6IGxheWVyWSxcbiAgICAgIHdpZHRoOiBwYXJlbnRXaWR0aCxcbiAgICAgIGhlaWdodDogcGFyZW50SGVpZ2h0XG4gICAgfSA9IHRleHRMYXllci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgcm90YXRvcjtcbiAgICBzd2l0Y2ggKHRleHRMYXllci5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1haW4tcm90YXRpb25cIikpIHtcbiAgICAgIGNhc2UgXCI5MFwiOlxuICAgICAgICByb3RhdG9yID0gKHgsIHksIHcsIGgpID0+ICh7XG4gICAgICAgICAgeDogKHkgLSBsYXllclkpIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIHk6IDEgLSAoeCArIHcgLSBsYXllclgpIC8gcGFyZW50V2lkdGgsXG4gICAgICAgICAgd2lkdGg6IGggLyBwYXJlbnRIZWlnaHQsXG4gICAgICAgICAgaGVpZ2h0OiB3IC8gcGFyZW50V2lkdGhcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIjE4MFwiOlxuICAgICAgICByb3RhdG9yID0gKHgsIHksIHcsIGgpID0+ICh7XG4gICAgICAgICAgeDogMSAtICh4ICsgdyAtIGxheWVyWCkgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICB5OiAxIC0gKHkgKyBoIC0gbGF5ZXJZKSAvIHBhcmVudEhlaWdodCxcbiAgICAgICAgICB3aWR0aDogdyAvIHBhcmVudFdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaCAvIHBhcmVudEhlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiMjcwXCI6XG4gICAgICAgIHJvdGF0b3IgPSAoeCwgeSwgdywgaCkgPT4gKHtcbiAgICAgICAgICB4OiAxIC0gKHkgKyBoIC0gbGF5ZXJZKSAvIHBhcmVudEhlaWdodCxcbiAgICAgICAgICB5OiAoeCAtIGxheWVyWCkgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICB3aWR0aDogaCAvIHBhcmVudEhlaWdodCxcbiAgICAgICAgICBoZWlnaHQ6IHcgLyBwYXJlbnRXaWR0aFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByb3RhdG9yID0gKHgsIHksIHcsIGgpID0+ICh7XG4gICAgICAgICAgeDogKHggLSBsYXllclgpIC8gcGFyZW50V2lkdGgsXG4gICAgICAgICAgeTogKHkgLSBsYXllclkpIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiB3IC8gcGFyZW50V2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoIC8gcGFyZW50SGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgYm94ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzZWxlY3Rpb24ucmFuZ2VDb3VudDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoaSk7XG4gICAgICBpZiAocmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gb2YgcmFuZ2UuZ2V0Q2xpZW50UmVjdHMoKSkge1xuICAgICAgICBpZiAod2lkdGggPT09IDAgfHwgaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYm94ZXMucHVzaChyb3RhdG9yKHgsIHksIHdpZHRoLCBoZWlnaHQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJveGVzLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBib3hlcztcbiAgfVxuICBhZGRDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKHtcbiAgICBhbm5vdGF0aW9uRWxlbWVudElkLFxuICAgIGlkXG4gIH0pIHtcbiAgICAodGhpcy4jY2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbnMgfHw9IG5ldyBNYXAoKSkuc2V0KGFubm90YXRpb25FbGVtZW50SWQsIGlkKTtcbiAgfVxuICByZW1vdmVDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKHtcbiAgICBhbm5vdGF0aW9uRWxlbWVudElkXG4gIH0pIHtcbiAgICB0aGlzLiNjaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9ucz8uZGVsZXRlKGFubm90YXRpb25FbGVtZW50SWQpO1xuICB9XG4gIHJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBjb25zdCBlZGl0b3JJZCA9IHRoaXMuI2NoYW5nZWRFeGlzdGluZ0Fubm90YXRpb25zPy5nZXQoYW5ub3RhdGlvbi5kYXRhLmlkKTtcbiAgICBpZiAoIWVkaXRvcklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI2Fubm90YXRpb25TdG9yYWdlLmdldFJhd1ZhbHVlKGVkaXRvcklkKTtcbiAgICBpZiAoIWVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSAmJiAhZWRpdG9yLmhhc0JlZW5Nb2RpZmllZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZGl0b3IucmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbik7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2FsdF90ZXh0LmpzXG5cbmNsYXNzIEFsdFRleHQge1xuICAjYWx0VGV4dCA9IG51bGw7XG4gICNhbHRUZXh0RGVjb3JhdGl2ZSA9IGZhbHNlO1xuICAjYWx0VGV4dEJ1dHRvbiA9IG51bGw7XG4gICNhbHRUZXh0QnV0dG9uTGFiZWwgPSBudWxsO1xuICAjYWx0VGV4dFRvb2x0aXAgPSBudWxsO1xuICAjYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgI2FsdFRleHRXYXNGcm9tS2V5Qm9hcmQgPSBmYWxzZTtcbiAgI2JhZGdlID0gbnVsbDtcbiAgI2VkaXRvciA9IG51bGw7XG4gICNndWVzc2VkVGV4dCA9IG51bGw7XG4gICN0ZXh0V2l0aERpc2NsYWltZXIgPSBudWxsO1xuICAjdXNlTmV3QWx0VGV4dEZsb3cgPSBmYWxzZTtcbiAgc3RhdGljICNsMTBuTmV3QnV0dG9uID0gbnVsbDtcbiAgc3RhdGljIF9sMTBuID0gbnVsbDtcbiAgY29uc3RydWN0b3IoZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9yID0gZWRpdG9yO1xuICAgIHRoaXMuI3VzZU5ld0FsdFRleHRGbG93ID0gZWRpdG9yLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dEZsb3c7XG4gICAgQWx0VGV4dC4jbDEwbk5ld0J1dHRvbiB8fD0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBhZGRlZDogXCJwZGZqcy1lZGl0b3ItbmV3LWFsdC10ZXh0LWFkZGVkLWJ1dHRvblwiLFxuICAgICAgXCJhZGRlZC1sYWJlbFwiOiBcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtYWRkZWQtYnV0dG9uLWxhYmVsXCIsXG4gICAgICBtaXNzaW5nOiBcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtbWlzc2luZy1idXR0b25cIixcbiAgICAgIFwibWlzc2luZy1sYWJlbFwiOiBcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtbWlzc2luZy1idXR0b24tbGFiZWxcIixcbiAgICAgIHJldmlldzogXCJwZGZqcy1lZGl0b3ItbmV3LWFsdC10ZXh0LXRvLXJldmlldy1idXR0b25cIixcbiAgICAgIFwicmV2aWV3LWxhYmVsXCI6IFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC10by1yZXZpZXctYnV0dG9uLWxhYmVsXCJcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuKSB7XG4gICAgQWx0VGV4dC5fbDEwbiA/Pz0gbDEwbjtcbiAgfVxuICBhc3luYyByZW5kZXIoKSB7XG4gICAgY29uc3QgYWx0VGV4dCA9IHRoaXMuI2FsdFRleHRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGFsdFRleHQuY2xhc3NOYW1lID0gXCJhbHRUZXh0XCI7XG4gICAgYWx0VGV4dC50YWJJbmRleCA9IFwiMFwiO1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy4jYWx0VGV4dEJ1dHRvbkxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgYWx0VGV4dC5hcHBlbmQobGFiZWwpO1xuICAgIGlmICh0aGlzLiN1c2VOZXdBbHRUZXh0Rmxvdykge1xuICAgICAgYWx0VGV4dC5jbGFzc0xpc3QuYWRkKFwibmV3XCIpO1xuICAgICAgYWx0VGV4dC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQWx0VGV4dC4jbDEwbk5ld0J1dHRvbi5taXNzaW5nKTtcbiAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBBbHRUZXh0LiNsMTBuTmV3QnV0dG9uW1wibWlzc2luZy1sYWJlbFwiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsdFRleHQuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZWRpdG9yLWFsdC10ZXh0LWJ1dHRvblwiKTtcbiAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWVkaXRvci1hbHQtdGV4dC1idXR0b24tbGFiZWxcIik7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgYWx0VGV4dC5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgYWx0VGV4dC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgZXZlbnQgPT4gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IG9uQ2xpY2sgPSBldmVudCA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuZWRpdEFsdFRleHQodGhpcy4jZWRpdG9yKTtcbiAgICAgIGlmICh0aGlzLiN1c2VOZXdBbHRUZXh0Rmxvdykge1xuICAgICAgICB0aGlzLiNlZGl0b3IuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICAgICAgYWN0aW9uOiBcInBkZmpzLmltYWdlLmFsdF90ZXh0LmltYWdlX3N0YXR1c19sYWJlbF9jbGlja2VkXCIsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgbGFiZWw6IHRoaXMuI2xhYmVsXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGFsdFRleHQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9uQ2xpY2ssIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBhbHRUZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC50YXJnZXQgPT09IGFsdFRleHQgJiYgZXZlbnQua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFdhc0Zyb21LZXlCb2FyZCA9IHRydWU7XG4gICAgICAgIG9uQ2xpY2soZXZlbnQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGF3YWl0IHRoaXMuI3NldFN0YXRlKCk7XG4gICAgcmV0dXJuIGFsdFRleHQ7XG4gIH1cbiAgZ2V0ICNsYWJlbCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWx0VGV4dCAmJiBcImFkZGVkXCIgfHwgdGhpcy4jYWx0VGV4dCA9PT0gbnVsbCAmJiB0aGlzLmd1ZXNzZWRUZXh0ICYmIFwicmV2aWV3XCIgfHwgXCJtaXNzaW5nXCI7XG4gIH1cbiAgZmluaXNoKCkge1xuICAgIGlmICghdGhpcy4jYWx0VGV4dEJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhbHRUZXh0QnV0dG9uLmZvY3VzKHtcbiAgICAgIGZvY3VzVmlzaWJsZTogdGhpcy4jYWx0VGV4dFdhc0Zyb21LZXlCb2FyZFxuICAgIH0pO1xuICAgIHRoaXMuI2FsdFRleHRXYXNGcm9tS2V5Qm9hcmQgPSBmYWxzZTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIGlmICh0aGlzLiN1c2VOZXdBbHRUZXh0Rmxvdykge1xuICAgICAgcmV0dXJuIHRoaXMuI2FsdFRleHQgPT09IG51bGw7XG4gICAgfVxuICAgIHJldHVybiAhdGhpcy4jYWx0VGV4dCAmJiAhdGhpcy4jYWx0VGV4dERlY29yYXRpdmU7XG4gIH1cbiAgaGFzRGF0YSgpIHtcbiAgICBpZiAodGhpcy4jdXNlTmV3QWx0VGV4dEZsb3cpIHtcbiAgICAgIHJldHVybiB0aGlzLiNhbHRUZXh0ICE9PSBudWxsIHx8ICEhdGhpcy4jZ3Vlc3NlZFRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlzRW1wdHkoKTtcbiAgfVxuICBnZXQgZ3Vlc3NlZFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2d1ZXNzZWRUZXh0O1xuICB9XG4gIGFzeW5jIHNldEd1ZXNzZWRUZXh0KGd1ZXNzZWRUZXh0KSB7XG4gICAgaWYgKHRoaXMuI2FsdFRleHQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZ3Vlc3NlZFRleHQgPSBndWVzc2VkVGV4dDtcbiAgICB0aGlzLiN0ZXh0V2l0aERpc2NsYWltZXIgPSBhd2FpdCBBbHRUZXh0Ll9sMTBuLmdldChcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtZ2VuZXJhdGVkLWFsdC10ZXh0LXdpdGgtZGlzY2xhaW1lclwiLCB7XG4gICAgICBnZW5lcmF0ZWRBbHRUZXh0OiBndWVzc2VkVGV4dFxuICAgIH0pO1xuICAgIHRoaXMuI3NldFN0YXRlKCk7XG4gIH1cbiAgdG9nZ2xlQWx0VGV4dEJhZGdlKHZpc2liaWxpdHkgPSBmYWxzZSkge1xuICAgIGlmICghdGhpcy4jdXNlTmV3QWx0VGV4dEZsb3cgfHwgdGhpcy4jYWx0VGV4dCkge1xuICAgICAgdGhpcy4jYmFkZ2U/LnJlbW92ZSgpO1xuICAgICAgdGhpcy4jYmFkZ2UgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2JhZGdlKSB7XG4gICAgICBjb25zdCBiYWRnZSA9IHRoaXMuI2JhZGdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGJhZGdlLmNsYXNzTmFtZSA9IFwibm9BbHRUZXh0QmFkZ2VcIjtcbiAgICAgIHRoaXMuI2VkaXRvci5kaXYuYXBwZW5kKGJhZGdlKTtcbiAgICB9XG4gICAgdGhpcy4jYmFkZ2UuY2xhc3NMaXN0LnRvZ2dsZShcImhpZGRlblwiLCAhdmlzaWJpbGl0eSk7XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZykge1xuICAgIGxldCBhbHRUZXh0ID0gdGhpcy4jYWx0VGV4dDtcbiAgICBpZiAoIWlzRm9yQ29weWluZyAmJiB0aGlzLiNndWVzc2VkVGV4dCA9PT0gYWx0VGV4dCkge1xuICAgICAgYWx0VGV4dCA9IHRoaXMuI3RleHRXaXRoRGlzY2xhaW1lcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGFsdFRleHQsXG4gICAgICBkZWNvcmF0aXZlOiB0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSxcbiAgICAgIGd1ZXNzZWRUZXh0OiB0aGlzLiNndWVzc2VkVGV4dCxcbiAgICAgIHRleHRXaXRoRGlzY2xhaW1lcjogdGhpcy4jdGV4dFdpdGhEaXNjbGFpbWVyXG4gICAgfTtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWx0VGV4dDogdGhpcy4jYWx0VGV4dCxcbiAgICAgIGRlY29yYXRpdmU6IHRoaXMuI2FsdFRleHREZWNvcmF0aXZlXG4gICAgfTtcbiAgfVxuICBzZXQgZGF0YSh7XG4gICAgYWx0VGV4dCxcbiAgICBkZWNvcmF0aXZlLFxuICAgIGd1ZXNzZWRUZXh0LFxuICAgIHRleHRXaXRoRGlzY2xhaW1lcixcbiAgICBjYW5jZWwgPSBmYWxzZVxuICB9KSB7XG4gICAgaWYgKGd1ZXNzZWRUZXh0KSB7XG4gICAgICB0aGlzLiNndWVzc2VkVGV4dCA9IGd1ZXNzZWRUZXh0O1xuICAgICAgdGhpcy4jdGV4dFdpdGhEaXNjbGFpbWVyID0gdGV4dFdpdGhEaXNjbGFpbWVyO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYWx0VGV4dCA9PT0gYWx0VGV4dCAmJiB0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSA9PT0gZGVjb3JhdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNhbmNlbCkge1xuICAgICAgdGhpcy4jYWx0VGV4dCA9IGFsdFRleHQ7XG4gICAgICB0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSA9IGRlY29yYXRpdmU7XG4gICAgfVxuICAgIHRoaXMuI3NldFN0YXRlKCk7XG4gIH1cbiAgdG9nZ2xlKGVuYWJsZWQgPSBmYWxzZSkge1xuICAgIGlmICghdGhpcy4jYWx0VGV4dEJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWVuYWJsZWQgJiYgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0KTtcbiAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuI2FsdFRleHRCdXR0b24uZGlzYWJsZWQgPSAhZW5hYmxlZDtcbiAgfVxuICBzaG93bigpIHtcbiAgICB0aGlzLiNlZGl0b3IuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwicGRmanMuaW1hZ2UuYWx0X3RleHQuaW1hZ2Vfc3RhdHVzX2xhYmVsX2Rpc3BsYXllZFwiLFxuICAgICAgZGF0YToge1xuICAgICAgICBsYWJlbDogdGhpcy4jbGFiZWxcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI2FsdFRleHRCdXR0b24/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2FsdFRleHRCdXR0b24gPSBudWxsO1xuICAgIHRoaXMuI2FsdFRleHRCdXR0b25MYWJlbCA9IG51bGw7XG4gICAgdGhpcy4jYWx0VGV4dFRvb2x0aXAgPSBudWxsO1xuICAgIHRoaXMuI2JhZGdlPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNiYWRnZSA9IG51bGw7XG4gIH1cbiAgYXN5bmMgI3NldFN0YXRlKCkge1xuICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuI2FsdFRleHRCdXR0b247XG4gICAgaWYgKCFidXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3VzZU5ld0FsdFRleHRGbG93KSB7XG4gICAgICBidXR0b24uY2xhc3NMaXN0LnRvZ2dsZShcImRvbmVcIiwgISF0aGlzLiNhbHRUZXh0KTtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQWx0VGV4dC4jbDEwbk5ld0J1dHRvblt0aGlzLiNsYWJlbF0pO1xuICAgICAgdGhpcy4jYWx0VGV4dEJ1dHRvbkxhYmVsPy5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQWx0VGV4dC4jbDEwbk5ld0J1dHRvbltgJHt0aGlzLiNsYWJlbH0tbGFiZWxgXSk7XG4gICAgICBpZiAoIXRoaXMuI2FsdFRleHQpIHtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXA/LnJlbW92ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy4jYWx0VGV4dCAmJiAhdGhpcy4jYWx0VGV4dERlY29yYXRpdmUpIHtcbiAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJkb25lXCIpO1xuICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcD8ucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwiZG9uZVwiKTtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItYWx0LXRleHQtZWRpdC1idXR0b25cIik7XG4gICAgfVxuICAgIGxldCB0b29sdGlwID0gdGhpcy4jYWx0VGV4dFRvb2x0aXA7XG4gICAgaWYgKCF0b29sdGlwKSB7XG4gICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcCA9IHRvb2x0aXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHRvb2x0aXAuY2xhc3NOYW1lID0gXCJ0b29sdGlwXCI7XG4gICAgICB0b29sdGlwLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJ0b29sdGlwXCIpO1xuICAgICAgdG9vbHRpcC5pZCA9IGBhbHQtdGV4dC10b29sdGlwLSR7dGhpcy4jZWRpdG9yLmlkfWA7XG4gICAgICBjb25zdCBERUxBWV9UT19TSE9XX1RPT0xUSVAgPSAxMDA7XG4gICAgICBjb25zdCBzaWduYWwgPSB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5fc2lnbmFsO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQpO1xuICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBudWxsO1xuICAgICAgfSwge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXAuY2xhc3NMaXN0LmFkZChcInNob3dcIik7XG4gICAgICAgICAgdGhpcy4jZWRpdG9yLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgICAgICAgYWN0aW9uOiBcImFsdF90ZXh0X3Rvb2x0aXBcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBERUxBWV9UT19TSE9XX1RPT0xUSVApO1xuICAgICAgfSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQpO1xuICAgICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXA/LmNsYXNzTGlzdC5yZW1vdmUoXCJzaG93XCIpO1xuICAgICAgfSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYWx0VGV4dERlY29yYXRpdmUpIHtcbiAgICAgIHRvb2x0aXAuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZWRpdG9yLWFsdC10ZXh0LWRlY29yYXRpdmUtdG9vbHRpcFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9vbHRpcC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIik7XG4gICAgICB0b29sdGlwLnRleHRDb250ZW50ID0gdGhpcy4jYWx0VGV4dDtcbiAgICB9XG4gICAgaWYgKCF0b29sdGlwLnBhcmVudE5vZGUpIHtcbiAgICAgIGJ1dHRvbi5hcHBlbmQodG9vbHRpcCk7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLiNlZGl0b3IuZ2V0SW1hZ2VGb3JBbHRUZXh0KCk7XG4gICAgZWxlbWVudD8uc2V0QXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiLCB0b29sdGlwLmlkKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS90b3VjaF9tYW5hZ2VyLmpzXG5cblxuY2xhc3MgVG91Y2hNYW5hZ2VyIHtcbiAgI2NvbnRhaW5lcjtcbiAgI2lzUGluY2hpbmcgPSBmYWxzZTtcbiAgI2lzUGluY2hpbmdTdG9wcGVkID0gbnVsbDtcbiAgI2lzUGluY2hpbmdEaXNhYmxlZDtcbiAgI29uUGluY2hTdGFydDtcbiAgI29uUGluY2hpbmc7XG4gICNvblBpbmNoRW5kO1xuICAjc2lnbmFsO1xuICAjdG91Y2hJbmZvID0gbnVsbDtcbiAgI3RvdWNoTWFuYWdlckFDO1xuICAjdG91Y2hNb3ZlQUMgPSBudWxsO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29udGFpbmVyLFxuICAgIGlzUGluY2hpbmdEaXNhYmxlZCA9IG51bGwsXG4gICAgaXNQaW5jaGluZ1N0b3BwZWQgPSBudWxsLFxuICAgIG9uUGluY2hTdGFydCA9IG51bGwsXG4gICAgb25QaW5jaGluZyA9IG51bGwsXG4gICAgb25QaW5jaEVuZCA9IG51bGwsXG4gICAgc2lnbmFsXG4gIH0pIHtcbiAgICB0aGlzLiNjb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy4jaXNQaW5jaGluZ1N0b3BwZWQgPSBpc1BpbmNoaW5nU3RvcHBlZDtcbiAgICB0aGlzLiNpc1BpbmNoaW5nRGlzYWJsZWQgPSBpc1BpbmNoaW5nRGlzYWJsZWQ7XG4gICAgdGhpcy4jb25QaW5jaFN0YXJ0ID0gb25QaW5jaFN0YXJ0O1xuICAgIHRoaXMuI29uUGluY2hpbmcgPSBvblBpbmNoaW5nO1xuICAgIHRoaXMuI29uUGluY2hFbmQgPSBvblBpbmNoRW5kO1xuICAgIHRoaXMuI3RvdWNoTWFuYWdlckFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHRoaXMuI3NpZ25hbCA9IEFib3J0U2lnbmFsLmFueShbc2lnbmFsLCB0aGlzLiN0b3VjaE1hbmFnZXJBQy5zaWduYWxdKTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy4jb25Ub3VjaFN0YXJ0LmJpbmQodGhpcyksIHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgc2lnbmFsOiB0aGlzLiNzaWduYWxcbiAgICB9KTtcbiAgfVxuICBnZXQgTUlOX1RPVUNIX0RJU1RBTkNFX1RPX1BJTkNIKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJNSU5fVE9VQ0hfRElTVEFOQ0VfVE9fUElOQ0hcIiwgMzUgLyAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkpO1xuICB9XG4gICNvblRvdWNoU3RhcnQoZXZ0KSB7XG4gICAgaWYgKHRoaXMuI2lzUGluY2hpbmdEaXNhYmxlZD8uKCkgfHwgZXZ0LnRvdWNoZXMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI3RvdWNoTW92ZUFDKSB7XG4gICAgICB0aGlzLiN0b3VjaE1vdmVBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IEFib3J0U2lnbmFsLmFueShbdGhpcy4jc2lnbmFsLCB0aGlzLiN0b3VjaE1vdmVBQy5zaWduYWxdKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuI2NvbnRhaW5lcjtcbiAgICAgIGNvbnN0IG9wdCA9IHtcbiAgICAgICAgc2lnbmFsLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuI29uVG91Y2hNb3ZlLmJpbmQodGhpcyksIG9wdCk7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuI29uVG91Y2hFbmQuYmluZCh0aGlzKSwgb3B0KTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgdGhpcy4jb25Ub3VjaEVuZC5iaW5kKHRoaXMpLCBvcHQpO1xuICAgICAgdGhpcy4jb25QaW5jaFN0YXJ0Py4oKTtcbiAgICB9XG4gICAgc3RvcEV2ZW50KGV2dCk7XG4gICAgaWYgKGV2dC50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCB0aGlzLiNpc1BpbmNoaW5nU3RvcHBlZD8uKCkpIHtcbiAgICAgIHRoaXMuI3RvdWNoSW5mbyA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBbdG91Y2gwLCB0b3VjaDFdID0gZXZ0LnRvdWNoZXM7XG4gICAgaWYgKHRvdWNoMC5pZGVudGlmaWVyID4gdG91Y2gxLmlkZW50aWZpZXIpIHtcbiAgICAgIFt0b3VjaDAsIHRvdWNoMV0gPSBbdG91Y2gxLCB0b3VjaDBdO1xuICAgIH1cbiAgICB0aGlzLiN0b3VjaEluZm8gPSB7XG4gICAgICB0b3VjaDBYOiB0b3VjaDAuc2NyZWVuWCxcbiAgICAgIHRvdWNoMFk6IHRvdWNoMC5zY3JlZW5ZLFxuICAgICAgdG91Y2gxWDogdG91Y2gxLnNjcmVlblgsXG4gICAgICB0b3VjaDFZOiB0b3VjaDEuc2NyZWVuWVxuICAgIH07XG4gIH1cbiAgI29uVG91Y2hNb3ZlKGV2dCkge1xuICAgIGlmICghdGhpcy4jdG91Y2hJbmZvIHx8IGV2dC50b3VjaGVzLmxlbmd0aCAhPT0gMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgW3RvdWNoMCwgdG91Y2gxXSA9IGV2dC50b3VjaGVzO1xuICAgIGlmICh0b3VjaDAuaWRlbnRpZmllciA+IHRvdWNoMS5pZGVudGlmaWVyKSB7XG4gICAgICBbdG91Y2gwLCB0b3VjaDFdID0gW3RvdWNoMSwgdG91Y2gwXTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc2NyZWVuWDogc2NyZWVuMFgsXG4gICAgICBzY3JlZW5ZOiBzY3JlZW4wWVxuICAgIH0gPSB0b3VjaDA7XG4gICAgY29uc3Qge1xuICAgICAgc2NyZWVuWDogc2NyZWVuMVgsXG4gICAgICBzY3JlZW5ZOiBzY3JlZW4xWVxuICAgIH0gPSB0b3VjaDE7XG4gICAgY29uc3QgdG91Y2hJbmZvID0gdGhpcy4jdG91Y2hJbmZvO1xuICAgIGNvbnN0IHtcbiAgICAgIHRvdWNoMFg6IHBUb3VjaDBYLFxuICAgICAgdG91Y2gwWTogcFRvdWNoMFksXG4gICAgICB0b3VjaDFYOiBwVG91Y2gxWCxcbiAgICAgIHRvdWNoMVk6IHBUb3VjaDFZXG4gICAgfSA9IHRvdWNoSW5mbztcbiAgICBjb25zdCBwcmV2R2FwWCA9IHBUb3VjaDFYIC0gcFRvdWNoMFg7XG4gICAgY29uc3QgcHJldkdhcFkgPSBwVG91Y2gxWSAtIHBUb3VjaDBZO1xuICAgIGNvbnN0IGN1cnJHYXBYID0gc2NyZWVuMVggLSBzY3JlZW4wWDtcbiAgICBjb25zdCBjdXJyR2FwWSA9IHNjcmVlbjFZIC0gc2NyZWVuMFk7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLmh5cG90KGN1cnJHYXBYLCBjdXJyR2FwWSkgfHwgMTtcbiAgICBjb25zdCBwRGlzdGFuY2UgPSBNYXRoLmh5cG90KHByZXZHYXBYLCBwcmV2R2FwWSkgfHwgMTtcbiAgICBpZiAoIXRoaXMuI2lzUGluY2hpbmcgJiYgTWF0aC5hYnMocERpc3RhbmNlIC0gZGlzdGFuY2UpIDw9IFRvdWNoTWFuYWdlci5NSU5fVE9VQ0hfRElTVEFOQ0VfVE9fUElOQ0gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdG91Y2hJbmZvLnRvdWNoMFggPSBzY3JlZW4wWDtcbiAgICB0b3VjaEluZm8udG91Y2gwWSA9IHNjcmVlbjBZO1xuICAgIHRvdWNoSW5mby50b3VjaDFYID0gc2NyZWVuMVg7XG4gICAgdG91Y2hJbmZvLnRvdWNoMVkgPSBzY3JlZW4xWTtcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoIXRoaXMuI2lzUGluY2hpbmcpIHtcbiAgICAgIHRoaXMuI2lzUGluY2hpbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvcmlnaW4gPSBbKHNjcmVlbjBYICsgc2NyZWVuMVgpIC8gMiwgKHNjcmVlbjBZICsgc2NyZWVuMVkpIC8gMl07XG4gICAgdGhpcy4jb25QaW5jaGluZz8uKG9yaWdpbiwgcERpc3RhbmNlLCBkaXN0YW5jZSk7XG4gIH1cbiAgI29uVG91Y2hFbmQoZXZ0KSB7XG4gICAgdGhpcy4jdG91Y2hNb3ZlQUMuYWJvcnQoKTtcbiAgICB0aGlzLiN0b3VjaE1vdmVBQyA9IG51bGw7XG4gICAgdGhpcy4jb25QaW5jaEVuZD8uKCk7XG4gICAgaWYgKCF0aGlzLiN0b3VjaEluZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy4jdG91Y2hJbmZvID0gbnVsbDtcbiAgICB0aGlzLiNpc1BpbmNoaW5nID0gZmFsc2U7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiN0b3VjaE1hbmFnZXJBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiN0b3VjaE1hbmFnZXJBQyA9IG51bGw7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2VkaXRvci5qc1xuXG5cblxuXG5cblxuY2xhc3MgQW5ub3RhdGlvbkVkaXRvciB7XG4gICNhY2Nlc3NpYmlsaXR5RGF0YSA9IG51bGw7XG4gICNhbGxSZXNpemVyRGl2cyA9IG51bGw7XG4gICNhbHRUZXh0ID0gbnVsbDtcbiAgI2Rpc2FibGVkID0gZmFsc2U7XG4gICNkcmFnUG9pbnRlcklkID0gbnVsbDtcbiAgI2RyYWdQb2ludGVyVHlwZSA9IFwiXCI7XG4gICNrZWVwQXNwZWN0UmF0aW8gPSBmYWxzZTtcbiAgI3Jlc2l6ZXJzRGl2ID0gbnVsbDtcbiAgI2xhc3RQb2ludGVyQ29vcmRzID0gbnVsbDtcbiAgI3NhdmVkRGltZW5zaW9ucyA9IG51bGw7XG4gICNmb2N1c0FDID0gbnVsbDtcbiAgI2ZvY3VzZWRSZXNpemVyTmFtZSA9IFwiXCI7XG4gICNoYXNCZWVuQ2xpY2tlZCA9IGZhbHNlO1xuICAjaW5pdGlhbFJlY3QgPSBudWxsO1xuICAjaXNFZGl0aW5nID0gZmFsc2U7XG4gICNpc0luRWRpdE1vZGUgPSBmYWxzZTtcbiAgI2lzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZCA9IGZhbHNlO1xuICAjbW92ZUluRE9NVGltZW91dCA9IG51bGw7XG4gICNwcmV2RHJhZ1ggPSAwO1xuICAjcHJldkRyYWdZID0gMDtcbiAgI3RlbGVtZXRyeVRpbWVvdXRzID0gbnVsbDtcbiAgI3RvdWNoTWFuYWdlciA9IG51bGw7XG4gIF9lZGl0VG9vbGJhciA9IG51bGw7XG4gIF9pbml0aWFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIF9pbml0aWFsRGF0YSA9IG51bGw7XG4gIF9pc1Zpc2libGUgPSB0cnVlO1xuICBfdWlNYW5hZ2VyID0gbnVsbDtcbiAgX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gIHN0YXRpYyBfbDEwbiA9IG51bGw7XG4gIHN0YXRpYyBfbDEwblJlc2l6ZXIgPSBudWxsO1xuICAjaXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgI3pJbmRleCA9IEFubm90YXRpb25FZGl0b3IuX3pJbmRleCsrO1xuICBzdGF0aWMgX2JvcmRlckxpbmVXaWR0aCA9IC0xO1xuICBzdGF0aWMgX2NvbG9yTWFuYWdlciA9IG5ldyBDb2xvck1hbmFnZXIoKTtcbiAgc3RhdGljIF96SW5kZXggPSAxO1xuICBzdGF0aWMgX3RlbGVtZXRyeVRpbWVvdXQgPSAxMDAwO1xuICBzdGF0aWMgZ2V0IF9yZXNpemVyS2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHJlc2l6ZSA9IEFubm90YXRpb25FZGl0b3IucHJvdG90eXBlLl9yZXNpemVXaXRoS2V5Ym9hcmQ7XG4gICAgY29uc3Qgc21hbGwgPSBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLlRSQU5TTEFURV9TTUFMTDtcbiAgICBjb25zdCBiaWcgPSBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLlRSQU5TTEFURV9CSUc7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9yZXNpemVyS2V5Ym9hcmRNYW5hZ2VyXCIsIG5ldyBLZXlib2FyZE1hbmFnZXIoW1tbXCJBcnJvd0xlZnRcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFstc21hbGwsIDBdXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93TGVmdFwiLCBcIm1hYytzaGlmdCtBcnJvd0xlZnRcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogWy1iaWcsIDBdXG4gICAgfV0sIFtbXCJBcnJvd1JpZ2h0XCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogW3NtYWxsLCAwXVxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1JpZ2h0XCIsIFwibWFjK3NoaWZ0K0Fycm93UmlnaHRcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogW2JpZywgMF1cbiAgICB9XSwgW1tcIkFycm93VXBcIiwgXCJtYWMrQXJyb3dVcFwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbMCwgLXNtYWxsXVxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1VwXCIsIFwibWFjK3NoaWZ0K0Fycm93VXBcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogWzAsIC1iaWddXG4gICAgfV0sIFtbXCJBcnJvd0Rvd25cIiwgXCJtYWMrQXJyb3dEb3duXCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFswLCBzbWFsbF1cbiAgICB9XSwgW1tcImN0cmwrQXJyb3dEb3duXCIsIFwibWFjK3NoaWZ0K0Fycm93RG93blwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbMCwgYmlnXVxuICAgIH1dLCBbW1wiRXNjYXBlXCIsIFwibWFjK0VzY2FwZVwiXSwgQW5ub3RhdGlvbkVkaXRvci5wcm90b3R5cGUuX3N0b3BSZXNpemluZ1dpdGhLZXlib2FyZF1dKSk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHRoaXMucGFyZW50ID0gcGFyYW1ldGVycy5wYXJlbnQ7XG4gICAgdGhpcy5pZCA9IHBhcmFtZXRlcnMuaWQ7XG4gICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gbnVsbDtcbiAgICB0aGlzLnBhZ2VJbmRleCA9IHBhcmFtZXRlcnMucGFyZW50LnBhZ2VJbmRleDtcbiAgICB0aGlzLm5hbWUgPSBwYXJhbWV0ZXJzLm5hbWU7XG4gICAgdGhpcy5kaXYgPSBudWxsO1xuICAgIHRoaXMuX3VpTWFuYWdlciA9IHBhcmFtZXRlcnMudWlNYW5hZ2VyO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IG51bGw7XG4gICAgdGhpcy5fd2lsbEtlZXBBc3BlY3RSYXRpbyA9IGZhbHNlO1xuICAgIHRoaXMuX2luaXRpYWxPcHRpb25zLmlzQ2VudGVyZWQgPSBwYXJhbWV0ZXJzLmlzQ2VudGVyZWQ7XG4gICAgdGhpcy5fc3RydWN0VHJlZVBhcmVudElkID0gbnVsbDtcbiAgICBjb25zdCB7XG4gICAgICByb3RhdGlvbixcbiAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICBwYWdlSGVpZ2h0LFxuICAgICAgICBwYWdlWCxcbiAgICAgICAgcGFnZVlcbiAgICAgIH1cbiAgICB9ID0gdGhpcy5wYXJlbnQudmlld3BvcnQ7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMucGFnZVJvdGF0aW9uID0gKDM2MCArIHJvdGF0aW9uIC0gdGhpcy5fdWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzLnJvdGF0aW9uKSAlIDM2MDtcbiAgICB0aGlzLnBhZ2VEaW1lbnNpb25zID0gW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF07XG4gICAgdGhpcy5wYWdlVHJhbnNsYXRpb24gPSBbcGFnZVgsIHBhZ2VZXTtcbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy54ID0gcGFyYW1ldGVycy54IC8gd2lkdGg7XG4gICAgdGhpcy55ID0gcGFyYW1ldGVycy55IC8gaGVpZ2h0O1xuICAgIHRoaXMuaXNBdHRhY2hlZFRvRE9NID0gZmFsc2U7XG4gICAgdGhpcy5kZWxldGVkID0gZmFsc2U7XG4gIH1cbiAgZ2V0IGVkaXRvclR5cGUoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvci5fdHlwZTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzRHJhd2VyKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgZ2V0IF9kZWZhdWx0TGluZUNvbG9yKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfZGVmYXVsdExpbmVDb2xvclwiLCB0aGlzLl9jb2xvck1hbmFnZXIuZ2V0SGV4Q29kZShcIkNhbnZhc1RleHRcIikpO1xuICB9XG4gIHN0YXRpYyBkZWxldGVBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpIHtcbiAgICBjb25zdCBmYWtlRWRpdG9yID0gbmV3IEZha2VFZGl0b3Ioe1xuICAgICAgaWQ6IGVkaXRvci5wYXJlbnQuZ2V0TmV4dElkKCksXG4gICAgICBwYXJlbnQ6IGVkaXRvci5wYXJlbnQsXG4gICAgICB1aU1hbmFnZXI6IGVkaXRvci5fdWlNYW5hZ2VyXG4gICAgfSk7XG4gICAgZmFrZUVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkID0gZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgZmFrZUVkaXRvci5kZWxldGVkID0gdHJ1ZTtcbiAgICBmYWtlRWRpdG9yLl91aU1hbmFnZXIuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShmYWtlRWRpdG9yKTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCBfdWlNYW5hZ2VyKSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5fbDEwbiA/Pz0gbDEwbjtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLl9sMTBuUmVzaXplciB8fD0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICB0b3BMZWZ0OiBcInBkZmpzLWVkaXRvci1yZXNpemVyLXRvcC1sZWZ0XCIsXG4gICAgICB0b3BNaWRkbGU6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItdG9wLW1pZGRsZVwiLFxuICAgICAgdG9wUmlnaHQ6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItdG9wLXJpZ2h0XCIsXG4gICAgICBtaWRkbGVSaWdodDogXCJwZGZqcy1lZGl0b3ItcmVzaXplci1taWRkbGUtcmlnaHRcIixcbiAgICAgIGJvdHRvbVJpZ2h0OiBcInBkZmpzLWVkaXRvci1yZXNpemVyLWJvdHRvbS1yaWdodFwiLFxuICAgICAgYm90dG9tTWlkZGxlOiBcInBkZmpzLWVkaXRvci1yZXNpemVyLWJvdHRvbS1taWRkbGVcIixcbiAgICAgIGJvdHRvbUxlZnQ6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItYm90dG9tLWxlZnRcIixcbiAgICAgIG1pZGRsZUxlZnQ6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItbWlkZGxlLWxlZnRcIlxuICAgIH0pO1xuICAgIGlmIChBbm5vdGF0aW9uRWRpdG9yLl9ib3JkZXJMaW5lV2lkdGggIT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuICAgIEFubm90YXRpb25FZGl0b3IuX2JvcmRlckxpbmVXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIi0tb3V0bGluZS13aWR0aFwiKSkgfHwgMDtcbiAgfVxuICBzdGF0aWMgdXBkYXRlRGVmYXVsdFBhcmFtcyhfdHlwZSwgX3ZhbHVlKSB7fVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHN0YXRpYyBpc0hhbmRsaW5nTWltZUZvclBhc3RpbmcobWltZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgcGFzdGUoaXRlbSwgcGFyZW50KSB7XG4gICAgdW5yZWFjaGFibGUoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgZ2V0IHByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0IF9pc0RyYWdnYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNEcmFnZ2FibGU7XG4gIH1cbiAgc2V0IF9pc0RyYWdnYWJsZSh2YWx1ZSkge1xuICAgIHRoaXMuI2lzRHJhZ2dhYmxlID0gdmFsdWU7XG4gICAgdGhpcy5kaXY/LmNsYXNzTGlzdC50b2dnbGUoXCJkcmFnZ2FibGVcIiwgdmFsdWUpO1xuICB9XG4gIGdldCBpc0VudGVySGFuZGxlZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjZW50ZXIoKSB7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnRSb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgdGhpcy54IC09IHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodCAvIChwYWdlV2lkdGggKiAyKTtcbiAgICAgICAgdGhpcy55ICs9IHRoaXMud2lkdGggKiBwYWdlV2lkdGggLyAocGFnZUhlaWdodCAqIDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICB0aGlzLnggKz0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMueSArPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHRoaXMueCArPSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQgLyAocGFnZVdpZHRoICogMik7XG4gICAgICAgIHRoaXMueSAtPSB0aGlzLndpZHRoICogcGFnZVdpZHRoIC8gKHBhZ2VIZWlnaHQgKiAyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnggLT0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMueSAtPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgYWRkQ29tbWFuZHMocGFyYW1zKSB7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmFkZENvbW1hbmRzKHBhcmFtcyk7XG4gIH1cbiAgZ2V0IGN1cnJlbnRMYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy5fdWlNYW5hZ2VyLmN1cnJlbnRMYXllcjtcbiAgfVxuICBzZXRJbkJhY2tncm91bmQoKSB7XG4gICAgdGhpcy5kaXYuc3R5bGUuekluZGV4ID0gMDtcbiAgfVxuICBzZXRJbkZvcmVncm91bmQoKSB7XG4gICAgdGhpcy5kaXYuc3R5bGUuekluZGV4ID0gdGhpcy4jekluZGV4O1xuICB9XG4gIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnBhZ2VJbmRleCA9IHBhcmVudC5wYWdlSW5kZXg7XG4gICAgICB0aGlzLnBhZ2VEaW1lbnNpb25zID0gcGFyZW50LnBhZ2VEaW1lbnNpb25zO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNzdG9wUmVzaXppbmcoKTtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIH1cbiAgZm9jdXNpbihldmVudCkge1xuICAgIGlmICghdGhpcy5fZm9jdXNFdmVudHNBbGxvd2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jaGFzQmVlbkNsaWNrZWQpIHtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNoYXNCZWVuQ2xpY2tlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb2N1c291dChldmVudCkge1xuICAgIGlmICghdGhpcy5fZm9jdXNFdmVudHNBbGxvd2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICBpZiAodGFyZ2V0Py5jbG9zZXN0KGAjJHt0aGlzLmlkfWApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKCF0aGlzLnBhcmVudD8uaXNNdWx0aXBsZVNlbGVjdGlvbikge1xuICAgICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIH1cbiAgfVxuICBjb21taXRPclJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29tbWl0KCk7XG4gICAgfVxuICB9XG4gIGNvbW1pdCgpIHtcbiAgICB0aGlzLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoKTtcbiAgfVxuICBhZGRUb0Fubm90YXRpb25TdG9yYWdlKCkge1xuICAgIHRoaXMuX3VpTWFuYWdlci5hZGRUb0Fubm90YXRpb25TdG9yYWdlKHRoaXMpO1xuICB9XG4gIHNldEF0KHgsIHksIHR4LCB0eSkge1xuICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBbdHgsIHR5XSA9IHRoaXMuc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24odHgsIHR5KTtcbiAgICB0aGlzLnggPSAoeCArIHR4KSAvIHdpZHRoO1xuICAgIHRoaXMueSA9ICh5ICsgdHkpIC8gaGVpZ2h0O1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICAjdHJhbnNsYXRlKFt3aWR0aCwgaGVpZ2h0XSwgeCwgeSkge1xuICAgIFt4LCB5XSA9IHRoaXMuc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24oeCwgeSk7XG4gICAgdGhpcy54ICs9IHggLyB3aWR0aDtcbiAgICB0aGlzLnkgKz0geSAvIGhlaWdodDtcbiAgICB0aGlzLl9vblRyYW5zbGF0aW5nKHRoaXMueCwgdGhpcy55KTtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgdHJhbnNsYXRlKHgsIHkpIHtcbiAgICB0aGlzLiN0cmFuc2xhdGUodGhpcy5wYXJlbnREaW1lbnNpb25zLCB4LCB5KTtcbiAgfVxuICB0cmFuc2xhdGVJblBhZ2UoeCwgeSkge1xuICAgIHRoaXMuI2luaXRpYWxSZWN0IHx8PSBbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XTtcbiAgICB0aGlzLiN0cmFuc2xhdGUodGhpcy5wYWdlRGltZW5zaW9ucywgeCwgeSk7XG4gICAgdGhpcy5kaXYuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgYmxvY2s6IFwibmVhcmVzdFwiXG4gICAgfSk7XG4gIH1cbiAgZHJhZyh0eCwgdHkpIHtcbiAgICB0aGlzLiNpbml0aWFsUmVjdCB8fD0gW3RoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodF07XG4gICAgY29uc3Qge1xuICAgICAgZGl2LFxuICAgICAgcGFyZW50RGltZW5zaW9uczogW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdXG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy54ICs9IHR4IC8gcGFyZW50V2lkdGg7XG4gICAgdGhpcy55ICs9IHR5IC8gcGFyZW50SGVpZ2h0O1xuICAgIGlmICh0aGlzLnBhcmVudCAmJiAodGhpcy54IDwgMCB8fCB0aGlzLnggPiAxIHx8IHRoaXMueSA8IDAgfHwgdGhpcy55ID4gMSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKHRoaXMucGFyZW50LmZpbmROZXdQYXJlbnQodGhpcywgeCwgeSkpIHtcbiAgICAgICAgdGhpcy54IC09IE1hdGguZmxvb3IodGhpcy54KTtcbiAgICAgICAgdGhpcy55IC09IE1hdGguZmxvb3IodGhpcy55KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgW2J4LCBieV0gPSB0aGlzLmdldEJhc2VUcmFuc2xhdGlvbigpO1xuICAgIHggKz0gYng7XG4gICAgeSArPSBieTtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSBkaXY7XG4gICAgc3R5bGUubGVmdCA9IGAkeygxMDAgKiB4KS50b0ZpeGVkKDIpfSVgO1xuICAgIHN0eWxlLnRvcCA9IGAkeygxMDAgKiB5KS50b0ZpeGVkKDIpfSVgO1xuICAgIHRoaXMuX29uVHJhbnNsYXRpbmcoeCwgeSk7XG4gICAgZGl2LnNjcm9sbEludG9WaWV3KHtcbiAgICAgIGJsb2NrOiBcIm5lYXJlc3RcIlxuICAgIH0pO1xuICB9XG4gIF9vblRyYW5zbGF0aW5nKHgsIHkpIHt9XG4gIF9vblRyYW5zbGF0ZWQoeCwgeSkge31cbiAgZ2V0IF9oYXNCZWVuTW92ZWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy4jaW5pdGlhbFJlY3QgJiYgKHRoaXMuI2luaXRpYWxSZWN0WzBdICE9PSB0aGlzLnggfHwgdGhpcy4jaW5pdGlhbFJlY3RbMV0gIT09IHRoaXMueSk7XG4gIH1cbiAgZ2V0IF9oYXNCZWVuUmVzaXplZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLiNpbml0aWFsUmVjdCAmJiAodGhpcy4jaW5pdGlhbFJlY3RbMl0gIT09IHRoaXMud2lkdGggfHwgdGhpcy4jaW5pdGlhbFJlY3RbM10gIT09IHRoaXMuaGVpZ2h0KTtcbiAgfVxuICBnZXRCYXNlVHJhbnNsYXRpb24oKSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGNvbnN0IHtcbiAgICAgIF9ib3JkZXJMaW5lV2lkdGhcbiAgICB9ID0gQW5ub3RhdGlvbkVkaXRvcjtcbiAgICBjb25zdCB4ID0gX2JvcmRlckxpbmVXaWR0aCAvIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IHkgPSBfYm9yZGVyTGluZVdpZHRoIC8gcGFyZW50SGVpZ2h0O1xuICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFsteCwgeV07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3gsIC15XTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbLXgsIC15XTtcbiAgICB9XG4gIH1cbiAgZ2V0IF9tdXN0Rml4UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZml4QW5kU2V0UG9zaXRpb24ocm90YXRpb24gPSB0aGlzLnJvdGF0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGl2OiB7XG4gICAgICAgIHN0eWxlXG4gICAgICB9LFxuICAgICAgcGFnZURpbWVuc2lvbnM6IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICB3aWR0aCAqPSBwYWdlV2lkdGg7XG4gICAgaGVpZ2h0ICo9IHBhZ2VIZWlnaHQ7XG4gICAgeCAqPSBwYWdlV2lkdGg7XG4gICAgeSAqPSBwYWdlSGVpZ2h0O1xuICAgIGlmICh0aGlzLl9tdXN0Rml4UG9zaXRpb24pIHtcbiAgICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihwYWdlV2lkdGggLSB3aWR0aCwgeCkpO1xuICAgICAgICAgIHkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihwYWdlSGVpZ2h0IC0gaGVpZ2h0LCB5KSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgOTA6XG4gICAgICAgICAgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2VXaWR0aCAtIGhlaWdodCwgeCkpO1xuICAgICAgICAgIHkgPSBNYXRoLm1pbihwYWdlSGVpZ2h0LCBNYXRoLm1heCh3aWR0aCwgeSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE4MDpcbiAgICAgICAgICB4ID0gTWF0aC5taW4ocGFnZVdpZHRoLCBNYXRoLm1heCh3aWR0aCwgeCkpO1xuICAgICAgICAgIHkgPSBNYXRoLm1pbihwYWdlSGVpZ2h0LCBNYXRoLm1heChoZWlnaHQsIHkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNzA6XG4gICAgICAgICAgeCA9IE1hdGgubWluKHBhZ2VXaWR0aCwgTWF0aC5tYXgoaGVpZ2h0LCB4KSk7XG4gICAgICAgICAgeSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2VIZWlnaHQgLSB3aWR0aCwgeSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnggPSB4IC89IHBhZ2VXaWR0aDtcbiAgICB0aGlzLnkgPSB5IC89IHBhZ2VIZWlnaHQ7XG4gICAgY29uc3QgW2J4LCBieV0gPSB0aGlzLmdldEJhc2VUcmFuc2xhdGlvbigpO1xuICAgIHggKz0gYng7XG4gICAgeSArPSBieTtcbiAgICBzdHlsZS5sZWZ0ID0gYCR7KDEwMCAqIHgpLnRvRml4ZWQoMil9JWA7XG4gICAgc3R5bGUudG9wID0gYCR7KDEwMCAqIHkpLnRvRml4ZWQoMil9JWA7XG4gICAgdGhpcy5tb3ZlSW5ET00oKTtcbiAgfVxuICBzdGF0aWMgI3JvdGF0ZVBvaW50KHgsIHksIGFuZ2xlKSB7XG4gICAgc3dpdGNoIChhbmdsZSkge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFt5LCAteF07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFsteCwgLXldO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbLXksIHhdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gIH1cbiAgc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24oeCwgeSkge1xuICAgIHJldHVybiBBbm5vdGF0aW9uRWRpdG9yLiNyb3RhdGVQb2ludCh4LCB5LCB0aGlzLnBhcmVudFJvdGF0aW9uKTtcbiAgfVxuICBwYWdlVHJhbnNsYXRpb25Ub1NjcmVlbih4LCB5KSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FZGl0b3IuI3JvdGF0ZVBvaW50KHgsIHksIDM2MCAtIHRoaXMucGFyZW50Um90YXRpb24pO1xuICB9XG4gICNnZXRSb3RhdGlvbk1hdHJpeChyb3RhdGlvbikge1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgICAgICAgcmV0dXJuIFswLCAtcGFnZVdpZHRoIC8gcGFnZUhlaWdodCwgcGFnZUhlaWdodCAvIHBhZ2VXaWR0aCwgMF07XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gWy0xLCAwLCAwLCAtMV07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICAgICAgICByZXR1cm4gWzAsIHBhZ2VXaWR0aCAvIHBhZ2VIZWlnaHQsIC1wYWdlSGVpZ2h0IC8gcGFnZVdpZHRoLCAwXTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFsxLCAwLCAwLCAxXTtcbiAgICB9XG4gIH1cbiAgZ2V0IHBhcmVudFNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLl91aU1hbmFnZXIudmlld1BhcmFtZXRlcnMucmVhbFNjYWxlO1xuICB9XG4gIGdldCBwYXJlbnRSb3RhdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX3VpTWFuYWdlci52aWV3UGFyYW1ldGVycy5yb3RhdGlvbiArIHRoaXMucGFnZVJvdGF0aW9uKSAlIDM2MDtcbiAgfVxuICBnZXQgcGFyZW50RGltZW5zaW9ucygpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXJlbnRTY2FsZSxcbiAgICAgIHBhZ2VEaW1lbnNpb25zOiBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XVxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiBbcGFnZVdpZHRoICogcGFyZW50U2NhbGUsIHBhZ2VIZWlnaHQgKiBwYXJlbnRTY2FsZV07XG4gIH1cbiAgc2V0RGltcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuZGl2O1xuICAgIHN0eWxlLndpZHRoID0gYCR7KDEwMCAqIHdpZHRoIC8gcGFyZW50V2lkdGgpLnRvRml4ZWQoMil9JWA7XG4gICAgaWYgKCF0aGlzLiNrZWVwQXNwZWN0UmF0aW8pIHtcbiAgICAgIHN0eWxlLmhlaWdodCA9IGAkeygxMDAgKiBoZWlnaHQgLyBwYXJlbnRIZWlnaHQpLnRvRml4ZWQoMil9JWA7XG4gICAgfVxuICB9XG4gIGZpeERpbXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy5kaXY7XG4gICAgY29uc3Qge1xuICAgICAgaGVpZ2h0LFxuICAgICAgd2lkdGhcbiAgICB9ID0gc3R5bGU7XG4gICAgY29uc3Qgd2lkdGhQZXJjZW50ID0gd2lkdGguZW5kc1dpdGgoXCIlXCIpO1xuICAgIGNvbnN0IGhlaWdodFBlcmNlbnQgPSAhdGhpcy4ja2VlcEFzcGVjdFJhdGlvICYmIGhlaWdodC5lbmRzV2l0aChcIiVcIik7XG4gICAgaWYgKHdpZHRoUGVyY2VudCAmJiBoZWlnaHRQZXJjZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBpZiAoIXdpZHRoUGVyY2VudCkge1xuICAgICAgc3R5bGUud2lkdGggPSBgJHsoMTAwICogcGFyc2VGbG9hdCh3aWR0aCkgLyBwYXJlbnRXaWR0aCkudG9GaXhlZCgyKX0lYDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNrZWVwQXNwZWN0UmF0aW8gJiYgIWhlaWdodFBlcmNlbnQpIHtcbiAgICAgIHN0eWxlLmhlaWdodCA9IGAkeygxMDAgKiBwYXJzZUZsb2F0KGhlaWdodCkgLyBwYXJlbnRIZWlnaHQpLnRvRml4ZWQoMil9JWA7XG4gICAgfVxuICB9XG4gIGdldEluaXRpYWxUcmFuc2xhdGlvbigpIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG4gICNjcmVhdGVSZXNpemVycygpIHtcbiAgICBpZiAodGhpcy4jcmVzaXplcnNEaXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jcmVzaXplcnNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuI3Jlc2l6ZXJzRGl2LmNsYXNzTGlzdC5hZGQoXCJyZXNpemVyc1wiKTtcbiAgICBjb25zdCBjbGFzc2VzID0gdGhpcy5fd2lsbEtlZXBBc3BlY3RSYXRpbyA/IFtcInRvcExlZnRcIiwgXCJ0b3BSaWdodFwiLCBcImJvdHRvbVJpZ2h0XCIsIFwiYm90dG9tTGVmdFwiXSA6IFtcInRvcExlZnRcIiwgXCJ0b3BNaWRkbGVcIiwgXCJ0b3BSaWdodFwiLCBcIm1pZGRsZVJpZ2h0XCIsIFwiYm90dG9tUmlnaHRcIiwgXCJib3R0b21NaWRkbGVcIiwgXCJib3R0b21MZWZ0XCIsIFwibWlkZGxlTGVmdFwiXTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgY2xhc3Nlcykge1xuICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuI3Jlc2l6ZXJzRGl2LmFwcGVuZChkaXYpO1xuICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoXCJyZXNpemVyXCIsIG5hbWUpO1xuICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtcmVzaXplci1uYW1lXCIsIG5hbWUpO1xuICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiNyZXNpemVyUG9pbnRlcmRvd24uYmluZCh0aGlzLCBuYW1lKSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBkaXYudGFiSW5kZXggPSAtMTtcbiAgICB9XG4gICAgdGhpcy5kaXYucHJlcGVuZCh0aGlzLiNyZXNpemVyc0Rpdik7XG4gIH1cbiAgI3Jlc2l6ZXJQb2ludGVyZG93bihuYW1lLCBldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWx0VGV4dD8udG9nZ2xlKGZhbHNlKTtcbiAgICBjb25zdCBzYXZlZERyYWdnYWJsZSA9IHRoaXMuX2lzRHJhZ2dhYmxlO1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgdGhpcy4jbGFzdFBvaW50ZXJDb29yZHMgPSBbZXZlbnQuc2NyZWVuWCwgZXZlbnQuc2NyZWVuWV07XG4gICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKGFjKTtcbiAgICB0aGlzLnBhcmVudC50b2dnbGVQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHRoaXMuI3Jlc2l6ZXJQb2ludGVybW92ZS5iaW5kKHRoaXMsIG5hbWUpLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHN0b3BFdmVudCwge1xuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuI3NhdmVkRGltZW5zaW9ucyA9IHtcbiAgICAgIHNhdmVkWDogdGhpcy54LFxuICAgICAgc2F2ZWRZOiB0aGlzLnksXG4gICAgICBzYXZlZFdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgc2F2ZWRIZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgfTtcbiAgICBjb25zdCBzYXZlZFBhcmVudEN1cnNvciA9IHRoaXMucGFyZW50LmRpdi5zdHlsZS5jdXJzb3I7XG4gICAgY29uc3Qgc2F2ZWRDdXJzb3IgPSB0aGlzLmRpdi5zdHlsZS5jdXJzb3I7XG4gICAgdGhpcy5kaXYuc3R5bGUuY3Vyc29yID0gdGhpcy5wYXJlbnQuZGl2LnN0eWxlLmN1cnNvciA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGV2ZW50LnRhcmdldCkuY3Vyc29yO1xuICAgIGNvbnN0IHBvaW50ZXJVcENhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgYWMuYWJvcnQoKTtcbiAgICAgIHRoaXMucGFyZW50LnRvZ2dsZVBvaW50ZXJFdmVudHModHJ1ZSk7XG4gICAgICB0aGlzLiNhbHRUZXh0Py50b2dnbGUodHJ1ZSk7XG4gICAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IHNhdmVkRHJhZ2dhYmxlO1xuICAgICAgdGhpcy5wYXJlbnQuZGl2LnN0eWxlLmN1cnNvciA9IHNhdmVkUGFyZW50Q3Vyc29yO1xuICAgICAgdGhpcy5kaXYuc3R5bGUuY3Vyc29yID0gc2F2ZWRDdXJzb3I7XG4gICAgICB0aGlzLiNhZGRSZXNpemVUb1VuZG9TdGFjaygpO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlclVwQ2FsbGJhY2ssIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVyVXBDYWxsYmFjaywge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgI3Jlc2l6ZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy5zZXREaW1zKHBhcmVudFdpZHRoICogd2lkdGgsIHBhcmVudEhlaWdodCAqIGhlaWdodCk7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgIHRoaXMuX29uUmVzaXplZCgpO1xuICB9XG4gIF9vblJlc2l6ZWQoKSB7fVxuICAjYWRkUmVzaXplVG9VbmRvU3RhY2soKSB7XG4gICAgaWYgKCF0aGlzLiNzYXZlZERpbWVuc2lvbnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc2F2ZWRYLFxuICAgICAgc2F2ZWRZLFxuICAgICAgc2F2ZWRXaWR0aCxcbiAgICAgIHNhdmVkSGVpZ2h0XG4gICAgfSA9IHRoaXMuI3NhdmVkRGltZW5zaW9ucztcbiAgICB0aGlzLiNzYXZlZERpbWVuc2lvbnMgPSBudWxsO1xuICAgIGNvbnN0IG5ld1ggPSB0aGlzLng7XG4gICAgY29uc3QgbmV3WSA9IHRoaXMueTtcbiAgICBjb25zdCBuZXdXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgaWYgKG5ld1ggPT09IHNhdmVkWCAmJiBuZXdZID09PSBzYXZlZFkgJiYgbmV3V2lkdGggPT09IHNhdmVkV2lkdGggJiYgbmV3SGVpZ2h0ID09PSBzYXZlZEhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogdGhpcy4jcmVzaXplLmJpbmQodGhpcywgbmV3WCwgbmV3WSwgbmV3V2lkdGgsIG5ld0hlaWdodCksXG4gICAgICB1bmRvOiB0aGlzLiNyZXNpemUuYmluZCh0aGlzLCBzYXZlZFgsIHNhdmVkWSwgc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpLFxuICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgX3JvdW5kKHgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh4ICogMTAwMDApIC8gMTAwMDA7XG4gIH1cbiAgI3Jlc2l6ZXJQb2ludGVybW92ZShuYW1lLCBldmVudCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCBzYXZlZFggPSB0aGlzLng7XG4gICAgY29uc3Qgc2F2ZWRZID0gdGhpcy55O1xuICAgIGNvbnN0IHNhdmVkV2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGNvbnN0IHNhdmVkSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgY29uc3QgbWluV2lkdGggPSBBbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFIC8gcGFyZW50V2lkdGg7XG4gICAgY29uc3QgbWluSGVpZ2h0ID0gQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSAvIHBhcmVudEhlaWdodDtcbiAgICBjb25zdCByb3RhdGlvbk1hdHJpeCA9IHRoaXMuI2dldFJvdGF0aW9uTWF0cml4KHRoaXMucm90YXRpb24pO1xuICAgIGNvbnN0IHRyYW5zZiA9ICh4LCB5KSA9PiBbcm90YXRpb25NYXRyaXhbMF0gKiB4ICsgcm90YXRpb25NYXRyaXhbMl0gKiB5LCByb3RhdGlvbk1hdHJpeFsxXSAqIHggKyByb3RhdGlvbk1hdHJpeFszXSAqIHldO1xuICAgIGNvbnN0IGludlJvdGF0aW9uTWF0cml4ID0gdGhpcy4jZ2V0Um90YXRpb25NYXRyaXgoMzYwIC0gdGhpcy5yb3RhdGlvbik7XG4gICAgY29uc3QgaW52VHJhbnNmID0gKHgsIHkpID0+IFtpbnZSb3RhdGlvbk1hdHJpeFswXSAqIHggKyBpbnZSb3RhdGlvbk1hdHJpeFsyXSAqIHksIGludlJvdGF0aW9uTWF0cml4WzFdICogeCArIGludlJvdGF0aW9uTWF0cml4WzNdICogeV07XG4gICAgbGV0IGdldFBvaW50O1xuICAgIGxldCBnZXRPcHBvc2l0ZTtcbiAgICBsZXQgaXNEaWFnb25hbCA9IGZhbHNlO1xuICAgIGxldCBpc0hvcml6b250YWwgPSBmYWxzZTtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgXCJ0b3BMZWZ0XCI6XG4gICAgICAgIGlzRGlhZ29uYWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbMCwgMF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3LCBoXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidG9wTWlkZGxlXCI6XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3IC8gMiwgMF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3IC8gMiwgaF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRvcFJpZ2h0XCI6XG4gICAgICAgIGlzRGlhZ29uYWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdywgMF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFswLCBoXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWlkZGxlUmlnaHRcIjpcbiAgICAgICAgaXNIb3Jpem9udGFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3csIGggLyAyXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gWzAsIGggLyAyXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYm90dG9tUmlnaHRcIjpcbiAgICAgICAgaXNEaWFnb25hbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3LCBoXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gWzAsIDBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJib3R0b21NaWRkbGVcIjpcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3cgLyAyLCBoXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3cgLyAyLCAwXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYm90dG9tTGVmdFwiOlxuICAgICAgICBpc0RpYWdvbmFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gWzAsIGhdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdywgMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1pZGRsZUxlZnRcIjpcbiAgICAgICAgaXNIb3Jpem9udGFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gWzAsIGggLyAyXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3csIGggLyAyXTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IHBvaW50ID0gZ2V0UG9pbnQoc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpO1xuICAgIGNvbnN0IG9wcG9zaXRlUG9pbnQgPSBnZXRPcHBvc2l0ZShzYXZlZFdpZHRoLCBzYXZlZEhlaWdodCk7XG4gICAgbGV0IHRyYW5zZk9wcG9zaXRlUG9pbnQgPSB0cmFuc2YoLi4ub3Bwb3NpdGVQb2ludCk7XG4gICAgY29uc3Qgb3Bwb3NpdGVYID0gQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoc2F2ZWRYICsgdHJhbnNmT3Bwb3NpdGVQb2ludFswXSk7XG4gICAgY29uc3Qgb3Bwb3NpdGVZID0gQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoc2F2ZWRZICsgdHJhbnNmT3Bwb3NpdGVQb2ludFsxXSk7XG4gICAgbGV0IHJhdGlvWCA9IDE7XG4gICAgbGV0IHJhdGlvWSA9IDE7XG4gICAgbGV0IGRlbHRhWCwgZGVsdGFZO1xuICAgIGlmICghZXZlbnQuZnJvbUtleWJvYXJkKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNjcmVlblgsXG4gICAgICAgIHNjcmVlbllcbiAgICAgIH0gPSBldmVudDtcbiAgICAgIGNvbnN0IFtsYXN0U2NyZWVuWCwgbGFzdFNjcmVlblldID0gdGhpcy4jbGFzdFBvaW50ZXJDb29yZHM7XG4gICAgICBbZGVsdGFYLCBkZWx0YVldID0gdGhpcy5zY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbihzY3JlZW5YIC0gbGFzdFNjcmVlblgsIHNjcmVlblkgLSBsYXN0U2NyZWVuWSk7XG4gICAgICB0aGlzLiNsYXN0UG9pbnRlckNvb3Jkc1swXSA9IHNjcmVlblg7XG4gICAgICB0aGlzLiNsYXN0UG9pbnRlckNvb3Jkc1sxXSA9IHNjcmVlblk7XG4gICAgfSBlbHNlIHtcbiAgICAgICh7XG4gICAgICAgIGRlbHRhWCxcbiAgICAgICAgZGVsdGFZXG4gICAgICB9ID0gZXZlbnQpO1xuICAgIH1cbiAgICBbZGVsdGFYLCBkZWx0YVldID0gaW52VHJhbnNmKGRlbHRhWCAvIHBhcmVudFdpZHRoLCBkZWx0YVkgLyBwYXJlbnRIZWlnaHQpO1xuICAgIGlmIChpc0RpYWdvbmFsKSB7XG4gICAgICBjb25zdCBvbGREaWFnID0gTWF0aC5oeXBvdChzYXZlZFdpZHRoLCBzYXZlZEhlaWdodCk7XG4gICAgICByYXRpb1ggPSByYXRpb1kgPSBNYXRoLm1heChNYXRoLm1pbihNYXRoLmh5cG90KG9wcG9zaXRlUG9pbnRbMF0gLSBwb2ludFswXSAtIGRlbHRhWCwgb3Bwb3NpdGVQb2ludFsxXSAtIHBvaW50WzFdIC0gZGVsdGFZKSAvIG9sZERpYWcsIDEgLyBzYXZlZFdpZHRoLCAxIC8gc2F2ZWRIZWlnaHQpLCBtaW5XaWR0aCAvIHNhdmVkV2lkdGgsIG1pbkhlaWdodCAvIHNhdmVkSGVpZ2h0KTtcbiAgICB9IGVsc2UgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgcmF0aW9YID0gTWF0aC5tYXgobWluV2lkdGgsIE1hdGgubWluKDEsIE1hdGguYWJzKG9wcG9zaXRlUG9pbnRbMF0gLSBwb2ludFswXSAtIGRlbHRhWCkpKSAvIHNhdmVkV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhdGlvWSA9IE1hdGgubWF4KG1pbkhlaWdodCwgTWF0aC5taW4oMSwgTWF0aC5hYnMob3Bwb3NpdGVQb2ludFsxXSAtIHBvaW50WzFdIC0gZGVsdGFZKSkpIC8gc2F2ZWRIZWlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IG5ld1dpZHRoID0gQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoc2F2ZWRXaWR0aCAqIHJhdGlvWCk7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoc2F2ZWRIZWlnaHQgKiByYXRpb1kpO1xuICAgIHRyYW5zZk9wcG9zaXRlUG9pbnQgPSB0cmFuc2YoLi4uZ2V0T3Bwb3NpdGUobmV3V2lkdGgsIG5ld0hlaWdodCkpO1xuICAgIGNvbnN0IG5ld1ggPSBvcHBvc2l0ZVggLSB0cmFuc2ZPcHBvc2l0ZVBvaW50WzBdO1xuICAgIGNvbnN0IG5ld1kgPSBvcHBvc2l0ZVkgLSB0cmFuc2ZPcHBvc2l0ZVBvaW50WzFdO1xuICAgIHRoaXMuI2luaXRpYWxSZWN0IHx8PSBbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XTtcbiAgICB0aGlzLndpZHRoID0gbmV3V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgdGhpcy54ID0gbmV3WDtcbiAgICB0aGlzLnkgPSBuZXdZO1xuICAgIHRoaXMuc2V0RGltcyhwYXJlbnRXaWR0aCAqIG5ld1dpZHRoLCBwYXJlbnRIZWlnaHQgKiBuZXdIZWlnaHQpO1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICB0aGlzLl9vblJlc2l6aW5nKCk7XG4gIH1cbiAgX29uUmVzaXppbmcoKSB7fVxuICBhbHRUZXh0RmluaXNoKCkge1xuICAgIHRoaXMuI2FsdFRleHQ/LmZpbmlzaCgpO1xuICB9XG4gIGFzeW5jIGFkZEVkaXRUb29sYmFyKCkge1xuICAgIGlmICh0aGlzLl9lZGl0VG9vbGJhciB8fCB0aGlzLiNpc0luRWRpdE1vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lZGl0VG9vbGJhcjtcbiAgICB9XG4gICAgdGhpcy5fZWRpdFRvb2xiYXIgPSBuZXcgRWRpdG9yVG9vbGJhcih0aGlzKTtcbiAgICB0aGlzLmRpdi5hcHBlbmQodGhpcy5fZWRpdFRvb2xiYXIucmVuZGVyKCkpO1xuICAgIGlmICh0aGlzLiNhbHRUZXh0KSB7XG4gICAgICBhd2FpdCB0aGlzLl9lZGl0VG9vbGJhci5hZGRBbHRUZXh0KHRoaXMuI2FsdFRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZWRpdFRvb2xiYXI7XG4gIH1cbiAgcmVtb3ZlRWRpdFRvb2xiYXIoKSB7XG4gICAgaWYgKCF0aGlzLl9lZGl0VG9vbGJhcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0VG9vbGJhci5yZW1vdmUoKTtcbiAgICB0aGlzLl9lZGl0VG9vbGJhciA9IG51bGw7XG4gICAgdGhpcy4jYWx0VGV4dD8uZGVzdHJveSgpO1xuICB9XG4gIGFkZENvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICBjb25zdCBlZGl0VG9vbGJhckRpdiA9IHRoaXMuX2VkaXRUb29sYmFyPy5kaXY7XG4gICAgaWYgKGVkaXRUb29sYmFyRGl2KSB7XG4gICAgICBlZGl0VG9vbGJhckRpdi5iZWZvcmUoY29udGFpbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXYuYXBwZW5kKGNvbnRhaW5lcik7XG4gICAgfVxuICB9XG4gIGdldENsaWVudERpbWVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9XG4gIGFzeW5jIGFkZEFsdFRleHRCdXR0b24oKSB7XG4gICAgaWYgKHRoaXMuI2FsdFRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgQWx0VGV4dC5pbml0aWFsaXplKEFubm90YXRpb25FZGl0b3IuX2wxMG4pO1xuICAgIHRoaXMuI2FsdFRleHQgPSBuZXcgQWx0VGV4dCh0aGlzKTtcbiAgICBpZiAodGhpcy4jYWNjZXNzaWJpbGl0eURhdGEpIHtcbiAgICAgIHRoaXMuI2FsdFRleHQuZGF0YSA9IHRoaXMuI2FjY2Vzc2liaWxpdHlEYXRhO1xuICAgICAgdGhpcy4jYWNjZXNzaWJpbGl0eURhdGEgPSBudWxsO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLmFkZEVkaXRUb29sYmFyKCk7XG4gIH1cbiAgZ2V0IGFsdFRleHREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLiNhbHRUZXh0Py5kYXRhO1xuICB9XG4gIHNldCBhbHRUZXh0RGF0YShkYXRhKSB7XG4gICAgaWYgKCF0aGlzLiNhbHRUZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FsdFRleHQuZGF0YSA9IGRhdGE7XG4gIH1cbiAgZ2V0IGd1ZXNzZWRBbHRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiNhbHRUZXh0Py5ndWVzc2VkVGV4dDtcbiAgfVxuICBhc3luYyBzZXRHdWVzc2VkQWx0VGV4dCh0ZXh0KSB7XG4gICAgYXdhaXQgdGhpcy4jYWx0VGV4dD8uc2V0R3Vlc3NlZFRleHQodGV4dCk7XG4gIH1cbiAgc2VyaWFsaXplQWx0VGV4dChpc0ZvckNvcHlpbmcpIHtcbiAgICByZXR1cm4gdGhpcy4jYWx0VGV4dD8uc2VyaWFsaXplKGlzRm9yQ29weWluZyk7XG4gIH1cbiAgaGFzQWx0VGV4dCgpIHtcbiAgICByZXR1cm4gISF0aGlzLiNhbHRUZXh0ICYmICF0aGlzLiNhbHRUZXh0LmlzRW1wdHkoKTtcbiAgfVxuICBoYXNBbHRUZXh0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWx0VGV4dD8uaGFzRGF0YSgpID8/IGZhbHNlO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1lZGl0b3Itcm90YXRpb25cIiwgKDM2MCAtIHRoaXMucm90YXRpb24pICUgMzYwKTtcbiAgICB0aGlzLmRpdi5jbGFzc05hbWUgPSB0aGlzLm5hbWU7XG4gICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiaWRcIiwgdGhpcy5pZCk7XG4gICAgdGhpcy5kaXYudGFiSW5kZXggPSB0aGlzLiNkaXNhYmxlZCA/IC0xIDogMDtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSkge1xuICAgICAgdGhpcy5kaXYuY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcbiAgICB9XG4gICAgdGhpcy5zZXRJbkZvcmVncm91bmQoKTtcbiAgICB0aGlzLiNhZGRGb2N1c0xpc3RlbmVycygpO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBpZiAodGhpcy5wYXJlbnRSb3RhdGlvbiAlIDE4MCAhPT0gMCkge1xuICAgICAgdGhpcy5kaXYuc3R5bGUubWF4V2lkdGggPSBgJHsoMTAwICogcGFyZW50SGVpZ2h0IC8gcGFyZW50V2lkdGgpLnRvRml4ZWQoMil9JWA7XG4gICAgICB0aGlzLmRpdi5zdHlsZS5tYXhIZWlnaHQgPSBgJHsoMTAwICogcGFyZW50V2lkdGggLyBwYXJlbnRIZWlnaHQpLnRvRml4ZWQoMil9JWA7XG4gICAgfVxuICAgIGNvbnN0IFt0eCwgdHldID0gdGhpcy5nZXRJbml0aWFsVHJhbnNsYXRpb24oKTtcbiAgICB0aGlzLnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgIGJpbmRFdmVudHModGhpcywgdGhpcy5kaXYsIFtcInBvaW50ZXJkb3duXCJdKTtcbiAgICBpZiAodGhpcy5pc1Jlc2l6YWJsZSAmJiB0aGlzLl91aU1hbmFnZXIuX3N1cHBvcnRzUGluY2hUb1pvb20pIHtcbiAgICAgIHRoaXMuI3RvdWNoTWFuYWdlciB8fD0gbmV3IFRvdWNoTWFuYWdlcih7XG4gICAgICAgIGNvbnRhaW5lcjogdGhpcy5kaXYsXG4gICAgICAgIGlzUGluY2hpbmdEaXNhYmxlZDogKCkgPT4gIXRoaXMuaXNTZWxlY3RlZCxcbiAgICAgICAgb25QaW5jaFN0YXJ0OiB0aGlzLiN0b3VjaFBpbmNoU3RhcnRDYWxsYmFjay5iaW5kKHRoaXMpLFxuICAgICAgICBvblBpbmNoaW5nOiB0aGlzLiN0b3VjaFBpbmNoQ2FsbGJhY2suYmluZCh0aGlzKSxcbiAgICAgICAgb25QaW5jaEVuZDogdGhpcy4jdG91Y2hQaW5jaEVuZENhbGxiYWNrLmJpbmQodGhpcyksXG4gICAgICAgIHNpZ25hbDogdGhpcy5fdWlNYW5hZ2VyLl9zaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl91aU1hbmFnZXIuX2VkaXRvclVuZG9CYXI/LmhpZGUoKTtcbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgI3RvdWNoUGluY2hTdGFydENhbGxiYWNrKCkge1xuICAgIHRoaXMuI3NhdmVkRGltZW5zaW9ucyA9IHtcbiAgICAgIHNhdmVkWDogdGhpcy54LFxuICAgICAgc2F2ZWRZOiB0aGlzLnksXG4gICAgICBzYXZlZFdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgc2F2ZWRIZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgfTtcbiAgICB0aGlzLiNhbHRUZXh0Py50b2dnbGUoZmFsc2UpO1xuICAgIHRoaXMucGFyZW50LnRvZ2dsZVBvaW50ZXJFdmVudHMoZmFsc2UpO1xuICB9XG4gICN0b3VjaFBpbmNoQ2FsbGJhY2soX29yaWdpbiwgcHJldkRpc3RhbmNlLCBkaXN0YW5jZSkge1xuICAgIGNvbnN0IHNsb3dEb3duRmFjdG9yID0gMC43O1xuICAgIGxldCBmYWN0b3IgPSBzbG93RG93bkZhY3RvciAqIChkaXN0YW5jZSAvIHByZXZEaXN0YW5jZSkgKyAxIC0gc2xvd0Rvd25GYWN0b3I7XG4gICAgaWYgKGZhY3RvciA9PT0gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByb3RhdGlvbk1hdHJpeCA9IHRoaXMuI2dldFJvdGF0aW9uTWF0cml4KHRoaXMucm90YXRpb24pO1xuICAgIGNvbnN0IHRyYW5zZiA9ICh4LCB5KSA9PiBbcm90YXRpb25NYXRyaXhbMF0gKiB4ICsgcm90YXRpb25NYXRyaXhbMl0gKiB5LCByb3RhdGlvbk1hdHJpeFsxXSAqIHggKyByb3RhdGlvbk1hdHJpeFszXSAqIHldO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCBzYXZlZFggPSB0aGlzLng7XG4gICAgY29uc3Qgc2F2ZWRZID0gdGhpcy55O1xuICAgIGNvbnN0IHNhdmVkV2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGNvbnN0IHNhdmVkSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgY29uc3QgbWluV2lkdGggPSBBbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFIC8gcGFyZW50V2lkdGg7XG4gICAgY29uc3QgbWluSGVpZ2h0ID0gQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSAvIHBhcmVudEhlaWdodDtcbiAgICBmYWN0b3IgPSBNYXRoLm1heChNYXRoLm1pbihmYWN0b3IsIDEgLyBzYXZlZFdpZHRoLCAxIC8gc2F2ZWRIZWlnaHQpLCBtaW5XaWR0aCAvIHNhdmVkV2lkdGgsIG1pbkhlaWdodCAvIHNhdmVkSGVpZ2h0KTtcbiAgICBjb25zdCBuZXdXaWR0aCA9IEFubm90YXRpb25FZGl0b3IuX3JvdW5kKHNhdmVkV2lkdGggKiBmYWN0b3IpO1xuICAgIGNvbnN0IG5ld0hlaWdodCA9IEFubm90YXRpb25FZGl0b3IuX3JvdW5kKHNhdmVkSGVpZ2h0ICogZmFjdG9yKTtcbiAgICBpZiAobmV3V2lkdGggPT09IHNhdmVkV2lkdGggJiYgbmV3SGVpZ2h0ID09PSBzYXZlZEhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNpbml0aWFsUmVjdCB8fD0gW3NhdmVkWCwgc2F2ZWRZLCBzYXZlZFdpZHRoLCBzYXZlZEhlaWdodF07XG4gICAgY29uc3QgdHJhbnNmQ2VudGVyUG9pbnQgPSB0cmFuc2Yoc2F2ZWRXaWR0aCAvIDIsIHNhdmVkSGVpZ2h0IC8gMik7XG4gICAgY29uc3QgY2VudGVyWCA9IEFubm90YXRpb25FZGl0b3IuX3JvdW5kKHNhdmVkWCArIHRyYW5zZkNlbnRlclBvaW50WzBdKTtcbiAgICBjb25zdCBjZW50ZXJZID0gQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoc2F2ZWRZICsgdHJhbnNmQ2VudGVyUG9pbnRbMV0pO1xuICAgIGNvbnN0IG5ld1RyYW5zZkNlbnRlclBvaW50ID0gdHJhbnNmKG5ld1dpZHRoIC8gMiwgbmV3SGVpZ2h0IC8gMik7XG4gICAgdGhpcy54ID0gY2VudGVyWCAtIG5ld1RyYW5zZkNlbnRlclBvaW50WzBdO1xuICAgIHRoaXMueSA9IGNlbnRlclkgLSBuZXdUcmFuc2ZDZW50ZXJQb2ludFsxXTtcbiAgICB0aGlzLndpZHRoID0gbmV3V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgdGhpcy5zZXREaW1zKHBhcmVudFdpZHRoICogbmV3V2lkdGgsIHBhcmVudEhlaWdodCAqIG5ld0hlaWdodCk7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgIHRoaXMuX29uUmVzaXppbmcoKTtcbiAgfVxuICAjdG91Y2hQaW5jaEVuZENhbGxiYWNrKCkge1xuICAgIHRoaXMuI2FsdFRleHQ/LnRvZ2dsZSh0cnVlKTtcbiAgICB0aGlzLnBhcmVudC50b2dnbGVQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgIHRoaXMuI2FkZFJlc2l6ZVRvVW5kb1N0YWNrKCk7XG4gIH1cbiAgcG9pbnRlcmRvd24oZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaGFzQmVlbkNsaWNrZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLl9pc0RyYWdnYWJsZSkge1xuICAgICAgdGhpcy4jc2V0VXBEcmFnU2Vzc2lvbihldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdE9uUG9pbnRlckV2ZW50KGV2ZW50KTtcbiAgfVxuICBnZXQgaXNTZWxlY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdWlNYW5hZ2VyLmlzU2VsZWN0ZWQodGhpcyk7XG4gIH1cbiAgI3NlbGVjdE9uUG9pbnRlckV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuY3RybEtleSAmJiAhaXNNYWMgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQubWV0YUtleSAmJiBpc01hYykge1xuICAgICAgdGhpcy5wYXJlbnQudG9nZ2xlU2VsZWN0ZWQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgIH1cbiAgfVxuICAjc2V0VXBEcmFnU2Vzc2lvbihldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzU2VsZWN0ZWRcbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLl91aU1hbmFnZXIuc2V0VXBEcmFnU2Vzc2lvbigpO1xuICAgIGxldCBoYXNEcmFnZ2luZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl91aU1hbmFnZXIuY29tYmluZWRTaWduYWwoYWMpO1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBzaWduYWxcbiAgICB9O1xuICAgIGNvbnN0IGNhbmNlbERyYWcgPSBlID0+IHtcbiAgICAgIGFjLmFib3J0KCk7XG4gICAgICB0aGlzLiNkcmFnUG9pbnRlcklkID0gbnVsbDtcbiAgICAgIHRoaXMuI2hhc0JlZW5DbGlja2VkID0gZmFsc2U7XG4gICAgICBpZiAoIXRoaXMuX3VpTWFuYWdlci5lbmREcmFnU2Vzc2lvbigpKSB7XG4gICAgICAgIHRoaXMuI3NlbGVjdE9uUG9pbnRlckV2ZW50KGUpO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0RyYWdnaW5nU3RhcnRlZCkge1xuICAgICAgICB0aGlzLl9vblN0b3BEcmFnZ2luZygpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuI3ByZXZEcmFnWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICB0aGlzLiNwcmV2RHJhZ1kgPSBldmVudC5jbGllbnRZO1xuICAgICAgdGhpcy4jZHJhZ1BvaW50ZXJJZCA9IGV2ZW50LnBvaW50ZXJJZDtcbiAgICAgIHRoaXMuI2RyYWdQb2ludGVyVHlwZSA9IGV2ZW50LnBvaW50ZXJUeXBlO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBlID0+IHtcbiAgICAgICAgaWYgKCFoYXNEcmFnZ2luZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICBoYXNEcmFnZ2luZ1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuX29uU3RhcnREcmFnZ2luZygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjbGllbnRYOiB4LFxuICAgICAgICAgIGNsaWVudFk6IHksXG4gICAgICAgICAgcG9pbnRlcklkXG4gICAgICAgIH0gPSBlO1xuICAgICAgICBpZiAocG9pbnRlcklkICE9PSB0aGlzLiNkcmFnUG9pbnRlcklkKSB7XG4gICAgICAgICAgc3RvcEV2ZW50KGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbdHgsIHR5XSA9IHRoaXMuc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24oeCAtIHRoaXMuI3ByZXZEcmFnWCwgeSAtIHRoaXMuI3ByZXZEcmFnWSk7XG4gICAgICAgIHRoaXMuI3ByZXZEcmFnWCA9IHg7XG4gICAgICAgIHRoaXMuI3ByZXZEcmFnWSA9IHk7XG4gICAgICAgIHRoaXMuX3VpTWFuYWdlci5kcmFnU2VsZWN0ZWRFZGl0b3JzKHR4LCB0eSk7XG4gICAgICB9LCBvcHRzKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHN0b3BFdmVudCwgb3B0cyk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGUgPT4ge1xuICAgICAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gdGhpcy4jZHJhZ1BvaW50ZXJUeXBlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuI3RvdWNoTWFuYWdlciB8fCBlLmlzUHJpbWFyeSkge1xuICAgICAgICAgICAgY2FuY2VsRHJhZyhlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RvcEV2ZW50KGUpO1xuICAgICAgfSwgb3B0cyk7XG4gICAgfVxuICAgIGNvbnN0IHBvaW50ZXJVcENhbGxiYWNrID0gZSA9PiB7XG4gICAgICBpZiAoIXRoaXMuI2RyYWdQb2ludGVySWQgfHwgdGhpcy4jZHJhZ1BvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQpIHtcbiAgICAgICAgY2FuY2VsRHJhZyhlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3RvcEV2ZW50KGUpO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlclVwQ2FsbGJhY2ssIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVyVXBDYWxsYmFjaywge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgX29uU3RhcnREcmFnZ2luZygpIHt9XG4gIF9vblN0b3BEcmFnZ2luZygpIHt9XG4gIG1vdmVJbkRPTSgpIHtcbiAgICBpZiAodGhpcy4jbW92ZUluRE9NVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI21vdmVJbkRPTVRpbWVvdXQpO1xuICAgIH1cbiAgICB0aGlzLiNtb3ZlSW5ET01UaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLiNtb3ZlSW5ET01UaW1lb3V0ID0gbnVsbDtcbiAgICAgIHRoaXMucGFyZW50Py5tb3ZlRWRpdG9ySW5ET00odGhpcyk7XG4gICAgfSwgMCk7XG4gIH1cbiAgX3NldFBhcmVudEFuZFBvc2l0aW9uKHBhcmVudCwgeCwgeSkge1xuICAgIHBhcmVudC5jaGFuZ2VQYXJlbnQodGhpcyk7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICB0aGlzLl9vblRyYW5zbGF0ZWQoKTtcbiAgfVxuICBnZXRSZWN0KHR4LCB0eSwgcm90YXRpb24gPSB0aGlzLnJvdGF0aW9uKSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLnBhcmVudFNjYWxlO1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgIGNvbnN0IHNoaWZ0WCA9IHR4IC8gc2NhbGU7XG4gICAgY29uc3Qgc2hpZnRZID0gdHkgLyBzY2FsZTtcbiAgICBjb25zdCB4ID0gdGhpcy54ICogcGFnZVdpZHRoO1xuICAgIGNvbnN0IHkgPSB0aGlzLnkgKiBwYWdlSGVpZ2h0O1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQ7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gW3ggKyBzaGlmdFggKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgLSBzaGlmdFkgLSBoZWlnaHQgKyBwYWdlWSwgeCArIHNoaWZ0WCArIHdpZHRoICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5IC0gc2hpZnRZICsgcGFnZVldO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFt4ICsgc2hpZnRZICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5ICsgc2hpZnRYICsgcGFnZVksIHggKyBzaGlmdFkgKyBoZWlnaHQgKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgKyBzaGlmdFggKyB3aWR0aCArIHBhZ2VZXTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gW3ggLSBzaGlmdFggLSB3aWR0aCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSArIHNoaWZ0WSArIHBhZ2VZLCB4IC0gc2hpZnRYICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5ICsgc2hpZnRZICsgaGVpZ2h0ICsgcGFnZVldO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeCAtIHNoaWZ0WSAtIGhlaWdodCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSAtIHNoaWZ0WCAtIHdpZHRoICsgcGFnZVksIHggLSBzaGlmdFkgKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgLSBzaGlmdFggKyBwYWdlWV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJvdGF0aW9uXCIpO1xuICAgIH1cbiAgfVxuICBnZXRSZWN0SW5DdXJyZW50Q29vcmRzKHJlY3QsIHBhZ2VIZWlnaHQpIHtcbiAgICBjb25zdCBbeDEsIHkxLCB4MiwgeTJdID0gcmVjdDtcbiAgICBjb25zdCB3aWR0aCA9IHgyIC0geDE7XG4gICAgY29uc3QgaGVpZ2h0ID0geTIgLSB5MTtcbiAgICBzd2l0Y2ggKHRoaXMucm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIFt4MSwgcGFnZUhlaWdodCAtIHkyLCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbeDEsIHBhZ2VIZWlnaHQgLSB5MSwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFt4MiwgcGFnZUhlaWdodCAtIHkxLCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3gyLCBwYWdlSGVpZ2h0IC0geTIsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByb3RhdGlvblwiKTtcbiAgICB9XG4gIH1cbiAgb25jZUFkZGVkKGZvY3VzKSB7fVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBlbmFibGVFZGl0TW9kZSgpIHtcbiAgICB0aGlzLiNpc0luRWRpdE1vZGUgPSB0cnVlO1xuICB9XG4gIGRpc2FibGVFZGl0TW9kZSgpIHtcbiAgICB0aGlzLiNpc0luRWRpdE1vZGUgPSBmYWxzZTtcbiAgfVxuICBpc0luRWRpdE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lzSW5FZGl0TW9kZTtcbiAgfVxuICBzaG91bGRHZXRLZXlib2FyZEV2ZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkO1xuICB9XG4gIG5lZWRzVG9CZVJlYnVpbHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2ICYmICF0aGlzLmlzQXR0YWNoZWRUb0RPTTtcbiAgfVxuICBnZXQgaXNPblNjcmVlbigpIHtcbiAgICBjb25zdCB7XG4gICAgICB0b3AsXG4gICAgICBsZWZ0LFxuICAgICAgYm90dG9tLFxuICAgICAgcmlnaHRcbiAgICB9ID0gdGhpcy5nZXRDbGllbnREaW1lbnNpb25zKCk7XG4gICAgY29uc3Qge1xuICAgICAgaW5uZXJIZWlnaHQsXG4gICAgICBpbm5lcldpZHRoXG4gICAgfSA9IHdpbmRvdztcbiAgICByZXR1cm4gbGVmdCA8IGlubmVyV2lkdGggJiYgcmlnaHQgPiAwICYmIHRvcCA8IGlubmVySGVpZ2h0ICYmIGJvdHRvbSA+IDA7XG4gIH1cbiAgI2FkZEZvY3VzTGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLiNmb2N1c0FDIHx8ICF0aGlzLmRpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNmb2N1c0FDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiNmb2N1c0FDKTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCB0aGlzLmZvY3VzaW4uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuZm9jdXNvdXQuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICB0aGlzLiNhZGRGb2N1c0xpc3RlbmVycygpO1xuICB9XG4gIHJvdGF0ZShfYW5nbGUpIHt9XG4gIHJlc2l6ZSgpIHt9XG4gIHNlcmlhbGl6ZURlbGV0ZWQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmFubm90YXRpb25FbGVtZW50SWQsXG4gICAgICBkZWxldGVkOiB0cnVlLFxuICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgIHBvcHVwUmVmOiB0aGlzLl9pbml0aWFsRGF0YT8ucG9wdXBSZWYgfHwgXCJcIlxuICAgIH07XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlLCBjb250ZXh0ID0gbnVsbCkge1xuICAgIHVucmVhY2hhYmxlKFwiQW4gZWRpdG9yIG11c3QgYmUgc2VyaWFsaXphYmxlXCIpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGNvbnN0IGVkaXRvciA9IG5ldyB0aGlzLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcih7XG4gICAgICBwYXJlbnQsXG4gICAgICBpZDogcGFyZW50LmdldE5leHRJZCgpLFxuICAgICAgdWlNYW5hZ2VyXG4gICAgfSk7XG4gICAgZWRpdG9yLnJvdGF0aW9uID0gZGF0YS5yb3RhdGlvbjtcbiAgICBlZGl0b3IuI2FjY2Vzc2liaWxpdHlEYXRhID0gZGF0YS5hY2Nlc3NpYmlsaXR5RGF0YTtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IGVkaXRvci5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSBlZGl0b3IuZ2V0UmVjdEluQ3VycmVudENvb3JkcyhkYXRhLnJlY3QsIHBhZ2VIZWlnaHQpO1xuICAgIGVkaXRvci54ID0geCAvIHBhZ2VXaWR0aDtcbiAgICBlZGl0b3IueSA9IHkgLyBwYWdlSGVpZ2h0O1xuICAgIGVkaXRvci53aWR0aCA9IHdpZHRoIC8gcGFnZVdpZHRoO1xuICAgIGVkaXRvci5oZWlnaHQgPSBoZWlnaHQgLyBwYWdlSGVpZ2h0O1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgZ2V0IGhhc0JlZW5Nb2RpZmllZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLmFubm90YXRpb25FbGVtZW50SWQgJiYgKHRoaXMuZGVsZXRlZCB8fCB0aGlzLnNlcmlhbGl6ZSgpICE9PSBudWxsKTtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy4jZm9jdXNBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNmb2N1c0FDID0gbnVsbDtcbiAgICBpZiAoIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICB0aGlzLmNvbW1pdCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LnJlbW92ZSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnJlbW92ZUVkaXRvcih0aGlzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI21vdmVJbkRPTVRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNtb3ZlSW5ET01UaW1lb3V0KTtcbiAgICAgIHRoaXMuI21vdmVJbkRPTVRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNzdG9wUmVzaXppbmcoKTtcbiAgICB0aGlzLnJlbW92ZUVkaXRUb29sYmFyKCk7XG4gICAgaWYgKHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzKSB7XG4gICAgICBmb3IgKGNvbnN0IHRpbWVvdXQgb2YgdGhpcy4jdGVsZW1ldHJ5VGltZW91dHMudmFsdWVzKCkpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgdGhpcy4jdGVsZW1ldHJ5VGltZW91dHMgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgdGhpcy4jdG91Y2hNYW5hZ2VyPy5kZXN0cm95KCk7XG4gICAgdGhpcy4jdG91Y2hNYW5hZ2VyID0gbnVsbDtcbiAgfVxuICBnZXQgaXNSZXNpemFibGUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG1ha2VSZXNpemFibGUoKSB7XG4gICAgaWYgKHRoaXMuaXNSZXNpemFibGUpIHtcbiAgICAgIHRoaXMuI2NyZWF0ZVJlc2l6ZXJzKCk7XG4gICAgICB0aGlzLiNyZXNpemVyc0Rpdi5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xuICAgICAgYmluZEV2ZW50cyh0aGlzLCB0aGlzLmRpdiwgW1wia2V5ZG93blwiXSk7XG4gICAgfVxuICB9XG4gIGdldCB0b29sYmFyUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAga2V5ZG93bihldmVudCkge1xuICAgIGlmICghdGhpcy5pc1Jlc2l6YWJsZSB8fCBldmVudC50YXJnZXQgIT09IHRoaXMuZGl2IHx8IGV2ZW50LmtleSAhPT0gXCJFbnRlclwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3VpTWFuYWdlci5zZXRTZWxlY3RlZCh0aGlzKTtcbiAgICB0aGlzLiNzYXZlZERpbWVuc2lvbnMgPSB7XG4gICAgICBzYXZlZFg6IHRoaXMueCxcbiAgICAgIHNhdmVkWTogdGhpcy55LFxuICAgICAgc2F2ZWRXaWR0aDogdGhpcy53aWR0aCxcbiAgICAgIHNhdmVkSGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLiNyZXNpemVyc0Rpdi5jaGlsZHJlbjtcbiAgICBpZiAoIXRoaXMuI2FsbFJlc2l6ZXJEaXZzKSB7XG4gICAgICB0aGlzLiNhbGxSZXNpemVyRGl2cyA9IEFycmF5LmZyb20oY2hpbGRyZW4pO1xuICAgICAgY29uc3QgYm91bmRSZXNpemVyS2V5ZG93biA9IHRoaXMuI3Jlc2l6ZXJLZXlkb3duLmJpbmQodGhpcyk7XG4gICAgICBjb25zdCBib3VuZFJlc2l6ZXJCbHVyID0gdGhpcy4jcmVzaXplckJsdXIuYmluZCh0aGlzKTtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5fc2lnbmFsO1xuICAgICAgZm9yIChjb25zdCBkaXYgb2YgdGhpcy4jYWxsUmVzaXplckRpdnMpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGRpdi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJlc2l6ZXItbmFtZVwiKTtcbiAgICAgICAgZGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJzcGluYnV0dG9uXCIpO1xuICAgICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgYm91bmRSZXNpemVyS2V5ZG93biwge1xuICAgICAgICAgIHNpZ25hbFxuICAgICAgICB9KTtcbiAgICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGJvdW5kUmVzaXplckJsdXIsIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy4jcmVzaXplckZvY3VzLmJpbmQodGhpcywgbmFtZSksIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQW5ub3RhdGlvbkVkaXRvci5fbDEwblJlc2l6ZXJbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmaXJzdCA9IHRoaXMuI2FsbFJlc2l6ZXJEaXZzWzBdO1xuICAgIGxldCBmaXJzdFBvc2l0aW9uID0gMDtcbiAgICBmb3IgKGNvbnN0IGRpdiBvZiBjaGlsZHJlbikge1xuICAgICAgaWYgKGRpdiA9PT0gZmlyc3QpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBmaXJzdFBvc2l0aW9uKys7XG4gICAgfVxuICAgIGNvbnN0IG5leHRGaXJzdFBvc2l0aW9uID0gKDM2MCAtIHRoaXMucm90YXRpb24gKyB0aGlzLnBhcmVudFJvdGF0aW9uKSAlIDM2MCAvIDkwICogKHRoaXMuI2FsbFJlc2l6ZXJEaXZzLmxlbmd0aCAvIDQpO1xuICAgIGlmIChuZXh0Rmlyc3RQb3NpdGlvbiAhPT0gZmlyc3RQb3NpdGlvbikge1xuICAgICAgaWYgKG5leHRGaXJzdFBvc2l0aW9uIDwgZmlyc3RQb3NpdGlvbikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpcnN0UG9zaXRpb24gLSBuZXh0Rmlyc3RQb3NpdGlvbjsgaSsrKSB7XG4gICAgICAgICAgdGhpcy4jcmVzaXplcnNEaXYuYXBwZW5kKHRoaXMuI3Jlc2l6ZXJzRGl2LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5leHRGaXJzdFBvc2l0aW9uID4gZmlyc3RQb3NpdGlvbikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRGaXJzdFBvc2l0aW9uIC0gZmlyc3RQb3NpdGlvbjsgaSsrKSB7XG4gICAgICAgICAgdGhpcy4jcmVzaXplcnNEaXYuZmlyc3RDaGlsZC5iZWZvcmUodGhpcy4jcmVzaXplcnNEaXYubGFzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgICBjb25zdCBkaXYgPSB0aGlzLiNhbGxSZXNpemVyRGl2c1tpKytdO1xuICAgICAgICBjb25zdCBuYW1lID0gZGl2LmdldEF0dHJpYnV0ZShcImRhdGEtcmVzaXplci1uYW1lXCIpO1xuICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQW5ub3RhdGlvbkVkaXRvci5fbDEwblJlc2l6ZXJbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNzZXRSZXNpemVyVGFiSW5kZXgoMCk7XG4gICAgdGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkID0gdHJ1ZTtcbiAgICB0aGlzLiNyZXNpemVyc0Rpdi5maXJzdENoaWxkLmZvY3VzKHtcbiAgICAgIGZvY3VzVmlzaWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgI3Jlc2l6ZXJLZXlkb3duKGV2ZW50KSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5fcmVzaXplcktleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgfVxuICAjcmVzaXplckJsdXIoZXZlbnQpIHtcbiAgICBpZiAodGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkICYmIGV2ZW50LnJlbGF0ZWRUYXJnZXQ/LnBhcmVudE5vZGUgIT09IHRoaXMuI3Jlc2l6ZXJzRGl2KSB7XG4gICAgICB0aGlzLiNzdG9wUmVzaXppbmcoKTtcbiAgICB9XG4gIH1cbiAgI3Jlc2l6ZXJGb2N1cyhuYW1lKSB7XG4gICAgdGhpcy4jZm9jdXNlZFJlc2l6ZXJOYW1lID0gdGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkID8gbmFtZSA6IFwiXCI7XG4gIH1cbiAgI3NldFJlc2l6ZXJUYWJJbmRleCh2YWx1ZSkge1xuICAgIGlmICghdGhpcy4jYWxsUmVzaXplckRpdnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBkaXYgb2YgdGhpcy4jYWxsUmVzaXplckRpdnMpIHtcbiAgICAgIGRpdi50YWJJbmRleCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICBfcmVzaXplV2l0aEtleWJvYXJkKHgsIHkpIHtcbiAgICBpZiAoIXRoaXMuI2lzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNyZXNpemVyUG9pbnRlcm1vdmUodGhpcy4jZm9jdXNlZFJlc2l6ZXJOYW1lLCB7XG4gICAgICBkZWx0YVg6IHgsXG4gICAgICBkZWx0YVk6IHksXG4gICAgICBmcm9tS2V5Ym9hcmQ6IHRydWVcbiAgICB9KTtcbiAgfVxuICAjc3RvcFJlc2l6aW5nKCkge1xuICAgIHRoaXMuI2lzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZCA9IGZhbHNlO1xuICAgIHRoaXMuI3NldFJlc2l6ZXJUYWJJbmRleCgtMSk7XG4gICAgdGhpcy4jYWRkUmVzaXplVG9VbmRvU3RhY2soKTtcbiAgfVxuICBfc3RvcFJlc2l6aW5nV2l0aEtleWJvYXJkKCkge1xuICAgIHRoaXMuI3N0b3BSZXNpemluZygpO1xuICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gIH1cbiAgc2VsZWN0KCkge1xuICAgIHRoaXMubWFrZVJlc2l6YWJsZSgpO1xuICAgIHRoaXMuZGl2Py5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRFZGl0b3JcIik7XG4gICAgaWYgKCF0aGlzLl9lZGl0VG9vbGJhcikge1xuICAgICAgdGhpcy5hZGRFZGl0VG9vbGJhcigpLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5kaXY/LmNsYXNzTGlzdC5jb250YWlucyhcInNlbGVjdGVkRWRpdG9yXCIpKSB7XG4gICAgICAgICAgdGhpcy5fZWRpdFRvb2xiYXI/LnNob3coKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2VkaXRUb29sYmFyPy5zaG93KCk7XG4gICAgdGhpcy4jYWx0VGV4dD8udG9nZ2xlQWx0VGV4dEJhZGdlKGZhbHNlKTtcbiAgfVxuICB1bnNlbGVjdCgpIHtcbiAgICB0aGlzLiNyZXNpemVyc0Rpdj8uY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcbiAgICB0aGlzLmRpdj8uY2xhc3NMaXN0LnJlbW92ZShcInNlbGVjdGVkRWRpdG9yXCIpO1xuICAgIGlmICh0aGlzLmRpdj8uY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5jdXJyZW50TGF5ZXIuZGl2LmZvY3VzKHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX2VkaXRUb29sYmFyPy5oaWRlKCk7XG4gICAgdGhpcy4jYWx0VGV4dD8udG9nZ2xlQWx0VGV4dEJhZGdlKHRydWUpO1xuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge31cbiAgZGlzYWJsZUVkaXRpbmcoKSB7fVxuICBlbmFibGVFZGl0aW5nKCkge31cbiAgZW50ZXJJbkVkaXRNb2RlKCkge31cbiAgZ2V0SW1hZ2VGb3JBbHRUZXh0KCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCBjb250ZW50RGl2KCkge1xuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICBnZXQgaXNFZGl0aW5nKCkge1xuICAgIHJldHVybiB0aGlzLiNpc0VkaXRpbmc7XG4gIH1cbiAgc2V0IGlzRWRpdGluZyh2YWx1ZSkge1xuICAgIHRoaXMuI2lzRWRpdGluZyA9IHZhbHVlO1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnBhcmVudC5zZXRTZWxlY3RlZCh0aGlzKTtcbiAgICAgIHRoaXMucGFyZW50LnNldEFjdGl2ZUVkaXRvcih0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0QWN0aXZlRWRpdG9yKG51bGwpO1xuICAgIH1cbiAgfVxuICBzZXRBc3BlY3RSYXRpbyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy4ja2VlcEFzcGVjdFJhdGlvID0gdHJ1ZTtcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuZGl2O1xuICAgIHN0eWxlLmFzcGVjdFJhdGlvID0gYXNwZWN0UmF0aW87XG4gICAgc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCI7XG4gIH1cbiAgc3RhdGljIGdldCBNSU5fU0laRSgpIHtcbiAgICByZXR1cm4gMTY7XG4gIH1cbiAgc3RhdGljIGNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldCB0ZWxlbWV0cnlJbml0aWFsRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWN0aW9uOiBcImFkZGVkXCJcbiAgICB9O1xuICB9XG4gIGdldCB0ZWxlbWV0cnlGaW5hbERhdGEoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgX3JlcG9ydFRlbGVtZXRyeShkYXRhLCBtdXN0V2FpdCA9IGZhbHNlKSB7XG4gICAgaWYgKG11c3RXYWl0KSB7XG4gICAgICB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cyB8fD0gbmV3IE1hcCgpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhY3Rpb25cbiAgICAgIH0gPSBkYXRhO1xuICAgICAgbGV0IHRpbWVvdXQgPSB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cy5nZXQoYWN0aW9uKTtcbiAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fcmVwb3J0VGVsZW1ldHJ5KGRhdGEpO1xuICAgICAgICB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cy5kZWxldGUoYWN0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzLnNpemUgPT09IDApIHtcbiAgICAgICAgICB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sIEFubm90YXRpb25FZGl0b3IuX3RlbGVtZXRyeVRpbWVvdXQpO1xuICAgICAgdGhpcy4jdGVsZW1ldHJ5VGltZW91dHMuc2V0KGFjdGlvbiwgdGltZW91dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRhdGEudHlwZSB8fD0gdGhpcy5lZGl0b3JUeXBlO1xuICAgIHRoaXMuX3VpTWFuYWdlci5fZXZlbnRCdXMuZGlzcGF0Y2goXCJyZXBvcnR0ZWxlbWV0cnlcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgZGV0YWlsczoge1xuICAgICAgICB0eXBlOiBcImVkaXRpbmdcIixcbiAgICAgICAgZGF0YVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNob3codmlzaWJsZSA9IHRoaXMuX2lzVmlzaWJsZSkge1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJoaWRkZW5cIiwgIXZpc2libGUpO1xuICAgIHRoaXMuX2lzVmlzaWJsZSA9IHZpc2libGU7XG4gIH1cbiAgZW5hYmxlKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgdGhpcy5kaXYudGFiSW5kZXggPSAwO1xuICAgIH1cbiAgICB0aGlzLiNkaXNhYmxlZCA9IGZhbHNlO1xuICB9XG4gIGRpc2FibGUoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICB0aGlzLmRpdi50YWJJbmRleCA9IC0xO1xuICAgIH1cbiAgICB0aGlzLiNkaXNhYmxlZCA9IHRydWU7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGxldCBjb250ZW50ID0gYW5ub3RhdGlvbi5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIi5hbm5vdGF0aW9uQ29udGVudFwiKTtcbiAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKFwiYW5ub3RhdGlvbkNvbnRlbnRcIiwgdGhpcy5lZGl0b3JUeXBlKTtcbiAgICAgIGFubm90YXRpb24uY29udGFpbmVyLnByZXBlbmQoY29udGVudCk7XG4gICAgfSBlbHNlIGlmIChjb250ZW50Lm5vZGVOYW1lID09PSBcIkNBTlZBU1wiKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBjb250ZW50O1xuICAgICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoXCJhbm5vdGF0aW9uQ29udGVudFwiLCB0aGlzLmVkaXRvclR5cGUpO1xuICAgICAgY2FudmFzLmJlZm9yZShjb250ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgcmVzZXRBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgZmlyc3RDaGlsZFxuICAgIH0gPSBhbm5vdGF0aW9uLmNvbnRhaW5lcjtcbiAgICBpZiAoZmlyc3RDaGlsZD8ubm9kZU5hbWUgPT09IFwiRElWXCIgJiYgZmlyc3RDaGlsZC5jbGFzc0xpc3QuY29udGFpbnMoXCJhbm5vdGF0aW9uQ29udGVudFwiKSkge1xuICAgICAgZmlyc3RDaGlsZC5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEZha2VFZGl0b3IgZXh0ZW5kcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIocGFyYW1zKTtcbiAgICB0aGlzLmFubm90YXRpb25FbGVtZW50SWQgPSBwYXJhbXMuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICB0aGlzLmRlbGV0ZWQgPSB0cnVlO1xuICB9XG4gIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVEZWxldGVkKCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL3NoYXJlZC9tdXJtdXJoYXNoMy5qc1xuY29uc3QgU0VFRCA9IDB4YzNkMmUxZjA7XG5jb25zdCBNQVNLX0hJR0ggPSAweGZmZmYwMDAwO1xuY29uc3QgTUFTS19MT1cgPSAweGZmZmY7XG5jbGFzcyBNdXJtdXJIYXNoM182NCB7XG4gIGNvbnN0cnVjdG9yKHNlZWQpIHtcbiAgICB0aGlzLmgxID0gc2VlZCA/IHNlZWQgJiAweGZmZmZmZmZmIDogU0VFRDtcbiAgICB0aGlzLmgyID0gc2VlZCA/IHNlZWQgJiAweGZmZmZmZmZmIDogU0VFRDtcbiAgfVxuICB1cGRhdGUoaW5wdXQpIHtcbiAgICBsZXQgZGF0YSwgbGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGggKiAyKTtcbiAgICAgIGxlbmd0aCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbnB1dC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZSA8PSAweGZmKSB7XG4gICAgICAgICAgZGF0YVtsZW5ndGgrK10gPSBjb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGFbbGVuZ3RoKytdID0gY29kZSA+Pj4gODtcbiAgICAgICAgICBkYXRhW2xlbmd0aCsrXSA9IGNvZGUgJiAweGZmO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoaW5wdXQpKSB7XG4gICAgICBkYXRhID0gaW5wdXQuc2xpY2UoKTtcbiAgICAgIGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIGZvcm1hdCwgbXVzdCBiZSBhIHN0cmluZyBvciBUeXBlZEFycmF5LlwiKTtcbiAgICB9XG4gICAgY29uc3QgYmxvY2tDb3VudHMgPSBsZW5ndGggPj4gMjtcbiAgICBjb25zdCB0YWlsTGVuZ3RoID0gbGVuZ3RoIC0gYmxvY2tDb3VudHMgKiA0O1xuICAgIGNvbnN0IGRhdGFVaW50MzIgPSBuZXcgVWludDMyQXJyYXkoZGF0YS5idWZmZXIsIDAsIGJsb2NrQ291bnRzKTtcbiAgICBsZXQgazEgPSAwLFxuICAgICAgazIgPSAwO1xuICAgIGxldCBoMSA9IHRoaXMuaDEsXG4gICAgICBoMiA9IHRoaXMuaDI7XG4gICAgY29uc3QgQzEgPSAweGNjOWUyZDUxLFxuICAgICAgQzIgPSAweDFiODczNTkzO1xuICAgIGNvbnN0IEMxX0xPVyA9IEMxICYgTUFTS19MT1csXG4gICAgICBDMl9MT1cgPSBDMiAmIE1BU0tfTE9XO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tDb3VudHM7IGkrKykge1xuICAgICAgaWYgKGkgJiAxKSB7XG4gICAgICAgIGsxID0gZGF0YVVpbnQzMltpXTtcbiAgICAgICAgazEgPSBrMSAqIEMxICYgTUFTS19ISUdIIHwgazEgKiBDMV9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgazEgPSBrMSA8PCAxNSB8IGsxID4+PiAxNztcbiAgICAgICAgazEgPSBrMSAqIEMyICYgTUFTS19ISUdIIHwgazEgKiBDMl9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgaDEgXj0gazE7XG4gICAgICAgIGgxID0gaDEgPDwgMTMgfCBoMSA+Pj4gMTk7XG4gICAgICAgIGgxID0gaDEgKiA1ICsgMHhlNjU0NmI2NDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGsyID0gZGF0YVVpbnQzMltpXTtcbiAgICAgICAgazIgPSBrMiAqIEMxICYgTUFTS19ISUdIIHwgazIgKiBDMV9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgazIgPSBrMiA8PCAxNSB8IGsyID4+PiAxNztcbiAgICAgICAgazIgPSBrMiAqIEMyICYgTUFTS19ISUdIIHwgazIgKiBDMl9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgaDIgXj0gazI7XG4gICAgICAgIGgyID0gaDIgPDwgMTMgfCBoMiA+Pj4gMTk7XG4gICAgICAgIGgyID0gaDIgKiA1ICsgMHhlNjU0NmI2NDtcbiAgICAgIH1cbiAgICB9XG4gICAgazEgPSAwO1xuICAgIHN3aXRjaCAodGFpbExlbmd0aCkge1xuICAgICAgY2FzZSAzOlxuICAgICAgICBrMSBePSBkYXRhW2Jsb2NrQ291bnRzICogNCArIDJdIDw8IDE2O1xuICAgICAgY2FzZSAyOlxuICAgICAgICBrMSBePSBkYXRhW2Jsb2NrQ291bnRzICogNCArIDFdIDw8IDg7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGsxIF49IGRhdGFbYmxvY2tDb3VudHMgKiA0XTtcbiAgICAgICAgazEgPSBrMSAqIEMxICYgTUFTS19ISUdIIHwgazEgKiBDMV9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgazEgPSBrMSA8PCAxNSB8IGsxID4+PiAxNztcbiAgICAgICAgazEgPSBrMSAqIEMyICYgTUFTS19ISUdIIHwgazEgKiBDMl9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgaWYgKGJsb2NrQ291bnRzICYgMSkge1xuICAgICAgICAgIGgxIF49IGsxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGgyIF49IGsxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuaDEgPSBoMTtcbiAgICB0aGlzLmgyID0gaDI7XG4gIH1cbiAgaGV4ZGlnZXN0KCkge1xuICAgIGxldCBoMSA9IHRoaXMuaDEsXG4gICAgICBoMiA9IHRoaXMuaDI7XG4gICAgaDEgXj0gaDIgPj4+IDE7XG4gICAgaDEgPSBoMSAqIDB4ZWQ1NThjY2QgJiBNQVNLX0hJR0ggfCBoMSAqIDB4OGNjZCAmIE1BU0tfTE9XO1xuICAgIGgyID0gaDIgKiAweGZmNTFhZmQ3ICYgTUFTS19ISUdIIHwgKChoMiA8PCAxNiB8IGgxID4+PiAxNikgKiAweGFmZDdlZDU1ICYgTUFTS19ISUdIKSA+Pj4gMTY7XG4gICAgaDEgXj0gaDIgPj4+IDE7XG4gICAgaDEgPSBoMSAqIDB4MWE4NWVjNTMgJiBNQVNLX0hJR0ggfCBoMSAqIDB4ZWM1MyAmIE1BU0tfTE9XO1xuICAgIGgyID0gaDIgKiAweGM0Y2ViOWZlICYgTUFTS19ISUdIIHwgKChoMiA8PCAxNiB8IGgxID4+PiAxNikgKiAweGI5ZmUxYTg1ICYgTUFTS19ISUdIKSA+Pj4gMTY7XG4gICAgaDEgXj0gaDIgPj4+IDE7XG4gICAgcmV0dXJuIChoMSA+Pj4gMCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsIFwiMFwiKSArIChoMiA+Pj4gMCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsIFwiMFwiKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9hbm5vdGF0aW9uX3N0b3JhZ2UuanNcblxuXG5cbmNvbnN0IFNlcmlhbGl6YWJsZUVtcHR5ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIG1hcDogbnVsbCxcbiAgaGFzaDogXCJcIixcbiAgdHJhbnNmZXI6IHVuZGVmaW5lZFxufSk7XG5jbGFzcyBBbm5vdGF0aW9uU3RvcmFnZSB7XG4gICNtb2RpZmllZCA9IGZhbHNlO1xuICAjbW9kaWZpZWRJZHMgPSBudWxsO1xuICAjc3RvcmFnZSA9IG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5vblNldE1vZGlmaWVkID0gbnVsbDtcbiAgICB0aGlzLm9uUmVzZXRNb2RpZmllZCA9IG51bGw7XG4gICAgdGhpcy5vbkFubm90YXRpb25FZGl0b3IgPSBudWxsO1xuICB9XG4gIGdldFZhbHVlKGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiNzdG9yYWdlLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkZWZhdWx0VmFsdWUsIHZhbHVlKTtcbiAgfVxuICBnZXRSYXdWYWx1ZShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5nZXQoa2V5KTtcbiAgfVxuICByZW1vdmUoa2V5KSB7XG4gICAgdGhpcy4jc3RvcmFnZS5kZWxldGUoa2V5KTtcbiAgICBpZiAodGhpcy4jc3RvcmFnZS5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLnJlc2V0TW9kaWZpZWQoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuI3N0b3JhZ2UudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQW5ub3RhdGlvbkVkaXRvcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5vbkFubm90YXRpb25FZGl0b3IobnVsbCk7XG4gICAgfVxuICB9XG4gIHNldFZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBvYmogPSB0aGlzLiNzdG9yYWdlLmdldChrZXkpO1xuICAgIGxldCBtb2RpZmllZCA9IGZhbHNlO1xuICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yIChjb25zdCBbZW50cnksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgIGlmIChvYmpbZW50cnldICE9PSB2YWwpIHtcbiAgICAgICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgb2JqW2VudHJ5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICB0aGlzLiNzdG9yYWdlLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVkKSB7XG4gICAgICB0aGlzLiNzZXRNb2RpZmllZCgpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBbm5vdGF0aW9uRWRpdG9yICYmIHR5cGVvZiB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvcih2YWx1ZS5jb25zdHJ1Y3Rvci5fdHlwZSk7XG4gICAgfVxuICB9XG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5oYXMoa2V5KTtcbiAgfVxuICBnZXRBbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3N0b3JhZ2Uuc2l6ZSA+IDAgPyBvYmplY3RGcm9tTWFwKHRoaXMuI3N0b3JhZ2UpIDogbnVsbDtcbiAgfVxuICBzZXRBbGwob2JqKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKG9iaikpIHtcbiAgICAgIHRoaXMuc2V0VmFsdWUoa2V5LCB2YWwpO1xuICAgIH1cbiAgfVxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5zaXplO1xuICB9XG4gICNzZXRNb2RpZmllZCgpIHtcbiAgICBpZiAoIXRoaXMuI21vZGlmaWVkKSB7XG4gICAgICB0aGlzLiNtb2RpZmllZCA9IHRydWU7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub25TZXRNb2RpZmllZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub25TZXRNb2RpZmllZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXNldE1vZGlmaWVkKCkge1xuICAgIGlmICh0aGlzLiNtb2RpZmllZCkge1xuICAgICAgdGhpcy4jbW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vblJlc2V0TW9kaWZpZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9uUmVzZXRNb2RpZmllZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgcHJpbnQoKSB7XG4gICAgcmV0dXJuIG5ldyBQcmludEFubm90YXRpb25TdG9yYWdlKHRoaXMpO1xuICB9XG4gIGdldCBzZXJpYWxpemFibGUoKSB7XG4gICAgaWYgKHRoaXMuI3N0b3JhZ2Uuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFNlcmlhbGl6YWJsZUVtcHR5O1xuICAgIH1cbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCksXG4gICAgICBoYXNoID0gbmV3IE11cm11ckhhc2gzXzY0KCksXG4gICAgICB0cmFuc2ZlciA9IFtdO1xuICAgIGNvbnN0IGNvbnRleHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBoYXNCaXRtYXAgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcy4jc3RvcmFnZSkge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHZhbCBpbnN0YW5jZW9mIEFubm90YXRpb25FZGl0b3IgPyB2YWwuc2VyaWFsaXplKGZhbHNlLCBjb250ZXh0KSA6IHZhbDtcbiAgICAgIGlmIChzZXJpYWxpemVkKSB7XG4gICAgICAgIG1hcC5zZXQoa2V5LCBzZXJpYWxpemVkKTtcbiAgICAgICAgaGFzaC51cGRhdGUoYCR7a2V5fToke0pTT04uc3RyaW5naWZ5KHNlcmlhbGl6ZWQpfWApO1xuICAgICAgICBoYXNCaXRtYXAgfHw9ICEhc2VyaWFsaXplZC5iaXRtYXA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNCaXRtYXApIHtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgbWFwLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5iaXRtYXApIHtcbiAgICAgICAgICB0cmFuc2Zlci5wdXNoKHZhbHVlLmJpdG1hcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcC5zaXplID4gMCA/IHtcbiAgICAgIG1hcCxcbiAgICAgIGhhc2g6IGhhc2guaGV4ZGlnZXN0KCksXG4gICAgICB0cmFuc2ZlclxuICAgIH0gOiBTZXJpYWxpemFibGVFbXB0eTtcbiAgfVxuICBnZXQgZWRpdG9yU3RhdHMoKSB7XG4gICAgbGV0IHN0YXRzID0gbnVsbDtcbiAgICBjb25zdCB0eXBlVG9FZGl0b3IgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLiNzdG9yYWdlLnZhbHVlcygpKSB7XG4gICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFubm90YXRpb25FZGl0b3IpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZWRpdG9yU3RhdHMgPSB2YWx1ZS50ZWxlbWV0cnlGaW5hbERhdGE7XG4gICAgICBpZiAoIWVkaXRvclN0YXRzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICB0eXBlXG4gICAgICB9ID0gZWRpdG9yU3RhdHM7XG4gICAgICBpZiAoIXR5cGVUb0VkaXRvci5oYXModHlwZSkpIHtcbiAgICAgICAgdHlwZVRvRWRpdG9yLnNldCh0eXBlLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpLmNvbnN0cnVjdG9yKTtcbiAgICAgIH1cbiAgICAgIHN0YXRzIHx8PSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgY29uc3QgbWFwID0gc3RhdHNbdHlwZV0gfHw9IG5ldyBNYXAoKTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyhlZGl0b3JTdGF0cykpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJ0eXBlXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY291bnRlcnMgPSBtYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghY291bnRlcnMpIHtcbiAgICAgICAgICBjb3VudGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICBtYXAuc2V0KGtleSwgY291bnRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvdW50ID0gY291bnRlcnMuZ2V0KHZhbCkgPz8gMDtcbiAgICAgICAgY291bnRlcnMuc2V0KHZhbCwgY291bnQgKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBbdHlwZSwgZWRpdG9yXSBvZiB0eXBlVG9FZGl0b3IpIHtcbiAgICAgIHN0YXRzW3R5cGVdID0gZWRpdG9yLmNvbXB1dGVUZWxlbWV0cnlGaW5hbERhdGEoc3RhdHNbdHlwZV0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdHM7XG4gIH1cbiAgcmVzZXRNb2RpZmllZElkcygpIHtcbiAgICB0aGlzLiNtb2RpZmllZElkcyA9IG51bGw7XG4gIH1cbiAgZ2V0IG1vZGlmaWVkSWRzKCkge1xuICAgIGlmICh0aGlzLiNtb2RpZmllZElkcykge1xuICAgICAgcmV0dXJuIHRoaXMuI21vZGlmaWVkSWRzO1xuICAgIH1cbiAgICBjb25zdCBpZHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuI3N0b3JhZ2UudmFsdWVzKCkpIHtcbiAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQW5ub3RhdGlvbkVkaXRvcikgfHwgIXZhbHVlLmFubm90YXRpb25FbGVtZW50SWQgfHwgIXZhbHVlLnNlcmlhbGl6ZSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWRzLnB1c2godmFsdWUuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNtb2RpZmllZElkcyA9IHtcbiAgICAgIGlkczogbmV3IFNldChpZHMpLFxuICAgICAgaGFzaDogaWRzLmpvaW4oXCIsXCIpXG4gICAgfTtcbiAgfVxufVxuY2xhc3MgUHJpbnRBbm5vdGF0aW9uU3RvcmFnZSBleHRlbmRzIEFubm90YXRpb25TdG9yYWdlIHtcbiAgI3NlcmlhbGl6YWJsZTtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB7XG4gICAgICBtYXAsXG4gICAgICBoYXNoLFxuICAgICAgdHJhbnNmZXJcbiAgICB9ID0gcGFyZW50LnNlcmlhbGl6YWJsZTtcbiAgICBjb25zdCBjbG9uZSA9IHN0cnVjdHVyZWRDbG9uZShtYXAsIHRyYW5zZmVyID8ge1xuICAgICAgdHJhbnNmZXJcbiAgICB9IDogbnVsbCk7XG4gICAgdGhpcy4jc2VyaWFsaXphYmxlID0ge1xuICAgICAgbWFwOiBjbG9uZSxcbiAgICAgIGhhc2gsXG4gICAgICB0cmFuc2ZlclxuICAgIH07XG4gIH1cbiAgZ2V0IHByaW50KCkge1xuICAgIHVucmVhY2hhYmxlKFwiU2hvdWxkIG5vdCBjYWxsIFByaW50QW5ub3RhdGlvblN0b3JhZ2UucHJpbnRcIik7XG4gIH1cbiAgZ2V0IHNlcmlhbGl6YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VyaWFsaXphYmxlO1xuICB9XG4gIGdldCBtb2RpZmllZElkcygpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwibW9kaWZpZWRJZHNcIiwge1xuICAgICAgaWRzOiBuZXcgU2V0KCksXG4gICAgICBoYXNoOiBcIlwiXG4gICAgfSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZm9udF9sb2FkZXIuanNcblxuY2xhc3MgRm9udExvYWRlciB7XG4gICNzeXN0ZW1Gb250cyA9IG5ldyBTZXQoKTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxUaGlzLmRvY3VtZW50LFxuICAgIHN0eWxlRWxlbWVudCA9IG51bGxcbiAgfSkge1xuICAgIHRoaXMuX2RvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgICB0aGlzLm5hdGl2ZUZvbnRGYWNlcyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLnN0eWxlRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5sb2FkaW5nUmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLmxvYWRUZXN0Rm9udElkID0gMDtcbiAgfVxuICBhZGROYXRpdmVGb250RmFjZShuYXRpdmVGb250RmFjZSkge1xuICAgIHRoaXMubmF0aXZlRm9udEZhY2VzLmFkZChuYXRpdmVGb250RmFjZSk7XG4gICAgdGhpcy5fZG9jdW1lbnQuZm9udHMuYWRkKG5hdGl2ZUZvbnRGYWNlKTtcbiAgfVxuICByZW1vdmVOYXRpdmVGb250RmFjZShuYXRpdmVGb250RmFjZSkge1xuICAgIHRoaXMubmF0aXZlRm9udEZhY2VzLmRlbGV0ZShuYXRpdmVGb250RmFjZSk7XG4gICAgdGhpcy5fZG9jdW1lbnQuZm9udHMuZGVsZXRlKG5hdGl2ZUZvbnRGYWNlKTtcbiAgfVxuICBpbnNlcnRSdWxlKHJ1bGUpIHtcbiAgICBpZiAoIXRoaXMuc3R5bGVFbGVtZW50KSB7XG4gICAgICB0aGlzLnN0eWxlRWxlbWVudCA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgIHRoaXMuX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0uYXBwZW5kKHRoaXMuc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGVTaGVldCA9IHRoaXMuc3R5bGVFbGVtZW50LnNoZWV0O1xuICAgIHN0eWxlU2hlZXQuaW5zZXJ0UnVsZShydWxlLCBzdHlsZVNoZWV0LmNzc1J1bGVzLmxlbmd0aCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBuYXRpdmVGb250RmFjZSBvZiB0aGlzLm5hdGl2ZUZvbnRGYWNlcykge1xuICAgICAgdGhpcy5fZG9jdW1lbnQuZm9udHMuZGVsZXRlKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICB9XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMuY2xlYXIoKTtcbiAgICB0aGlzLiNzeXN0ZW1Gb250cy5jbGVhcigpO1xuICAgIGlmICh0aGlzLnN0eWxlRWxlbWVudCkge1xuICAgICAgdGhpcy5zdHlsZUVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICB0aGlzLnN0eWxlRWxlbWVudCA9IG51bGw7XG4gICAgfVxuICB9XG4gIGFzeW5jIGxvYWRTeXN0ZW1Gb250KHtcbiAgICBzeXN0ZW1Gb250SW5mbzogaW5mbyxcbiAgICBfaW5zcGVjdEZvbnRcbiAgfSkge1xuICAgIGlmICghaW5mbyB8fCB0aGlzLiNzeXN0ZW1Gb250cy5oYXMoaW5mby5sb2FkZWROYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhc3NlcnQoIXRoaXMuZGlzYWJsZUZvbnRGYWNlLCBcImxvYWRTeXN0ZW1Gb250IHNob3VsZG4ndCBiZSBjYWxsZWQgd2hlbiBgZGlzYWJsZUZvbnRGYWNlYCBpcyBzZXQuXCIpO1xuICAgIGlmICh0aGlzLmlzRm9udExvYWRpbmdBUElTdXBwb3J0ZWQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbG9hZGVkTmFtZSxcbiAgICAgICAgc3JjLFxuICAgICAgICBzdHlsZVxuICAgICAgfSA9IGluZm87XG4gICAgICBjb25zdCBmb250RmFjZSA9IG5ldyBGb250RmFjZShsb2FkZWROYW1lLCBzcmMsIHN0eWxlKTtcbiAgICAgIHRoaXMuYWRkTmF0aXZlRm9udEZhY2UoZm9udEZhY2UpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZm9udEZhY2UubG9hZCgpO1xuICAgICAgICB0aGlzLiNzeXN0ZW1Gb250cy5hZGQobG9hZGVkTmFtZSk7XG4gICAgICAgIF9pbnNwZWN0Rm9udD8uKGluZm8pO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHdhcm4oYENhbm5vdCBsb2FkIHN5c3RlbSBmb250OiAke2luZm8uYmFzZUZvbnROYW1lfSwgaW5zdGFsbGluZyBpdCBjb3VsZCBoZWxwIHRvIGltcHJvdmUgUERGIHJlbmRlcmluZy5gKTtcbiAgICAgICAgdGhpcy5yZW1vdmVOYXRpdmVGb250RmFjZShmb250RmFjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHVucmVhY2hhYmxlKFwiTm90IGltcGxlbWVudGVkOiBsb2FkU3lzdGVtRm9udCB3aXRob3V0IHRoZSBGb250IExvYWRpbmcgQVBJLlwiKTtcbiAgfVxuICBhc3luYyBiaW5kKGZvbnQpIHtcbiAgICBpZiAoZm9udC5hdHRhY2hlZCB8fCBmb250Lm1pc3NpbmdGaWxlICYmICFmb250LnN5c3RlbUZvbnRJbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvbnQuYXR0YWNoZWQgPSB0cnVlO1xuICAgIGlmIChmb250LnN5c3RlbUZvbnRJbmZvKSB7XG4gICAgICBhd2FpdCB0aGlzLmxvYWRTeXN0ZW1Gb250KGZvbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkKSB7XG4gICAgICBjb25zdCBuYXRpdmVGb250RmFjZSA9IGZvbnQuY3JlYXRlTmF0aXZlRm9udEZhY2UoKTtcbiAgICAgIGlmIChuYXRpdmVGb250RmFjZSkge1xuICAgICAgICB0aGlzLmFkZE5hdGl2ZUZvbnRGYWNlKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBuYXRpdmVGb250RmFjZS5sb2FkZWQ7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgd2FybihgRmFpbGVkIHRvIGxvYWQgZm9udCAnJHtuYXRpdmVGb250RmFjZS5mYW1pbHl9JzogJyR7ZXh9Jy5gKTtcbiAgICAgICAgICBmb250LmRpc2FibGVGb250RmFjZSA9IHRydWU7XG4gICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcnVsZSA9IGZvbnQuY3JlYXRlRm9udEZhY2VSdWxlKCk7XG4gICAgaWYgKHJ1bGUpIHtcbiAgICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlKTtcbiAgICAgIGlmICh0aGlzLmlzU3luY0ZvbnRMb2FkaW5nU3VwcG9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5fcXVldWVMb2FkaW5nQ2FsbGJhY2socmVzb2x2ZSk7XG4gICAgICAgIHRoaXMuX3ByZXBhcmVGb250TG9hZEV2ZW50KGZvbnQsIHJlcXVlc3QpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBpc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkKCkge1xuICAgIGNvbnN0IGhhc0ZvbnRzID0gISF0aGlzLl9kb2N1bWVudD8uZm9udHM7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzRm9udExvYWRpbmdBUElTdXBwb3J0ZWRcIiwgaGFzRm9udHMpO1xuICB9XG4gIGdldCBpc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZCgpIHtcbiAgICBsZXQgc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgaWYgKGlzTm9kZUpTKSB7XG4gICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgbmF2aWdhdG9yPy51c2VyQWdlbnQgPT09IFwic3RyaW5nXCIgJiYgL01vemlsbGFcXC81LjAuKj9ydjpcXGQrLio/IEdlY2tvLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWRcIiwgc3VwcG9ydGVkKTtcbiAgfVxuICBfcXVldWVMb2FkaW5nQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICBmdW5jdGlvbiBjb21wbGV0ZVJlcXVlc3QoKSB7XG4gICAgICBhc3NlcnQoIXJlcXVlc3QuZG9uZSwgXCJjb21wbGV0ZVJlcXVlc3QoKSBjYW5ub3QgYmUgY2FsbGVkIHR3aWNlLlwiKTtcbiAgICAgIHJlcXVlc3QuZG9uZSA9IHRydWU7XG4gICAgICB3aGlsZSAobG9hZGluZ1JlcXVlc3RzLmxlbmd0aCA+IDAgJiYgbG9hZGluZ1JlcXVlc3RzWzBdLmRvbmUpIHtcbiAgICAgICAgY29uc3Qgb3RoZXJSZXF1ZXN0ID0gbG9hZGluZ1JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICAgIHNldFRpbWVvdXQob3RoZXJSZXF1ZXN0LmNhbGxiYWNrLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbG9hZGluZ1JlcXVlc3RzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgY29tcGxldGU6IGNvbXBsZXRlUmVxdWVzdCxcbiAgICAgIGNhbGxiYWNrXG4gICAgfTtcbiAgICBsb2FkaW5nUmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfVxuICBnZXQgX2xvYWRUZXN0Rm9udCgpIHtcbiAgICBjb25zdCB0ZXN0Rm9udCA9IGF0b2IoXCJUMVJVVHdBTEFJQUFBd0F3UTBaR0lESHRaZzRBQUFPWUFBQUFnVVpHVkUxbGt6WndBQUFFSEFBQUFCeEhSRVZHQUJRQVwiICsgXCJGUUFBQkRnQUFBQWVUMU12TWxZTll3a0FBQUVnQUFBQVlHTnRZWEFCRFFMVUFBQUNOQUFBQVVKb1pXRmsveFZGRFFBQVwiICsgXCJBTHdBQUFBMmFHaGxZUWRrQStvQUFBRDBBQUFBSkdodGRIZ0Q2QUFBQUFBRVdBQUFBQVp0WVhod0FBSlFBQUFBQVJnQVwiICsgXCJBQUFHYm1GdFpWam1kSDRBQUFHQUFBQUFzWEJ2YzNUL2hnQXpBQUFEZUFBQUFDQUFBUUFBQUFFQUFMWlJGc1JmRHp6MVwiICsgXCJBQXNENkFBQUFBRE9CT1RMQUFBQUFNNEtIRHdBQUFBQUErZ0RJUUFBQUFnQUFnQUFBQUFBQUFBQkFBQURJUUFBQUZvRFwiICsgXCI2QUFBQUFBRDZBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUFVQUFBQWdBQUFBUUQ2QUgwQUFVQUFBS0tBcndBQUFDTVwiICsgXCJBb29DdkFBQUFlQUFNUUVDQUFBQ0FBWUpBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUZCbVJXUUF3QUF1QUM0RFwiICsgXCJJUDg0QUZvRElRQUFBQUFBQVFBQUFBQUFBQUFBQUNBQUlBQUJBQUFBRGdDdUFBRUFBQUFBQUFBQUFRQUFBQUVBQUFBQVwiICsgXCJBQUVBQVFBQUFBRUFBQUFBQUFJQUFRQUFBQUVBQUFBQUFBTUFBUUFBQUFFQUFBQUFBQVFBQVFBQUFBRUFBQUFBQUFVQVwiICsgXCJBUUFBQUFFQUFBQUFBQVlBQVFBQUFBTUFBUVFKQUFBQUFnQUJBQU1BQVFRSkFBRUFBZ0FCQUFNQUFRUUpBQUlBQWdBQlwiICsgXCJBQU1BQVFRSkFBTUFBZ0FCQUFNQUFRUUpBQVFBQWdBQkFBTUFBUVFKQUFVQUFnQUJBQU1BQVFRSkFBWUFBZ0FCV0FCWVwiICsgXCJBQUFBQUFBQUF3QUFBQU1BQUFBY0FBRUFBQUFBQUR3QUF3QUJBQUFBSEFBRUFDQUFBQUFFQUFRQUFRQUFBQzcvL3dBQVwiICsgXCJBQzcvLy8vVEFBRUFBQUFBQUFBQkJnQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFNQUFBQUFBQUQvZ3dBeUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFCQUFRRUFBRUJBUUpZQUFFQkFTSDREd0Q0R3dIRUF2Z2NBL2dYQkl3TUFZdUwrbno1dFFYa0Q1ajNDQkxuRVFBQ1wiICsgXCJBUUVCSVZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlBQUFCQVFBQUR3QUNBUUVFRS90M1wiICsgXCJEb3Y2ZkFINmZBVCtmUHA4K253SERvc01Ddm0xQ3ZtMURBejZmQlFBQUFBQUFBQUJBQUFBQU1tSmJ6RUFBQUFBemdUalwiICsgXCJGUUFBQUFET0JPUXBBQUVBQUFBQUFBQUFEQUFVQUFRQUFBQUJBQUFBQWdBQkFBQUFBQUFBQUFBRDZBQUFBQUFBQUE9PVwiKTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2xvYWRUZXN0Rm9udFwiLCB0ZXN0Rm9udCk7XG4gIH1cbiAgX3ByZXBhcmVGb250TG9hZEV2ZW50KGZvbnQsIHJlcXVlc3QpIHtcbiAgICBmdW5jdGlvbiBpbnQzMihkYXRhLCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0KSA8PCAyNCB8IGRhdGEuY2hhckNvZGVBdChvZmZzZXQgKyAxKSA8PCAxNiB8IGRhdGEuY2hhckNvZGVBdChvZmZzZXQgKyAyKSA8PCA4IHwgZGF0YS5jaGFyQ29kZUF0KG9mZnNldCArIDMpICYgMHhmZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3BsaWNlU3RyaW5nKHMsIG9mZnNldCwgcmVtb3ZlLCBpbnNlcnQpIHtcbiAgICAgIGNvbnN0IGNodW5rMSA9IHMuc3Vic3RyaW5nKDAsIG9mZnNldCk7XG4gICAgICBjb25zdCBjaHVuazIgPSBzLnN1YnN0cmluZyhvZmZzZXQgKyByZW1vdmUpO1xuICAgICAgcmV0dXJuIGNodW5rMSArIGluc2VydCArIGNodW5rMjtcbiAgICB9XG4gICAgbGV0IGksIGlpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gMTtcbiAgICBjYW52YXMuaGVpZ2h0ID0gMTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGxldCBjYWxsZWQgPSAwO1xuICAgIGZ1bmN0aW9uIGlzRm9udFJlYWR5KG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoKytjYWxsZWQgPiAzMCkge1xuICAgICAgICB3YXJuKFwiTG9hZCB0ZXN0IGZvbnQgbmV2ZXIgbG9hZGVkLlwiKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LmZvbnQgPSBcIjMwcHggXCIgKyBuYW1lO1xuICAgICAgY3R4LmZpbGxUZXh0KFwiLlwiLCAwLCAyMCk7XG4gICAgICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpO1xuICAgICAgaWYgKGltYWdlRGF0YS5kYXRhWzNdID4gMCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KGlzRm9udFJlYWR5LmJpbmQobnVsbCwgbmFtZSwgY2FsbGJhY2spKTtcbiAgICB9XG4gICAgY29uc3QgbG9hZFRlc3RGb250SWQgPSBgbHQke0RhdGUubm93KCl9JHt0aGlzLmxvYWRUZXN0Rm9udElkKyt9YDtcbiAgICBsZXQgZGF0YSA9IHRoaXMuX2xvYWRUZXN0Rm9udDtcbiAgICBjb25zdCBDT01NRU5UX09GRlNFVCA9IDk3NjtcbiAgICBkYXRhID0gc3BsaWNlU3RyaW5nKGRhdGEsIENPTU1FTlRfT0ZGU0VULCBsb2FkVGVzdEZvbnRJZC5sZW5ndGgsIGxvYWRUZXN0Rm9udElkKTtcbiAgICBjb25zdCBDRkZfQ0hFQ0tTVU1fT0ZGU0VUID0gMTY7XG4gICAgY29uc3QgWFhYWF9WQUxVRSA9IDB4NTg1ODU4NTg7XG4gICAgbGV0IGNoZWNrc3VtID0gaW50MzIoZGF0YSwgQ0ZGX0NIRUNLU1VNX09GRlNFVCk7XG4gICAgZm9yIChpID0gMCwgaWkgPSBsb2FkVGVzdEZvbnRJZC5sZW5ndGggLSAzOyBpIDwgaWk7IGkgKz0gNCkge1xuICAgICAgY2hlY2tzdW0gPSBjaGVja3N1bSAtIFhYWFhfVkFMVUUgKyBpbnQzMihsb2FkVGVzdEZvbnRJZCwgaSkgfCAwO1xuICAgIH1cbiAgICBpZiAoaSA8IGxvYWRUZXN0Rm9udElkLmxlbmd0aCkge1xuICAgICAgY2hlY2tzdW0gPSBjaGVja3N1bSAtIFhYWFhfVkFMVUUgKyBpbnQzMihsb2FkVGVzdEZvbnRJZCArIFwiWFhYXCIsIGkpIHwgMDtcbiAgICB9XG4gICAgZGF0YSA9IHNwbGljZVN0cmluZyhkYXRhLCBDRkZfQ0hFQ0tTVU1fT0ZGU0VULCA0LCBzdHJpbmczMihjaGVja3N1bSkpO1xuICAgIGNvbnN0IHVybCA9IGB1cmwoZGF0YTpmb250L29wZW50eXBlO2Jhc2U2NCwke2J0b2EoZGF0YSl9KTtgO1xuICAgIGNvbnN0IHJ1bGUgPSBgQGZvbnQtZmFjZSB7Zm9udC1mYW1pbHk6XCIke2xvYWRUZXN0Rm9udElkfVwiO3NyYzoke3VybH19YDtcbiAgICB0aGlzLmluc2VydFJ1bGUocnVsZSk7XG4gICAgY29uc3QgZGl2ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgZGl2LnN0eWxlLndpZHRoID0gZGl2LnN0eWxlLmhlaWdodCA9IFwiMTBweFwiO1xuICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBkaXYuc3R5bGUudG9wID0gZGl2LnN0eWxlLmxlZnQgPSBcIjBweFwiO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBbZm9udC5sb2FkZWROYW1lLCBsb2FkVGVzdEZvbnRJZF0pIHtcbiAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBcIkhpXCI7XG4gICAgICBzcGFuLnN0eWxlLmZvbnRGYW1pbHkgPSBuYW1lO1xuICAgICAgZGl2LmFwcGVuZChzcGFuKTtcbiAgICB9XG4gICAgdGhpcy5fZG9jdW1lbnQuYm9keS5hcHBlbmQoZGl2KTtcbiAgICBpc0ZvbnRSZWFkeShsb2FkVGVzdEZvbnRJZCwgKCkgPT4ge1xuICAgICAgZGl2LnJlbW92ZSgpO1xuICAgICAgcmVxdWVzdC5jb21wbGV0ZSgpO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBGb250RmFjZU9iamVjdCB7XG4gIGNvbnN0cnVjdG9yKHRyYW5zbGF0ZWREYXRhLCB7XG4gICAgZGlzYWJsZUZvbnRGYWNlID0gZmFsc2UsXG4gICAgZm9udEV4dHJhUHJvcGVydGllcyA9IGZhbHNlLFxuICAgIGluc3BlY3RGb250ID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5jb21waWxlZEdseXBocyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChjb25zdCBpIGluIHRyYW5zbGF0ZWREYXRhKSB7XG4gICAgICB0aGlzW2ldID0gdHJhbnNsYXRlZERhdGFbaV07XG4gICAgfVxuICAgIHRoaXMuZGlzYWJsZUZvbnRGYWNlID0gZGlzYWJsZUZvbnRGYWNlID09PSB0cnVlO1xuICAgIHRoaXMuZm9udEV4dHJhUHJvcGVydGllcyA9IGZvbnRFeHRyYVByb3BlcnRpZXMgPT09IHRydWU7XG4gICAgdGhpcy5faW5zcGVjdEZvbnQgPSBpbnNwZWN0Rm9udDtcbiAgfVxuICBjcmVhdGVOYXRpdmVGb250RmFjZSgpIHtcbiAgICBpZiAoIXRoaXMuZGF0YSB8fCB0aGlzLmRpc2FibGVGb250RmFjZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBuYXRpdmVGb250RmFjZTtcbiAgICBpZiAoIXRoaXMuY3NzRm9udEluZm8pIHtcbiAgICAgIG5hdGl2ZUZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKHRoaXMubG9hZGVkTmFtZSwgdGhpcy5kYXRhLCB7fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNzcyA9IHtcbiAgICAgICAgd2VpZ2h0OiB0aGlzLmNzc0ZvbnRJbmZvLmZvbnRXZWlnaHRcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jc3NGb250SW5mby5pdGFsaWNBbmdsZSkge1xuICAgICAgICBjc3Muc3R5bGUgPSBgb2JsaXF1ZSAke3RoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGV9ZGVnYDtcbiAgICAgIH1cbiAgICAgIG5hdGl2ZUZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKHRoaXMuY3NzRm9udEluZm8uZm9udEZhbWlseSwgdGhpcy5kYXRhLCBjc3MpO1xuICAgIH1cbiAgICB0aGlzLl9pbnNwZWN0Rm9udD8uKHRoaXMpO1xuICAgIHJldHVybiBuYXRpdmVGb250RmFjZTtcbiAgfVxuICBjcmVhdGVGb250RmFjZVJ1bGUoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kaXNhYmxlRm9udEZhY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBgdXJsKGRhdGE6JHt0aGlzLm1pbWV0eXBlfTtiYXNlNjQsJHt0b0Jhc2U2NFV0aWwodGhpcy5kYXRhKX0pO2A7XG4gICAgbGV0IHJ1bGU7XG4gICAgaWYgKCF0aGlzLmNzc0ZvbnRJbmZvKSB7XG4gICAgICBydWxlID0gYEBmb250LWZhY2Uge2ZvbnQtZmFtaWx5OlwiJHt0aGlzLmxvYWRlZE5hbWV9XCI7c3JjOiR7dXJsfX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY3NzID0gYGZvbnQtd2VpZ2h0OiAke3RoaXMuY3NzRm9udEluZm8uZm9udFdlaWdodH07YDtcbiAgICAgIGlmICh0aGlzLmNzc0ZvbnRJbmZvLml0YWxpY0FuZ2xlKSB7XG4gICAgICAgIGNzcyArPSBgZm9udC1zdHlsZTogb2JsaXF1ZSAke3RoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGV9ZGVnO2A7XG4gICAgICB9XG4gICAgICBydWxlID0gYEBmb250LWZhY2Uge2ZvbnQtZmFtaWx5OlwiJHt0aGlzLmNzc0ZvbnRJbmZvLmZvbnRGYW1pbHl9XCI7JHtjc3N9c3JjOiR7dXJsfX1gO1xuICAgIH1cbiAgICB0aGlzLl9pbnNwZWN0Rm9udD8uKHRoaXMsIHVybCk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgZ2V0UGF0aEdlbmVyYXRvcihvYmpzLCBjaGFyYWN0ZXIpIHtcbiAgICBpZiAodGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl07XG4gICAgfVxuICAgIGNvbnN0IG9iaklkID0gdGhpcy5sb2FkZWROYW1lICsgXCJfcGF0aF9cIiArIGNoYXJhY3RlcjtcbiAgICBsZXQgY21kcztcbiAgICB0cnkge1xuICAgICAgY21kcyA9IG9ianMuZ2V0KG9iaklkKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgd2FybihgZ2V0UGF0aEdlbmVyYXRvciAtIGlnbm9yaW5nIGNoYXJhY3RlcjogXCIke2V4fVwiLmApO1xuICAgIH1cbiAgICBjb25zdCBwYXRoID0gbmV3IFBhdGgyRChjbWRzIHx8IFwiXCIpO1xuICAgIGlmICghdGhpcy5mb250RXh0cmFQcm9wZXJ0aWVzKSB7XG4gICAgICBvYmpzLmRlbGV0ZShvYmpJZCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl0gPSBwYXRoO1xuICB9XG59XG5cbjsvLyAuL3NyYy9zaGFyZWQvbWVzc2FnZV9oYW5kbGVyLmpzXG5cbmNvbnN0IENhbGxiYWNrS2luZCA9IHtcbiAgREFUQTogMSxcbiAgRVJST1I6IDJcbn07XG5jb25zdCBTdHJlYW1LaW5kID0ge1xuICBDQU5DRUw6IDEsXG4gIENBTkNFTF9DT01QTEVURTogMixcbiAgQ0xPU0U6IDMsXG4gIEVOUVVFVUU6IDQsXG4gIEVSUk9SOiA1LFxuICBQVUxMOiA2LFxuICBQVUxMX0NPTVBMRVRFOiA3LFxuICBTVEFSVF9DT01QTEVURTogOFxufTtcbmZ1bmN0aW9uIG9uRm4oKSB7fVxuZnVuY3Rpb24gd3JhcFJlYXNvbihleCkge1xuICBpZiAoZXggaW5zdGFuY2VvZiBBYm9ydEV4Y2VwdGlvbiB8fCBleCBpbnN0YW5jZW9mIEludmFsaWRQREZFeGNlcHRpb24gfHwgZXggaW5zdGFuY2VvZiBNaXNzaW5nUERGRXhjZXB0aW9uIHx8IGV4IGluc3RhbmNlb2YgUGFzc3dvcmRFeGNlcHRpb24gfHwgZXggaW5zdGFuY2VvZiBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24gfHwgZXggaW5zdGFuY2VvZiBVbmtub3duRXJyb3JFeGNlcHRpb24pIHtcbiAgICByZXR1cm4gZXg7XG4gIH1cbiAgaWYgKCEoZXggaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgZXggPT09IFwib2JqZWN0XCIgJiYgZXggIT09IG51bGwpKSB7XG4gICAgdW5yZWFjaGFibGUoJ3dyYXBSZWFzb246IEV4cGVjdGVkIFwicmVhc29uXCIgdG8gYmUgYSAocG9zc2libHkgY2xvbmVkKSBFcnJvci4nKTtcbiAgfVxuICBzd2l0Y2ggKGV4Lm5hbWUpIHtcbiAgICBjYXNlIFwiQWJvcnRFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgQWJvcnRFeGNlcHRpb24oZXgubWVzc2FnZSk7XG4gICAgY2FzZSBcIkludmFsaWRQREZFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgSW52YWxpZFBERkV4Y2VwdGlvbihleC5tZXNzYWdlKTtcbiAgICBjYXNlIFwiTWlzc2luZ1BERkV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBNaXNzaW5nUERGRXhjZXB0aW9uKGV4Lm1lc3NhZ2UpO1xuICAgIGNhc2UgXCJQYXNzd29yZEV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBQYXNzd29yZEV4Y2VwdGlvbihleC5tZXNzYWdlLCBleC5jb2RlKTtcbiAgICBjYXNlIFwiVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbihleC5tZXNzYWdlLCBleC5zdGF0dXMpO1xuICAgIGNhc2UgXCJVbmtub3duRXJyb3JFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgVW5rbm93bkVycm9yRXhjZXB0aW9uKGV4Lm1lc3NhZ2UsIGV4LmRldGFpbHMpO1xuICB9XG4gIHJldHVybiBuZXcgVW5rbm93bkVycm9yRXhjZXB0aW9uKGV4Lm1lc3NhZ2UsIGV4LnRvU3RyaW5nKCkpO1xufVxuY2xhc3MgTWVzc2FnZUhhbmRsZXIge1xuICAjbWVzc2FnZUFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICBjb25zdHJ1Y3Rvcihzb3VyY2VOYW1lLCB0YXJnZXROYW1lLCBjb21PYmopIHtcbiAgICB0aGlzLnNvdXJjZU5hbWUgPSBzb3VyY2VOYW1lO1xuICAgIHRoaXMudGFyZ2V0TmFtZSA9IHRhcmdldE5hbWU7XG4gICAgdGhpcy5jb21PYmogPSBjb21PYmo7XG4gICAgdGhpcy5jYWxsYmFja0lkID0gMTtcbiAgICB0aGlzLnN0cmVhbUlkID0gMTtcbiAgICB0aGlzLnN0cmVhbVNpbmtzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmFjdGlvbkhhbmRsZXIgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbU9iai5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLiNvbk1lc3NhZ2UuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsOiB0aGlzLiNtZXNzYWdlQUMuc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgI29uTWVzc2FnZSh7XG4gICAgZGF0YVxuICB9KSB7XG4gICAgaWYgKGRhdGEudGFyZ2V0TmFtZSAhPT0gdGhpcy5zb3VyY2VOYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhLnN0cmVhbSkge1xuICAgICAgdGhpcy4jcHJvY2Vzc1N0cmVhbU1lc3NhZ2UoZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhLmNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBjYWxsYmFja0lkID0gZGF0YS5jYWxsYmFja0lkO1xuICAgICAgY29uc3QgY2FwYWJpbGl0eSA9IHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF07XG4gICAgICBpZiAoIWNhcGFiaWxpdHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVzb2x2ZSBjYWxsYmFjayAke2NhbGxiYWNrSWR9YCk7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllc1tjYWxsYmFja0lkXTtcbiAgICAgIGlmIChkYXRhLmNhbGxiYWNrID09PSBDYWxsYmFja0tpbmQuREFUQSkge1xuICAgICAgICBjYXBhYmlsaXR5LnJlc29sdmUoZGF0YS5kYXRhKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS5jYWxsYmFjayA9PT0gQ2FsbGJhY2tLaW5kLkVSUk9SKSB7XG4gICAgICAgIGNhcGFiaWxpdHkucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgY2FsbGJhY2sgY2FzZVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYWN0aW9uID0gdGhpcy5hY3Rpb25IYW5kbGVyW2RhdGEuYWN0aW9uXTtcbiAgICBpZiAoIWFjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGFjdGlvbiBmcm9tIHdvcmtlcjogJHtkYXRhLmFjdGlvbn1gKTtcbiAgICB9XG4gICAgaWYgKGRhdGEuY2FsbGJhY2tJZCkge1xuICAgICAgY29uc3Qgc291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZSxcbiAgICAgICAgdGFyZ2V0TmFtZSA9IGRhdGEuc291cmNlTmFtZSxcbiAgICAgICAgY29tT2JqID0gdGhpcy5jb21PYmo7XG4gICAgICBQcm9taXNlLnRyeShhY3Rpb24sIGRhdGEuZGF0YSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIGNhbGxiYWNrOiBDYWxsYmFja0tpbmQuREFUQSxcbiAgICAgICAgICBjYWxsYmFja0lkOiBkYXRhLmNhbGxiYWNrSWQsXG4gICAgICAgICAgZGF0YTogcmVzdWx0XG4gICAgICAgIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBjYWxsYmFjazogQ2FsbGJhY2tLaW5kLkVSUk9SLFxuICAgICAgICAgIGNhbGxiYWNrSWQ6IGRhdGEuY2FsbGJhY2tJZCxcbiAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YS5zdHJlYW1JZCkge1xuICAgICAgdGhpcy4jY3JlYXRlU3RyZWFtU2luayhkYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYWN0aW9uKGRhdGEuZGF0YSk7XG4gIH1cbiAgb24oYWN0aW9uTmFtZSwgaGFuZGxlcikge1xuICAgIGNvbnN0IGFoID0gdGhpcy5hY3Rpb25IYW5kbGVyO1xuICAgIGlmIChhaFthY3Rpb25OYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBhbHJlYWR5IGFuIGFjdGlvbk5hbWUgY2FsbGVkIFwiJHthY3Rpb25OYW1lfVwiYCk7XG4gICAgfVxuICAgIGFoW2FjdGlvbk5hbWVdID0gaGFuZGxlcjtcbiAgfVxuICBzZW5kKGFjdGlvbk5hbWUsIGRhdGEsIHRyYW5zZmVycykge1xuICAgIHRoaXMuY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgIHNvdXJjZU5hbWU6IHRoaXMuc291cmNlTmFtZSxcbiAgICAgIHRhcmdldE5hbWU6IHRoaXMudGFyZ2V0TmFtZSxcbiAgICAgIGFjdGlvbjogYWN0aW9uTmFtZSxcbiAgICAgIGRhdGFcbiAgICB9LCB0cmFuc2ZlcnMpO1xuICB9XG4gIHNlbmRXaXRoUHJvbWlzZShhY3Rpb25OYW1lLCBkYXRhLCB0cmFuc2ZlcnMpIHtcbiAgICBjb25zdCBjYWxsYmFja0lkID0gdGhpcy5jYWxsYmFja0lkKys7XG4gICAgY29uc3QgY2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF0gPSBjYXBhYmlsaXR5O1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHNvdXJjZU5hbWU6IHRoaXMuc291cmNlTmFtZSxcbiAgICAgICAgdGFyZ2V0TmFtZTogdGhpcy50YXJnZXROYW1lLFxuICAgICAgICBhY3Rpb246IGFjdGlvbk5hbWUsXG4gICAgICAgIGNhbGxiYWNrSWQsXG4gICAgICAgIGRhdGFcbiAgICAgIH0sIHRyYW5zZmVycyk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGNhcGFiaWxpdHkucmVqZWN0KGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBzZW5kV2l0aFN0cmVhbShhY3Rpb25OYW1lLCBkYXRhLCBxdWV1ZWluZ1N0cmF0ZWd5LCB0cmFuc2ZlcnMpIHtcbiAgICBjb25zdCBzdHJlYW1JZCA9IHRoaXMuc3RyZWFtSWQrKyxcbiAgICAgIHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICB0YXJnZXROYW1lID0gdGhpcy50YXJnZXROYW1lLFxuICAgICAgY29tT2JqID0gdGhpcy5jb21PYmo7XG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBzdGFydDogY29udHJvbGxlciA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0Q2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXSA9IHtcbiAgICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICAgIHN0YXJ0Q2FsbDogc3RhcnRDYXBhYmlsaXR5LFxuICAgICAgICAgIHB1bGxDYWxsOiBudWxsLFxuICAgICAgICAgIGNhbmNlbENhbGw6IG51bGwsXG4gICAgICAgICAgaXNDbG9zZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uTmFtZSxcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGRlc2lyZWRTaXplOiBjb250cm9sbGVyLmRlc2lyZWRTaXplXG4gICAgICAgIH0sIHRyYW5zZmVycyk7XG4gICAgICAgIHJldHVybiBzdGFydENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgIH0sXG4gICAgICBwdWxsOiBjb250cm9sbGVyID0+IHtcbiAgICAgICAgY29uc3QgcHVsbENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0ucHVsbENhbGwgPSBwdWxsQ2FwYWJpbGl0eTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTEwsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgZGVzaXJlZFNpemU6IGNvbnRyb2xsZXIuZGVzaXJlZFNpemVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwdWxsQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgfSxcbiAgICAgIGNhbmNlbDogcmVhc29uID0+IHtcbiAgICAgICAgYXNzZXJ0KHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yLCBcImNhbmNlbCBtdXN0IGhhdmUgYSB2YWxpZCByZWFzb25cIik7XG4gICAgICAgIGNvbnN0IGNhbmNlbENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uY2FuY2VsQ2FsbCA9IGNhbmNlbENhcGFiaWxpdHk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkNBTkNFTCxcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNhbmNlbENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgIH1cbiAgICB9LCBxdWV1ZWluZ1N0cmF0ZWd5KTtcbiAgfVxuICAjY3JlYXRlU3RyZWFtU2luayhkYXRhKSB7XG4gICAgY29uc3Qgc3RyZWFtSWQgPSBkYXRhLnN0cmVhbUlkLFxuICAgICAgc291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZSxcbiAgICAgIHRhcmdldE5hbWUgPSBkYXRhLnNvdXJjZU5hbWUsXG4gICAgICBjb21PYmogPSB0aGlzLmNvbU9iajtcbiAgICBjb25zdCBzZWxmID0gdGhpcyxcbiAgICAgIGFjdGlvbiA9IHRoaXMuYWN0aW9uSGFuZGxlcltkYXRhLmFjdGlvbl07XG4gICAgY29uc3Qgc3RyZWFtU2luayA9IHtcbiAgICAgIGVucXVldWUoY2h1bmssIHNpemUgPSAxLCB0cmFuc2ZlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdERlc2lyZWRTaXplID0gdGhpcy5kZXNpcmVkU2l6ZTtcbiAgICAgICAgdGhpcy5kZXNpcmVkU2l6ZSAtPSBzaXplO1xuICAgICAgICBpZiAobGFzdERlc2lyZWRTaXplID4gMCAmJiB0aGlzLmRlc2lyZWRTaXplIDw9IDApIHtcbiAgICAgICAgICB0aGlzLnNpbmtDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICAgICAgdGhpcy5yZWFkeSA9IHRoaXMuc2lua0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuRU5RVUVVRSxcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICBjaHVua1xuICAgICAgICB9LCB0cmFuc2ZlcnMpO1xuICAgICAgfSxcbiAgICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkNMT1NFLFxuICAgICAgICAgIHN0cmVhbUlkXG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgc2VsZi5zdHJlYW1TaW5rc1tzdHJlYW1JZF07XG4gICAgICB9LFxuICAgICAgZXJyb3IocmVhc29uKSB7XG4gICAgICAgIGFzc2VydChyZWFzb24gaW5zdGFuY2VvZiBFcnJvciwgXCJlcnJvciBtdXN0IGhhdmUgYSB2YWxpZCByZWFzb25cIik7XG4gICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuRVJST1IsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgc2lua0NhcGFiaWxpdHk6IFByb21pc2Uud2l0aFJlc29sdmVycygpLFxuICAgICAgb25QdWxsOiBudWxsLFxuICAgICAgb25DYW5jZWw6IG51bGwsXG4gICAgICBpc0NhbmNlbGxlZDogZmFsc2UsXG4gICAgICBkZXNpcmVkU2l6ZTogZGF0YS5kZXNpcmVkU2l6ZSxcbiAgICAgIHJlYWR5OiBudWxsXG4gICAgfTtcbiAgICBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICBzdHJlYW1TaW5rLnJlYWR5ID0gc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIHRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdID0gc3RyZWFtU2luaztcbiAgICBQcm9taXNlLnRyeShhY3Rpb24sIGRhdGEuZGF0YSwgc3RyZWFtU2luaykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuU1RBUlRfQ09NUExFVEUsXG4gICAgICAgIHN0cmVhbUlkLFxuICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuU1RBUlRfQ09NUExFVEUsXG4gICAgICAgIHN0cmVhbUlkLFxuICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgI3Byb2Nlc3NTdHJlYW1NZXNzYWdlKGRhdGEpIHtcbiAgICBjb25zdCBzdHJlYW1JZCA9IGRhdGEuc3RyZWFtSWQsXG4gICAgICBzb3VyY2VOYW1lID0gdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgdGFyZ2V0TmFtZSA9IGRhdGEuc291cmNlTmFtZSxcbiAgICAgIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgIGNvbnN0IHN0cmVhbUNvbnRyb2xsZXIgPSB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXSxcbiAgICAgIHN0cmVhbVNpbmsgPSB0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXTtcbiAgICBzd2l0Y2ggKGRhdGEuc3RyZWFtKSB7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuU1RBUlRfQ09NUExFVEU6XG4gICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnN0YXJ0Q2FsbC5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5zdGFydENhbGwucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFOlxuICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5wdWxsQ2FsbC5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5wdWxsQ2FsbC5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLlBVTEw6XG4gICAgICAgIGlmICghc3RyZWFtU2luaykge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbVNpbmsuZGVzaXJlZFNpemUgPD0gMCAmJiBkYXRhLmRlc2lyZWRTaXplID4gMCkge1xuICAgICAgICAgIHN0cmVhbVNpbmsuc2lua0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbVNpbmsuZGVzaXJlZFNpemUgPSBkYXRhLmRlc2lyZWRTaXplO1xuICAgICAgICBQcm9taXNlLnRyeShzdHJlYW1TaW5rLm9uUHVsbCB8fCBvbkZuKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5FTlFVRVVFOlxuICAgICAgICBhc3NlcnQoc3RyZWFtQ29udHJvbGxlciwgXCJlbnF1ZXVlIHNob3VsZCBoYXZlIHN0cmVhbSBjb250cm9sbGVyXCIpO1xuICAgICAgICBpZiAoc3RyZWFtQ29udHJvbGxlci5pc0Nsb3NlZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY29udHJvbGxlci5lbnF1ZXVlKGRhdGEuY2h1bmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5DTE9TRTpcbiAgICAgICAgYXNzZXJ0KHN0cmVhbUNvbnRyb2xsZXIsIFwiY2xvc2Ugc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXJcIik7XG4gICAgICAgIGlmIChzdHJlYW1Db250cm9sbGVyLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtQ29udHJvbGxlci5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB0aGlzLiNkZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIsIHN0cmVhbUlkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuRVJST1I6XG4gICAgICAgIGFzc2VydChzdHJlYW1Db250cm9sbGVyLCBcImVycm9yIHNob3VsZCBoYXZlIHN0cmVhbSBjb250cm9sbGVyXCIpO1xuICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNvbnRyb2xsZXIuZXJyb3Iod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB0aGlzLiNkZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIsIHN0cmVhbUlkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuQ0FOQ0VMX0NPTVBMRVRFOlxuICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jYW5jZWxDYWxsLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNhbmNlbENhbGwucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNkZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIsIHN0cmVhbUlkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuQ0FOQ0VMOlxuICAgICAgICBpZiAoIXN0cmVhbVNpbmspIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhUmVhc29uID0gd3JhcFJlYXNvbihkYXRhLnJlYXNvbik7XG4gICAgICAgIFByb21pc2UudHJ5KHN0cmVhbVNpbmsub25DYW5jZWwgfHwgb25GbiwgZGF0YVJlYXNvbikudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkNBTkNFTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkNBTkNFTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0cmVhbVNpbmsuc2lua0NhcGFiaWxpdHkucmVqZWN0KGRhdGFSZWFzb24pO1xuICAgICAgICBzdHJlYW1TaW5rLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgc3RyZWFtIGNhc2VcIik7XG4gICAgfVxuICB9XG4gIGFzeW5jICNkZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIsIHN0cmVhbUlkKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKFtzdHJlYW1Db250cm9sbGVyLnN0YXJ0Q2FsbD8ucHJvbWlzZSwgc3RyZWFtQ29udHJvbGxlci5wdWxsQ2FsbD8ucHJvbWlzZSwgc3RyZWFtQ29udHJvbGxlci5jYW5jZWxDYWxsPy5wcm9taXNlXSk7XG4gICAgZGVsZXRlIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jbWVzc2FnZUFDPy5hYm9ydCgpO1xuICAgIHRoaXMuI21lc3NhZ2VBQyA9IG51bGw7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvY2FudmFzX2ZhY3RvcnkuanNcblxuY2xhc3MgQmFzZUNhbnZhc0ZhY3Rvcnkge1xuICAjZW5hYmxlSFdBID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBlbmFibGVIV0EgPSBmYWxzZVxuICB9KSB7XG4gICAgdGhpcy4jZW5hYmxlSFdBID0gZW5hYmxlSFdBO1xuICB9XG4gIGNyZWF0ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY2FudmFzIHNpemVcIik7XG4gICAgfVxuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2NyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzLFxuICAgICAgY29udGV4dDogY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogIXRoaXMuI2VuYWJsZUhXQVxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHJlc2V0KGNhbnZhc0FuZENvbnRleHQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoIWNhbnZhc0FuZENvbnRleHQuY2FudmFzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgaXMgbm90IHNwZWNpZmllZFwiKTtcbiAgICB9XG4gICAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY2FudmFzIHNpemVcIik7XG4gICAgfVxuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG4gIGRlc3Ryb3koY2FudmFzQW5kQ29udGV4dCkge1xuICAgIGlmICghY2FudmFzQW5kQ29udGV4dC5jYW52YXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBpcyBub3Qgc3BlY2lmaWVkXCIpO1xuICAgIH1cbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy53aWR0aCA9IDA7XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcyA9IG51bGw7XG4gICAgY2FudmFzQW5kQ29udGV4dC5jb250ZXh0ID0gbnVsbDtcbiAgfVxuICBfY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgX2NyZWF0ZUNhbnZhc2AgY2FsbGVkLlwiKTtcbiAgfVxufVxuY2xhc3MgRE9NQ2FudmFzRmFjdG9yeSBleHRlbmRzIEJhc2VDYW52YXNGYWN0b3J5IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxUaGlzLmRvY3VtZW50LFxuICAgIGVuYWJsZUhXQSA9IGZhbHNlXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBlbmFibGVIV0FcbiAgICB9KTtcbiAgICB0aGlzLl9kb2N1bWVudCA9IG93bmVyRG9jdW1lbnQ7XG4gIH1cbiAgX2NyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiBjYW52YXM7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvY21hcF9yZWFkZXJfZmFjdG9yeS5qc1xuXG5cbmNsYXNzIEJhc2VDTWFwUmVhZGVyRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBiYXNlVXJsID0gbnVsbCxcbiAgICBpc0NvbXByZXNzZWQgPSB0cnVlXG4gIH0pIHtcbiAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICAgIHRoaXMuaXNDb21wcmVzc2VkID0gaXNDb21wcmVzc2VkO1xuICB9XG4gIGFzeW5jIGZldGNoKHtcbiAgICBuYW1lXG4gIH0pIHtcbiAgICBpZiAoIXRoaXMuYmFzZVVybCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoYXQgdGhlIGBjTWFwVXJsYCBhbmQgYGNNYXBQYWNrZWRgIEFQSSBwYXJhbWV0ZXJzIGFyZSBwcm92aWRlZC5cIik7XG4gICAgfVxuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ01hcCBuYW1lIG11c3QgYmUgc3BlY2lmaWVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gdGhpcy5iYXNlVXJsICsgbmFtZSArICh0aGlzLmlzQ29tcHJlc3NlZCA/IFwiLmJjbWFwXCIgOiBcIlwiKTtcbiAgICByZXR1cm4gdGhpcy5fZmV0Y2godXJsKS50aGVuKGNNYXBEYXRhID0+ICh7XG4gICAgICBjTWFwRGF0YSxcbiAgICAgIGlzQ29tcHJlc3NlZDogdGhpcy5pc0NvbXByZXNzZWRcbiAgICB9KSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGxvYWQgJHt0aGlzLmlzQ29tcHJlc3NlZCA/IFwiYmluYXJ5IFwiIDogXCJcIn1DTWFwIGF0OiAke3VybH1gKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBfZmV0Y2godXJsKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYF9mZXRjaGAgY2FsbGVkLlwiKTtcbiAgfVxufVxuY2xhc3MgRE9NQ01hcFJlYWRlckZhY3RvcnkgZXh0ZW5kcyBCYXNlQ01hcFJlYWRlckZhY3Rvcnkge1xuICBhc3luYyBfZmV0Y2godXJsKSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGZldGNoRGF0YSh1cmwsIHRoaXMuaXNDb21wcmVzc2VkID8gXCJhcnJheWJ1ZmZlclwiIDogXCJ0ZXh0XCIpO1xuICAgIHJldHVybiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBuZXcgVWludDhBcnJheShkYXRhKSA6IHN0cmluZ1RvQnl0ZXMoZGF0YSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZmlsdGVyX2ZhY3RvcnkuanNcblxuXG5jbGFzcyBCYXNlRmlsdGVyRmFjdG9yeSB7XG4gIGFkZEZpbHRlcihtYXBzKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIGFkZEhDTUZpbHRlcihmZ0NvbG9yLCBiZ0NvbG9yKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIGFkZEFscGhhRmlsdGVyKG1hcCkge1xuICAgIHJldHVybiBcIm5vbmVcIjtcbiAgfVxuICBhZGRMdW1pbm9zaXR5RmlsdGVyKG1hcCkge1xuICAgIHJldHVybiBcIm5vbmVcIjtcbiAgfVxuICBhZGRIaWdobGlnaHRIQ01GaWx0ZXIoZmlsdGVyTmFtZSwgZmdDb2xvciwgYmdDb2xvciwgbmV3RmdDb2xvciwgbmV3QmdDb2xvcikge1xuICAgIHJldHVybiBcIm5vbmVcIjtcbiAgfVxuICBkZXN0cm95KGtlZXBIQ00gPSBmYWxzZSkge31cbn1cbmNsYXNzIERPTUZpbHRlckZhY3RvcnkgZXh0ZW5kcyBCYXNlRmlsdGVyRmFjdG9yeSB7XG4gICNiYXNlVXJsO1xuICAjX2NhY2hlO1xuICAjX2RlZnM7XG4gICNkb2NJZDtcbiAgI2RvY3VtZW50O1xuICAjX2hjbUNhY2hlO1xuICAjaWQgPSAwO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZG9jSWQsXG4gICAgb3duZXJEb2N1bWVudCA9IGdsb2JhbFRoaXMuZG9jdW1lbnRcbiAgfSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jZG9jSWQgPSBkb2NJZDtcbiAgICB0aGlzLiNkb2N1bWVudCA9IG93bmVyRG9jdW1lbnQ7XG4gIH1cbiAgZ2V0ICNjYWNoZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jX2NhY2hlIHx8PSBuZXcgTWFwKCk7XG4gIH1cbiAgZ2V0ICNoY21DYWNoZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jX2hjbUNhY2hlIHx8PSBuZXcgTWFwKCk7XG4gIH1cbiAgZ2V0ICNkZWZzKCkge1xuICAgIGlmICghdGhpcy4jX2RlZnMpIHtcbiAgICAgIGNvbnN0IGRpdiA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0eWxlXG4gICAgICB9ID0gZGl2O1xuICAgICAgc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICBzdHlsZS5jb250YWluID0gXCJzdHJpY3RcIjtcbiAgICAgIHN0eWxlLndpZHRoID0gc3R5bGUuaGVpZ2h0ID0gMDtcbiAgICAgIHN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgc3R5bGUudG9wID0gc3R5bGUubGVmdCA9IDA7XG4gICAgICBzdHlsZS56SW5kZXggPSAtMTtcbiAgICAgIGNvbnN0IHN2ZyA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwic3ZnXCIpO1xuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIDApO1xuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCAwKTtcbiAgICAgIHRoaXMuI19kZWZzID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJkZWZzXCIpO1xuICAgICAgZGl2LmFwcGVuZChzdmcpO1xuICAgICAgc3ZnLmFwcGVuZCh0aGlzLiNfZGVmcyk7XG4gICAgICB0aGlzLiNkb2N1bWVudC5ib2R5LmFwcGVuZChkaXYpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jX2RlZnM7XG4gIH1cbiAgI2NyZWF0ZVRhYmxlcyhtYXBzKSB7XG4gICAgaWYgKG1hcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBtYXBSID0gbWFwc1swXTtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICBidWZmZXJbaV0gPSBtYXBSW2ldIC8gMjU1O1xuICAgICAgfVxuICAgICAgY29uc3QgdGFibGUgPSBidWZmZXIuam9pbihcIixcIik7XG4gICAgICByZXR1cm4gW3RhYmxlLCB0YWJsZSwgdGFibGVdO1xuICAgIH1cbiAgICBjb25zdCBbbWFwUiwgbWFwRywgbWFwQl0gPSBtYXBzO1xuICAgIGNvbnN0IGJ1ZmZlclIgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICBjb25zdCBidWZmZXJHID0gbmV3IEFycmF5KDI1Nik7XG4gICAgY29uc3QgYnVmZmVyQiA9IG5ldyBBcnJheSgyNTYpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIGJ1ZmZlclJbaV0gPSBtYXBSW2ldIC8gMjU1O1xuICAgICAgYnVmZmVyR1tpXSA9IG1hcEdbaV0gLyAyNTU7XG4gICAgICBidWZmZXJCW2ldID0gbWFwQltpXSAvIDI1NTtcbiAgICB9XG4gICAgcmV0dXJuIFtidWZmZXJSLmpvaW4oXCIsXCIpLCBidWZmZXJHLmpvaW4oXCIsXCIpLCBidWZmZXJCLmpvaW4oXCIsXCIpXTtcbiAgfVxuICAjY3JlYXRlVXJsKGlkKSB7XG4gICAgaWYgKHRoaXMuI2Jhc2VVcmwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy4jYmFzZVVybCA9IFwiXCI7XG4gICAgICBjb25zdCB1cmwgPSB0aGlzLiNkb2N1bWVudC5VUkw7XG4gICAgICBpZiAodXJsICE9PSB0aGlzLiNkb2N1bWVudC5iYXNlVVJJKSB7XG4gICAgICAgIGlmIChpc0RhdGFTY2hlbWUodXJsKSkge1xuICAgICAgICAgIHdhcm4oJyNjcmVhdGVVcmw6IGlnbm9yZSBcImRhdGE6XCItVVJMIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuI2Jhc2VVcmwgPSB1cmwuc3BsaXQoXCIjXCIsIDEpWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBgdXJsKCR7dGhpcy4jYmFzZVVybH0jJHtpZH0pYDtcbiAgfVxuICBhZGRGaWx0ZXIobWFwcykge1xuICAgIGlmICghbWFwcykge1xuICAgICAgcmV0dXJuIFwibm9uZVwiO1xuICAgIH1cbiAgICBsZXQgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQobWFwcyk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IFt0YWJsZVIsIHRhYmxlRywgdGFibGVCXSA9IHRoaXMuI2NyZWF0ZVRhYmxlcyhtYXBzKTtcbiAgICBjb25zdCBrZXkgPSBtYXBzLmxlbmd0aCA9PT0gMSA/IHRhYmxlUiA6IGAke3RhYmxlUn0ke3RhYmxlR30ke3RhYmxlQn1gO1xuICAgIHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLiNjYWNoZS5zZXQobWFwcywgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X3RyYW5zZmVyX21hcF8ke3RoaXMuI2lkKyt9YDtcbiAgICBjb25zdCB1cmwgPSB0aGlzLiNjcmVhdGVVcmwoaWQpO1xuICAgIHRoaXMuI2NhY2hlLnNldChtYXBzLCB1cmwpO1xuICAgIHRoaXMuI2NhY2hlLnNldChrZXksIHVybCk7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy4jY3JlYXRlRmlsdGVyKGlkKTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24odGFibGVSLCB0YWJsZUcsIHRhYmxlQiwgZmlsdGVyKTtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGFkZEhDTUZpbHRlcihmZ0NvbG9yLCBiZ0NvbG9yKSB7XG4gICAgY29uc3Qga2V5ID0gYCR7ZmdDb2xvcn0tJHtiZ0NvbG9yfWA7XG4gICAgY29uc3QgZmlsdGVyTmFtZSA9IFwiYmFzZVwiO1xuICAgIGxldCBpbmZvID0gdGhpcy4jaGNtQ2FjaGUuZ2V0KGZpbHRlck5hbWUpO1xuICAgIGlmIChpbmZvPy5rZXkgPT09IGtleSkge1xuICAgICAgcmV0dXJuIGluZm8udXJsO1xuICAgIH1cbiAgICBpZiAoaW5mbykge1xuICAgICAgaW5mby5maWx0ZXI/LnJlbW92ZSgpO1xuICAgICAgaW5mby5rZXkgPSBrZXk7XG4gICAgICBpbmZvLnVybCA9IFwibm9uZVwiO1xuICAgICAgaW5mby5maWx0ZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvID0ge1xuICAgICAgICBrZXksXG4gICAgICAgIHVybDogXCJub25lXCIsXG4gICAgICAgIGZpbHRlcjogbnVsbFxuICAgICAgfTtcbiAgICAgIHRoaXMuI2hjbUNhY2hlLnNldChmaWx0ZXJOYW1lLCBpbmZvKTtcbiAgICB9XG4gICAgaWYgKCFmZ0NvbG9yIHx8ICFiZ0NvbG9yKSB7XG4gICAgICByZXR1cm4gaW5mby51cmw7XG4gICAgfVxuICAgIGNvbnN0IGZnUkdCID0gdGhpcy4jZ2V0UkdCKGZnQ29sb3IpO1xuICAgIGZnQ29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvciguLi5mZ1JHQik7XG4gICAgY29uc3QgYmdSR0IgPSB0aGlzLiNnZXRSR0IoYmdDb2xvcik7XG4gICAgYmdDb2xvciA9IFV0aWwubWFrZUhleENvbG9yKC4uLmJnUkdCKTtcbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gXCJcIjtcbiAgICBpZiAoZmdDb2xvciA9PT0gXCIjMDAwMDAwXCIgJiYgYmdDb2xvciA9PT0gXCIjZmZmZmZmXCIgfHwgZmdDb2xvciA9PT0gYmdDb2xvcikge1xuICAgICAgcmV0dXJuIGluZm8udXJsO1xuICAgIH1cbiAgICBjb25zdCBtYXAgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAyNTU7IGkrKykge1xuICAgICAgY29uc3QgeCA9IGkgLyAyNTU7XG4gICAgICBtYXBbaV0gPSB4IDw9IDAuMDM5MjggPyB4IC8gMTIuOTIgOiAoKHggKyAwLjA1NSkgLyAxLjA1NSkgKiogMi40O1xuICAgIH1cbiAgICBjb25zdCB0YWJsZSA9IG1hcC5qb2luKFwiLFwiKTtcbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X2hjbV9maWx0ZXJgO1xuICAgIGNvbnN0IGZpbHRlciA9IGluZm8uZmlsdGVyID0gdGhpcy4jY3JlYXRlRmlsdGVyKGlkKTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24odGFibGUsIHRhYmxlLCB0YWJsZSwgZmlsdGVyKTtcbiAgICB0aGlzLiNhZGRHcmF5Q29udmVyc2lvbihmaWx0ZXIpO1xuICAgIGNvbnN0IGdldFN0ZXBzID0gKGMsIG4pID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gZmdSR0JbY10gLyAyNTU7XG4gICAgICBjb25zdCBlbmQgPSBiZ1JHQltjXSAvIDI1NTtcbiAgICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheShuICsgMSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBuOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gc3RhcnQgKyBpIC8gbiAqIChlbmQgLSBzdGFydCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyLmpvaW4oXCIsXCIpO1xuICAgIH07XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKGdldFN0ZXBzKDAsIDUpLCBnZXRTdGVwcygxLCA1KSwgZ2V0U3RlcHMoMiwgNSksIGZpbHRlcik7XG4gICAgaW5mby51cmwgPSB0aGlzLiNjcmVhdGVVcmwoaWQpO1xuICAgIHJldHVybiBpbmZvLnVybDtcbiAgfVxuICBhZGRBbHBoYUZpbHRlcihtYXApIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQobWFwKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgW3RhYmxlQV0gPSB0aGlzLiNjcmVhdGVUYWJsZXMoW21hcF0pO1xuICAgIGNvbnN0IGtleSA9IGBhbHBoYV8ke3RhYmxlQX1gO1xuICAgIHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLiNjYWNoZS5zZXQobWFwLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gYGdfJHt0aGlzLiNkb2NJZH1fYWxwaGFfbWFwXyR7dGhpcy4jaWQrK31gO1xuICAgIGNvbnN0IHVybCA9IHRoaXMuI2NyZWF0ZVVybChpZCk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KG1hcCwgdXJsKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQoa2V5LCB1cmwpO1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBBbHBoYUNvbnZlcnNpb24odGFibGVBLCBmaWx0ZXIpO1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgYWRkTHVtaW5vc2l0eUZpbHRlcihtYXApIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQobWFwIHx8IFwibHVtaW5vc2l0eVwiKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgbGV0IHRhYmxlQSwga2V5O1xuICAgIGlmIChtYXApIHtcbiAgICAgIFt0YWJsZUFdID0gdGhpcy4jY3JlYXRlVGFibGVzKFttYXBdKTtcbiAgICAgIGtleSA9IGBsdW1pbm9zaXR5XyR7dGFibGVBfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IFwibHVtaW5vc2l0eVwiO1xuICAgIH1cbiAgICB2YWx1ZSA9IHRoaXMuI2NhY2hlLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy4jY2FjaGUuc2V0KG1hcCwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X2x1bWlub3NpdHlfbWFwXyR7dGhpcy4jaWQrK31gO1xuICAgIGNvbnN0IHVybCA9IHRoaXMuI2NyZWF0ZVVybChpZCk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KG1hcCwgdXJsKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQoa2V5LCB1cmwpO1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkTHVtaW5vc2l0eUNvbnZlcnNpb24oZmlsdGVyKTtcbiAgICBpZiAobWFwKSB7XG4gICAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcEFscGhhQ29udmVyc2lvbih0YWJsZUEsIGZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0SENNRmlsdGVyKGZpbHRlck5hbWUsIGZnQ29sb3IsIGJnQ29sb3IsIG5ld0ZnQ29sb3IsIG5ld0JnQ29sb3IpIHtcbiAgICBjb25zdCBrZXkgPSBgJHtmZ0NvbG9yfS0ke2JnQ29sb3J9LSR7bmV3RmdDb2xvcn0tJHtuZXdCZ0NvbG9yfWA7XG4gICAgbGV0IGluZm8gPSB0aGlzLiNoY21DYWNoZS5nZXQoZmlsdGVyTmFtZSk7XG4gICAgaWYgKGluZm8/LmtleSA9PT0ga2V5KSB7XG4gICAgICByZXR1cm4gaW5mby51cmw7XG4gICAgfVxuICAgIGlmIChpbmZvKSB7XG4gICAgICBpbmZvLmZpbHRlcj8ucmVtb3ZlKCk7XG4gICAgICBpbmZvLmtleSA9IGtleTtcbiAgICAgIGluZm8udXJsID0gXCJub25lXCI7XG4gICAgICBpbmZvLmZpbHRlciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gPSB7XG4gICAgICAgIGtleSxcbiAgICAgICAgdXJsOiBcIm5vbmVcIixcbiAgICAgICAgZmlsdGVyOiBudWxsXG4gICAgICB9O1xuICAgICAgdGhpcy4jaGNtQ2FjaGUuc2V0KGZpbHRlck5hbWUsIGluZm8pO1xuICAgIH1cbiAgICBpZiAoIWZnQ29sb3IgfHwgIWJnQ29sb3IpIHtcbiAgICAgIHJldHVybiBpbmZvLnVybDtcbiAgICB9XG4gICAgY29uc3QgW2ZnUkdCLCBiZ1JHQl0gPSBbZmdDb2xvciwgYmdDb2xvcl0ubWFwKHRoaXMuI2dldFJHQi5iaW5kKHRoaXMpKTtcbiAgICBsZXQgZmdHcmF5ID0gTWF0aC5yb3VuZCgwLjIxMjYgKiBmZ1JHQlswXSArIDAuNzE1MiAqIGZnUkdCWzFdICsgMC4wNzIyICogZmdSR0JbMl0pO1xuICAgIGxldCBiZ0dyYXkgPSBNYXRoLnJvdW5kKDAuMjEyNiAqIGJnUkdCWzBdICsgMC43MTUyICogYmdSR0JbMV0gKyAwLjA3MjIgKiBiZ1JHQlsyXSk7XG4gICAgbGV0IFtuZXdGZ1JHQiwgbmV3QmdSR0JdID0gW25ld0ZnQ29sb3IsIG5ld0JnQ29sb3JdLm1hcCh0aGlzLiNnZXRSR0IuYmluZCh0aGlzKSk7XG4gICAgaWYgKGJnR3JheSA8IGZnR3JheSkge1xuICAgICAgW2ZnR3JheSwgYmdHcmF5LCBuZXdGZ1JHQiwgbmV3QmdSR0JdID0gW2JnR3JheSwgZmdHcmF5LCBuZXdCZ1JHQiwgbmV3RmdSR0JdO1xuICAgIH1cbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gXCJcIjtcbiAgICBjb25zdCBnZXRTdGVwcyA9IChmZywgYmcsIG4pID0+IHtcbiAgICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgY29uc3Qgc3RlcCA9IChiZ0dyYXkgLSBmZ0dyYXkpIC8gbjtcbiAgICAgIGNvbnN0IG5ld1N0YXJ0ID0gZmcgLyAyNTU7XG4gICAgICBjb25zdCBuZXdTdGVwID0gKGJnIC0gZmcpIC8gKDI1NSAqIG4pO1xuICAgICAgbGV0IHByZXYgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGsgPSBNYXRoLnJvdW5kKGZnR3JheSArIGkgKiBzdGVwKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBuZXdTdGFydCArIGkgKiBuZXdTdGVwO1xuICAgICAgICBmb3IgKGxldCBqID0gcHJldjsgaiA8PSBrOyBqKyspIHtcbiAgICAgICAgICBhcnJbal0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2ID0gayArIDE7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gcHJldjsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGFycltwcmV2IC0gMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyLmpvaW4oXCIsXCIpO1xuICAgIH07XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV9oY21fJHtmaWx0ZXJOYW1lfV9maWx0ZXJgO1xuICAgIGNvbnN0IGZpbHRlciA9IGluZm8uZmlsdGVyID0gdGhpcy4jY3JlYXRlRmlsdGVyKGlkKTtcbiAgICB0aGlzLiNhZGRHcmF5Q29udmVyc2lvbihmaWx0ZXIpO1xuICAgIHRoaXMuI2FkZFRyYW5zZmVyTWFwQ29udmVyc2lvbihnZXRTdGVwcyhuZXdGZ1JHQlswXSwgbmV3QmdSR0JbMF0sIDUpLCBnZXRTdGVwcyhuZXdGZ1JHQlsxXSwgbmV3QmdSR0JbMV0sIDUpLCBnZXRTdGVwcyhuZXdGZ1JHQlsyXSwgbmV3QmdSR0JbMl0sIDUpLCBmaWx0ZXIpO1xuICAgIGluZm8udXJsID0gdGhpcy4jY3JlYXRlVXJsKGlkKTtcbiAgICByZXR1cm4gaW5mby51cmw7XG4gIH1cbiAgZGVzdHJveShrZWVwSENNID0gZmFsc2UpIHtcbiAgICBpZiAoa2VlcEhDTSAmJiB0aGlzLiNfaGNtQ2FjaGU/LnNpemUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jX2RlZnM/LnBhcmVudE5vZGUucGFyZW50Tm9kZS5yZW1vdmUoKTtcbiAgICB0aGlzLiNfZGVmcyA9IG51bGw7XG4gICAgdGhpcy4jX2NhY2hlPy5jbGVhcigpO1xuICAgIHRoaXMuI19jYWNoZSA9IG51bGw7XG4gICAgdGhpcy4jX2hjbUNhY2hlPy5jbGVhcigpO1xuICAgIHRoaXMuI19oY21DYWNoZSA9IG51bGw7XG4gICAgdGhpcy4jaWQgPSAwO1xuICB9XG4gICNhZGRMdW1pbm9zaXR5Q29udmVyc2lvbihmaWx0ZXIpIHtcbiAgICBjb25zdCBmZUNvbG9yTWF0cml4ID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmZUNvbG9yTWF0cml4XCIpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcIm1hdHJpeFwiKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZShcInZhbHVlc1wiLCBcIjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMyAwLjU5IDAuMTEgMCAwXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb2xvck1hdHJpeCk7XG4gIH1cbiAgI2FkZEdyYXlDb252ZXJzaW9uKGZpbHRlcikge1xuICAgIGNvbnN0IGZlQ29sb3JNYXRyaXggPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImZlQ29sb3JNYXRyaXhcIik7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwibWF0cml4XCIpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKFwidmFsdWVzXCIsIFwiMC4yMTI2IDAuNzE1MiAwLjA3MjIgMCAwIDAuMjEyNiAwLjcxNTIgMC4wNzIyIDAgMCAwLjIxMjYgMC43MTUyIDAuMDcyMiAwIDAgMCAwIDAgMSAwXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb2xvck1hdHJpeCk7XG4gIH1cbiAgI2NyZWF0ZUZpbHRlcihpZCkge1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZmlsdGVyXCIpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIiwgXCJzUkdCXCIpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZCk7XG4gICAgdGhpcy4jZGVmcy5hcHBlbmQoZmlsdGVyKTtcbiAgICByZXR1cm4gZmlsdGVyO1xuICB9XG4gICNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgZnVuYywgdGFibGUpIHtcbiAgICBjb25zdCBmZUZ1bmMgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBmdW5jKTtcbiAgICBmZUZ1bmMuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImRpc2NyZXRlXCIpO1xuICAgIGZlRnVuYy5zZXRBdHRyaWJ1dGUoXCJ0YWJsZVZhbHVlc1wiLCB0YWJsZSk7XG4gICAgZmVDb21wb25lbnRUcmFuc2Zlci5hcHBlbmQoZmVGdW5jKTtcbiAgfVxuICAjYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKHJUYWJsZSwgZ1RhYmxlLCBiVGFibGUsIGZpbHRlcikge1xuICAgIGNvbnN0IGZlQ29tcG9uZW50VHJhbnNmZXIgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImZlQ29tcG9uZW50VHJhbnNmZXJcIik7XG4gICAgZmlsdGVyLmFwcGVuZChmZUNvbXBvbmVudFRyYW5zZmVyKTtcbiAgICB0aGlzLiNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgXCJmZUZ1bmNSXCIsIHJUYWJsZSk7XG4gICAgdGhpcy4jYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIFwiZmVGdW5jR1wiLCBnVGFibGUpO1xuICAgIHRoaXMuI2FwcGVuZEZlRnVuYyhmZUNvbXBvbmVudFRyYW5zZmVyLCBcImZlRnVuY0JcIiwgYlRhYmxlKTtcbiAgfVxuICAjYWRkVHJhbnNmZXJNYXBBbHBoYUNvbnZlcnNpb24oYVRhYmxlLCBmaWx0ZXIpIHtcbiAgICBjb25zdCBmZUNvbXBvbmVudFRyYW5zZmVyID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmZUNvbXBvbmVudFRyYW5zZmVyXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gICAgdGhpcy4jYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIFwiZmVGdW5jQVwiLCBhVGFibGUpO1xuICB9XG4gICNnZXRSR0IoY29sb3IpIHtcbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gY29sb3I7XG4gICAgcmV0dXJuIGdldFJHQihnZXRDb21wdXRlZFN0eWxlKHRoaXMuI2RlZnMpLmdldFByb3BlcnR5VmFsdWUoXCJjb2xvclwiKSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvc3RhbmRhcmRfZm9udGRhdGFfZmFjdG9yeS5qc1xuXG5cbmNsYXNzIEJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBiYXNlVXJsID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgfVxuICBhc3luYyBmZXRjaCh7XG4gICAgZmlsZW5hbWVcbiAgfSkge1xuICAgIGlmICghdGhpcy5iYXNlVXJsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhhdCB0aGUgYHN0YW5kYXJkRm9udERhdGFVcmxgIEFQSSBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIWZpbGVuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb250IGZpbGVuYW1lIG11c3QgYmUgc3BlY2lmaWVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gYCR7dGhpcy5iYXNlVXJsfSR7ZmlsZW5hbWV9YDtcbiAgICByZXR1cm4gdGhpcy5fZmV0Y2godXJsKS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gbG9hZCBmb250IGRhdGEgYXQ6ICR7dXJsfWApO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgX2ZldGNoYCBjYWxsZWQuXCIpO1xuICB9XG59XG5jbGFzcyBET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSBleHRlbmRzIEJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB7XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgZmV0Y2hEYXRhKHVybCwgXCJhcnJheWJ1ZmZlclwiKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvbm9kZV91dGlscy5qc1xuXG5cblxuXG5cbmlmIChpc05vZGVKUykge1xuICB3YXJuKFwiUGxlYXNlIHVzZSB0aGUgYGxlZ2FjeWAgYnVpbGQgaW4gTm9kZS5qcyBlbnZpcm9ubWVudHMuXCIpO1xufVxuYXN5bmMgZnVuY3Rpb24gbm9kZV91dGlsc19mZXRjaERhdGEodXJsKSB7XG4gIGNvbnN0IGZzID0gcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlKFwiZnNcIik7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBmcy5wcm9taXNlcy5yZWFkRmlsZSh1cmwpO1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG59XG5jbGFzcyBOb2RlRmlsdGVyRmFjdG9yeSBleHRlbmRzIEJhc2VGaWx0ZXJGYWN0b3J5IHt9XG5jbGFzcyBOb2RlQ2FudmFzRmFjdG9yeSBleHRlbmRzIEJhc2VDYW52YXNGYWN0b3J5IHtcbiAgX2NyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcmVxdWlyZSA9IHByb2Nlc3MuZ2V0QnVpbHRpbk1vZHVsZShcIm1vZHVsZVwiKS5jcmVhdGVSZXF1aXJlKGltcG9ydC5tZXRhLnVybCk7XG4gICAgY29uc3QgY2FudmFzID0gcmVxdWlyZShcIkBuYXBpLXJzL2NhbnZhc1wiKTtcbiAgICByZXR1cm4gY2FudmFzLmNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxufVxuY2xhc3MgTm9kZUNNYXBSZWFkZXJGYWN0b3J5IGV4dGVuZHMgQmFzZUNNYXBSZWFkZXJGYWN0b3J5IHtcbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIHJldHVybiBub2RlX3V0aWxzX2ZldGNoRGF0YSh1cmwpO1xuICB9XG59XG5jbGFzcyBOb2RlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgZXh0ZW5kcyBCYXNlU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkge1xuICBhc3luYyBfZmV0Y2godXJsKSB7XG4gICAgcmV0dXJuIG5vZGVfdXRpbHNfZmV0Y2hEYXRhKHVybCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvcGF0dGVybl9oZWxwZXIuanNcblxuXG5jb25zdCBQYXRoVHlwZSA9IHtcbiAgRklMTDogXCJGaWxsXCIsXG4gIFNUUk9LRTogXCJTdHJva2VcIixcbiAgU0hBRElORzogXCJTaGFkaW5nXCJcbn07XG5mdW5jdGlvbiBhcHBseUJvdW5kaW5nQm94KGN0eCwgYmJveCkge1xuICBpZiAoIWJib3gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgd2lkdGggPSBiYm94WzJdIC0gYmJveFswXTtcbiAgY29uc3QgaGVpZ2h0ID0gYmJveFszXSAtIGJib3hbMV07XG4gIGNvbnN0IHJlZ2lvbiA9IG5ldyBQYXRoMkQoKTtcbiAgcmVnaW9uLnJlY3QoYmJveFswXSwgYmJveFsxXSwgd2lkdGgsIGhlaWdodCk7XG4gIGN0eC5jbGlwKHJlZ2lvbik7XG59XG5jbGFzcyBCYXNlU2hhZGluZ1BhdHRlcm4ge1xuICBnZXRQYXR0ZXJuKCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBnZXRQYXR0ZXJuYCBjYWxsZWQuXCIpO1xuICB9XG59XG5jbGFzcyBSYWRpYWxBeGlhbFNoYWRpbmdQYXR0ZXJuIGV4dGVuZHMgQmFzZVNoYWRpbmdQYXR0ZXJuIHtcbiAgY29uc3RydWN0b3IoSVIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3R5cGUgPSBJUlsxXTtcbiAgICB0aGlzLl9iYm94ID0gSVJbMl07XG4gICAgdGhpcy5fY29sb3JTdG9wcyA9IElSWzNdO1xuICAgIHRoaXMuX3AwID0gSVJbNF07XG4gICAgdGhpcy5fcDEgPSBJUls1XTtcbiAgICB0aGlzLl9yMCA9IElSWzZdO1xuICAgIHRoaXMuX3IxID0gSVJbN107XG4gICAgdGhpcy5tYXRyaXggPSBudWxsO1xuICB9XG4gIF9jcmVhdGVHcmFkaWVudChjdHgpIHtcbiAgICBsZXQgZ3JhZDtcbiAgICBpZiAodGhpcy5fdHlwZSA9PT0gXCJheGlhbFwiKSB7XG4gICAgICBncmFkID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHRoaXMuX3AwWzBdLCB0aGlzLl9wMFsxXSwgdGhpcy5fcDFbMF0sIHRoaXMuX3AxWzFdKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3R5cGUgPT09IFwicmFkaWFsXCIpIHtcbiAgICAgIGdyYWQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQodGhpcy5fcDBbMF0sIHRoaXMuX3AwWzFdLCB0aGlzLl9yMCwgdGhpcy5fcDFbMF0sIHRoaXMuX3AxWzFdLCB0aGlzLl9yMSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY29sb3JTdG9wIG9mIHRoaXMuX2NvbG9yU3RvcHMpIHtcbiAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKGNvbG9yU3RvcFswXSwgY29sb3JTdG9wWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIGdyYWQ7XG4gIH1cbiAgZ2V0UGF0dGVybihjdHgsIG93bmVyLCBpbnZlcnNlLCBwYXRoVHlwZSkge1xuICAgIGxldCBwYXR0ZXJuO1xuICAgIGlmIChwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU1RST0tFIHx8IHBhdGhUeXBlID09PSBQYXRoVHlwZS5GSUxMKSB7XG4gICAgICBjb25zdCBvd25lckJCb3ggPSBvd25lci5jdXJyZW50LmdldENsaXBwZWRQYXRoQm91bmRpbmdCb3gocGF0aFR5cGUsIGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KSkgfHwgWzAsIDAsIDAsIDBdO1xuICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLmNlaWwob3duZXJCQm94WzJdIC0gb3duZXJCQm94WzBdKSB8fCAxO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5jZWlsKG93bmVyQkJveFszXSAtIG93bmVyQkJveFsxXSkgfHwgMTtcbiAgICAgIGNvbnN0IHRtcENhbnZhcyA9IG93bmVyLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcInBhdHRlcm5cIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgIHRtcEN0eC5jbGVhclJlY3QoMCwgMCwgdG1wQ3R4LmNhbnZhcy53aWR0aCwgdG1wQ3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgICAgdG1wQ3R4LmJlZ2luUGF0aCgpO1xuICAgICAgdG1wQ3R4LnJlY3QoMCwgMCwgdG1wQ3R4LmNhbnZhcy53aWR0aCwgdG1wQ3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgICAgdG1wQ3R4LnRyYW5zbGF0ZSgtb3duZXJCQm94WzBdLCAtb3duZXJCQm94WzFdKTtcbiAgICAgIGludmVyc2UgPSBVdGlsLnRyYW5zZm9ybShpbnZlcnNlLCBbMSwgMCwgMCwgMSwgb3duZXJCQm94WzBdLCBvd25lckJCb3hbMV1dKTtcbiAgICAgIHRtcEN0eC50cmFuc2Zvcm0oLi4ub3duZXIuYmFzZVRyYW5zZm9ybSk7XG4gICAgICBpZiAodGhpcy5tYXRyaXgpIHtcbiAgICAgICAgdG1wQ3R4LnRyYW5zZm9ybSguLi50aGlzLm1hdHJpeCk7XG4gICAgICB9XG4gICAgICBhcHBseUJvdW5kaW5nQm94KHRtcEN0eCwgdGhpcy5fYmJveCk7XG4gICAgICB0bXBDdHguZmlsbFN0eWxlID0gdGhpcy5fY3JlYXRlR3JhZGllbnQodG1wQ3R4KTtcbiAgICAgIHRtcEN0eC5maWxsKCk7XG4gICAgICBwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4odG1wQ2FudmFzLmNhbnZhcywgXCJuby1yZXBlYXRcIik7XG4gICAgICBjb25zdCBkb21NYXRyaXggPSBuZXcgRE9NTWF0cml4KGludmVyc2UpO1xuICAgICAgcGF0dGVybi5zZXRUcmFuc2Zvcm0oZG9tTWF0cml4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBwbHlCb3VuZGluZ0JveChjdHgsIHRoaXMuX2Jib3gpO1xuICAgICAgcGF0dGVybiA9IHRoaXMuX2NyZWF0ZUdyYWRpZW50KGN0eCk7XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG59XG5mdW5jdGlvbiBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcDEsIHAyLCBwMywgYzEsIGMyLCBjMykge1xuICBjb25zdCBjb29yZHMgPSBjb250ZXh0LmNvb3JkcyxcbiAgICBjb2xvcnMgPSBjb250ZXh0LmNvbG9ycztcbiAgY29uc3QgYnl0ZXMgPSBkYXRhLmRhdGEsXG4gICAgcm93U2l6ZSA9IGRhdGEud2lkdGggKiA0O1xuICBsZXQgdG1wO1xuICBpZiAoY29vcmRzW3AxICsgMV0gPiBjb29yZHNbcDIgKyAxXSkge1xuICAgIHRtcCA9IHAxO1xuICAgIHAxID0gcDI7XG4gICAgcDIgPSB0bXA7XG4gICAgdG1wID0gYzE7XG4gICAgYzEgPSBjMjtcbiAgICBjMiA9IHRtcDtcbiAgfVxuICBpZiAoY29vcmRzW3AyICsgMV0gPiBjb29yZHNbcDMgKyAxXSkge1xuICAgIHRtcCA9IHAyO1xuICAgIHAyID0gcDM7XG4gICAgcDMgPSB0bXA7XG4gICAgdG1wID0gYzI7XG4gICAgYzIgPSBjMztcbiAgICBjMyA9IHRtcDtcbiAgfVxuICBpZiAoY29vcmRzW3AxICsgMV0gPiBjb29yZHNbcDIgKyAxXSkge1xuICAgIHRtcCA9IHAxO1xuICAgIHAxID0gcDI7XG4gICAgcDIgPSB0bXA7XG4gICAgdG1wID0gYzE7XG4gICAgYzEgPSBjMjtcbiAgICBjMiA9IHRtcDtcbiAgfVxuICBjb25zdCB4MSA9IChjb29yZHNbcDFdICsgY29udGV4dC5vZmZzZXRYKSAqIGNvbnRleHQuc2NhbGVYO1xuICBjb25zdCB5MSA9IChjb29yZHNbcDEgKyAxXSArIGNvbnRleHQub2Zmc2V0WSkgKiBjb250ZXh0LnNjYWxlWTtcbiAgY29uc3QgeDIgPSAoY29vcmRzW3AyXSArIGNvbnRleHQub2Zmc2V0WCkgKiBjb250ZXh0LnNjYWxlWDtcbiAgY29uc3QgeTIgPSAoY29vcmRzW3AyICsgMV0gKyBjb250ZXh0Lm9mZnNldFkpICogY29udGV4dC5zY2FsZVk7XG4gIGNvbnN0IHgzID0gKGNvb3Jkc1twM10gKyBjb250ZXh0Lm9mZnNldFgpICogY29udGV4dC5zY2FsZVg7XG4gIGNvbnN0IHkzID0gKGNvb3Jkc1twMyArIDFdICsgY29udGV4dC5vZmZzZXRZKSAqIGNvbnRleHQuc2NhbGVZO1xuICBpZiAoeTEgPj0geTMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYzFyID0gY29sb3JzW2MxXSxcbiAgICBjMWcgPSBjb2xvcnNbYzEgKyAxXSxcbiAgICBjMWIgPSBjb2xvcnNbYzEgKyAyXTtcbiAgY29uc3QgYzJyID0gY29sb3JzW2MyXSxcbiAgICBjMmcgPSBjb2xvcnNbYzIgKyAxXSxcbiAgICBjMmIgPSBjb2xvcnNbYzIgKyAyXTtcbiAgY29uc3QgYzNyID0gY29sb3JzW2MzXSxcbiAgICBjM2cgPSBjb2xvcnNbYzMgKyAxXSxcbiAgICBjM2IgPSBjb2xvcnNbYzMgKyAyXTtcbiAgY29uc3QgbWluWSA9IE1hdGgucm91bmQoeTEpLFxuICAgIG1heFkgPSBNYXRoLnJvdW5kKHkzKTtcbiAgbGV0IHhhLCBjYXIsIGNhZywgY2FiO1xuICBsZXQgeGIsIGNiciwgY2JnLCBjYmI7XG4gIGZvciAobGV0IHkgPSBtaW5ZOyB5IDw9IG1heFk7IHkrKykge1xuICAgIGlmICh5IDwgeTIpIHtcbiAgICAgIGNvbnN0IGsgPSB5IDwgeTEgPyAwIDogKHkxIC0geSkgLyAoeTEgLSB5Mik7XG4gICAgICB4YSA9IHgxIC0gKHgxIC0geDIpICogaztcbiAgICAgIGNhciA9IGMxciAtIChjMXIgLSBjMnIpICogaztcbiAgICAgIGNhZyA9IGMxZyAtIChjMWcgLSBjMmcpICogaztcbiAgICAgIGNhYiA9IGMxYiAtIChjMWIgLSBjMmIpICogaztcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGs7XG4gICAgICBpZiAoeSA+IHkzKSB7XG4gICAgICAgIGsgPSAxO1xuICAgICAgfSBlbHNlIGlmICh5MiA9PT0geTMpIHtcbiAgICAgICAgayA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrID0gKHkyIC0geSkgLyAoeTIgLSB5Myk7XG4gICAgICB9XG4gICAgICB4YSA9IHgyIC0gKHgyIC0geDMpICogaztcbiAgICAgIGNhciA9IGMyciAtIChjMnIgLSBjM3IpICogaztcbiAgICAgIGNhZyA9IGMyZyAtIChjMmcgLSBjM2cpICogaztcbiAgICAgIGNhYiA9IGMyYiAtIChjMmIgLSBjM2IpICogaztcbiAgICB9XG4gICAgbGV0IGs7XG4gICAgaWYgKHkgPCB5MSkge1xuICAgICAgayA9IDA7XG4gICAgfSBlbHNlIGlmICh5ID4geTMpIHtcbiAgICAgIGsgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBrID0gKHkxIC0geSkgLyAoeTEgLSB5Myk7XG4gICAgfVxuICAgIHhiID0geDEgLSAoeDEgLSB4MykgKiBrO1xuICAgIGNiciA9IGMxciAtIChjMXIgLSBjM3IpICogaztcbiAgICBjYmcgPSBjMWcgLSAoYzFnIC0gYzNnKSAqIGs7XG4gICAgY2JiID0gYzFiIC0gKGMxYiAtIGMzYikgKiBrO1xuICAgIGNvbnN0IHgxXyA9IE1hdGgucm91bmQoTWF0aC5taW4oeGEsIHhiKSk7XG4gICAgY29uc3QgeDJfID0gTWF0aC5yb3VuZChNYXRoLm1heCh4YSwgeGIpKTtcbiAgICBsZXQgaiA9IHJvd1NpemUgKiB5ICsgeDFfICogNDtcbiAgICBmb3IgKGxldCB4ID0geDFfOyB4IDw9IHgyXzsgeCsrKSB7XG4gICAgICBrID0gKHhhIC0geCkgLyAoeGEgLSB4Yik7XG4gICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgayA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGsgPiAxKSB7XG4gICAgICAgIGsgPSAxO1xuICAgICAgfVxuICAgICAgYnl0ZXNbaisrXSA9IGNhciAtIChjYXIgLSBjYnIpICogayB8IDA7XG4gICAgICBieXRlc1tqKytdID0gY2FnIC0gKGNhZyAtIGNiZykgKiBrIHwgMDtcbiAgICAgIGJ5dGVzW2orK10gPSBjYWIgLSAoY2FiIC0gY2JiKSAqIGsgfCAwO1xuICAgICAgYnl0ZXNbaisrXSA9IDI1NTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRyYXdGaWd1cmUoZGF0YSwgZmlndXJlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHBzID0gZmlndXJlLmNvb3JkcztcbiAgY29uc3QgY3MgPSBmaWd1cmUuY29sb3JzO1xuICBsZXQgaSwgaWk7XG4gIHN3aXRjaCAoZmlndXJlLnR5cGUpIHtcbiAgICBjYXNlIFwibGF0dGljZVwiOlxuICAgICAgY29uc3QgdmVydGljZXNQZXJSb3cgPSBmaWd1cmUudmVydGljZXNQZXJSb3c7XG4gICAgICBjb25zdCByb3dzID0gTWF0aC5mbG9vcihwcy5sZW5ndGggLyB2ZXJ0aWNlc1BlclJvdykgLSAxO1xuICAgICAgY29uc3QgY29scyA9IHZlcnRpY2VzUGVyUm93IC0gMTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgbGV0IHEgPSBpICogdmVydGljZXNQZXJSb3c7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sczsgaisrLCBxKyspIHtcbiAgICAgICAgICBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcHNbcV0sIHBzW3EgKyAxXSwgcHNbcSArIHZlcnRpY2VzUGVyUm93XSwgY3NbcV0sIGNzW3EgKyAxXSwgY3NbcSArIHZlcnRpY2VzUGVyUm93XSk7XG4gICAgICAgICAgZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHBzW3EgKyB2ZXJ0aWNlc1BlclJvdyArIDFdLCBwc1txICsgMV0sIHBzW3EgKyB2ZXJ0aWNlc1BlclJvd10sIGNzW3EgKyB2ZXJ0aWNlc1BlclJvdyArIDFdLCBjc1txICsgMV0sIGNzW3EgKyB2ZXJ0aWNlc1BlclJvd10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwidHJpYW5nbGVzXCI6XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IHBzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDMpIHtcbiAgICAgICAgZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHBzW2ldLCBwc1tpICsgMV0sIHBzW2kgKyAyXSwgY3NbaV0sIGNzW2kgKyAxXSwgY3NbaSArIDJdKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGZpZ3VyZVwiKTtcbiAgfVxufVxuY2xhc3MgTWVzaFNoYWRpbmdQYXR0ZXJuIGV4dGVuZHMgQmFzZVNoYWRpbmdQYXR0ZXJuIHtcbiAgY29uc3RydWN0b3IoSVIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2Nvb3JkcyA9IElSWzJdO1xuICAgIHRoaXMuX2NvbG9ycyA9IElSWzNdO1xuICAgIHRoaXMuX2ZpZ3VyZXMgPSBJUls0XTtcbiAgICB0aGlzLl9ib3VuZHMgPSBJUls1XTtcbiAgICB0aGlzLl9iYm94ID0gSVJbN107XG4gICAgdGhpcy5fYmFja2dyb3VuZCA9IElSWzhdO1xuICAgIHRoaXMubWF0cml4ID0gbnVsbDtcbiAgfVxuICBfY3JlYXRlTWVzaENhbnZhcyhjb21iaW5lZFNjYWxlLCBiYWNrZ3JvdW5kQ29sb3IsIGNhY2hlZENhbnZhc2VzKSB7XG4gICAgY29uc3QgRVhQRUNURURfU0NBTEUgPSAxLjE7XG4gICAgY29uc3QgTUFYX1BBVFRFUk5fU0laRSA9IDMwMDA7XG4gICAgY29uc3QgQk9SREVSX1NJWkUgPSAyO1xuICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLmZsb29yKHRoaXMuX2JvdW5kc1swXSk7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGguZmxvb3IodGhpcy5fYm91bmRzWzFdKTtcbiAgICBjb25zdCBib3VuZHNXaWR0aCA9IE1hdGguY2VpbCh0aGlzLl9ib3VuZHNbMl0pIC0gb2Zmc2V0WDtcbiAgICBjb25zdCBib3VuZHNIZWlnaHQgPSBNYXRoLmNlaWwodGhpcy5fYm91bmRzWzNdKSAtIG9mZnNldFk7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLm1pbihNYXRoLmNlaWwoTWF0aC5hYnMoYm91bmRzV2lkdGggKiBjb21iaW5lZFNjYWxlWzBdICogRVhQRUNURURfU0NBTEUpKSwgTUFYX1BBVFRFUk5fU0laRSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5taW4oTWF0aC5jZWlsKE1hdGguYWJzKGJvdW5kc0hlaWdodCAqIGNvbWJpbmVkU2NhbGVbMV0gKiBFWFBFQ1RFRF9TQ0FMRSkpLCBNQVhfUEFUVEVSTl9TSVpFKTtcbiAgICBjb25zdCBzY2FsZVggPSBib3VuZHNXaWR0aCAvIHdpZHRoO1xuICAgIGNvbnN0IHNjYWxlWSA9IGJvdW5kc0hlaWdodCAvIGhlaWdodDtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgY29vcmRzOiB0aGlzLl9jb29yZHMsXG4gICAgICBjb2xvcnM6IHRoaXMuX2NvbG9ycyxcbiAgICAgIG9mZnNldFg6IC1vZmZzZXRYLFxuICAgICAgb2Zmc2V0WTogLW9mZnNldFksXG4gICAgICBzY2FsZVg6IDEgLyBzY2FsZVgsXG4gICAgICBzY2FsZVk6IDEgLyBzY2FsZVlcbiAgICB9O1xuICAgIGNvbnN0IHBhZGRlZFdpZHRoID0gd2lkdGggKyBCT1JERVJfU0laRSAqIDI7XG4gICAgY29uc3QgcGFkZGVkSGVpZ2h0ID0gaGVpZ2h0ICsgQk9SREVSX1NJWkUgKiAyO1xuICAgIGNvbnN0IHRtcENhbnZhcyA9IGNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1lc2hcIiwgcGFkZGVkV2lkdGgsIHBhZGRlZEhlaWdodCk7XG4gICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgY29uc3QgZGF0YSA9IHRtcEN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY29uc3QgYnl0ZXMgPSBkYXRhLmRhdGE7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBieXRlcy5sZW5ndGg7IGkgPCBpaTsgaSArPSA0KSB7XG4gICAgICAgIGJ5dGVzW2ldID0gYmFja2dyb3VuZENvbG9yWzBdO1xuICAgICAgICBieXRlc1tpICsgMV0gPSBiYWNrZ3JvdW5kQ29sb3JbMV07XG4gICAgICAgIGJ5dGVzW2kgKyAyXSA9IGJhY2tncm91bmRDb2xvclsyXTtcbiAgICAgICAgYnl0ZXNbaSArIDNdID0gMjU1O1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZpZ3VyZSBvZiB0aGlzLl9maWd1cmVzKSB7XG4gICAgICBkcmF3RmlndXJlKGRhdGEsIGZpZ3VyZSwgY29udGV4dCk7XG4gICAgfVxuICAgIHRtcEN0eC5wdXRJbWFnZURhdGEoZGF0YSwgQk9SREVSX1NJWkUsIEJPUkRFUl9TSVpFKTtcbiAgICBjb25zdCBjYW52YXMgPSB0bXBDYW52YXMuY2FudmFzO1xuICAgIHJldHVybiB7XG4gICAgICBjYW52YXMsXG4gICAgICBvZmZzZXRYOiBvZmZzZXRYIC0gQk9SREVSX1NJWkUgKiBzY2FsZVgsXG4gICAgICBvZmZzZXRZOiBvZmZzZXRZIC0gQk9SREVSX1NJWkUgKiBzY2FsZVksXG4gICAgICBzY2FsZVgsXG4gICAgICBzY2FsZVlcbiAgICB9O1xuICB9XG4gIGdldFBhdHRlcm4oY3R4LCBvd25lciwgaW52ZXJzZSwgcGF0aFR5cGUpIHtcbiAgICBhcHBseUJvdW5kaW5nQm94KGN0eCwgdGhpcy5fYmJveCk7XG4gICAgbGV0IHNjYWxlO1xuICAgIGlmIChwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU0hBRElORykge1xuICAgICAgc2NhbGUgPSBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlID0gVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShvd25lci5iYXNlVHJhbnNmb3JtKTtcbiAgICAgIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgICBjb25zdCBtYXRyaXhTY2FsZSA9IFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodGhpcy5tYXRyaXgpO1xuICAgICAgICBzY2FsZSA9IFtzY2FsZVswXSAqIG1hdHJpeFNjYWxlWzBdLCBzY2FsZVsxXSAqIG1hdHJpeFNjYWxlWzFdXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcyA9IHRoaXMuX2NyZWF0ZU1lc2hDYW52YXMoc2NhbGUsIHBhdGhUeXBlID09PSBQYXRoVHlwZS5TSEFESU5HID8gbnVsbCA6IHRoaXMuX2JhY2tncm91bmQsIG93bmVyLmNhY2hlZENhbnZhc2VzKTtcbiAgICBpZiAocGF0aFR5cGUgIT09IFBhdGhUeXBlLlNIQURJTkcpIHtcbiAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4ub3duZXIuYmFzZVRyYW5zZm9ybSk7XG4gICAgICBpZiAodGhpcy5tYXRyaXgpIHtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSguLi50aGlzLm1hdHJpeCk7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC50cmFuc2xhdGUodGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRYLCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFkpO1xuICAgIGN0eC5zY2FsZSh0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWCwgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVkpO1xuICAgIHJldHVybiBjdHguY3JlYXRlUGF0dGVybih0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLmNhbnZhcywgXCJuby1yZXBlYXRcIik7XG4gIH1cbn1cbmNsYXNzIER1bW15U2hhZGluZ1BhdHRlcm4gZXh0ZW5kcyBCYXNlU2hhZGluZ1BhdHRlcm4ge1xuICBnZXRQYXR0ZXJuKCkge1xuICAgIHJldHVybiBcImhvdHBpbmtcIjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U2hhZGluZ1BhdHRlcm4oSVIpIHtcbiAgc3dpdGNoIChJUlswXSkge1xuICAgIGNhc2UgXCJSYWRpYWxBeGlhbFwiOlxuICAgICAgcmV0dXJuIG5ldyBSYWRpYWxBeGlhbFNoYWRpbmdQYXR0ZXJuKElSKTtcbiAgICBjYXNlIFwiTWVzaFwiOlxuICAgICAgcmV0dXJuIG5ldyBNZXNoU2hhZGluZ1BhdHRlcm4oSVIpO1xuICAgIGNhc2UgXCJEdW1teVwiOlxuICAgICAgcmV0dXJuIG5ldyBEdW1teVNoYWRpbmdQYXR0ZXJuKCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIElSIHR5cGU6ICR7SVJbMF19YCk7XG59XG5jb25zdCBQYWludFR5cGUgPSB7XG4gIENPTE9SRUQ6IDEsXG4gIFVOQ09MT1JFRDogMlxufTtcbmNsYXNzIFRpbGluZ1BhdHRlcm4ge1xuICBzdGF0aWMgTUFYX1BBVFRFUk5fU0laRSA9IDMwMDA7XG4gIGNvbnN0cnVjdG9yKElSLCBjb2xvciwgY3R4LCBjYW52YXNHcmFwaGljc0ZhY3RvcnksIGJhc2VUcmFuc2Zvcm0pIHtcbiAgICB0aGlzLm9wZXJhdG9yTGlzdCA9IElSWzJdO1xuICAgIHRoaXMubWF0cml4ID0gSVJbM107XG4gICAgdGhpcy5iYm94ID0gSVJbNF07XG4gICAgdGhpcy54c3RlcCA9IElSWzVdO1xuICAgIHRoaXMueXN0ZXAgPSBJUls2XTtcbiAgICB0aGlzLnBhaW50VHlwZSA9IElSWzddO1xuICAgIHRoaXMudGlsaW5nVHlwZSA9IElSWzhdO1xuICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmNhbnZhc0dyYXBoaWNzRmFjdG9yeSA9IGNhbnZhc0dyYXBoaWNzRmFjdG9yeTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSBiYXNlVHJhbnNmb3JtO1xuICB9XG4gIGNyZWF0ZVBhdHRlcm5DYW52YXMob3duZXIpIHtcbiAgICBjb25zdCB7XG4gICAgICBiYm94LFxuICAgICAgb3BlcmF0b3JMaXN0LFxuICAgICAgcGFpbnRUeXBlLFxuICAgICAgdGlsaW5nVHlwZSxcbiAgICAgIGNvbG9yLFxuICAgICAgY2FudmFzR3JhcGhpY3NGYWN0b3J5XG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHtcbiAgICAgIHhzdGVwLFxuICAgICAgeXN0ZXBcbiAgICB9ID0gdGhpcztcbiAgICB4c3RlcCA9IE1hdGguYWJzKHhzdGVwKTtcbiAgICB5c3RlcCA9IE1hdGguYWJzKHlzdGVwKTtcbiAgICBpbmZvKFwiVGlsaW5nVHlwZTogXCIgKyB0aWxpbmdUeXBlKTtcbiAgICBjb25zdCB4MCA9IGJib3hbMF0sXG4gICAgICB5MCA9IGJib3hbMV0sXG4gICAgICB4MSA9IGJib3hbMl0sXG4gICAgICB5MSA9IGJib3hbM107XG4gICAgY29uc3Qgd2lkdGggPSB4MSAtIHgwO1xuICAgIGNvbnN0IGhlaWdodCA9IHkxIC0geTA7XG4gICAgY29uc3QgbWF0cml4U2NhbGUgPSBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRoaXMubWF0cml4KTtcbiAgICBjb25zdCBjdXJNYXRyaXhTY2FsZSA9IFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodGhpcy5iYXNlVHJhbnNmb3JtKTtcbiAgICBjb25zdCBjb21iaW5lZFNjYWxlWCA9IG1hdHJpeFNjYWxlWzBdICogY3VyTWF0cml4U2NhbGVbMF07XG4gICAgY29uc3QgY29tYmluZWRTY2FsZVkgPSBtYXRyaXhTY2FsZVsxXSAqIGN1ck1hdHJpeFNjYWxlWzFdO1xuICAgIGxldCBjYW52YXNXaWR0aCA9IHdpZHRoLFxuICAgICAgY2FudmFzSGVpZ2h0ID0gaGVpZ2h0LFxuICAgICAgcmVkcmF3SG9yaXpvbnRhbGx5ID0gZmFsc2UsXG4gICAgICByZWRyYXdWZXJ0aWNhbGx5ID0gZmFsc2U7XG4gICAgY29uc3QgeFNjYWxlZFN0ZXAgPSBNYXRoLmNlaWwoeHN0ZXAgKiBjb21iaW5lZFNjYWxlWCk7XG4gICAgY29uc3QgeVNjYWxlZFN0ZXAgPSBNYXRoLmNlaWwoeXN0ZXAgKiBjb21iaW5lZFNjYWxlWSk7XG4gICAgY29uc3QgeFNjYWxlZFdpZHRoID0gTWF0aC5jZWlsKHdpZHRoICogY29tYmluZWRTY2FsZVgpO1xuICAgIGNvbnN0IHlTY2FsZWRIZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICogY29tYmluZWRTY2FsZVkpO1xuICAgIGlmICh4U2NhbGVkU3RlcCA+PSB4U2NhbGVkV2lkdGgpIHtcbiAgICAgIGNhbnZhc1dpZHRoID0geHN0ZXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZHJhd0hvcml6b250YWxseSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh5U2NhbGVkU3RlcCA+PSB5U2NhbGVkSGVpZ2h0KSB7XG4gICAgICBjYW52YXNIZWlnaHQgPSB5c3RlcDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVkcmF3VmVydGljYWxseSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGRpbXggPSB0aGlzLmdldFNpemVBbmRTY2FsZShjYW52YXNXaWR0aCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCBjb21iaW5lZFNjYWxlWCk7XG4gICAgY29uc3QgZGlteSA9IHRoaXMuZ2V0U2l6ZUFuZFNjYWxlKGNhbnZhc0hlaWdodCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCwgY29tYmluZWRTY2FsZVkpO1xuICAgIGNvbnN0IHRtcENhbnZhcyA9IG93bmVyLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcInBhdHRlcm5cIiwgZGlteC5zaXplLCBkaW15LnNpemUpO1xuICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IGdyYXBoaWNzID0gY2FudmFzR3JhcGhpY3NGYWN0b3J5LmNyZWF0ZUNhbnZhc0dyYXBoaWNzKHRtcEN0eCk7XG4gICAgZ3JhcGhpY3MuZ3JvdXBMZXZlbCA9IG93bmVyLmdyb3VwTGV2ZWw7XG4gICAgdGhpcy5zZXRGaWxsQW5kU3Ryb2tlU3R5bGVUb0NvbnRleHQoZ3JhcGhpY3MsIHBhaW50VHlwZSwgY29sb3IpO1xuICAgIHRtcEN0eC50cmFuc2xhdGUoLWRpbXguc2NhbGUgKiB4MCwgLWRpbXkuc2NhbGUgKiB5MCk7XG4gICAgZ3JhcGhpY3MudHJhbnNmb3JtKGRpbXguc2NhbGUsIDAsIDAsIGRpbXkuc2NhbGUsIDAsIDApO1xuICAgIHRtcEN0eC5zYXZlKCk7XG4gICAgdGhpcy5jbGlwQmJveChncmFwaGljcywgeDAsIHkwLCB4MSwgeTEpO1xuICAgIGdyYXBoaWNzLmJhc2VUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGdyYXBoaWNzLmN0eCk7XG4gICAgZ3JhcGhpY3MuZXhlY3V0ZU9wZXJhdG9yTGlzdChvcGVyYXRvckxpc3QpO1xuICAgIGdyYXBoaWNzLmVuZERyYXdpbmcoKTtcbiAgICB0bXBDdHgucmVzdG9yZSgpO1xuICAgIGlmIChyZWRyYXdIb3Jpem9udGFsbHkgfHwgcmVkcmF3VmVydGljYWxseSkge1xuICAgICAgY29uc3QgaW1hZ2UgPSB0bXBDYW52YXMuY2FudmFzO1xuICAgICAgaWYgKHJlZHJhd0hvcml6b250YWxseSkge1xuICAgICAgICBjYW52YXNXaWR0aCA9IHhzdGVwO1xuICAgICAgfVxuICAgICAgaWYgKHJlZHJhd1ZlcnRpY2FsbHkpIHtcbiAgICAgICAgY2FudmFzSGVpZ2h0ID0geXN0ZXA7XG4gICAgICB9XG4gICAgICBjb25zdCBkaW14MiA9IHRoaXMuZ2V0U2l6ZUFuZFNjYWxlKGNhbnZhc1dpZHRoLCB0aGlzLmN0eC5jYW52YXMud2lkdGgsIGNvbWJpbmVkU2NhbGVYKTtcbiAgICAgIGNvbnN0IGRpbXkyID0gdGhpcy5nZXRTaXplQW5kU2NhbGUoY2FudmFzSGVpZ2h0LCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0LCBjb21iaW5lZFNjYWxlWSk7XG4gICAgICBjb25zdCB4U2l6ZSA9IGRpbXgyLnNpemU7XG4gICAgICBjb25zdCB5U2l6ZSA9IGRpbXkyLnNpemU7XG4gICAgICBjb25zdCB0bXBDYW52YXMyID0gb3duZXIuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwicGF0dGVybi13b3JrYXJvdW5kXCIsIHhTaXplLCB5U2l6ZSk7XG4gICAgICBjb25zdCB0bXBDdHgyID0gdG1wQ2FudmFzMi5jb250ZXh0O1xuICAgICAgY29uc3QgaWkgPSByZWRyYXdIb3Jpem9udGFsbHkgPyBNYXRoLmZsb29yKHdpZHRoIC8geHN0ZXApIDogMDtcbiAgICAgIGNvbnN0IGpqID0gcmVkcmF3VmVydGljYWxseSA/IE1hdGguZmxvb3IoaGVpZ2h0IC8geXN0ZXApIDogMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGlpOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPD0gamo7IGorKykge1xuICAgICAgICAgIHRtcEN0eDIuZHJhd0ltYWdlKGltYWdlLCB4U2l6ZSAqIGksIHlTaXplICogaiwgeFNpemUsIHlTaXplLCAwLCAwLCB4U2l6ZSwgeVNpemUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYW52YXM6IHRtcENhbnZhczIuY2FudmFzLFxuICAgICAgICBzY2FsZVg6IGRpbXgyLnNjYWxlLFxuICAgICAgICBzY2FsZVk6IGRpbXkyLnNjYWxlLFxuICAgICAgICBvZmZzZXRYOiB4MCxcbiAgICAgICAgb2Zmc2V0WTogeTBcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjYW52YXM6IHRtcENhbnZhcy5jYW52YXMsXG4gICAgICBzY2FsZVg6IGRpbXguc2NhbGUsXG4gICAgICBzY2FsZVk6IGRpbXkuc2NhbGUsXG4gICAgICBvZmZzZXRYOiB4MCxcbiAgICAgIG9mZnNldFk6IHkwXG4gICAgfTtcbiAgfVxuICBnZXRTaXplQW5kU2NhbGUoc3RlcCwgcmVhbE91dHB1dFNpemUsIHNjYWxlKSB7XG4gICAgY29uc3QgbWF4U2l6ZSA9IE1hdGgubWF4KFRpbGluZ1BhdHRlcm4uTUFYX1BBVFRFUk5fU0laRSwgcmVhbE91dHB1dFNpemUpO1xuICAgIGxldCBzaXplID0gTWF0aC5jZWlsKHN0ZXAgKiBzY2FsZSk7XG4gICAgaWYgKHNpemUgPj0gbWF4U2l6ZSkge1xuICAgICAgc2l6ZSA9IG1heFNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlID0gc2l6ZSAvIHN0ZXA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzY2FsZSxcbiAgICAgIHNpemVcbiAgICB9O1xuICB9XG4gIGNsaXBCYm94KGdyYXBoaWNzLCB4MCwgeTAsIHgxLCB5MSkge1xuICAgIGNvbnN0IGJib3hXaWR0aCA9IHgxIC0geDA7XG4gICAgY29uc3QgYmJveEhlaWdodCA9IHkxIC0geTA7XG4gICAgZ3JhcGhpY3MuY3R4LnJlY3QoeDAsIHkwLCBiYm94V2lkdGgsIGJib3hIZWlnaHQpO1xuICAgIGdyYXBoaWNzLmN1cnJlbnQudXBkYXRlUmVjdE1pbk1heChnZXRDdXJyZW50VHJhbnNmb3JtKGdyYXBoaWNzLmN0eCksIFt4MCwgeTAsIHgxLCB5MV0pO1xuICAgIGdyYXBoaWNzLmNsaXAoKTtcbiAgICBncmFwaGljcy5lbmRQYXRoKCk7XG4gIH1cbiAgc2V0RmlsbEFuZFN0cm9rZVN0eWxlVG9Db250ZXh0KGdyYXBoaWNzLCBwYWludFR5cGUsIGNvbG9yKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGdyYXBoaWNzLmN0eCxcbiAgICAgIGN1cnJlbnQgPSBncmFwaGljcy5jdXJyZW50O1xuICAgIHN3aXRjaCAocGFpbnRUeXBlKSB7XG4gICAgICBjYXNlIFBhaW50VHlwZS5DT0xPUkVEOlxuICAgICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY3R4LnN0cm9rZVN0eWxlO1xuICAgICAgICBjdXJyZW50LmZpbGxDb2xvciA9IGN0eC5maWxsU3R5bGU7XG4gICAgICAgIGN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBjdHguc3Ryb2tlU3R5bGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQYWludFR5cGUuVU5DT0xPUkVEOlxuICAgICAgICBjb25zdCBjc3NDb2xvciA9IFV0aWwubWFrZUhleENvbG9yKGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0pO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNzc0NvbG9yO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY3NzQ29sb3I7XG4gICAgICAgIGN1cnJlbnQuZmlsbENvbG9yID0gY3NzQ29sb3I7XG4gICAgICAgIGN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBjc3NDb2xvcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYFVuc3VwcG9ydGVkIHBhaW50IHR5cGU6ICR7cGFpbnRUeXBlfWApO1xuICAgIH1cbiAgfVxuICBnZXRQYXR0ZXJuKGN0eCwgb3duZXIsIGludmVyc2UsIHBhdGhUeXBlKSB7XG4gICAgbGV0IG1hdHJpeCA9IGludmVyc2U7XG4gICAgaWYgKHBhdGhUeXBlICE9PSBQYXRoVHlwZS5TSEFESU5HKSB7XG4gICAgICBtYXRyaXggPSBVdGlsLnRyYW5zZm9ybShtYXRyaXgsIG93bmVyLmJhc2VUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICAgIG1hdHJpeCA9IFV0aWwudHJhbnNmb3JtKG1hdHJpeCwgdGhpcy5tYXRyaXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzID0gdGhpcy5jcmVhdGVQYXR0ZXJuQ2FudmFzKG93bmVyKTtcbiAgICBsZXQgZG9tTWF0cml4ID0gbmV3IERPTU1hdHJpeChtYXRyaXgpO1xuICAgIGRvbU1hdHJpeCA9IGRvbU1hdHJpeC50cmFuc2xhdGUodGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRYLCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFkpO1xuICAgIGRvbU1hdHJpeCA9IGRvbU1hdHJpeC5zY2FsZSgxIC8gdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVgsIDEgLyB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWSk7XG4gICAgY29uc3QgcGF0dGVybiA9IGN0eC5jcmVhdGVQYXR0ZXJuKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuY2FudmFzLCBcInJlcGVhdFwiKTtcbiAgICBwYXR0ZXJuLnNldFRyYW5zZm9ybShkb21NYXRyaXgpO1xuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG59XG5cbjsvLyAuL3NyYy9zaGFyZWQvaW1hZ2VfdXRpbHMuanNcblxuZnVuY3Rpb24gY29udmVydFRvUkdCQShwYXJhbXMpIHtcbiAgc3dpdGNoIChwYXJhbXMua2luZCkge1xuICAgIGNhc2UgSW1hZ2VLaW5kLkdSQVlTQ0FMRV8xQlBQOlxuICAgICAgcmV0dXJuIGNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBKHBhcmFtcyk7XG4gICAgY2FzZSBJbWFnZUtpbmQuUkdCXzI0QlBQOlxuICAgICAgcmV0dXJuIGNvbnZlcnRSR0JUb1JHQkEocGFyYW1zKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBKHtcbiAgc3JjLFxuICBzcmNQb3MgPSAwLFxuICBkZXN0LFxuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBub25CbGFja0NvbG9yID0gMHhmZmZmZmZmZixcbiAgaW52ZXJzZURlY29kZSA9IGZhbHNlXG59KSB7XG4gIGNvbnN0IGJsYWNrID0gdXRpbF9GZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbiA/IDB4ZmYwMDAwMDAgOiAweDAwMDAwMGZmO1xuICBjb25zdCBbemVyb01hcHBpbmcsIG9uZU1hcHBpbmddID0gaW52ZXJzZURlY29kZSA/IFtub25CbGFja0NvbG9yLCBibGFja10gOiBbYmxhY2ssIG5vbkJsYWNrQ29sb3JdO1xuICBjb25zdCB3aWR0aEluU291cmNlID0gd2lkdGggPj4gMztcbiAgY29uc3Qgd2lkdGhSZW1haW5kZXIgPSB3aWR0aCAmIDc7XG4gIGNvbnN0IHNyY0xlbmd0aCA9IHNyYy5sZW5ndGg7XG4gIGRlc3QgPSBuZXcgVWludDMyQXJyYXkoZGVzdC5idWZmZXIpO1xuICBsZXQgZGVzdFBvcyA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICBmb3IgKGNvbnN0IG1heCA9IHNyY1BvcyArIHdpZHRoSW5Tb3VyY2U7IHNyY1BvcyA8IG1heDsgc3JjUG9zKyspIHtcbiAgICAgIGNvbnN0IGVsZW0gPSBzcmNQb3MgPCBzcmNMZW5ndGggPyBzcmNbc3JjUG9zXSA6IDI1NTtcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMDAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMSA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICB9XG4gICAgaWYgKHdpZHRoUmVtYWluZGVyID09PSAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZWxlbSA9IHNyY1BvcyA8IHNyY0xlbmd0aCA/IHNyY1tzcmNQb3MrK10gOiAyNTU7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aWR0aFJlbWFpbmRlcjsgaisrKSB7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMSA8PCA3IC0gaiA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzcmNQb3MsXG4gICAgZGVzdFBvc1xuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFJHQlRvUkdCQSh7XG4gIHNyYyxcbiAgc3JjUG9zID0gMCxcbiAgZGVzdCxcbiAgZGVzdFBvcyA9IDAsXG4gIHdpZHRoLFxuICBoZWlnaHRcbn0pIHtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBsZW4gPSB3aWR0aCAqIGhlaWdodCAqIDM7XG4gIGNvbnN0IGxlbjMyID0gbGVuID4+IDI7XG4gIGNvbnN0IHNyYzMyID0gbmV3IFVpbnQzMkFycmF5KHNyYy5idWZmZXIsIHNyY1BvcywgbGVuMzIpO1xuICBpZiAoRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4pIHtcbiAgICBmb3IgKDsgaSA8IGxlbjMyIC0gMjsgaSArPSAzLCBkZXN0UG9zICs9IDQpIHtcbiAgICAgIGNvbnN0IHMxID0gc3JjMzJbaV07XG4gICAgICBjb25zdCBzMiA9IHNyYzMyW2kgKyAxXTtcbiAgICAgIGNvbnN0IHMzID0gc3JjMzJbaSArIDJdO1xuICAgICAgZGVzdFtkZXN0UG9zXSA9IHMxIHwgMHhmZjAwMDAwMDtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDFdID0gczEgPj4+IDI0IHwgczIgPDwgOCB8IDB4ZmYwMDAwMDA7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAyXSA9IHMyID4+PiAxNiB8IHMzIDw8IDE2IHwgMHhmZjAwMDAwMDtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDNdID0gczMgPj4+IDggfCAweGZmMDAwMDAwO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gaSAqIDQsIGpqID0gc3JjUG9zICsgbGVuOyBqIDwgamo7IGogKz0gMykge1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW2pdIHwgc3JjW2ogKyAxXSA8PCA4IHwgc3JjW2ogKyAyXSA8PCAxNiB8IDB4ZmYwMDAwMDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoOyBpIDwgbGVuMzIgLSAyOyBpICs9IDMsIGRlc3RQb3MgKz0gNCkge1xuICAgICAgY29uc3QgczEgPSBzcmMzMltpXTtcbiAgICAgIGNvbnN0IHMyID0gc3JjMzJbaSArIDFdO1xuICAgICAgY29uc3QgczMgPSBzcmMzMltpICsgMl07XG4gICAgICBkZXN0W2Rlc3RQb3NdID0gczEgfCAweGZmO1xuICAgICAgZGVzdFtkZXN0UG9zICsgMV0gPSBzMSA8PCAyNCB8IHMyID4+PiA4IHwgMHhmZjtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDJdID0gczIgPDwgMTYgfCBzMyA+Pj4gMTYgfCAweGZmO1xuICAgICAgZGVzdFtkZXN0UG9zICsgM10gPSBzMyA8PCA4IHwgMHhmZjtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IGkgKiA0LCBqaiA9IHNyY1BvcyArIGxlbjsgaiA8IGpqOyBqICs9IDMpIHtcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tqXSA8PCAyNCB8IHNyY1tqICsgMV0gPDwgMTYgfCBzcmNbaiArIDJdIDw8IDggfCAweGZmO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHNyY1Bvczogc3JjUG9zICsgbGVuLFxuICAgIGRlc3RQb3NcbiAgfTtcbn1cbmZ1bmN0aW9uIGdyYXlUb1JHQkEoc3JjLCBkZXN0KSB7XG4gIGlmIChGZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbikge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBkZXN0W2ldID0gc3JjW2ldICogMHgxMDEwMSB8IDB4ZmYwMDAwMDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBkZXN0W2ldID0gc3JjW2ldICogMHgxMDEwMTAwIHwgMHgwMDAwMDBmZjtcbiAgICB9XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvY2FudmFzLmpzXG5cblxuXG5cbmNvbnN0IE1JTl9GT05UX1NJWkUgPSAxNjtcbmNvbnN0IE1BWF9GT05UX1NJWkUgPSAxMDA7XG5jb25zdCBFWEVDVVRJT05fVElNRSA9IDE1O1xuY29uc3QgRVhFQ1VUSU9OX1NURVBTID0gMTA7XG5jb25zdCBNQVhfU0laRV9UT19DT01QSUxFID0gMTAwMDtcbmNvbnN0IEZVTExfQ0hVTktfSEVJR0hUID0gMTY7XG5mdW5jdGlvbiBtaXJyb3JDb250ZXh0T3BlcmF0aW9ucyhjdHgsIGRlc3RDdHgpIHtcbiAgaWYgKGN0eC5fcmVtb3ZlTWlycm9yaW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGV4dCBpcyBhbHJlYWR5IGZvcndhcmRpbmcgb3BlcmF0aW9ucy5cIik7XG4gIH1cbiAgY3R4Ll9fb3JpZ2luYWxTYXZlID0gY3R4LnNhdmU7XG4gIGN0eC5fX29yaWdpbmFsUmVzdG9yZSA9IGN0eC5yZXN0b3JlO1xuICBjdHguX19vcmlnaW5hbFJvdGF0ZSA9IGN0eC5yb3RhdGU7XG4gIGN0eC5fX29yaWdpbmFsU2NhbGUgPSBjdHguc2NhbGU7XG4gIGN0eC5fX29yaWdpbmFsVHJhbnNsYXRlID0gY3R4LnRyYW5zbGF0ZTtcbiAgY3R4Ll9fb3JpZ2luYWxUcmFuc2Zvcm0gPSBjdHgudHJhbnNmb3JtO1xuICBjdHguX19vcmlnaW5hbFNldFRyYW5zZm9ybSA9IGN0eC5zZXRUcmFuc2Zvcm07XG4gIGN0eC5fX29yaWdpbmFsUmVzZXRUcmFuc2Zvcm0gPSBjdHgucmVzZXRUcmFuc2Zvcm07XG4gIGN0eC5fX29yaWdpbmFsQ2xpcCA9IGN0eC5jbGlwO1xuICBjdHguX19vcmlnaW5hbE1vdmVUbyA9IGN0eC5tb3ZlVG87XG4gIGN0eC5fX29yaWdpbmFsTGluZVRvID0gY3R4LmxpbmVUbztcbiAgY3R4Ll9fb3JpZ2luYWxCZXppZXJDdXJ2ZVRvID0gY3R4LmJlemllckN1cnZlVG87XG4gIGN0eC5fX29yaWdpbmFsUmVjdCA9IGN0eC5yZWN0O1xuICBjdHguX19vcmlnaW5hbENsb3NlUGF0aCA9IGN0eC5jbG9zZVBhdGg7XG4gIGN0eC5fX29yaWdpbmFsQmVnaW5QYXRoID0gY3R4LmJlZ2luUGF0aDtcbiAgY3R4Ll9yZW1vdmVNaXJyb3JpbmcgPSAoKSA9PiB7XG4gICAgY3R4LnNhdmUgPSBjdHguX19vcmlnaW5hbFNhdmU7XG4gICAgY3R4LnJlc3RvcmUgPSBjdHguX19vcmlnaW5hbFJlc3RvcmU7XG4gICAgY3R4LnJvdGF0ZSA9IGN0eC5fX29yaWdpbmFsUm90YXRlO1xuICAgIGN0eC5zY2FsZSA9IGN0eC5fX29yaWdpbmFsU2NhbGU7XG4gICAgY3R4LnRyYW5zbGF0ZSA9IGN0eC5fX29yaWdpbmFsVHJhbnNsYXRlO1xuICAgIGN0eC50cmFuc2Zvcm0gPSBjdHguX19vcmlnaW5hbFRyYW5zZm9ybTtcbiAgICBjdHguc2V0VHJhbnNmb3JtID0gY3R4Ll9fb3JpZ2luYWxTZXRUcmFuc2Zvcm07XG4gICAgY3R4LnJlc2V0VHJhbnNmb3JtID0gY3R4Ll9fb3JpZ2luYWxSZXNldFRyYW5zZm9ybTtcbiAgICBjdHguY2xpcCA9IGN0eC5fX29yaWdpbmFsQ2xpcDtcbiAgICBjdHgubW92ZVRvID0gY3R4Ll9fb3JpZ2luYWxNb3ZlVG87XG4gICAgY3R4LmxpbmVUbyA9IGN0eC5fX29yaWdpbmFsTGluZVRvO1xuICAgIGN0eC5iZXppZXJDdXJ2ZVRvID0gY3R4Ll9fb3JpZ2luYWxCZXppZXJDdXJ2ZVRvO1xuICAgIGN0eC5yZWN0ID0gY3R4Ll9fb3JpZ2luYWxSZWN0O1xuICAgIGN0eC5jbG9zZVBhdGggPSBjdHguX19vcmlnaW5hbENsb3NlUGF0aDtcbiAgICBjdHguYmVnaW5QYXRoID0gY3R4Ll9fb3JpZ2luYWxCZWdpblBhdGg7XG4gICAgZGVsZXRlIGN0eC5fcmVtb3ZlTWlycm9yaW5nO1xuICB9O1xuICBjdHguc2F2ZSA9IGZ1bmN0aW9uIGN0eFNhdmUoKSB7XG4gICAgZGVzdEN0eC5zYXZlKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsU2F2ZSgpO1xuICB9O1xuICBjdHgucmVzdG9yZSA9IGZ1bmN0aW9uIGN0eFJlc3RvcmUoKSB7XG4gICAgZGVzdEN0eC5yZXN0b3JlKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsUmVzdG9yZSgpO1xuICB9O1xuICBjdHgudHJhbnNsYXRlID0gZnVuY3Rpb24gY3R4VHJhbnNsYXRlKHgsIHkpIHtcbiAgICBkZXN0Q3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxUcmFuc2xhdGUoeCwgeSk7XG4gIH07XG4gIGN0eC5zY2FsZSA9IGZ1bmN0aW9uIGN0eFNjYWxlKHgsIHkpIHtcbiAgICBkZXN0Q3R4LnNjYWxlKHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbFNjYWxlKHgsIHkpO1xuICB9O1xuICBjdHgudHJhbnNmb3JtID0gZnVuY3Rpb24gY3R4VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBkZXN0Q3R4LnRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gIH07XG4gIGN0eC5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiBjdHhTZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZikge1xuICAgIGRlc3RDdHguc2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgIHRoaXMuX19vcmlnaW5hbFNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgfTtcbiAgY3R4LnJlc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gY3R4UmVzZXRUcmFuc2Zvcm0oKSB7XG4gICAgZGVzdEN0eC5yZXNldFRyYW5zZm9ybSgpO1xuICAgIHRoaXMuX19vcmlnaW5hbFJlc2V0VHJhbnNmb3JtKCk7XG4gIH07XG4gIGN0eC5yb3RhdGUgPSBmdW5jdGlvbiBjdHhSb3RhdGUoYW5nbGUpIHtcbiAgICBkZXN0Q3R4LnJvdGF0ZShhbmdsZSk7XG4gICAgdGhpcy5fX29yaWdpbmFsUm90YXRlKGFuZ2xlKTtcbiAgfTtcbiAgY3R4LmNsaXAgPSBmdW5jdGlvbiBjdHhSb3RhdGUocnVsZSkge1xuICAgIGRlc3RDdHguY2xpcChydWxlKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxDbGlwKHJ1bGUpO1xuICB9O1xuICBjdHgubW92ZVRvID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBkZXN0Q3R4Lm1vdmVUbyh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxNb3ZlVG8oeCwgeSk7XG4gIH07XG4gIGN0eC5saW5lVG8gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGRlc3RDdHgubGluZVRvKHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbExpbmVUbyh4LCB5KTtcbiAgfTtcbiAgY3R4LmJlemllckN1cnZlVG8gPSBmdW5jdGlvbiAoY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSkge1xuICAgIGRlc3RDdHguYmV6aWVyQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxCZXppZXJDdXJ2ZVRvKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpO1xuICB9O1xuICBjdHgucmVjdCA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgZGVzdEN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuX19vcmlnaW5hbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gIH07XG4gIGN0eC5jbG9zZVBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVzdEN0eC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxDbG9zZVBhdGgoKTtcbiAgfTtcbiAgY3R4LmJlZ2luUGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICBkZXN0Q3R4LmJlZ2luUGF0aCgpO1xuICAgIHRoaXMuX19vcmlnaW5hbEJlZ2luUGF0aCgpO1xuICB9O1xufVxuY2xhc3MgQ2FjaGVkQ2FudmFzZXMge1xuICBjb25zdHJ1Y3RvcihjYW52YXNGYWN0b3J5KSB7XG4gICAgdGhpcy5jYW52YXNGYWN0b3J5ID0gY2FudmFzRmFjdG9yeTtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICBnZXRDYW52YXMoaWQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBsZXQgY2FudmFzRW50cnk7XG4gICAgaWYgKHRoaXMuY2FjaGVbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNhbnZhc0VudHJ5ID0gdGhpcy5jYWNoZVtpZF07XG4gICAgICB0aGlzLmNhbnZhc0ZhY3RvcnkucmVzZXQoY2FudmFzRW50cnksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYW52YXNFbnRyeSA9IHRoaXMuY2FudmFzRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLmNhY2hlW2lkXSA9IGNhbnZhc0VudHJ5O1xuICAgIH1cbiAgICByZXR1cm4gY2FudmFzRW50cnk7XG4gIH1cbiAgZGVsZXRlKGlkKSB7XG4gICAgZGVsZXRlIHRoaXMuY2FjaGVbaWRdO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGZvciAoY29uc3QgaWQgaW4gdGhpcy5jYWNoZSkge1xuICAgICAgY29uc3QgY2FudmFzRW50cnkgPSB0aGlzLmNhY2hlW2lkXTtcbiAgICAgIHRoaXMuY2FudmFzRmFjdG9yeS5kZXN0cm95KGNhbnZhc0VudHJ5KTtcbiAgICAgIGRlbGV0ZSB0aGlzLmNhY2hlW2lkXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhjdHgsIHNyY0ltZywgc3JjWCwgc3JjWSwgc3JjVywgc3JjSCwgZGVzdFgsIGRlc3RZLCBkZXN0VywgZGVzdEgpIHtcbiAgY29uc3QgW2EsIGIsIGMsIGQsIHR4LCB0eV0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCk7XG4gIGlmIChiID09PSAwICYmIGMgPT09IDApIHtcbiAgICBjb25zdCB0bFggPSBkZXN0WCAqIGEgKyB0eDtcbiAgICBjb25zdCByVGxYID0gTWF0aC5yb3VuZCh0bFgpO1xuICAgIGNvbnN0IHRsWSA9IGRlc3RZICogZCArIHR5O1xuICAgIGNvbnN0IHJUbFkgPSBNYXRoLnJvdW5kKHRsWSk7XG4gICAgY29uc3QgYnJYID0gKGRlc3RYICsgZGVzdFcpICogYSArIHR4O1xuICAgIGNvbnN0IHJXaWR0aCA9IE1hdGguYWJzKE1hdGgucm91bmQoYnJYKSAtIHJUbFgpIHx8IDE7XG4gICAgY29uc3QgYnJZID0gKGRlc3RZICsgZGVzdEgpICogZCArIHR5O1xuICAgIGNvbnN0IHJIZWlnaHQgPSBNYXRoLmFicyhNYXRoLnJvdW5kKGJyWSkgLSByVGxZKSB8fCAxO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oTWF0aC5zaWduKGEpLCAwLCAwLCBNYXRoLnNpZ24oZCksIHJUbFgsIHJUbFkpO1xuICAgIGN0eC5kcmF3SW1hZ2Uoc3JjSW1nLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCAwLCAwLCByV2lkdGgsIHJIZWlnaHQpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgdHgsIHR5KTtcbiAgICByZXR1cm4gW3JXaWR0aCwgckhlaWdodF07XG4gIH1cbiAgaWYgKGEgPT09IDAgJiYgZCA9PT0gMCkge1xuICAgIGNvbnN0IHRsWCA9IGRlc3RZICogYyArIHR4O1xuICAgIGNvbnN0IHJUbFggPSBNYXRoLnJvdW5kKHRsWCk7XG4gICAgY29uc3QgdGxZID0gZGVzdFggKiBiICsgdHk7XG4gICAgY29uc3QgclRsWSA9IE1hdGgucm91bmQodGxZKTtcbiAgICBjb25zdCBiclggPSAoZGVzdFkgKyBkZXN0SCkgKiBjICsgdHg7XG4gICAgY29uc3QgcldpZHRoID0gTWF0aC5hYnMoTWF0aC5yb3VuZChiclgpIC0gclRsWCkgfHwgMTtcbiAgICBjb25zdCBiclkgPSAoZGVzdFggKyBkZXN0VykgKiBiICsgdHk7XG4gICAgY29uc3QgckhlaWdodCA9IE1hdGguYWJzKE1hdGgucm91bmQoYnJZKSAtIHJUbFkpIHx8IDE7XG4gICAgY3R4LnNldFRyYW5zZm9ybSgwLCBNYXRoLnNpZ24oYiksIE1hdGguc2lnbihjKSwgMCwgclRsWCwgclRsWSk7XG4gICAgY3R4LmRyYXdJbWFnZShzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIDAsIDAsIHJIZWlnaHQsIHJXaWR0aCk7XG4gICAgY3R4LnNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCB0eCwgdHkpO1xuICAgIHJldHVybiBbckhlaWdodCwgcldpZHRoXTtcbiAgfVxuICBjdHguZHJhd0ltYWdlKHNyY0ltZywgc3JjWCwgc3JjWSwgc3JjVywgc3JjSCwgZGVzdFgsIGRlc3RZLCBkZXN0VywgZGVzdEgpO1xuICBjb25zdCBzY2FsZVggPSBNYXRoLmh5cG90KGEsIGIpO1xuICBjb25zdCBzY2FsZVkgPSBNYXRoLmh5cG90KGMsIGQpO1xuICByZXR1cm4gW3NjYWxlWCAqIGRlc3RXLCBzY2FsZVkgKiBkZXN0SF07XG59XG5mdW5jdGlvbiBjb21waWxlVHlwZTNHbHlwaChpbWdEYXRhKSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IGltZ0RhdGE7XG4gIGlmICh3aWR0aCA+IE1BWF9TSVpFX1RPX0NPTVBJTEUgfHwgaGVpZ2h0ID4gTUFYX1NJWkVfVE9fQ09NUElMRSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IFBPSU5UX1RPX1BST0NFU1NfTElNSVQgPSAxMDAwO1xuICBjb25zdCBQT0lOVF9UWVBFUyA9IG5ldyBVaW50OEFycmF5KFswLCAyLCA0LCAwLCAxLCAwLCA1LCA0LCA4LCAxMCwgMCwgOCwgMCwgMiwgMSwgMF0pO1xuICBjb25zdCB3aWR0aDEgPSB3aWR0aCArIDE7XG4gIGxldCBwb2ludHMgPSBuZXcgVWludDhBcnJheSh3aWR0aDEgKiAoaGVpZ2h0ICsgMSkpO1xuICBsZXQgaSwgaiwgajA7XG4gIGNvbnN0IGxpbmVTaXplID0gd2lkdGggKyA3ICYgfjc7XG4gIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkobGluZVNpemUgKiBoZWlnaHQpLFxuICAgIHBvcyA9IDA7XG4gIGZvciAoY29uc3QgZWxlbSBvZiBpbWdEYXRhLmRhdGEpIHtcbiAgICBsZXQgbWFzayA9IDEyODtcbiAgICB3aGlsZSAobWFzayA+IDApIHtcbiAgICAgIGRhdGFbcG9zKytdID0gZWxlbSAmIG1hc2sgPyAwIDogMjU1O1xuICAgICAgbWFzayA+Pj0gMTtcbiAgICB9XG4gIH1cbiAgbGV0IGNvdW50ID0gMDtcbiAgcG9zID0gMDtcbiAgaWYgKGRhdGFbcG9zXSAhPT0gMCkge1xuICAgIHBvaW50c1swXSA9IDE7XG4gICAgKytjb3VudDtcbiAgfVxuICBmb3IgKGogPSAxOyBqIDwgd2lkdGg7IGorKykge1xuICAgIGlmIChkYXRhW3Bvc10gIT09IGRhdGFbcG9zICsgMV0pIHtcbiAgICAgIHBvaW50c1tqXSA9IGRhdGFbcG9zXSA/IDIgOiAxO1xuICAgICAgKytjb3VudDtcbiAgICB9XG4gICAgcG9zKys7XG4gIH1cbiAgaWYgKGRhdGFbcG9zXSAhPT0gMCkge1xuICAgIHBvaW50c1tqXSA9IDI7XG4gICAgKytjb3VudDtcbiAgfVxuICBmb3IgKGkgPSAxOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICBwb3MgPSBpICogbGluZVNpemU7XG4gICAgajAgPSBpICogd2lkdGgxO1xuICAgIGlmIChkYXRhW3BvcyAtIGxpbmVTaXplXSAhPT0gZGF0YVtwb3NdKSB7XG4gICAgICBwb2ludHNbajBdID0gZGF0YVtwb3NdID8gMSA6IDg7XG4gICAgICArK2NvdW50O1xuICAgIH1cbiAgICBsZXQgc3VtID0gKGRhdGFbcG9zXSA/IDQgOiAwKSArIChkYXRhW3BvcyAtIGxpbmVTaXplXSA/IDggOiAwKTtcbiAgICBmb3IgKGogPSAxOyBqIDwgd2lkdGg7IGorKykge1xuICAgICAgc3VtID0gKHN1bSA+PiAyKSArIChkYXRhW3BvcyArIDFdID8gNCA6IDApICsgKGRhdGFbcG9zIC0gbGluZVNpemUgKyAxXSA/IDggOiAwKTtcbiAgICAgIGlmIChQT0lOVF9UWVBFU1tzdW1dKSB7XG4gICAgICAgIHBvaW50c1tqMCArIGpdID0gUE9JTlRfVFlQRVNbc3VtXTtcbiAgICAgICAgKytjb3VudDtcbiAgICAgIH1cbiAgICAgIHBvcysrO1xuICAgIH1cbiAgICBpZiAoZGF0YVtwb3MgLSBsaW5lU2l6ZV0gIT09IGRhdGFbcG9zXSkge1xuICAgICAgcG9pbnRzW2owICsgal0gPSBkYXRhW3Bvc10gPyAyIDogNDtcbiAgICAgICsrY291bnQ7XG4gICAgfVxuICAgIGlmIChjb3VudCA+IFBPSU5UX1RPX1BST0NFU1NfTElNSVQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBwb3MgPSBsaW5lU2l6ZSAqIChoZWlnaHQgLSAxKTtcbiAgajAgPSBpICogd2lkdGgxO1xuICBpZiAoZGF0YVtwb3NdICE9PSAwKSB7XG4gICAgcG9pbnRzW2owXSA9IDg7XG4gICAgKytjb3VudDtcbiAgfVxuICBmb3IgKGogPSAxOyBqIDwgd2lkdGg7IGorKykge1xuICAgIGlmIChkYXRhW3Bvc10gIT09IGRhdGFbcG9zICsgMV0pIHtcbiAgICAgIHBvaW50c1tqMCArIGpdID0gZGF0YVtwb3NdID8gNCA6IDg7XG4gICAgICArK2NvdW50O1xuICAgIH1cbiAgICBwb3MrKztcbiAgfVxuICBpZiAoZGF0YVtwb3NdICE9PSAwKSB7XG4gICAgcG9pbnRzW2owICsgal0gPSA0O1xuICAgICsrY291bnQ7XG4gIH1cbiAgaWYgKGNvdW50ID4gUE9JTlRfVE9fUFJPQ0VTU19MSU1JVCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHN0ZXBzID0gbmV3IEludDMyQXJyYXkoWzAsIHdpZHRoMSwgLTEsIDAsIC13aWR0aDEsIDAsIDAsIDAsIDFdKTtcbiAgY29uc3QgcGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgZm9yIChpID0gMDsgY291bnQgJiYgaSA8PSBoZWlnaHQ7IGkrKykge1xuICAgIGxldCBwID0gaSAqIHdpZHRoMTtcbiAgICBjb25zdCBlbmQgPSBwICsgd2lkdGg7XG4gICAgd2hpbGUgKHAgPCBlbmQgJiYgIXBvaW50c1twXSkge1xuICAgICAgcCsrO1xuICAgIH1cbiAgICBpZiAocCA9PT0gZW5kKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcGF0aC5tb3ZlVG8ocCAlIHdpZHRoMSwgaSk7XG4gICAgY29uc3QgcDAgPSBwO1xuICAgIGxldCB0eXBlID0gcG9pbnRzW3BdO1xuICAgIGRvIHtcbiAgICAgIGNvbnN0IHN0ZXAgPSBzdGVwc1t0eXBlXTtcbiAgICAgIGRvIHtcbiAgICAgICAgcCArPSBzdGVwO1xuICAgICAgfSB3aGlsZSAoIXBvaW50c1twXSk7XG4gICAgICBjb25zdCBwcCA9IHBvaW50c1twXTtcbiAgICAgIGlmIChwcCAhPT0gNSAmJiBwcCAhPT0gMTApIHtcbiAgICAgICAgdHlwZSA9IHBwO1xuICAgICAgICBwb2ludHNbcF0gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9IHBwICYgMHgzMyAqIHR5cGUgPj4gNDtcbiAgICAgICAgcG9pbnRzW3BdICY9IHR5cGUgPj4gMiB8IHR5cGUgPDwgMjtcbiAgICAgIH1cbiAgICAgIHBhdGgubGluZVRvKHAgJSB3aWR0aDEsIHAgLyB3aWR0aDEgfCAwKTtcbiAgICAgIGlmICghcG9pbnRzW3BdKSB7XG4gICAgICAgIC0tY291bnQ7XG4gICAgICB9XG4gICAgfSB3aGlsZSAocDAgIT09IHApO1xuICAgIC0taTtcbiAgfVxuICBkYXRhID0gbnVsbDtcbiAgcG9pbnRzID0gbnVsbDtcbiAgY29uc3QgZHJhd091dGxpbmUgPSBmdW5jdGlvbiAoYykge1xuICAgIGMuc2F2ZSgpO1xuICAgIGMuc2NhbGUoMSAvIHdpZHRoLCAtMSAvIGhlaWdodCk7XG4gICAgYy50cmFuc2xhdGUoMCwgLWhlaWdodCk7XG4gICAgYy5maWxsKHBhdGgpO1xuICAgIGMuYmVnaW5QYXRoKCk7XG4gICAgYy5yZXN0b3JlKCk7XG4gIH07XG4gIHJldHVybiBkcmF3T3V0bGluZTtcbn1cbmNsYXNzIENhbnZhc0V4dHJhU3RhdGUge1xuICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5hbHBoYUlzU2hhcGUgPSBmYWxzZTtcbiAgICB0aGlzLmZvbnRTaXplID0gMDtcbiAgICB0aGlzLmZvbnRTaXplU2NhbGUgPSAxO1xuICAgIHRoaXMudGV4dE1hdHJpeCA9IElERU5USVRZX01BVFJJWDtcbiAgICB0aGlzLnRleHRNYXRyaXhTY2FsZSA9IDE7XG4gICAgdGhpcy5mb250TWF0cml4ID0gRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgdGhpcy5sZWFkaW5nID0gMDtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5saW5lWCA9IDA7XG4gICAgdGhpcy5saW5lWSA9IDA7XG4gICAgdGhpcy5jaGFyU3BhY2luZyA9IDA7XG4gICAgdGhpcy53b3JkU3BhY2luZyA9IDA7XG4gICAgdGhpcy50ZXh0SFNjYWxlID0gMTtcbiAgICB0aGlzLnRleHRSZW5kZXJpbmdNb2RlID0gVGV4dFJlbmRlcmluZ01vZGUuRklMTDtcbiAgICB0aGlzLnRleHRSaXNlID0gMDtcbiAgICB0aGlzLmZpbGxDb2xvciA9IFwiIzAwMDAwMFwiO1xuICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBcIiMwMDAwMDBcIjtcbiAgICB0aGlzLnBhdHRlcm5GaWxsID0gZmFsc2U7XG4gICAgdGhpcy5wYXR0ZXJuU3Ryb2tlID0gZmFsc2U7XG4gICAgdGhpcy5maWxsQWxwaGEgPSAxO1xuICAgIHRoaXMuc3Ryb2tlQWxwaGEgPSAxO1xuICAgIHRoaXMubGluZVdpZHRoID0gMTtcbiAgICB0aGlzLmFjdGl2ZVNNYXNrID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zZmVyTWFwcyA9IFwibm9uZVwiO1xuICAgIHRoaXMuc3RhcnROZXdQYXRoQW5kQ2xpcEJveChbMCwgMCwgd2lkdGgsIGhlaWdodF0pO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICBjbG9uZS5jbGlwQm94ID0gdGhpcy5jbGlwQm94LnNsaWNlKCk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIHNldEN1cnJlbnRQb2ludCh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG4gIHVwZGF0ZVBhdGhNaW5NYXgodHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgW3gsIHldID0gVXRpbC5hcHBseVRyYW5zZm9ybShbeCwgeV0sIHRyYW5zZm9ybSk7XG4gICAgdGhpcy5taW5YID0gTWF0aC5taW4odGhpcy5taW5YLCB4KTtcbiAgICB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLm1pblksIHkpO1xuICAgIHRoaXMubWF4WCA9IE1hdGgubWF4KHRoaXMubWF4WCwgeCk7XG4gICAgdGhpcy5tYXhZID0gTWF0aC5tYXgodGhpcy5tYXhZLCB5KTtcbiAgfVxuICB1cGRhdGVSZWN0TWluTWF4KHRyYW5zZm9ybSwgcmVjdCkge1xuICAgIGNvbnN0IHAxID0gVXRpbC5hcHBseVRyYW5zZm9ybShyZWN0LCB0cmFuc2Zvcm0pO1xuICAgIGNvbnN0IHAyID0gVXRpbC5hcHBseVRyYW5zZm9ybShyZWN0LnNsaWNlKDIpLCB0cmFuc2Zvcm0pO1xuICAgIGNvbnN0IHAzID0gVXRpbC5hcHBseVRyYW5zZm9ybShbcmVjdFswXSwgcmVjdFszXV0sIHRyYW5zZm9ybSk7XG4gICAgY29uc3QgcDQgPSBVdGlsLmFwcGx5VHJhbnNmb3JtKFtyZWN0WzJdLCByZWN0WzFdXSwgdHJhbnNmb3JtKTtcbiAgICB0aGlzLm1pblggPSBNYXRoLm1pbih0aGlzLm1pblgsIHAxWzBdLCBwMlswXSwgcDNbMF0sIHA0WzBdKTtcbiAgICB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLm1pblksIHAxWzFdLCBwMlsxXSwgcDNbMV0sIHA0WzFdKTtcbiAgICB0aGlzLm1heFggPSBNYXRoLm1heCh0aGlzLm1heFgsIHAxWzBdLCBwMlswXSwgcDNbMF0sIHA0WzBdKTtcbiAgICB0aGlzLm1heFkgPSBNYXRoLm1heCh0aGlzLm1heFksIHAxWzFdLCBwMlsxXSwgcDNbMV0sIHA0WzFdKTtcbiAgfVxuICB1cGRhdGVTY2FsaW5nUGF0aE1pbk1heCh0cmFuc2Zvcm0sIG1pbk1heCkge1xuICAgIFV0aWwuc2NhbGVNaW5NYXgodHJhbnNmb3JtLCBtaW5NYXgpO1xuICAgIHRoaXMubWluWCA9IE1hdGgubWluKHRoaXMubWluWCwgbWluTWF4WzBdKTtcbiAgICB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLm1pblksIG1pbk1heFsxXSk7XG4gICAgdGhpcy5tYXhYID0gTWF0aC5tYXgodGhpcy5tYXhYLCBtaW5NYXhbMl0pO1xuICAgIHRoaXMubWF4WSA9IE1hdGgubWF4KHRoaXMubWF4WSwgbWluTWF4WzNdKTtcbiAgfVxuICB1cGRhdGVDdXJ2ZVBhdGhNaW5NYXgodHJhbnNmb3JtLCB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIG1pbk1heCkge1xuICAgIGNvbnN0IGJveCA9IFV0aWwuYmV6aWVyQm91bmRpbmdCb3goeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBtaW5NYXgpO1xuICAgIGlmIChtaW5NYXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVSZWN0TWluTWF4KHRyYW5zZm9ybSwgYm94KTtcbiAgfVxuICBnZXRQYXRoQm91bmRpbmdCb3gocGF0aFR5cGUgPSBQYXRoVHlwZS5GSUxMLCB0cmFuc2Zvcm0gPSBudWxsKSB7XG4gICAgY29uc3QgYm94ID0gW3RoaXMubWluWCwgdGhpcy5taW5ZLCB0aGlzLm1heFgsIHRoaXMubWF4WV07XG4gICAgaWYgKHBhdGhUeXBlID09PSBQYXRoVHlwZS5TVFJPS0UpIHtcbiAgICAgIGlmICghdHJhbnNmb3JtKSB7XG4gICAgICAgIHVucmVhY2hhYmxlKFwiU3Ryb2tlIGJvdW5kaW5nIGJveCBtdXN0IGluY2x1ZGUgdHJhbnNmb3JtLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNjYWxlID0gVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0cmFuc2Zvcm0pO1xuICAgICAgY29uc3QgeFN0cm9rZVBhZCA9IHNjYWxlWzBdICogdGhpcy5saW5lV2lkdGggLyAyO1xuICAgICAgY29uc3QgeVN0cm9rZVBhZCA9IHNjYWxlWzFdICogdGhpcy5saW5lV2lkdGggLyAyO1xuICAgICAgYm94WzBdIC09IHhTdHJva2VQYWQ7XG4gICAgICBib3hbMV0gLT0geVN0cm9rZVBhZDtcbiAgICAgIGJveFsyXSArPSB4U3Ryb2tlUGFkO1xuICAgICAgYm94WzNdICs9IHlTdHJva2VQYWQ7XG4gICAgfVxuICAgIHJldHVybiBib3g7XG4gIH1cbiAgdXBkYXRlQ2xpcEZyb21QYXRoKCkge1xuICAgIGNvbnN0IGludGVyc2VjdCA9IFV0aWwuaW50ZXJzZWN0KHRoaXMuY2xpcEJveCwgdGhpcy5nZXRQYXRoQm91bmRpbmdCb3goKSk7XG4gICAgdGhpcy5zdGFydE5ld1BhdGhBbmRDbGlwQm94KGludGVyc2VjdCB8fCBbMCwgMCwgMCwgMF0pO1xuICB9XG4gIGlzRW1wdHlDbGlwKCkge1xuICAgIHJldHVybiB0aGlzLm1pblggPT09IEluZmluaXR5O1xuICB9XG4gIHN0YXJ0TmV3UGF0aEFuZENsaXBCb3goYm94KSB7XG4gICAgdGhpcy5jbGlwQm94ID0gYm94O1xuICAgIHRoaXMubWluWCA9IEluZmluaXR5O1xuICAgIHRoaXMubWluWSA9IEluZmluaXR5O1xuICAgIHRoaXMubWF4WCA9IDA7XG4gICAgdGhpcy5tYXhZID0gMDtcbiAgfVxuICBnZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KHBhdGhUeXBlID0gUGF0aFR5cGUuRklMTCwgdHJhbnNmb3JtID0gbnVsbCkge1xuICAgIHJldHVybiBVdGlsLmludGVyc2VjdCh0aGlzLmNsaXBCb3gsIHRoaXMuZ2V0UGF0aEJvdW5kaW5nQm94KHBhdGhUeXBlLCB0cmFuc2Zvcm0pKTtcbiAgfVxufVxuZnVuY3Rpb24gcHV0QmluYXJ5SW1hZ2VEYXRhKGN0eCwgaW1nRGF0YSkge1xuICBpZiAoaW1nRGF0YSBpbnN0YW5jZW9mIEltYWdlRGF0YSkge1xuICAgIGN0eC5wdXRJbWFnZURhdGEoaW1nRGF0YSwgMCwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0LFxuICAgIHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgY29uc3QgcGFydGlhbENodW5rSGVpZ2h0ID0gaGVpZ2h0ICUgRlVMTF9DSFVOS19IRUlHSFQ7XG4gIGNvbnN0IGZ1bGxDaHVua3MgPSAoaGVpZ2h0IC0gcGFydGlhbENodW5rSGVpZ2h0KSAvIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCB0b3RhbENodW5rcyA9IHBhcnRpYWxDaHVua0hlaWdodCA9PT0gMCA/IGZ1bGxDaHVua3MgOiBmdWxsQ2h1bmtzICsgMTtcbiAgY29uc3QgY2h1bmtJbWdEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgRlVMTF9DSFVOS19IRUlHSFQpO1xuICBsZXQgc3JjUG9zID0gMCxcbiAgICBkZXN0UG9zO1xuICBjb25zdCBzcmMgPSBpbWdEYXRhLmRhdGE7XG4gIGNvbnN0IGRlc3QgPSBjaHVua0ltZ0RhdGEuZGF0YTtcbiAgbGV0IGksIGosIHRoaXNDaHVua0hlaWdodCwgZWxlbXNJblRoaXNDaHVuaztcbiAgaWYgKGltZ0RhdGEua2luZCA9PT0gdXRpbF9JbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFApIHtcbiAgICBjb25zdCBzcmNMZW5ndGggPSBzcmMuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBkZXN0MzIgPSBuZXcgVWludDMyQXJyYXkoZGVzdC5idWZmZXIsIDAsIGRlc3QuYnl0ZUxlbmd0aCA+PiAyKTtcbiAgICBjb25zdCBkZXN0MzJEYXRhTGVuZ3RoID0gZGVzdDMyLmxlbmd0aDtcbiAgICBjb25zdCBmdWxsU3JjRGlmZiA9IHdpZHRoICsgNyA+PiAzO1xuICAgIGNvbnN0IHdoaXRlID0gMHhmZmZmZmZmZjtcbiAgICBjb25zdCBibGFjayA9IHV0aWxfRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4gPyAweGZmMDAwMDAwIDogMHgwMDAwMDBmZjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxDaHVua3M7IGkrKykge1xuICAgICAgdGhpc0NodW5rSGVpZ2h0ID0gaSA8IGZ1bGxDaHVua3MgPyBGVUxMX0NIVU5LX0hFSUdIVCA6IHBhcnRpYWxDaHVua0hlaWdodDtcbiAgICAgIGRlc3RQb3MgPSAwO1xuICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXNDaHVua0hlaWdodDsgaisrKSB7XG4gICAgICAgIGNvbnN0IHNyY0RpZmYgPSBzcmNMZW5ndGggLSBzcmNQb3M7XG4gICAgICAgIGxldCBrID0gMDtcbiAgICAgICAgY29uc3Qga0VuZCA9IHNyY0RpZmYgPiBmdWxsU3JjRGlmZiA/IHdpZHRoIDogc3JjRGlmZiAqIDggLSA3O1xuICAgICAgICBjb25zdCBrRW5kVW5yb2xsZWQgPSBrRW5kICYgfjc7XG4gICAgICAgIGxldCBtYXNrID0gMDtcbiAgICAgICAgbGV0IHNyY0J5dGUgPSAwO1xuICAgICAgICBmb3IgKDsgayA8IGtFbmRVbnJvbGxlZDsgayArPSA4KSB7XG4gICAgICAgICAgc3JjQnl0ZSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMTI4ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA2NCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMzIgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDE2ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA4ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA0ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAyID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAxID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgayA8IGtFbmQ7IGsrKykge1xuICAgICAgICAgIGlmIChtYXNrID09PSAwKSB7XG4gICAgICAgICAgICBzcmNCeXRlID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgICAgIG1hc2sgPSAxMjg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIG1hc2sgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIG1hc2sgPj49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChkZXN0UG9zIDwgZGVzdDMyRGF0YUxlbmd0aCkge1xuICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IDA7XG4gICAgICB9XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaSAqIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW1nRGF0YS5raW5kID09PSB1dGlsX0ltYWdlS2luZC5SR0JBXzMyQlBQKSB7XG4gICAgaiA9IDA7XG4gICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogRlVMTF9DSFVOS19IRUlHSFQgKiA0O1xuICAgIGZvciAoaSA9IDA7IGkgPCBmdWxsQ2h1bmtzOyBpKyspIHtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNQb3MsIHNyY1BvcyArIGVsZW1zSW5UaGlzQ2h1bmspKTtcbiAgICAgIHNyY1BvcyArPSBlbGVtc0luVGhpc0NodW5rO1xuICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGopO1xuICAgICAgaiArPSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgICB9XG4gICAgaWYgKGkgPCB0b3RhbENodW5rcykge1xuICAgICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogcGFydGlhbENodW5rSGVpZ2h0ICogNDtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNQb3MsIHNyY1BvcyArIGVsZW1zSW5UaGlzQ2h1bmspKTtcbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBqKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW1nRGF0YS5raW5kID09PSB1dGlsX0ltYWdlS2luZC5SR0JfMjRCUFApIHtcbiAgICB0aGlzQ2h1bmtIZWlnaHQgPSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiB0aGlzQ2h1bmtIZWlnaHQ7XG4gICAgZm9yIChpID0gMDsgaSA8IHRvdGFsQ2h1bmtzOyBpKyspIHtcbiAgICAgIGlmIChpID49IGZ1bGxDaHVua3MpIHtcbiAgICAgICAgdGhpc0NodW5rSGVpZ2h0ID0gcGFydGlhbENodW5rSGVpZ2h0O1xuICAgICAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiB0aGlzQ2h1bmtIZWlnaHQ7XG4gICAgICB9XG4gICAgICBkZXN0UG9zID0gMDtcbiAgICAgIGZvciAoaiA9IGVsZW1zSW5UaGlzQ2h1bms7IGotLTspIHtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gMjU1O1xuICAgICAgfVxuICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGkgKiBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgYmFkIGltYWdlIGtpbmQ6ICR7aW1nRGF0YS5raW5kfWApO1xuICB9XG59XG5mdW5jdGlvbiBwdXRCaW5hcnlJbWFnZU1hc2soY3R4LCBpbWdEYXRhKSB7XG4gIGlmIChpbWdEYXRhLmJpdG1hcCkge1xuICAgIGN0eC5kcmF3SW1hZ2UoaW1nRGF0YS5iaXRtYXAsIDAsIDApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodCxcbiAgICB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gIGNvbnN0IHBhcnRpYWxDaHVua0hlaWdodCA9IGhlaWdodCAlIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCBmdWxsQ2h1bmtzID0gKGhlaWdodCAtIHBhcnRpYWxDaHVua0hlaWdodCkgLyBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgY29uc3QgdG90YWxDaHVua3MgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQgPT09IDAgPyBmdWxsQ2h1bmtzIDogZnVsbENodW5rcyArIDE7XG4gIGNvbnN0IGNodW5rSW1nRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgbGV0IHNyY1BvcyA9IDA7XG4gIGNvbnN0IHNyYyA9IGltZ0RhdGEuZGF0YTtcbiAgY29uc3QgZGVzdCA9IGNodW5rSW1nRGF0YS5kYXRhO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsQ2h1bmtzOyBpKyspIHtcbiAgICBjb25zdCB0aGlzQ2h1bmtIZWlnaHQgPSBpIDwgZnVsbENodW5rcyA/IEZVTExfQ0hVTktfSEVJR0hUIDogcGFydGlhbENodW5rSGVpZ2h0O1xuICAgICh7XG4gICAgICBzcmNQb3NcbiAgICB9ID0gY29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEoe1xuICAgICAgc3JjLFxuICAgICAgc3JjUG9zLFxuICAgICAgZGVzdCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzQ2h1bmtIZWlnaHQsXG4gICAgICBub25CbGFja0NvbG9yOiAwXG4gICAgfSkpO1xuICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBpICogRlVMTF9DSFVOS19IRUlHSFQpO1xuICB9XG59XG5mdW5jdGlvbiBjb3B5Q3R4U3RhdGUoc291cmNlQ3R4LCBkZXN0Q3R4KSB7XG4gIGNvbnN0IHByb3BlcnRpZXMgPSBbXCJzdHJva2VTdHlsZVwiLCBcImZpbGxTdHlsZVwiLCBcImZpbGxSdWxlXCIsIFwiZ2xvYmFsQWxwaGFcIiwgXCJsaW5lV2lkdGhcIiwgXCJsaW5lQ2FwXCIsIFwibGluZUpvaW5cIiwgXCJtaXRlckxpbWl0XCIsIFwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXCIsIFwiZm9udFwiLCBcImZpbHRlclwiXTtcbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKHNvdXJjZUN0eFtwcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVzdEN0eFtwcm9wZXJ0eV0gPSBzb3VyY2VDdHhbcHJvcGVydHldO1xuICAgIH1cbiAgfVxuICBpZiAoc291cmNlQ3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZXN0Q3R4LnNldExpbmVEYXNoKHNvdXJjZUN0eC5nZXRMaW5lRGFzaCgpKTtcbiAgICBkZXN0Q3R4LmxpbmVEYXNoT2Zmc2V0ID0gc291cmNlQ3R4LmxpbmVEYXNoT2Zmc2V0O1xuICB9XG59XG5mdW5jdGlvbiByZXNldEN0eFRvRGVmYXVsdChjdHgpIHtcbiAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZSA9IFwiIzAwMDAwMFwiO1xuICBjdHguZmlsbFJ1bGUgPSBcIm5vbnplcm9cIjtcbiAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gIGN0eC5saW5lQ2FwID0gXCJidXR0XCI7XG4gIGN0eC5saW5lSm9pbiA9IFwibWl0ZXJcIjtcbiAgY3R4Lm1pdGVyTGltaXQgPSAxMDtcbiAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLW92ZXJcIjtcbiAgY3R4LmZvbnQgPSBcIjEwcHggc2Fucy1zZXJpZlwiO1xuICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBjdHguc2V0TGluZURhc2goW10pO1xuICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IDA7XG4gIH1cbiAgaWYgKCFpc05vZGVKUykge1xuICAgIGNvbnN0IHtcbiAgICAgIGZpbHRlclxuICAgIH0gPSBjdHg7XG4gICAgaWYgKGZpbHRlciAhPT0gXCJub25lXCIgJiYgZmlsdGVyICE9PSBcIlwiKSB7XG4gICAgICBjdHguZmlsdGVyID0gXCJub25lXCI7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQodHJhbnNmb3JtLCBpbnRlcnBvbGF0ZSkge1xuICBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBzY2FsZSA9IFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodHJhbnNmb3JtKTtcbiAgc2NhbGVbMF0gPSBNYXRoLmZyb3VuZChzY2FsZVswXSk7XG4gIHNjYWxlWzFdID0gTWF0aC5mcm91bmQoc2NhbGVbMV0pO1xuICBjb25zdCBhY3R1YWxTY2FsZSA9IE1hdGguZnJvdW5kKChnbG9iYWxUaGlzLmRldmljZVBpeGVsUmF0aW8gfHwgMSkgKiBQaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFMpO1xuICByZXR1cm4gc2NhbGVbMF0gPD0gYWN0dWFsU2NhbGUgJiYgc2NhbGVbMV0gPD0gYWN0dWFsU2NhbGU7XG59XG5jb25zdCBMSU5FX0NBUF9TVFlMRVMgPSBbXCJidXR0XCIsIFwicm91bmRcIiwgXCJzcXVhcmVcIl07XG5jb25zdCBMSU5FX0pPSU5fU1RZTEVTID0gW1wibWl0ZXJcIiwgXCJyb3VuZFwiLCBcImJldmVsXCJdO1xuY29uc3QgTk9STUFMX0NMSVAgPSB7fTtcbmNvbnN0IEVPX0NMSVAgPSB7fTtcbmNsYXNzIENhbnZhc0dyYXBoaWNzIHtcbiAgY29uc3RydWN0b3IoY2FudmFzQ3R4LCBjb21tb25PYmpzLCBvYmpzLCBjYW52YXNGYWN0b3J5LCBmaWx0ZXJGYWN0b3J5LCB7XG4gICAgb3B0aW9uYWxDb250ZW50Q29uZmlnLFxuICAgIG1hcmtlZENvbnRlbnRTdGFjayA9IG51bGxcbiAgfSwgYW5ub3RhdGlvbkNhbnZhc01hcCwgcGFnZUNvbG9ycykge1xuICAgIHRoaXMuY3R4ID0gY2FudmFzQ3R4O1xuICAgIHRoaXMuY3VycmVudCA9IG5ldyBDYW52YXNFeHRyYVN0YXRlKHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCk7XG4gICAgdGhpcy5zdGF0ZVN0YWNrID0gW107XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gZmFsc2U7XG4gICAgdGhpcy5yZXMgPSBudWxsO1xuICAgIHRoaXMueG9ianMgPSBudWxsO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IGNvbW1vbk9ianM7XG4gICAgdGhpcy5vYmpzID0gb2JqcztcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBjYW52YXNGYWN0b3J5O1xuICAgIHRoaXMuZmlsdGVyRmFjdG9yeSA9IGZpbHRlckZhY3Rvcnk7XG4gICAgdGhpcy5ncm91cFN0YWNrID0gW107XG4gICAgdGhpcy5wcm9jZXNzaW5nVHlwZTMgPSBudWxsO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IG51bGw7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtU3RhY2sgPSBbXTtcbiAgICB0aGlzLmdyb3VwTGV2ZWwgPSAwO1xuICAgIHRoaXMuc21hc2tTdGFjayA9IFtdO1xuICAgIHRoaXMuc21hc2tDb3VudGVyID0gMDtcbiAgICB0aGlzLnRlbXBTTWFzayA9IG51bGw7XG4gICAgdGhpcy5zdXNwZW5kZWRDdHggPSBudWxsO1xuICAgIHRoaXMuY29udGVudFZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrID0gbWFya2VkQ29udGVudFN0YWNrIHx8IFtdO1xuICAgIHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnID0gb3B0aW9uYWxDb250ZW50Q29uZmlnO1xuICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMgPSBuZXcgQ2FjaGVkQ2FudmFzZXModGhpcy5jYW52YXNGYWN0b3J5KTtcbiAgICB0aGlzLmNhY2hlZFBhdHRlcm5zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCA9IGFubm90YXRpb25DYW52YXNNYXA7XG4gICAgdGhpcy52aWV3cG9ydFNjYWxlID0gMTtcbiAgICB0aGlzLm91dHB1dFNjYWxlWCA9IDE7XG4gICAgdGhpcy5vdXRwdXRTY2FsZVkgPSAxO1xuICAgIHRoaXMucGFnZUNvbG9ycyA9IHBhZ2VDb2xvcnM7XG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZyA9IFstMSwgMF07XG4gICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gICAgdGhpcy5fY2FjaGVkQml0bWFwc01hcCA9IG5ldyBNYXAoKTtcbiAgfVxuICBnZXRPYmplY3QoZGF0YSwgZmFsbGJhY2sgPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZGF0YS5zdGFydHNXaXRoKFwiZ19cIikgPyB0aGlzLmNvbW1vbk9ianMuZ2V0KGRhdGEpIDogdGhpcy5vYmpzLmdldChkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbGxiYWNrO1xuICB9XG4gIGJlZ2luRHJhd2luZyh7XG4gICAgdHJhbnNmb3JtLFxuICAgIHZpZXdwb3J0LFxuICAgIHRyYW5zcGFyZW5jeSA9IGZhbHNlLFxuICAgIGJhY2tncm91bmQgPSBudWxsXG4gIH0pIHtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuY3R4LmNhbnZhcy53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0O1xuICAgIGNvbnN0IHNhdmVkRmlsbFN0eWxlID0gdGhpcy5jdHguZmlsbFN0eWxlO1xuICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmQgfHwgXCIjZmZmZmZmXCI7XG4gICAgdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gc2F2ZWRGaWxsU3R5bGU7XG4gICAgaWYgKHRyYW5zcGFyZW5jeSkge1xuICAgICAgY29uc3QgdHJhbnNwYXJlbnRDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcInRyYW5zcGFyZW50XCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5jb21wb3NpdGVDdHggPSB0aGlzLmN0eDtcbiAgICAgIHRoaXMudHJhbnNwYXJlbnRDYW52YXMgPSB0cmFuc3BhcmVudENhbnZhcy5jYW52YXM7XG4gICAgICB0aGlzLmN0eCA9IHRyYW5zcGFyZW50Q2FudmFzLmNvbnRleHQ7XG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICB0aGlzLmN0eC50cmFuc2Zvcm0oLi4uZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmNvbXBvc2l0ZUN0eCkpO1xuICAgIH1cbiAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgcmVzZXRDdHhUb0RlZmF1bHQodGhpcy5jdHgpO1xuICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgIHRoaXMuY3R4LnRyYW5zZm9ybSguLi50cmFuc2Zvcm0pO1xuICAgICAgdGhpcy5vdXRwdXRTY2FsZVggPSB0cmFuc2Zvcm1bMF07XG4gICAgICB0aGlzLm91dHB1dFNjYWxlWSA9IHRyYW5zZm9ybVswXTtcbiAgICB9XG4gICAgdGhpcy5jdHgudHJhbnNmb3JtKC4uLnZpZXdwb3J0LnRyYW5zZm9ybSk7XG4gICAgdGhpcy52aWV3cG9ydFNjYWxlID0gdmlld3BvcnQuc2NhbGU7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCk7XG4gIH1cbiAgZXhlY3V0ZU9wZXJhdG9yTGlzdChvcGVyYXRvckxpc3QsIGV4ZWN1dGlvblN0YXJ0SWR4LCBjb250aW51ZUNhbGxiYWNrLCBzdGVwcGVyKSB7XG4gICAgY29uc3QgYXJnc0FycmF5ID0gb3BlcmF0b3JMaXN0LmFyZ3NBcnJheTtcbiAgICBjb25zdCBmbkFycmF5ID0gb3BlcmF0b3JMaXN0LmZuQXJyYXk7XG4gICAgbGV0IGkgPSBleGVjdXRpb25TdGFydElkeCB8fCAwO1xuICAgIGNvbnN0IGFyZ3NBcnJheUxlbiA9IGFyZ3NBcnJheS5sZW5ndGg7XG4gICAgaWYgKGFyZ3NBcnJheUxlbiA9PT0gaSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rT3BlcmF0aW9ucyA9IGFyZ3NBcnJheUxlbiAtIGkgPiBFWEVDVVRJT05fU1RFUFMgJiYgdHlwZW9mIGNvbnRpbnVlQ2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIjtcbiAgICBjb25zdCBlbmRUaW1lID0gY2h1bmtPcGVyYXRpb25zID8gRGF0ZS5ub3coKSArIEVYRUNVVElPTl9USU1FIDogMDtcbiAgICBsZXQgc3RlcHMgPSAwO1xuICAgIGNvbnN0IGNvbW1vbk9ianMgPSB0aGlzLmNvbW1vbk9ianM7XG4gICAgY29uc3Qgb2JqcyA9IHRoaXMub2JqcztcbiAgICBsZXQgZm5JZDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKHN0ZXBwZXIgIT09IHVuZGVmaW5lZCAmJiBpID09PSBzdGVwcGVyLm5leHRCcmVha1BvaW50KSB7XG4gICAgICAgIHN0ZXBwZXIuYnJlYWtJdChpLCBjb250aW51ZUNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICBmbklkID0gZm5BcnJheVtpXTtcbiAgICAgIGlmIChmbklkICE9PSBPUFMuZGVwZW5kZW5jeSkge1xuICAgICAgICB0aGlzW2ZuSWRdLmFwcGx5KHRoaXMsIGFyZ3NBcnJheVtpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGRlcE9iaklkIG9mIGFyZ3NBcnJheVtpXSkge1xuICAgICAgICAgIGNvbnN0IG9ianNQb29sID0gZGVwT2JqSWQuc3RhcnRzV2l0aChcImdfXCIpID8gY29tbW9uT2JqcyA6IG9ianM7XG4gICAgICAgICAgaWYgKCFvYmpzUG9vbC5oYXMoZGVwT2JqSWQpKSB7XG4gICAgICAgICAgICBvYmpzUG9vbC5nZXQoZGVwT2JqSWQsIGNvbnRpbnVlQ2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgICBpZiAoaSA9PT0gYXJnc0FycmF5TGVuKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgICAgaWYgKGNodW5rT3BlcmF0aW9ucyAmJiArK3N0ZXBzID4gRVhFQ1VUSU9OX1NURVBTKSB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpID4gZW5kVGltZSkge1xuICAgICAgICAgIGNvbnRpbnVlQ2FsbGJhY2soKTtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICBzdGVwcyA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNyZXN0b3JlSW5pdGlhbFN0YXRlKCkge1xuICAgIHdoaWxlICh0aGlzLnN0YXRlU3RhY2subGVuZ3RoIHx8IHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgPSBudWxsO1xuICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICBpZiAodGhpcy50cmFuc3BhcmVudENhbnZhcykge1xuICAgICAgdGhpcy5jdHggPSB0aGlzLmNvbXBvc2l0ZUN0eDtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZSh0aGlzLnRyYW5zcGFyZW50Q2FudmFzLCAwLCAwKTtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMudHJhbnNwYXJlbnRDYW52YXMgPSBudWxsO1xuICAgIH1cbiAgfVxuICBlbmREcmF3aW5nKCkge1xuICAgIHRoaXMuI3Jlc3RvcmVJbml0aWFsU3RhdGUoKTtcbiAgICB0aGlzLmNhY2hlZENhbnZhc2VzLmNsZWFyKCk7XG4gICAgdGhpcy5jYWNoZWRQYXR0ZXJucy5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgY2FjaGUgb2YgdGhpcy5fY2FjaGVkQml0bWFwc01hcC52YWx1ZXMoKSkge1xuICAgICAgZm9yIChjb25zdCBjYW52YXMgb2YgY2FjaGUudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLmNsZWFyKCk7XG4gICAgdGhpcy4jZHJhd0ZpbHRlcigpO1xuICB9XG4gICNkcmF3RmlsdGVyKCkge1xuICAgIGlmICh0aGlzLnBhZ2VDb2xvcnMpIHtcbiAgICAgIGNvbnN0IGhjbUZpbHRlcklkID0gdGhpcy5maWx0ZXJGYWN0b3J5LmFkZEhDTUZpbHRlcih0aGlzLnBhZ2VDb2xvcnMuZm9yZWdyb3VuZCwgdGhpcy5wYWdlQ29sb3JzLmJhY2tncm91bmQpO1xuICAgICAgaWYgKGhjbUZpbHRlcklkICE9PSBcIm5vbmVcIikge1xuICAgICAgICBjb25zdCBzYXZlZEZpbHRlciA9IHRoaXMuY3R4LmZpbHRlcjtcbiAgICAgICAgdGhpcy5jdHguZmlsdGVyID0gaGNtRmlsdGVySWQ7XG4gICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZSh0aGlzLmN0eC5jYW52YXMsIDAsIDApO1xuICAgICAgICB0aGlzLmN0eC5maWx0ZXIgPSBzYXZlZEZpbHRlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3NjYWxlSW1hZ2UoaW1nLCBpbnZlcnNlVHJhbnNmb3JtKSB7XG4gICAgY29uc3Qgd2lkdGggPSBpbWcud2lkdGggPz8gaW1nLmRpc3BsYXlXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWcuaGVpZ2h0ID8/IGltZy5kaXNwbGF5SGVpZ2h0O1xuICAgIGxldCB3aWR0aFNjYWxlID0gTWF0aC5tYXgoTWF0aC5oeXBvdChpbnZlcnNlVHJhbnNmb3JtWzBdLCBpbnZlcnNlVHJhbnNmb3JtWzFdKSwgMSk7XG4gICAgbGV0IGhlaWdodFNjYWxlID0gTWF0aC5tYXgoTWF0aC5oeXBvdChpbnZlcnNlVHJhbnNmb3JtWzJdLCBpbnZlcnNlVHJhbnNmb3JtWzNdKSwgMSk7XG4gICAgbGV0IHBhaW50V2lkdGggPSB3aWR0aCxcbiAgICAgIHBhaW50SGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGxldCB0bXBDYW52YXNJZCA9IFwicHJlc2NhbGUxXCI7XG4gICAgbGV0IHRtcENhbnZhcywgdG1wQ3R4O1xuICAgIHdoaWxlICh3aWR0aFNjYWxlID4gMiAmJiBwYWludFdpZHRoID4gMSB8fCBoZWlnaHRTY2FsZSA+IDIgJiYgcGFpbnRIZWlnaHQgPiAxKSB7XG4gICAgICBsZXQgbmV3V2lkdGggPSBwYWludFdpZHRoLFxuICAgICAgICBuZXdIZWlnaHQgPSBwYWludEhlaWdodDtcbiAgICAgIGlmICh3aWR0aFNjYWxlID4gMiAmJiBwYWludFdpZHRoID4gMSkge1xuICAgICAgICBuZXdXaWR0aCA9IHBhaW50V2lkdGggPj0gMTYzODQgPyBNYXRoLmZsb29yKHBhaW50V2lkdGggLyAyKSAtIDEgfHwgMSA6IE1hdGguY2VpbChwYWludFdpZHRoIC8gMik7XG4gICAgICAgIHdpZHRoU2NhbGUgLz0gcGFpbnRXaWR0aCAvIG5ld1dpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodFNjYWxlID4gMiAmJiBwYWludEhlaWdodCA+IDEpIHtcbiAgICAgICAgbmV3SGVpZ2h0ID0gcGFpbnRIZWlnaHQgPj0gMTYzODQgPyBNYXRoLmZsb29yKHBhaW50SGVpZ2h0IC8gMikgLSAxIHx8IDEgOiBNYXRoLmNlaWwocGFpbnRIZWlnaHQpIC8gMjtcbiAgICAgICAgaGVpZ2h0U2NhbGUgLz0gcGFpbnRIZWlnaHQgLyBuZXdIZWlnaHQ7XG4gICAgICB9XG4gICAgICB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyh0bXBDYW52YXNJZCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgIHRtcEN0eC5jbGVhclJlY3QoMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICB0bXBDdHguZHJhd0ltYWdlKGltZywgMCwgMCwgcGFpbnRXaWR0aCwgcGFpbnRIZWlnaHQsIDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgaW1nID0gdG1wQ2FudmFzLmNhbnZhcztcbiAgICAgIHBhaW50V2lkdGggPSBuZXdXaWR0aDtcbiAgICAgIHBhaW50SGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgdG1wQ2FudmFzSWQgPSB0bXBDYW52YXNJZCA9PT0gXCJwcmVzY2FsZTFcIiA/IFwicHJlc2NhbGUyXCIgOiBcInByZXNjYWxlMVwiO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaW1nLFxuICAgICAgcGFpbnRXaWR0aCxcbiAgICAgIHBhaW50SGVpZ2h0XG4gICAgfTtcbiAgfVxuICBfY3JlYXRlTWFza0NhbnZhcyhpbWcpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBpbWc7XG4gICAgY29uc3QgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICBjb25zdCBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCk7XG4gICAgbGV0IGNhY2hlLCBjYWNoZUtleSwgc2NhbGVkLCBtYXNrQ2FudmFzO1xuICAgIGlmICgoaW1nLmJpdG1hcCB8fCBpbWcuZGF0YSkgJiYgaW1nLmNvdW50ID4gMSkge1xuICAgICAgY29uc3QgbWFpbktleSA9IGltZy5iaXRtYXAgfHwgaW1nLmRhdGEuYnVmZmVyO1xuICAgICAgY2FjaGVLZXkgPSBKU09OLnN0cmluZ2lmeShpc1BhdHRlcm5GaWxsID8gY3VycmVudFRyYW5zZm9ybSA6IFtjdXJyZW50VHJhbnNmb3JtLnNsaWNlKDAsIDQpLCBmaWxsQ29sb3JdKTtcbiAgICAgIGNhY2hlID0gdGhpcy5fY2FjaGVkQml0bWFwc01hcC5nZXQobWFpbktleSk7XG4gICAgICBpZiAoIWNhY2hlKSB7XG4gICAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLnNldChtYWluS2V5LCBjYWNoZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjYWNoZWRJbWFnZSA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoY2FjaGVkSW1hZ2UgJiYgIWlzUGF0dGVybkZpbGwpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGgucm91bmQoTWF0aC5taW4oY3VycmVudFRyYW5zZm9ybVswXSwgY3VycmVudFRyYW5zZm9ybVsyXSkgKyBjdXJyZW50VHJhbnNmb3JtWzRdKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGgucm91bmQoTWF0aC5taW4oY3VycmVudFRyYW5zZm9ybVsxXSwgY3VycmVudFRyYW5zZm9ybVszXSkgKyBjdXJyZW50VHJhbnNmb3JtWzVdKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjYW52YXM6IGNhY2hlZEltYWdlLFxuICAgICAgICAgIG9mZnNldFgsXG4gICAgICAgICAgb2Zmc2V0WVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgc2NhbGVkID0gY2FjaGVkSW1hZ2U7XG4gICAgfVxuICAgIGlmICghc2NhbGVkKSB7XG4gICAgICBtYXNrQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJtYXNrQ2FudmFzXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcHV0QmluYXJ5SW1hZ2VNYXNrKG1hc2tDYW52YXMuY29udGV4dCwgaW1nKTtcbiAgICB9XG4gICAgbGV0IG1hc2tUb0NhbnZhcyA9IFV0aWwudHJhbnNmb3JtKGN1cnJlbnRUcmFuc2Zvcm0sIFsxIC8gd2lkdGgsIDAsIDAsIC0xIC8gaGVpZ2h0LCAwLCAwXSk7XG4gICAgbWFza1RvQ2FudmFzID0gVXRpbC50cmFuc2Zvcm0obWFza1RvQ2FudmFzLCBbMSwgMCwgMCwgMSwgMCwgLWhlaWdodF0pO1xuICAgIGNvbnN0IFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSA9IFV0aWwuZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3goWzAsIDAsIHdpZHRoLCBoZWlnaHRdLCBtYXNrVG9DYW52YXMpO1xuICAgIGNvbnN0IGRyYXduV2lkdGggPSBNYXRoLnJvdW5kKG1heFggLSBtaW5YKSB8fCAxO1xuICAgIGNvbnN0IGRyYXduSGVpZ2h0ID0gTWF0aC5yb3VuZChtYXhZIC0gbWluWSkgfHwgMTtcbiAgICBjb25zdCBmaWxsQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJmaWxsQ2FudmFzXCIsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0KTtcbiAgICBjb25zdCBmaWxsQ3R4ID0gZmlsbENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IG9mZnNldFggPSBtaW5YO1xuICAgIGNvbnN0IG9mZnNldFkgPSBtaW5ZO1xuICAgIGZpbGxDdHgudHJhbnNsYXRlKC1vZmZzZXRYLCAtb2Zmc2V0WSk7XG4gICAgZmlsbEN0eC50cmFuc2Zvcm0oLi4ubWFza1RvQ2FudmFzKTtcbiAgICBpZiAoIXNjYWxlZCkge1xuICAgICAgc2NhbGVkID0gdGhpcy5fc2NhbGVJbWFnZShtYXNrQ2FudmFzLmNhbnZhcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoZmlsbEN0eCkpO1xuICAgICAgc2NhbGVkID0gc2NhbGVkLmltZztcbiAgICAgIGlmIChjYWNoZSAmJiBpc1BhdHRlcm5GaWxsKSB7XG4gICAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgc2NhbGVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmlsbEN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQoZ2V0Q3VycmVudFRyYW5zZm9ybShmaWxsQ3R4KSwgaW1nLmludGVycG9sYXRlKTtcbiAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoZmlsbEN0eCwgc2NhbGVkLCAwLCAwLCBzY2FsZWQud2lkdGgsIHNjYWxlZC5oZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGZpbGxDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2UtaW5cIjtcbiAgICBjb25zdCBpbnZlcnNlID0gVXRpbC50cmFuc2Zvcm0oZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoZmlsbEN0eCksIFsxLCAwLCAwLCAxLCAtb2Zmc2V0WCwgLW9mZnNldFldKTtcbiAgICBmaWxsQ3R4LmZpbGxTdHlsZSA9IGlzUGF0dGVybkZpbGwgPyBmaWxsQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsIGludmVyc2UsIFBhdGhUeXBlLkZJTEwpIDogZmlsbENvbG9yO1xuICAgIGZpbGxDdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKGNhY2hlICYmICFpc1BhdHRlcm5GaWxsKSB7XG4gICAgICB0aGlzLmNhY2hlZENhbnZhc2VzLmRlbGV0ZShcImZpbGxDYW52YXNcIik7XG4gICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIGZpbGxDYW52YXMuY2FudmFzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhczogZmlsbENhbnZhcy5jYW52YXMsXG4gICAgICBvZmZzZXRYOiBNYXRoLnJvdW5kKG9mZnNldFgpLFxuICAgICAgb2Zmc2V0WTogTWF0aC5yb3VuZChvZmZzZXRZKVxuICAgIH07XG4gIH1cbiAgc2V0TGluZVdpZHRoKHdpZHRoKSB7XG4gICAgaWYgKHdpZHRoICE9PSB0aGlzLmN1cnJlbnQubGluZVdpZHRoKSB7XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5saW5lV2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmN0eC5saW5lV2lkdGggPSB3aWR0aDtcbiAgfVxuICBzZXRMaW5lQ2FwKHN0eWxlKSB7XG4gICAgdGhpcy5jdHgubGluZUNhcCA9IExJTkVfQ0FQX1NUWUxFU1tzdHlsZV07XG4gIH1cbiAgc2V0TGluZUpvaW4oc3R5bGUpIHtcbiAgICB0aGlzLmN0eC5saW5lSm9pbiA9IExJTkVfSk9JTl9TVFlMRVNbc3R5bGVdO1xuICB9XG4gIHNldE1pdGVyTGltaXQobGltaXQpIHtcbiAgICB0aGlzLmN0eC5taXRlckxpbWl0ID0gbGltaXQ7XG4gIH1cbiAgc2V0RGFzaChkYXNoQXJyYXksIGRhc2hQaGFzZSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hBcnJheSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoUGhhc2U7XG4gICAgfVxuICB9XG4gIHNldFJlbmRlcmluZ0ludGVudChpbnRlbnQpIHt9XG4gIHNldEZsYXRuZXNzKGZsYXRuZXNzKSB7fVxuICBzZXRHU3RhdGUoc3RhdGVzKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3RhdGVzKSB7XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlIFwiTFdcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVXaWR0aCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMQ1wiOlxuICAgICAgICAgIHRoaXMuc2V0TGluZUNhcCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMSlwiOlxuICAgICAgICAgIHRoaXMuc2V0TGluZUpvaW4odmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTUxcIjpcbiAgICAgICAgICB0aGlzLnNldE1pdGVyTGltaXQodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRFwiOlxuICAgICAgICAgIHRoaXMuc2V0RGFzaCh2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUklcIjpcbiAgICAgICAgICB0aGlzLnNldFJlbmRlcmluZ0ludGVudCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJGTFwiOlxuICAgICAgICAgIHRoaXMuc2V0RmxhdG5lc3ModmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRm9udFwiOlxuICAgICAgICAgIHRoaXMuc2V0Rm9udCh2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQ0FcIjpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQWxwaGEgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNhXCI6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmZpbGxBbHBoYSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJCTVwiOlxuICAgICAgICAgIHRoaXMuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiU01hc2tcIjpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgPSB2YWx1ZSA/IHRoaXMudGVtcFNNYXNrIDogbnVsbDtcbiAgICAgICAgICB0aGlzLnRlbXBTTWFzayA9IG51bGw7XG4gICAgICAgICAgdGhpcy5jaGVja1NNYXNrU3RhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlRSXCI6XG4gICAgICAgICAgdGhpcy5jdHguZmlsdGVyID0gdGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyA9IHRoaXMuZmlsdGVyRmFjdG9yeS5hZGRGaWx0ZXIodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgaW5TTWFza01vZGUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5zdXNwZW5kZWRDdHg7XG4gIH1cbiAgY2hlY2tTTWFza1N0YXRlKCkge1xuICAgIGNvbnN0IGluU01hc2tNb2RlID0gdGhpcy5pblNNYXNrTW9kZTtcbiAgICBpZiAodGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrICYmICFpblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5iZWdpblNNYXNrTW9kZSgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuY3VycmVudC5hY3RpdmVTTWFzayAmJiBpblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5lbmRTTWFza01vZGUoKTtcbiAgICB9XG4gIH1cbiAgYmVnaW5TTWFza01vZGUoKSB7XG4gICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJlZ2luU01hc2tNb2RlIGNhbGxlZCB3aGlsZSBhbHJlYWR5IGluIHNtYXNrIG1vZGVcIik7XG4gICAgfVxuICAgIGNvbnN0IGRyYXduV2lkdGggPSB0aGlzLmN0eC5jYW52YXMud2lkdGg7XG4gICAgY29uc3QgZHJhd25IZWlnaHQgPSB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0O1xuICAgIGNvbnN0IGNhY2hlSWQgPSBcInNtYXNrR3JvdXBBdFwiICsgdGhpcy5ncm91cExldmVsO1xuICAgIGNvbnN0IHNjcmF0Y2hDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhjYWNoZUlkLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodCk7XG4gICAgdGhpcy5zdXNwZW5kZWRDdHggPSB0aGlzLmN0eDtcbiAgICB0aGlzLmN0eCA9IHNjcmF0Y2hDYW52YXMuY29udGV4dDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjdHguc2V0VHJhbnNmb3JtKC4uLmdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5zdXNwZW5kZWRDdHgpKTtcbiAgICBjb3B5Q3R4U3RhdGUodGhpcy5zdXNwZW5kZWRDdHgsIGN0eCk7XG4gICAgbWlycm9yQ29udGV4dE9wZXJhdGlvbnMoY3R4LCB0aGlzLnN1c3BlbmRlZEN0eCk7XG4gICAgdGhpcy5zZXRHU3RhdGUoW1tcIkJNXCIsIFwic291cmNlLW92ZXJcIl0sIFtcImNhXCIsIDFdLCBbXCJDQVwiLCAxXV0pO1xuICB9XG4gIGVuZFNNYXNrTW9kZSgpIHtcbiAgICBpZiAoIXRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImVuZFNNYXNrTW9kZSBjYWxsZWQgd2hpbGUgbm90IGluIHNtYXNrIG1vZGVcIik7XG4gICAgfVxuICAgIHRoaXMuY3R4Ll9yZW1vdmVNaXJyb3JpbmcoKTtcbiAgICBjb3B5Q3R4U3RhdGUodGhpcy5jdHgsIHRoaXMuc3VzcGVuZGVkQ3R4KTtcbiAgICB0aGlzLmN0eCA9IHRoaXMuc3VzcGVuZGVkQ3R4O1xuICAgIHRoaXMuc3VzcGVuZGVkQ3R4ID0gbnVsbDtcbiAgfVxuICBjb21wb3NlKGRpcnR5Qm94KSB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFkaXJ0eUJveCkge1xuICAgICAgZGlydHlCb3ggPSBbMCwgMCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlydHlCb3hbMF0gPSBNYXRoLmZsb29yKGRpcnR5Qm94WzBdKTtcbiAgICAgIGRpcnR5Qm94WzFdID0gTWF0aC5mbG9vcihkaXJ0eUJveFsxXSk7XG4gICAgICBkaXJ0eUJveFsyXSA9IE1hdGguY2VpbChkaXJ0eUJveFsyXSk7XG4gICAgICBkaXJ0eUJveFszXSA9IE1hdGguY2VpbChkaXJ0eUJveFszXSk7XG4gICAgfVxuICAgIGNvbnN0IHNtYXNrID0gdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrO1xuICAgIGNvbnN0IHN1c3BlbmRlZEN0eCA9IHRoaXMuc3VzcGVuZGVkQ3R4O1xuICAgIHRoaXMuY29tcG9zZVNNYXNrKHN1c3BlbmRlZEN0eCwgc21hc2ssIHRoaXMuY3R4LCBkaXJ0eUJveCk7XG4gICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgY29tcG9zZVNNYXNrKGN0eCwgc21hc2ssIGxheWVyQ3R4LCBsYXllckJveCkge1xuICAgIGNvbnN0IGxheWVyT2Zmc2V0WCA9IGxheWVyQm94WzBdO1xuICAgIGNvbnN0IGxheWVyT2Zmc2V0WSA9IGxheWVyQm94WzFdO1xuICAgIGNvbnN0IGxheWVyV2lkdGggPSBsYXllckJveFsyXSAtIGxheWVyT2Zmc2V0WDtcbiAgICBjb25zdCBsYXllckhlaWdodCA9IGxheWVyQm94WzNdIC0gbGF5ZXJPZmZzZXRZO1xuICAgIGlmIChsYXllcldpZHRoID09PSAwIHx8IGxheWVySGVpZ2h0ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZ2VuZXJpY0NvbXBvc2VTTWFzayhzbWFzay5jb250ZXh0LCBsYXllckN0eCwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHQsIHNtYXNrLnN1YnR5cGUsIHNtYXNrLmJhY2tkcm9wLCBzbWFzay50cmFuc2Zlck1hcCwgbGF5ZXJPZmZzZXRYLCBsYXllck9mZnNldFksIHNtYXNrLm9mZnNldFgsIHNtYXNrLm9mZnNldFkpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2Utb3ZlclwiO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgY3R4LmRyYXdJbWFnZShsYXllckN0eC5jYW52YXMsIDAsIDApO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgZ2VuZXJpY0NvbXBvc2VTTWFzayhtYXNrQ3R4LCBsYXllckN0eCwgd2lkdGgsIGhlaWdodCwgc3VidHlwZSwgYmFja2Ryb3AsIHRyYW5zZmVyTWFwLCBsYXllck9mZnNldFgsIGxheWVyT2Zmc2V0WSwgbWFza09mZnNldFgsIG1hc2tPZmZzZXRZKSB7XG4gICAgbGV0IG1hc2tDYW52YXMgPSBtYXNrQ3R4LmNhbnZhcztcbiAgICBsZXQgbWFza1ggPSBsYXllck9mZnNldFggLSBtYXNrT2Zmc2V0WDtcbiAgICBsZXQgbWFza1kgPSBsYXllck9mZnNldFkgLSBtYXNrT2Zmc2V0WTtcbiAgICBpZiAoYmFja2Ryb3ApIHtcbiAgICAgIGNvbnN0IGJhY2tkcm9wUkdCID0gVXRpbC5tYWtlSGV4Q29sb3IoLi4uYmFja2Ryb3ApO1xuICAgICAgaWYgKG1hc2tYIDwgMCB8fCBtYXNrWSA8IDAgfHwgbWFza1ggKyB3aWR0aCA+IG1hc2tDYW52YXMud2lkdGggfHwgbWFza1kgKyBoZWlnaHQgPiBtYXNrQ2FudmFzLmhlaWdodCkge1xuICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1hc2tFeHRlbnNpb25cIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5jb250ZXh0O1xuICAgICAgICBjdHguZHJhd0ltYWdlKG1hc2tDYW52YXMsIC1tYXNrWCwgLW1hc2tZKTtcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24tYXRvcFwiO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gYmFja2Ryb3BSR0I7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgbWFza0NhbnZhcyA9IGNhbnZhcy5jYW52YXM7XG4gICAgICAgIG1hc2tYID0gbWFza1kgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFza0N0eC5zYXZlKCk7XG4gICAgICAgIG1hc2tDdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICBtYXNrQ3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgY29uc3QgY2xpcCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgY2xpcC5yZWN0KG1hc2tYLCBtYXNrWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIG1hc2tDdHguY2xpcChjbGlwKTtcbiAgICAgICAgbWFza0N0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLWF0b3BcIjtcbiAgICAgICAgbWFza0N0eC5maWxsU3R5bGUgPSBiYWNrZHJvcFJHQjtcbiAgICAgICAgbWFza0N0eC5maWxsUmVjdChtYXNrWCwgbWFza1ksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBtYXNrQ3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGF5ZXJDdHguc2F2ZSgpO1xuICAgIGxheWVyQ3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICBsYXllckN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgaWYgKHN1YnR5cGUgPT09IFwiQWxwaGFcIiAmJiB0cmFuc2Zlck1hcCkge1xuICAgICAgbGF5ZXJDdHguZmlsdGVyID0gdGhpcy5maWx0ZXJGYWN0b3J5LmFkZEFscGhhRmlsdGVyKHRyYW5zZmVyTWFwKTtcbiAgICB9IGVsc2UgaWYgKHN1YnR5cGUgPT09IFwiTHVtaW5vc2l0eVwiKSB7XG4gICAgICBsYXllckN0eC5maWx0ZXIgPSB0aGlzLmZpbHRlckZhY3RvcnkuYWRkTHVtaW5vc2l0eUZpbHRlcih0cmFuc2Zlck1hcCk7XG4gICAgfVxuICAgIGNvbnN0IGNsaXAgPSBuZXcgUGF0aDJEKCk7XG4gICAgY2xpcC5yZWN0KGxheWVyT2Zmc2V0WCwgbGF5ZXJPZmZzZXRZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBsYXllckN0eC5jbGlwKGNsaXApO1xuICAgIGxheWVyQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24taW5cIjtcbiAgICBsYXllckN0eC5kcmF3SW1hZ2UobWFza0NhbnZhcywgbWFza1gsIG1hc2tZLCB3aWR0aCwgaGVpZ2h0LCBsYXllck9mZnNldFgsIGxheWVyT2Zmc2V0WSwgd2lkdGgsIGhlaWdodCk7XG4gICAgbGF5ZXJDdHgucmVzdG9yZSgpO1xuICB9XG4gIHNhdmUoKSB7XG4gICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIGNvcHlDdHhTdGF0ZSh0aGlzLmN0eCwgdGhpcy5zdXNwZW5kZWRDdHgpO1xuICAgICAgdGhpcy5zdXNwZW5kZWRDdHguc2F2ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgfVxuICAgIGNvbnN0IG9sZCA9IHRoaXMuY3VycmVudDtcbiAgICB0aGlzLnN0YXRlU3RhY2sucHVzaChvbGQpO1xuICAgIHRoaXMuY3VycmVudCA9IG9sZC5jbG9uZSgpO1xuICB9XG4gIHJlc3RvcmUoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggPT09IDAgJiYgdGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5lbmRTTWFza01vZGUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggIT09IDApIHtcbiAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMuc3RhdGVTdGFjay5wb3AoKTtcbiAgICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICAgIHRoaXMuc3VzcGVuZGVkQ3R4LnJlc3RvcmUoKTtcbiAgICAgICAgY29weUN0eFN0YXRlKHRoaXMuc3VzcGVuZGVkQ3R4LCB0aGlzLmN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNoZWNrU01hc2tTdGF0ZSgpO1xuICAgICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgdHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICB0aGlzLmN0eC50cmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IC0xO1xuICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICB9XG4gIGNvbnN0cnVjdFBhdGgob3BzLCBhcmdzLCBtaW5NYXgpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGxldCB4ID0gY3VycmVudC54LFxuICAgICAgeSA9IGN1cnJlbnQueTtcbiAgICBsZXQgc3RhcnRYLCBzdGFydFk7XG4gICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KTtcbiAgICBjb25zdCBpc1NjYWxpbmdNYXRyaXggPSBjdXJyZW50VHJhbnNmb3JtWzBdID09PSAwICYmIGN1cnJlbnRUcmFuc2Zvcm1bM10gPT09IDAgfHwgY3VycmVudFRyYW5zZm9ybVsxXSA9PT0gMCAmJiBjdXJyZW50VHJhbnNmb3JtWzJdID09PSAwO1xuICAgIGNvbnN0IG1pbk1heEZvckJlemllciA9IGlzU2NhbGluZ01hdHJpeCA/IG1pbk1heC5zbGljZSgwKSA6IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwLCBpaSA9IG9wcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBzd2l0Y2ggKG9wc1tpXSB8IDApIHtcbiAgICAgICAgY2FzZSBPUFMucmVjdGFuZ2xlOlxuICAgICAgICAgIHggPSBhcmdzW2orK107XG4gICAgICAgICAgeSA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBjb25zdCBoZWlnaHQgPSBhcmdzW2orK107XG4gICAgICAgICAgY29uc3QgeHcgPSB4ICsgd2lkdGg7XG4gICAgICAgICAgY29uc3QgeWggPSB5ICsgaGVpZ2h0O1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgaWYgKHdpZHRoID09PSAwIHx8IGhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4dywgeWgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHh3LCB5KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeHcsIHloKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeWgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzU2NhbGluZ01hdHJpeCkge1xuICAgICAgICAgICAgY3VycmVudC51cGRhdGVSZWN0TWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIFt4LCB5LCB4dywgeWhdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE9QUy5tb3ZlVG86XG4gICAgICAgICAgeCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgaWYgKCFpc1NjYWxpbmdNYXRyaXgpIHtcbiAgICAgICAgICAgIGN1cnJlbnQudXBkYXRlUGF0aE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCB4LCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgT1BTLmxpbmVUbzpcbiAgICAgICAgICB4ID0gYXJnc1tqKytdO1xuICAgICAgICAgIHkgPSBhcmdzW2orK107XG4gICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICBpZiAoIWlzU2NhbGluZ01hdHJpeCkge1xuICAgICAgICAgICAgY3VycmVudC51cGRhdGVQYXRoTWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIHgsIHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBPUFMuY3VydmVUbzpcbiAgICAgICAgICBzdGFydFggPSB4O1xuICAgICAgICAgIHN0YXJ0WSA9IHk7XG4gICAgICAgICAgeCA9IGFyZ3NbaiArIDRdO1xuICAgICAgICAgIHkgPSBhcmdzW2ogKyA1XTtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhhcmdzW2pdLCBhcmdzW2ogKyAxXSwgYXJnc1tqICsgMl0sIGFyZ3NbaiArIDNdLCB4LCB5KTtcbiAgICAgICAgICBjdXJyZW50LnVwZGF0ZUN1cnZlUGF0aE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCBzdGFydFgsIHN0YXJ0WSwgYXJnc1tqXSwgYXJnc1tqICsgMV0sIGFyZ3NbaiArIDJdLCBhcmdzW2ogKyAzXSwgeCwgeSwgbWluTWF4Rm9yQmV6aWVyKTtcbiAgICAgICAgICBqICs9IDY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgT1BTLmN1cnZlVG8yOlxuICAgICAgICAgIHN0YXJ0WCA9IHg7XG4gICAgICAgICAgc3RhcnRZID0geTtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4LCB5LCBhcmdzW2pdLCBhcmdzW2ogKyAxXSwgYXJnc1tqICsgMl0sIGFyZ3NbaiArIDNdKTtcbiAgICAgICAgICBjdXJyZW50LnVwZGF0ZUN1cnZlUGF0aE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCBzdGFydFgsIHN0YXJ0WSwgeCwgeSwgYXJnc1tqXSwgYXJnc1tqICsgMV0sIGFyZ3NbaiArIDJdLCBhcmdzW2ogKyAzXSwgbWluTWF4Rm9yQmV6aWVyKTtcbiAgICAgICAgICB4ID0gYXJnc1tqICsgMl07XG4gICAgICAgICAgeSA9IGFyZ3NbaiArIDNdO1xuICAgICAgICAgIGogKz0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBPUFMuY3VydmVUbzM6XG4gICAgICAgICAgc3RhcnRYID0geDtcbiAgICAgICAgICBzdGFydFkgPSB5O1xuICAgICAgICAgIHggPSBhcmdzW2ogKyAyXTtcbiAgICAgICAgICB5ID0gYXJnc1tqICsgM107XG4gICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oYXJnc1tqXSwgYXJnc1tqICsgMV0sIHgsIHksIHgsIHkpO1xuICAgICAgICAgIGN1cnJlbnQudXBkYXRlQ3VydmVQYXRoTWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIHN0YXJ0WCwgc3RhcnRZLCBhcmdzW2pdLCBhcmdzW2ogKyAxXSwgeCwgeSwgeCwgeSwgbWluTWF4Rm9yQmV6aWVyKTtcbiAgICAgICAgICBqICs9IDQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgT1BTLmNsb3NlUGF0aDpcbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1NjYWxpbmdNYXRyaXgpIHtcbiAgICAgIGN1cnJlbnQudXBkYXRlU2NhbGluZ1BhdGhNaW5NYXgoY3VycmVudFRyYW5zZm9ybSwgbWluTWF4Rm9yQmV6aWVyKTtcbiAgICB9XG4gICAgY3VycmVudC5zZXRDdXJyZW50UG9pbnQoeCwgeSk7XG4gIH1cbiAgY2xvc2VQYXRoKCkge1xuICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xuICB9XG4gIHN0cm9rZShjb25zdW1lUGF0aCA9IHRydWUpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBzdHJva2VDb2xvciA9IHRoaXMuY3VycmVudC5zdHJva2VDb2xvcjtcbiAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmN1cnJlbnQuc3Ryb2tlQWxwaGE7XG4gICAgaWYgKHRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3Ryb2tlQ29sb3IgPT09IFwib2JqZWN0XCIgJiYgc3Ryb2tlQ29sb3I/LmdldFBhdHRlcm4pIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCksIFBhdGhUeXBlLlNUUk9LRSk7XG4gICAgICAgIHRoaXMucmVzY2FsZUFuZFN0cm9rZShmYWxzZSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlc2NhbGVBbmRTdHJva2UodHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb25zdW1lUGF0aCkge1xuICAgICAgdGhpcy5jb25zdW1lUGF0aCh0aGlzLmN1cnJlbnQuZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveCgpKTtcbiAgICB9XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5jdXJyZW50LmZpbGxBbHBoYTtcbiAgfVxuICBjbG9zZVN0cm9rZSgpIHtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuc3Ryb2tlKCk7XG4gIH1cbiAgZmlsbChjb25zdW1lUGF0aCA9IHRydWUpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgIGNvbnN0IGlzUGF0dGVybkZpbGwgPSB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgbGV0IG5lZWRSZXN0b3JlID0gZmFsc2U7XG4gICAgaWYgKGlzUGF0dGVybkZpbGwpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gZmlsbENvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpLCBQYXRoVHlwZS5GSUxMKTtcbiAgICAgIG5lZWRSZXN0b3JlID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgaW50ZXJzZWN0ID0gdGhpcy5jdXJyZW50LmdldENsaXBwZWRQYXRoQm91bmRpbmdCb3goKTtcbiAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSAmJiBpbnRlcnNlY3QgIT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLnBlbmRpbmdFT0ZpbGwpIHtcbiAgICAgICAgY3R4LmZpbGwoXCJldmVub2RkXCIpO1xuICAgICAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZWVkUmVzdG9yZSkge1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgaWYgKGNvbnN1bWVQYXRoKSB7XG4gICAgICB0aGlzLmNvbnN1bWVQYXRoKGludGVyc2VjdCk7XG4gICAgfVxuICB9XG4gIGVvRmlsbCgpIHtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSB0cnVlO1xuICAgIHRoaXMuZmlsbCgpO1xuICB9XG4gIGZpbGxTdHJva2UoKSB7XG4gICAgdGhpcy5maWxsKGZhbHNlKTtcbiAgICB0aGlzLnN0cm9rZShmYWxzZSk7XG4gICAgdGhpcy5jb25zdW1lUGF0aCgpO1xuICB9XG4gIGVvRmlsbFN0cm9rZSgpIHtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSB0cnVlO1xuICAgIHRoaXMuZmlsbFN0cm9rZSgpO1xuICB9XG4gIGNsb3NlRmlsbFN0cm9rZSgpIHtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuZmlsbFN0cm9rZSgpO1xuICB9XG4gIGNsb3NlRU9GaWxsU3Ryb2tlKCkge1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLmZpbGxTdHJva2UoKTtcbiAgfVxuICBlbmRQYXRoKCkge1xuICAgIHRoaXMuY29uc3VtZVBhdGgoKTtcbiAgfVxuICBjbGlwKCkge1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBOT1JNQUxfQ0xJUDtcbiAgfVxuICBlb0NsaXAoKSB7XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IEVPX0NMSVA7XG4gIH1cbiAgYmVnaW5UZXh0KCkge1xuICAgIHRoaXMuY3VycmVudC50ZXh0TWF0cml4ID0gSURFTlRJVFlfTUFUUklYO1xuICAgIHRoaXMuY3VycmVudC50ZXh0TWF0cml4U2NhbGUgPSAxO1xuICAgIHRoaXMuY3VycmVudC54ID0gdGhpcy5jdXJyZW50LmxpbmVYID0gMDtcbiAgICB0aGlzLmN1cnJlbnQueSA9IHRoaXMuY3VycmVudC5saW5lWSA9IDA7XG4gIH1cbiAgZW5kVGV4dCgpIHtcbiAgICBjb25zdCBwYXRocyA9IHRoaXMucGVuZGluZ1RleHRQYXRocztcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBpZiAocGF0aHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXdQYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgIGNvbnN0IGludlRyYW5zZiA9IGN0eC5nZXRUcmFuc2Zvcm0oKS5pbnZlcnRTZWxmKCk7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGZvbnRTaXplLFxuICAgICAgcGF0aFxuICAgIH0gb2YgcGF0aHMpIHtcbiAgICAgIG5ld1BhdGguYWRkUGF0aChwYXRoLCBuZXcgRE9NTWF0cml4KHRyYW5zZm9ybSkucHJlTXVsdGlwbHlTZWxmKGludlRyYW5zZikudHJhbnNsYXRlKHgsIHkpLnNjYWxlKGZvbnRTaXplLCAtZm9udFNpemUpKTtcbiAgICB9XG4gICAgY3R4LmNsaXAobmV3UGF0aCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdUZXh0UGF0aHM7XG4gIH1cbiAgc2V0Q2hhclNwYWNpbmcoc3BhY2luZykge1xuICAgIHRoaXMuY3VycmVudC5jaGFyU3BhY2luZyA9IHNwYWNpbmc7XG4gIH1cbiAgc2V0V29yZFNwYWNpbmcoc3BhY2luZykge1xuICAgIHRoaXMuY3VycmVudC53b3JkU3BhY2luZyA9IHNwYWNpbmc7XG4gIH1cbiAgc2V0SFNjYWxlKHNjYWxlKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRIU2NhbGUgPSBzY2FsZSAvIDEwMDtcbiAgfVxuICBzZXRMZWFkaW5nKGxlYWRpbmcpIHtcbiAgICB0aGlzLmN1cnJlbnQubGVhZGluZyA9IC1sZWFkaW5nO1xuICB9XG4gIHNldEZvbnQoZm9udFJlZk5hbWUsIHNpemUpIHtcbiAgICBjb25zdCBmb250T2JqID0gdGhpcy5jb21tb25PYmpzLmdldChmb250UmVmTmFtZSk7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBpZiAoIWZvbnRPYmopIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgZmluZCBmb250IGZvciAke2ZvbnRSZWZOYW1lfWApO1xuICAgIH1cbiAgICBjdXJyZW50LmZvbnRNYXRyaXggPSBmb250T2JqLmZvbnRNYXRyaXggfHwgRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgaWYgKGN1cnJlbnQuZm9udE1hdHJpeFswXSA9PT0gMCB8fCBjdXJyZW50LmZvbnRNYXRyaXhbM10gPT09IDApIHtcbiAgICAgIHdhcm4oXCJJbnZhbGlkIGZvbnQgbWF0cml4IGZvciBmb250IFwiICsgZm9udFJlZk5hbWUpO1xuICAgIH1cbiAgICBpZiAoc2l6ZSA8IDApIHtcbiAgICAgIHNpemUgPSAtc2l6ZTtcbiAgICAgIGN1cnJlbnQuZm9udERpcmVjdGlvbiA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LmZvbnREaXJlY3Rpb24gPSAxO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQuZm9udCA9IGZvbnRPYmo7XG4gICAgdGhpcy5jdXJyZW50LmZvbnRTaXplID0gc2l6ZTtcbiAgICBpZiAoZm9udE9iai5pc1R5cGUzRm9udCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gZm9udE9iai5sb2FkZWROYW1lIHx8IFwic2Fucy1zZXJpZlwiO1xuICAgIGNvbnN0IHR5cGVmYWNlID0gZm9udE9iai5zeXN0ZW1Gb250SW5mbz8uY3NzIHx8IGBcIiR7bmFtZX1cIiwgJHtmb250T2JqLmZhbGxiYWNrTmFtZX1gO1xuICAgIGxldCBib2xkID0gXCJub3JtYWxcIjtcbiAgICBpZiAoZm9udE9iai5ibGFjaykge1xuICAgICAgYm9sZCA9IFwiOTAwXCI7XG4gICAgfSBlbHNlIGlmIChmb250T2JqLmJvbGQpIHtcbiAgICAgIGJvbGQgPSBcImJvbGRcIjtcbiAgICB9XG4gICAgY29uc3QgaXRhbGljID0gZm9udE9iai5pdGFsaWMgPyBcIml0YWxpY1wiIDogXCJub3JtYWxcIjtcbiAgICBsZXQgYnJvd3NlckZvbnRTaXplID0gc2l6ZTtcbiAgICBpZiAoc2l6ZSA8IE1JTl9GT05UX1NJWkUpIHtcbiAgICAgIGJyb3dzZXJGb250U2l6ZSA9IE1JTl9GT05UX1NJWkU7XG4gICAgfSBlbHNlIGlmIChzaXplID4gTUFYX0ZPTlRfU0laRSkge1xuICAgICAgYnJvd3NlckZvbnRTaXplID0gTUFYX0ZPTlRfU0laRTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LmZvbnRTaXplU2NhbGUgPSBzaXplIC8gYnJvd3NlckZvbnRTaXplO1xuICAgIHRoaXMuY3R4LmZvbnQgPSBgJHtpdGFsaWN9ICR7Ym9sZH0gJHticm93c2VyRm9udFNpemV9cHggJHt0eXBlZmFjZX1gO1xuICB9XG4gIHNldFRleHRSZW5kZXJpbmdNb2RlKG1vZGUpIHtcbiAgICB0aGlzLmN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPSBtb2RlO1xuICB9XG4gIHNldFRleHRSaXNlKHJpc2UpIHtcbiAgICB0aGlzLmN1cnJlbnQudGV4dFJpc2UgPSByaXNlO1xuICB9XG4gIG1vdmVUZXh0KHgsIHkpIHtcbiAgICB0aGlzLmN1cnJlbnQueCA9IHRoaXMuY3VycmVudC5saW5lWCArPSB4O1xuICAgIHRoaXMuY3VycmVudC55ID0gdGhpcy5jdXJyZW50LmxpbmVZICs9IHk7XG4gIH1cbiAgc2V0TGVhZGluZ01vdmVUZXh0KHgsIHkpIHtcbiAgICB0aGlzLnNldExlYWRpbmcoLXkpO1xuICAgIHRoaXMubW92ZVRleHQoeCwgeSk7XG4gIH1cbiAgc2V0VGV4dE1hdHJpeChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRNYXRyaXggPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgdGhpcy5jdXJyZW50LnRleHRNYXRyaXhTY2FsZSA9IE1hdGguaHlwb3QoYSwgYik7XG4gICAgdGhpcy5jdXJyZW50LnggPSB0aGlzLmN1cnJlbnQubGluZVggPSAwO1xuICAgIHRoaXMuY3VycmVudC55ID0gdGhpcy5jdXJyZW50LmxpbmVZID0gMDtcbiAgfVxuICBuZXh0TGluZSgpIHtcbiAgICB0aGlzLm1vdmVUZXh0KDAsIHRoaXMuY3VycmVudC5sZWFkaW5nKTtcbiAgfVxuICAjZ2V0U2NhbGVkUGF0aChwYXRoLCBjdXJyZW50VHJhbnNmb3JtLCB0cmFuc2Zvcm0pIHtcbiAgICBjb25zdCBuZXdQYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgIG5ld1BhdGguYWRkUGF0aChwYXRoLCBuZXcgRE9NTWF0cml4KHRyYW5zZm9ybSkuaW52ZXJ0U2VsZigpLm11bHRpcGx5U2VsZihjdXJyZW50VHJhbnNmb3JtKSk7XG4gICAgcmV0dXJuIG5ld1BhdGg7XG4gIH1cbiAgcGFpbnRDaGFyKGNoYXJhY3RlciwgeCwgeSwgcGF0dGVybkZpbGxUcmFuc2Zvcm0sIHBhdHRlcm5TdHJva2VUcmFuc2Zvcm0pIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgY29uc3QgdGV4dFJlbmRlcmluZ01vZGUgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlO1xuICAgIGNvbnN0IGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZSAvIGN1cnJlbnQuZm9udFNpemVTY2FsZTtcbiAgICBjb25zdCBmaWxsU3Ryb2tlTW9kZSA9IHRleHRSZW5kZXJpbmdNb2RlICYgVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0VfTUFTSztcbiAgICBjb25zdCBpc0FkZFRvUGF0aFNldCA9ICEhKHRleHRSZW5kZXJpbmdNb2RlICYgVGV4dFJlbmRlcmluZ01vZGUuQUREX1RPX1BBVEhfRkxBRyk7XG4gICAgY29uc3QgcGF0dGVybkZpbGwgPSBjdXJyZW50LnBhdHRlcm5GaWxsICYmICFmb250Lm1pc3NpbmdGaWxlO1xuICAgIGNvbnN0IHBhdHRlcm5TdHJva2UgPSBjdXJyZW50LnBhdHRlcm5TdHJva2UgJiYgIWZvbnQubWlzc2luZ0ZpbGU7XG4gICAgbGV0IHBhdGg7XG4gICAgaWYgKGZvbnQuZGlzYWJsZUZvbnRGYWNlIHx8IGlzQWRkVG9QYXRoU2V0IHx8IHBhdHRlcm5GaWxsIHx8IHBhdHRlcm5TdHJva2UpIHtcbiAgICAgIHBhdGggPSBmb250LmdldFBhdGhHZW5lcmF0b3IodGhpcy5jb21tb25PYmpzLCBjaGFyYWN0ZXIpO1xuICAgIH1cbiAgICBpZiAoZm9udC5kaXNhYmxlRm9udEZhY2UgfHwgcGF0dGVybkZpbGwgfHwgcGF0dGVyblN0cm9rZSkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBjdHguc2NhbGUoZm9udFNpemUsIC1mb250U2l6ZSk7XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTEwgfHwgZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGlmIChwYXR0ZXJuRmlsbFRyYW5zZm9ybSkge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBjdHguZ2V0VHJhbnNmb3JtKCk7XG4gICAgICAgICAgY3R4LnNldFRyYW5zZm9ybSguLi5wYXR0ZXJuRmlsbFRyYW5zZm9ybSk7XG4gICAgICAgICAgY3R4LmZpbGwodGhpcy4jZ2V0U2NhbGVkUGF0aChwYXRoLCBjdXJyZW50VHJhbnNmb3JtLCBwYXR0ZXJuRmlsbFRyYW5zZm9ybSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5maWxsKHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgaWYgKHBhdHRlcm5TdHJva2VUcmFuc2Zvcm0pIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50VHJhbnNmb3JtID0gY3R4LmdldFRyYW5zZm9ybSgpO1xuICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4ucGF0dGVyblN0cm9rZVRyYW5zZm9ybSk7XG4gICAgICAgICAgY3R4LnN0cm9rZSh0aGlzLiNnZXRTY2FsZWRQYXRoKHBhdGgsIGN1cnJlbnRUcmFuc2Zvcm0sIHBhdHRlcm5TdHJva2VUcmFuc2Zvcm0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgubGluZVdpZHRoIC89IGZvbnRTaXplO1xuICAgICAgICAgIGN0eC5zdHJva2UocGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTCB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KGNoYXJhY3RlciwgeCwgeSk7XG4gICAgICB9XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgY3R4LnN0cm9rZVRleHQoY2hhcmFjdGVyLCB4LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQWRkVG9QYXRoU2V0KSB7XG4gICAgICBjb25zdCBwYXRocyA9IHRoaXMucGVuZGluZ1RleHRQYXRocyB8fD0gW107XG4gICAgICBwYXRocy5wdXNoKHtcbiAgICAgICAgdHJhbnNmb3JtOiBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCksXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGZvbnRTaXplLFxuICAgICAgICBwYXRoXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0IGlzRm9udFN1YnBpeGVsQUFFbmFibGVkKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQ6IGN0eFxuICAgIH0gPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlzRm9udFN1YnBpeGVsQUFFbmFibGVkXCIsIDEwLCAxMCk7XG4gICAgY3R4LnNjYWxlKDEuNSwgMSk7XG4gICAgY3R4LmZpbGxUZXh0KFwiSVwiLCAwLCAxMCk7XG4gICAgY29uc3QgZGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMTAsIDEwKS5kYXRhO1xuICAgIGxldCBlbmFibGVkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDM7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICBpZiAoZGF0YVtpXSA+IDAgJiYgZGF0YVtpXSA8IDI1NSkge1xuICAgICAgICBlbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZFwiLCBlbmFibGVkKTtcbiAgfVxuICBzaG93VGV4dChnbHlwaHMpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgaWYgKGZvbnQuaXNUeXBlM0ZvbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNob3dUeXBlM1RleHQoZ2x5cGhzKTtcbiAgICB9XG4gICAgY29uc3QgZm9udFNpemUgPSBjdXJyZW50LmZvbnRTaXplO1xuICAgIGlmIChmb250U2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZm9udFNpemVTY2FsZSA9IGN1cnJlbnQuZm9udFNpemVTY2FsZTtcbiAgICBjb25zdCBjaGFyU3BhY2luZyA9IGN1cnJlbnQuY2hhclNwYWNpbmc7XG4gICAgY29uc3Qgd29yZFNwYWNpbmcgPSBjdXJyZW50LndvcmRTcGFjaW5nO1xuICAgIGNvbnN0IGZvbnREaXJlY3Rpb24gPSBjdXJyZW50LmZvbnREaXJlY3Rpb247XG4gICAgY29uc3QgdGV4dEhTY2FsZSA9IGN1cnJlbnQudGV4dEhTY2FsZSAqIGZvbnREaXJlY3Rpb247XG4gICAgY29uc3QgZ2x5cGhzTGVuZ3RoID0gZ2x5cGhzLmxlbmd0aDtcbiAgICBjb25zdCB2ZXJ0aWNhbCA9IGZvbnQudmVydGljYWw7XG4gICAgY29uc3Qgc3BhY2luZ0RpciA9IHZlcnRpY2FsID8gMSA6IC0xO1xuICAgIGNvbnN0IGRlZmF1bHRWTWV0cmljcyA9IGZvbnQuZGVmYXVsdFZNZXRyaWNzO1xuICAgIGNvbnN0IHdpZHRoQWR2YW5jZVNjYWxlID0gZm9udFNpemUgKiBjdXJyZW50LmZvbnRNYXRyaXhbMF07XG4gICAgY29uc3Qgc2ltcGxlRmlsbFRleHQgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMICYmICFmb250LmRpc2FibGVGb250RmFjZSAmJiAhY3VycmVudC5wYXR0ZXJuRmlsbDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2Zvcm0oLi4uY3VycmVudC50ZXh0TWF0cml4KTtcbiAgICBjdHgudHJhbnNsYXRlKGN1cnJlbnQueCwgY3VycmVudC55ICsgY3VycmVudC50ZXh0UmlzZSk7XG4gICAgaWYgKGZvbnREaXJlY3Rpb24gPiAwKSB7XG4gICAgICBjdHguc2NhbGUodGV4dEhTY2FsZSwgLTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguc2NhbGUodGV4dEhTY2FsZSwgMSk7XG4gICAgfVxuICAgIGxldCBwYXR0ZXJuRmlsbFRyYW5zZm9ybSwgcGF0dGVyblN0cm9rZVRyYW5zZm9ybTtcbiAgICBpZiAoY3VycmVudC5wYXR0ZXJuRmlsbCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGNvbnN0IHBhdHRlcm4gPSBjdXJyZW50LmZpbGxDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSwgUGF0aFR5cGUuRklMTCk7XG4gICAgICBwYXR0ZXJuRmlsbFRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gcGF0dGVybjtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnQucGF0dGVyblN0cm9rZSkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGNvbnN0IHBhdHRlcm4gPSBjdXJyZW50LnN0cm9rZUNvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpLCBQYXRoVHlwZS5TVFJPS0UpO1xuICAgICAgcGF0dGVyblN0cm9rZVRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBwYXR0ZXJuO1xuICAgIH1cbiAgICBsZXQgbGluZVdpZHRoID0gY3VycmVudC5saW5lV2lkdGg7XG4gICAgY29uc3Qgc2NhbGUgPSBjdXJyZW50LnRleHRNYXRyaXhTY2FsZTtcbiAgICBpZiAoc2NhbGUgPT09IDAgfHwgbGluZVdpZHRoID09PSAwKSB7XG4gICAgICBjb25zdCBmaWxsU3Ryb2tlTW9kZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgJiBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRV9NQVNLO1xuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGxpbmVXaWR0aCA9IHRoaXMuZ2V0U2luZ2xlUGl4ZWxXaWR0aCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lV2lkdGggLz0gc2NhbGU7XG4gICAgfVxuICAgIGlmIChmb250U2l6ZVNjYWxlICE9PSAxLjApIHtcbiAgICAgIGN0eC5zY2FsZShmb250U2l6ZVNjYWxlLCBmb250U2l6ZVNjYWxlKTtcbiAgICAgIGxpbmVXaWR0aCAvPSBmb250U2l6ZVNjYWxlO1xuICAgIH1cbiAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgIGlmIChmb250LmlzSW52YWxpZFBERmpzRm9udCkge1xuICAgICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICAgIGxldCB3aWR0aCA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGdseXBoIG9mIGdseXBocykge1xuICAgICAgICBjaGFycy5wdXNoKGdseXBoLnVuaWNvZGUpO1xuICAgICAgICB3aWR0aCArPSBnbHlwaC53aWR0aDtcbiAgICAgIH1cbiAgICAgIGN0eC5maWxsVGV4dChjaGFycy5qb2luKFwiXCIpLCAwLCAwKTtcbiAgICAgIGN1cnJlbnQueCArPSB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlICogdGV4dEhTY2FsZTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxldCB4ID0gMCxcbiAgICAgIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGdseXBoc0xlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgZ2x5cGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgeCArPSBzcGFjaW5nRGlyICogZ2x5cGggKiBmb250U2l6ZSAvIDEwMDA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IHJlc3RvcmVOZWVkZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHNwYWNpbmcgPSAoZ2x5cGguaXNTcGFjZSA/IHdvcmRTcGFjaW5nIDogMCkgKyBjaGFyU3BhY2luZztcbiAgICAgIGNvbnN0IGNoYXJhY3RlciA9IGdseXBoLmZvbnRDaGFyO1xuICAgICAgY29uc3QgYWNjZW50ID0gZ2x5cGguYWNjZW50O1xuICAgICAgbGV0IHNjYWxlZFgsIHNjYWxlZFk7XG4gICAgICBsZXQgd2lkdGggPSBnbHlwaC53aWR0aDtcbiAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICBjb25zdCB2bWV0cmljID0gZ2x5cGgudm1ldHJpYyB8fCBkZWZhdWx0Vk1ldHJpY3M7XG4gICAgICAgIGNvbnN0IHZ4ID0gLShnbHlwaC52bWV0cmljID8gdm1ldHJpY1sxXSA6IHdpZHRoICogMC41KSAqIHdpZHRoQWR2YW5jZVNjYWxlO1xuICAgICAgICBjb25zdCB2eSA9IHZtZXRyaWNbMl0gKiB3aWR0aEFkdmFuY2VTY2FsZTtcbiAgICAgICAgd2lkdGggPSB2bWV0cmljID8gLXZtZXRyaWNbMF0gOiB3aWR0aDtcbiAgICAgICAgc2NhbGVkWCA9IHZ4IC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgc2NhbGVkWSA9ICh4ICsgdnkpIC8gZm9udFNpemVTY2FsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjYWxlZFggPSB4IC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgc2NhbGVkWSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoZm9udC5yZW1lYXN1cmUgJiYgd2lkdGggPiAwKSB7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVkV2lkdGggPSBjdHgubWVhc3VyZVRleHQoY2hhcmFjdGVyKS53aWR0aCAqIDEwMDAgLyBmb250U2l6ZSAqIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIGlmICh3aWR0aCA8IG1lYXN1cmVkV2lkdGggJiYgdGhpcy5pc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZCkge1xuICAgICAgICAgIGNvbnN0IGNoYXJhY3RlclNjYWxlWCA9IHdpZHRoIC8gbWVhc3VyZWRXaWR0aDtcbiAgICAgICAgICByZXN0b3JlTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgIGN0eC5zY2FsZShjaGFyYWN0ZXJTY2FsZVgsIDEpO1xuICAgICAgICAgIHNjYWxlZFggLz0gY2hhcmFjdGVyU2NhbGVYO1xuICAgICAgICB9IGVsc2UgaWYgKHdpZHRoICE9PSBtZWFzdXJlZFdpZHRoKSB7XG4gICAgICAgICAgc2NhbGVkWCArPSAod2lkdGggLSBtZWFzdXJlZFdpZHRoKSAvIDIwMDAgKiBmb250U2l6ZSAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlICYmIChnbHlwaC5pc0luRm9udCB8fCBmb250Lm1pc3NpbmdGaWxlKSkge1xuICAgICAgICBpZiAoc2ltcGxlRmlsbFRleHQgJiYgIWFjY2VudCkge1xuICAgICAgICAgIGN0eC5maWxsVGV4dChjaGFyYWN0ZXIsIHNjYWxlZFgsIHNjYWxlZFkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFpbnRDaGFyKGNoYXJhY3Rlciwgc2NhbGVkWCwgc2NhbGVkWSwgcGF0dGVybkZpbGxUcmFuc2Zvcm0sIHBhdHRlcm5TdHJva2VUcmFuc2Zvcm0pO1xuICAgICAgICAgIGlmIChhY2NlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlZEFjY2VudFggPSBzY2FsZWRYICsgZm9udFNpemUgKiBhY2NlbnQub2Zmc2V0LnggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVkQWNjZW50WSA9IHNjYWxlZFkgLSBmb250U2l6ZSAqIGFjY2VudC5vZmZzZXQueSAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgICAgICB0aGlzLnBhaW50Q2hhcihhY2NlbnQuZm9udENoYXIsIHNjYWxlZEFjY2VudFgsIHNjYWxlZEFjY2VudFksIHBhdHRlcm5GaWxsVHJhbnNmb3JtLCBwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYXJXaWR0aCA9IHZlcnRpY2FsID8gd2lkdGggKiB3aWR0aEFkdmFuY2VTY2FsZSAtIHNwYWNpbmcgKiBmb250RGlyZWN0aW9uIDogd2lkdGggKiB3aWR0aEFkdmFuY2VTY2FsZSArIHNwYWNpbmcgKiBmb250RGlyZWN0aW9uO1xuICAgICAgeCArPSBjaGFyV2lkdGg7XG4gICAgICBpZiAocmVzdG9yZU5lZWRlZCkge1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmVydGljYWwpIHtcbiAgICAgIGN1cnJlbnQueSAtPSB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LnggKz0geCAqIHRleHRIU2NhbGU7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBzaG93VHlwZTNUZXh0KGdseXBocykge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY29uc3QgZm9udCA9IGN1cnJlbnQuZm9udDtcbiAgICBjb25zdCBmb250U2l6ZSA9IGN1cnJlbnQuZm9udFNpemU7XG4gICAgY29uc3QgZm9udERpcmVjdGlvbiA9IGN1cnJlbnQuZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCBzcGFjaW5nRGlyID0gZm9udC52ZXJ0aWNhbCA/IDEgOiAtMTtcbiAgICBjb25zdCBjaGFyU3BhY2luZyA9IGN1cnJlbnQuY2hhclNwYWNpbmc7XG4gICAgY29uc3Qgd29yZFNwYWNpbmcgPSBjdXJyZW50LndvcmRTcGFjaW5nO1xuICAgIGNvbnN0IHRleHRIU2NhbGUgPSBjdXJyZW50LnRleHRIU2NhbGUgKiBmb250RGlyZWN0aW9uO1xuICAgIGNvbnN0IGZvbnRNYXRyaXggPSBjdXJyZW50LmZvbnRNYXRyaXggfHwgRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgY29uc3QgZ2x5cGhzTGVuZ3RoID0gZ2x5cGhzLmxlbmd0aDtcbiAgICBjb25zdCBpc1RleHRJbnZpc2libGUgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5JTlZJU0lCTEU7XG4gICAgbGV0IGksIGdseXBoLCB3aWR0aCwgc3BhY2luZ0xlbmd0aDtcbiAgICBpZiAoaXNUZXh0SW52aXNpYmxlIHx8IGZvbnRTaXplID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPSAtMTtcbiAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2Zvcm0oLi4uY3VycmVudC50ZXh0TWF0cml4KTtcbiAgICBjdHgudHJhbnNsYXRlKGN1cnJlbnQueCwgY3VycmVudC55KTtcbiAgICBjdHguc2NhbGUodGV4dEhTY2FsZSwgZm9udERpcmVjdGlvbik7XG4gICAgZm9yIChpID0gMDsgaSA8IGdseXBoc0xlbmd0aDsgKytpKSB7XG4gICAgICBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgZ2x5cGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgc3BhY2luZ0xlbmd0aCA9IHNwYWNpbmdEaXIgKiBnbHlwaCAqIGZvbnRTaXplIC8gMTAwMDtcbiAgICAgICAgdGhpcy5jdHgudHJhbnNsYXRlKHNwYWNpbmdMZW5ndGgsIDApO1xuICAgICAgICBjdXJyZW50LnggKz0gc3BhY2luZ0xlbmd0aCAqIHRleHRIU2NhbGU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3BhY2luZyA9IChnbHlwaC5pc1NwYWNlID8gd29yZFNwYWNpbmcgOiAwKSArIGNoYXJTcGFjaW5nO1xuICAgICAgY29uc3Qgb3BlcmF0b3JMaXN0ID0gZm9udC5jaGFyUHJvY09wZXJhdG9yTGlzdFtnbHlwaC5vcGVyYXRvckxpc3RJZF07XG4gICAgICBpZiAoIW9wZXJhdG9yTGlzdCkge1xuICAgICAgICB3YXJuKGBUeXBlMyBjaGFyYWN0ZXIgXCIke2dseXBoLm9wZXJhdG9yTGlzdElkfVwiIGlzIG5vdCBhdmFpbGFibGUuYCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nVHlwZTMgPSBnbHlwaDtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICAgIGN0eC5zY2FsZShmb250U2l6ZSwgZm9udFNpemUpO1xuICAgICAgICBjdHgudHJhbnNmb3JtKC4uLmZvbnRNYXRyaXgpO1xuICAgICAgICB0aGlzLmV4ZWN1dGVPcGVyYXRvckxpc3Qob3BlcmF0b3JMaXN0KTtcbiAgICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IFV0aWwuYXBwbHlUcmFuc2Zvcm0oW2dseXBoLndpZHRoLCAwXSwgZm9udE1hdHJpeCk7XG4gICAgICB3aWR0aCA9IHRyYW5zZm9ybWVkWzBdICogZm9udFNpemUgKyBzcGFjaW5nO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh3aWR0aCwgMCk7XG4gICAgICBjdXJyZW50LnggKz0gd2lkdGggKiB0ZXh0SFNjYWxlO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHRoaXMucHJvY2Vzc2luZ1R5cGUzID0gbnVsbDtcbiAgfVxuICBzZXRDaGFyV2lkdGgoeFdpZHRoLCB5V2lkdGgpIHt9XG4gIHNldENoYXJXaWR0aEFuZEJvdW5kcyh4V2lkdGgsIHlXaWR0aCwgbGx4LCBsbHksIHVyeCwgdXJ5KSB7XG4gICAgdGhpcy5jdHgucmVjdChsbHgsIGxseSwgdXJ4IC0gbGx4LCB1cnkgLSBsbHkpO1xuICAgIHRoaXMuY3R4LmNsaXAoKTtcbiAgICB0aGlzLmVuZFBhdGgoKTtcbiAgfVxuICBnZXRDb2xvck5fUGF0dGVybihJUikge1xuICAgIGxldCBwYXR0ZXJuO1xuICAgIGlmIChJUlswXSA9PT0gXCJUaWxpbmdQYXR0ZXJuXCIpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gSVJbMV07XG4gICAgICBjb25zdCBiYXNlVHJhbnNmb3JtID0gdGhpcy5iYXNlVHJhbnNmb3JtIHx8IGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpO1xuICAgICAgY29uc3QgY2FudmFzR3JhcGhpY3NGYWN0b3J5ID0ge1xuICAgICAgICBjcmVhdGVDYW52YXNHcmFwaGljczogY3R4ID0+IG5ldyBDYW52YXNHcmFwaGljcyhjdHgsIHRoaXMuY29tbW9uT2JqcywgdGhpcy5vYmpzLCB0aGlzLmNhbnZhc0ZhY3RvcnksIHRoaXMuZmlsdGVyRmFjdG9yeSwge1xuICAgICAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZzogdGhpcy5vcHRpb25hbENvbnRlbnRDb25maWcsXG4gICAgICAgICAgbWFya2VkQ29udGVudFN0YWNrOiB0aGlzLm1hcmtlZENvbnRlbnRTdGFja1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICAgIHBhdHRlcm4gPSBuZXcgVGlsaW5nUGF0dGVybihJUiwgY29sb3IsIHRoaXMuY3R4LCBjYW52YXNHcmFwaGljc0ZhY3RvcnksIGJhc2VUcmFuc2Zvcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXR0ZXJuID0gdGhpcy5fZ2V0UGF0dGVybihJUlsxXSwgSVJbMl0pO1xuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuICBzZXRTdHJva2VDb2xvck4oKSB7XG4gICAgdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gdGhpcy5nZXRDb2xvck5fUGF0dGVybihhcmd1bWVudHMpO1xuICAgIHRoaXMuY3VycmVudC5wYXR0ZXJuU3Ryb2tlID0gdHJ1ZTtcbiAgfVxuICBzZXRGaWxsQ29sb3JOKCkge1xuICAgIHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSB0aGlzLmdldENvbG9yTl9QYXR0ZXJuKGFyZ3VtZW50cyk7XG4gICAgdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsID0gdHJ1ZTtcbiAgfVxuICBzZXRTdHJva2VSR0JDb2xvcihyLCBnLCBiKSB7XG4gICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvcihyLCBnLCBiKTtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVyblN0cm9rZSA9IGZhbHNlO1xuICB9XG4gIHNldFN0cm9rZVRyYW5zcGFyZW50KCkge1xuICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgIHRoaXMuY3VycmVudC5wYXR0ZXJuU3Ryb2tlID0gZmFsc2U7XG4gIH1cbiAgc2V0RmlsbFJHQkNvbG9yKHIsIGcsIGIpIHtcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IociwgZywgYik7XG4gICAgdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsID0gZmFsc2U7XG4gIH1cbiAgc2V0RmlsbFRyYW5zcGFyZW50KCkge1xuICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsID0gZmFsc2U7XG4gIH1cbiAgX2dldFBhdHRlcm4ob2JqSWQsIG1hdHJpeCA9IG51bGwpIHtcbiAgICBsZXQgcGF0dGVybjtcbiAgICBpZiAodGhpcy5jYWNoZWRQYXR0ZXJucy5oYXMob2JqSWQpKSB7XG4gICAgICBwYXR0ZXJuID0gdGhpcy5jYWNoZWRQYXR0ZXJucy5nZXQob2JqSWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXR0ZXJuID0gZ2V0U2hhZGluZ1BhdHRlcm4odGhpcy5nZXRPYmplY3Qob2JqSWQpKTtcbiAgICAgIHRoaXMuY2FjaGVkUGF0dGVybnMuc2V0KG9iaklkLCBwYXR0ZXJuKTtcbiAgICB9XG4gICAgaWYgKG1hdHJpeCkge1xuICAgICAgcGF0dGVybi5tYXRyaXggPSBtYXRyaXg7XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG4gIHNoYWRpbmdGaWxsKG9iaklkKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIHRoaXMuc2F2ZSgpO1xuICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLl9nZXRQYXR0ZXJuKG9iaklkKTtcbiAgICBjdHguZmlsbFN0eWxlID0gcGF0dGVybi5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSwgUGF0aFR5cGUuU0hBRElORyk7XG4gICAgY29uc3QgaW52ID0gZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KTtcbiAgICBpZiAoaW52KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSBjdHguY2FudmFzO1xuICAgICAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IFV0aWwuZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3goWzAsIDAsIHdpZHRoLCBoZWlnaHRdLCBpbnYpO1xuICAgICAgdGhpcy5jdHguZmlsbFJlY3QoeDAsIHkwLCB4MSAtIHgwLCB5MSAtIHkwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHguZmlsbFJlY3QoLTFlMTAsIC0xZTEwLCAyZTEwLCAyZTEwKTtcbiAgICB9XG4gICAgdGhpcy5jb21wb3NlKHRoaXMuY3VycmVudC5nZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KCkpO1xuICAgIHRoaXMucmVzdG9yZSgpO1xuICB9XG4gIGJlZ2luSW5saW5lSW1hZ2UoKSB7XG4gICAgdW5yZWFjaGFibGUoXCJTaG91bGQgbm90IGNhbGwgYmVnaW5JbmxpbmVJbWFnZVwiKTtcbiAgfVxuICBiZWdpbkltYWdlRGF0YSgpIHtcbiAgICB1bnJlYWNoYWJsZShcIlNob3VsZCBub3QgY2FsbCBiZWdpbkltYWdlRGF0YVwiKTtcbiAgfVxuICBwYWludEZvcm1YT2JqZWN0QmVnaW4obWF0cml4LCBiYm94KSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2F2ZSgpO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybVN0YWNrLnB1c2godGhpcy5iYXNlVHJhbnNmb3JtKTtcbiAgICBpZiAobWF0cml4KSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybSguLi5tYXRyaXgpO1xuICAgIH1cbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KTtcbiAgICBpZiAoYmJveCkge1xuICAgICAgY29uc3Qgd2lkdGggPSBiYm94WzJdIC0gYmJveFswXTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGJib3hbM10gLSBiYm94WzFdO1xuICAgICAgdGhpcy5jdHgucmVjdChiYm94WzBdLCBiYm94WzFdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuY3VycmVudC51cGRhdGVSZWN0TWluTWF4KGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpLCBiYm94KTtcbiAgICAgIHRoaXMuY2xpcCgpO1xuICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgfVxuICB9XG4gIHBhaW50Rm9ybVhPYmplY3RFbmQoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IHRoaXMuYmFzZVRyYW5zZm9ybVN0YWNrLnBvcCgpO1xuICB9XG4gIGJlZ2luR3JvdXAoZ3JvdXApIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zYXZlKCk7XG4gICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRoaXMuZW5kU01hc2tNb2RlKCk7XG4gICAgICB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50Q3R4ID0gdGhpcy5jdHg7XG4gICAgaWYgKCFncm91cC5pc29sYXRlZCkge1xuICAgICAgaW5mbyhcIlRPRE86IFN1cHBvcnQgbm9uLWlzb2xhdGVkIGdyb3Vwcy5cIik7XG4gICAgfVxuICAgIGlmIChncm91cC5rbm9ja291dCkge1xuICAgICAgd2FybihcIktub2Nrb3V0IGdyb3VwcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3VycmVudEN0eCk7XG4gICAgaWYgKGdyb3VwLm1hdHJpeCkge1xuICAgICAgY3VycmVudEN0eC50cmFuc2Zvcm0oLi4uZ3JvdXAubWF0cml4KTtcbiAgICB9XG4gICAgaWYgKCFncm91cC5iYm94KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCb3VuZGluZyBib3ggaXMgcmVxdWlyZWQuXCIpO1xuICAgIH1cbiAgICBsZXQgYm91bmRzID0gVXRpbC5nZXRBeGlhbEFsaWduZWRCb3VuZGluZ0JveChncm91cC5iYm94LCBnZXRDdXJyZW50VHJhbnNmb3JtKGN1cnJlbnRDdHgpKTtcbiAgICBjb25zdCBjYW52YXNCb3VuZHMgPSBbMCwgMCwgY3VycmVudEN0eC5jYW52YXMud2lkdGgsIGN1cnJlbnRDdHguY2FudmFzLmhlaWdodF07XG4gICAgYm91bmRzID0gVXRpbC5pbnRlcnNlY3QoYm91bmRzLCBjYW52YXNCb3VuZHMpIHx8IFswLCAwLCAwLCAwXTtcbiAgICBjb25zdCBvZmZzZXRYID0gTWF0aC5mbG9vcihib3VuZHNbMF0pO1xuICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLmZsb29yKGJvdW5kc1sxXSk7XG4gICAgY29uc3QgZHJhd25XaWR0aCA9IE1hdGgubWF4KE1hdGguY2VpbChib3VuZHNbMl0pIC0gb2Zmc2V0WCwgMSk7XG4gICAgY29uc3QgZHJhd25IZWlnaHQgPSBNYXRoLm1heChNYXRoLmNlaWwoYm91bmRzWzNdKSAtIG9mZnNldFksIDEpO1xuICAgIHRoaXMuY3VycmVudC5zdGFydE5ld1BhdGhBbmRDbGlwQm94KFswLCAwLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodF0pO1xuICAgIGxldCBjYWNoZUlkID0gXCJncm91cEF0XCIgKyB0aGlzLmdyb3VwTGV2ZWw7XG4gICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICBjYWNoZUlkICs9IFwiX3NtYXNrX1wiICsgdGhpcy5zbWFza0NvdW50ZXIrKyAlIDI7XG4gICAgfVxuICAgIGNvbnN0IHNjcmF0Y2hDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhjYWNoZUlkLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodCk7XG4gICAgY29uc3QgZ3JvdXBDdHggPSBzY3JhdGNoQ2FudmFzLmNvbnRleHQ7XG4gICAgZ3JvdXBDdHgudHJhbnNsYXRlKC1vZmZzZXRYLCAtb2Zmc2V0WSk7XG4gICAgZ3JvdXBDdHgudHJhbnNmb3JtKC4uLmN1cnJlbnRUcmFuc2Zvcm0pO1xuICAgIGlmIChncm91cC5zbWFzaykge1xuICAgICAgdGhpcy5zbWFza1N0YWNrLnB1c2goe1xuICAgICAgICBjYW52YXM6IHNjcmF0Y2hDYW52YXMuY2FudmFzLFxuICAgICAgICBjb250ZXh0OiBncm91cEN0eCxcbiAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WSxcbiAgICAgICAgc3VidHlwZTogZ3JvdXAuc21hc2suc3VidHlwZSxcbiAgICAgICAgYmFja2Ryb3A6IGdyb3VwLnNtYXNrLmJhY2tkcm9wLFxuICAgICAgICB0cmFuc2Zlck1hcDogZ3JvdXAuc21hc2sudHJhbnNmZXJNYXAgfHwgbnVsbCxcbiAgICAgICAgc3RhcnRUcmFuc2Zvcm1JbnZlcnNlOiBudWxsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudEN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICBjdXJyZW50Q3R4LnRyYW5zbGF0ZShvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgIGN1cnJlbnRDdHguc2F2ZSgpO1xuICAgIH1cbiAgICBjb3B5Q3R4U3RhdGUoY3VycmVudEN0eCwgZ3JvdXBDdHgpO1xuICAgIHRoaXMuY3R4ID0gZ3JvdXBDdHg7XG4gICAgdGhpcy5zZXRHU3RhdGUoW1tcIkJNXCIsIFwic291cmNlLW92ZXJcIl0sIFtcImNhXCIsIDFdLCBbXCJDQVwiLCAxXV0pO1xuICAgIHRoaXMuZ3JvdXBTdGFjay5wdXNoKGN1cnJlbnRDdHgpO1xuICAgIHRoaXMuZ3JvdXBMZXZlbCsrO1xuICB9XG4gIGVuZEdyb3VwKGdyb3VwKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZ3JvdXBMZXZlbC0tO1xuICAgIGNvbnN0IGdyb3VwQ3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5ncm91cFN0YWNrLnBvcCgpO1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgIGlmIChncm91cC5zbWFzaykge1xuICAgICAgdGhpcy50ZW1wU01hc2sgPSB0aGlzLnNtYXNrU3RhY2sucG9wKCk7XG4gICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgY29uc3QgY3VycmVudE10eCA9IGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpO1xuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oLi4uY3VycmVudE10eCk7XG4gICAgICBjb25zdCBkaXJ0eUJveCA9IFV0aWwuZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3goWzAsIDAsIGdyb3VwQ3R4LmNhbnZhcy53aWR0aCwgZ3JvdXBDdHguY2FudmFzLmhlaWdodF0sIGN1cnJlbnRNdHgpO1xuICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKGdyb3VwQ3R4LmNhbnZhcywgMCwgMCk7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLmNvbXBvc2UoZGlydHlCb3gpO1xuICAgIH1cbiAgfVxuICBiZWdpbkFubm90YXRpb24oaWQsIHJlY3QsIHRyYW5zZm9ybSwgbWF0cml4LCBoYXNPd25DYW52YXMpIHtcbiAgICB0aGlzLiNyZXN0b3JlSW5pdGlhbFN0YXRlKCk7XG4gICAgcmVzZXRDdHhUb0RlZmF1bHQodGhpcy5jdHgpO1xuICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICB0aGlzLnNhdmUoKTtcbiAgICBpZiAodGhpcy5iYXNlVHJhbnNmb3JtKSB7XG4gICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oLi4udGhpcy5iYXNlVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgaWYgKHJlY3QpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gcmVjdFsyXSAtIHJlY3RbMF07XG4gICAgICBjb25zdCBoZWlnaHQgPSByZWN0WzNdIC0gcmVjdFsxXTtcbiAgICAgIGlmIChoYXNPd25DYW52YXMgJiYgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwKSB7XG4gICAgICAgIHRyYW5zZm9ybSA9IHRyYW5zZm9ybS5zbGljZSgpO1xuICAgICAgICB0cmFuc2Zvcm1bNF0gLT0gcmVjdFswXTtcbiAgICAgICAgdHJhbnNmb3JtWzVdIC09IHJlY3RbMV07XG4gICAgICAgIHJlY3QgPSByZWN0LnNsaWNlKCk7XG4gICAgICAgIHJlY3RbMF0gPSByZWN0WzFdID0gMDtcbiAgICAgICAgcmVjdFsyXSA9IHdpZHRoO1xuICAgICAgICByZWN0WzNdID0gaGVpZ2h0O1xuICAgICAgICBjb25zdCBbc2NhbGVYLCBzY2FsZVldID0gVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KSk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB2aWV3cG9ydFNjYWxlXG4gICAgICAgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBjYW52YXNXaWR0aCA9IE1hdGguY2VpbCh3aWR0aCAqIHRoaXMub3V0cHV0U2NhbGVYICogdmlld3BvcnRTY2FsZSk7XG4gICAgICAgIGNvbnN0IGNhbnZhc0hlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgKiB0aGlzLm91dHB1dFNjYWxlWSAqIHZpZXdwb3J0U2NhbGUpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25DYW52YXMgPSB0aGlzLmNhbnZhc0ZhY3RvcnkuY3JlYXRlKGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY2FudmFzLFxuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgfSA9IHRoaXMuYW5ub3RhdGlvbkNhbnZhcztcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwLnNldChpZCwgY2FudmFzKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzLnNhdmVkQ3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIHRoaXMuY3R4ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oc2NhbGVYLCAwLCAwLCAtc2NhbGVZLCAwLCBoZWlnaHQgKiBzY2FsZVkpO1xuICAgICAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgICAgIHRoaXMuZW5kUGF0aCgpO1xuICAgICAgICB0aGlzLmN0eC5yZWN0KHJlY3RbMF0sIHJlY3RbMV0sIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmN0eC5jbGlwKCk7XG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQgPSBuZXcgQ2FudmFzRXh0cmFTdGF0ZSh0aGlzLmN0eC5jYW52YXMud2lkdGgsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgIHRoaXMudHJhbnNmb3JtKC4uLnRyYW5zZm9ybSk7XG4gICAgdGhpcy50cmFuc2Zvcm0oLi4ubWF0cml4KTtcbiAgfVxuICBlbmRBbm5vdGF0aW9uKCkge1xuICAgIGlmICh0aGlzLmFubm90YXRpb25DYW52YXMpIHtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuI2RyYXdGaWx0ZXIoKTtcbiAgICAgIHRoaXMuY3R4ID0gdGhpcy5hbm5vdGF0aW9uQ2FudmFzLnNhdmVkQ3R4O1xuICAgICAgZGVsZXRlIHRoaXMuYW5ub3RhdGlvbkNhbnZhcy5zYXZlZEN0eDtcbiAgICAgIGRlbGV0ZSB0aGlzLmFubm90YXRpb25DYW52YXM7XG4gICAgfVxuICB9XG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdChpbWcpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY291bnQgPSBpbWcuY291bnQ7XG4gICAgaW1nID0gdGhpcy5nZXRPYmplY3QoaW1nLmRhdGEsIGltZyk7XG4gICAgaW1nLmNvdW50ID0gY291bnQ7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZ2x5cGggPSB0aGlzLnByb2Nlc3NpbmdUeXBlMztcbiAgICBpZiAoZ2x5cGgpIHtcbiAgICAgIGlmIChnbHlwaC5jb21waWxlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGdseXBoLmNvbXBpbGVkID0gY29tcGlsZVR5cGUzR2x5cGgoaW1nKTtcbiAgICAgIH1cbiAgICAgIGlmIChnbHlwaC5jb21waWxlZCkge1xuICAgICAgICBnbHlwaC5jb21waWxlZChjdHgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1hc2sgPSB0aGlzLl9jcmVhdGVNYXNrQ2FudmFzKGltZyk7XG4gICAgY29uc3QgbWFza0NhbnZhcyA9IG1hc2suY2FudmFzO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICBjdHguZHJhd0ltYWdlKG1hc2tDYW52YXMsIG1hc2sub2Zmc2V0WCwgbWFzay5vZmZzZXRZKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdFJlcGVhdChpbWcsIHNjYWxlWCwgc2tld1ggPSAwLCBza2V3WSA9IDAsIHNjYWxlWSwgcG9zaXRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGltZyA9IHRoaXMuZ2V0T2JqZWN0KGltZy5kYXRhLCBpbWcpO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KTtcbiAgICBjdHgudHJhbnNmb3JtKHNjYWxlWCwgc2tld1gsIHNrZXdZLCBzY2FsZVksIDAsIDApO1xuICAgIGNvbnN0IG1hc2sgPSB0aGlzLl9jcmVhdGVNYXNrQ2FudmFzKGltZyk7XG4gICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCBtYXNrLm9mZnNldFggLSBjdXJyZW50VHJhbnNmb3JtWzRdLCBtYXNrLm9mZnNldFkgLSBjdXJyZW50VHJhbnNmb3JtWzVdKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgY29uc3QgdHJhbnMgPSBVdGlsLnRyYW5zZm9ybShjdXJyZW50VHJhbnNmb3JtLCBbc2NhbGVYLCBza2V3WCwgc2tld1ksIHNjYWxlWSwgcG9zaXRpb25zW2ldLCBwb3NpdGlvbnNbaSArIDFdXSk7XG4gICAgICBjb25zdCBbeCwgeV0gPSBVdGlsLmFwcGx5VHJhbnNmb3JtKFswLCAwXSwgdHJhbnMpO1xuICAgICAgY3R4LmRyYXdJbWFnZShtYXNrLmNhbnZhcywgeCwgeSk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0R3JvdXAoaW1hZ2VzKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGZpbGxDb2xvciA9IHRoaXMuY3VycmVudC5maWxsQ29sb3I7XG4gICAgY29uc3QgaXNQYXR0ZXJuRmlsbCA9IHRoaXMuY3VycmVudC5wYXR0ZXJuRmlsbDtcbiAgICBmb3IgKGNvbnN0IGltYWdlIG9mIGltYWdlcykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB0cmFuc2Zvcm1cbiAgICAgIH0gPSBpbWFnZTtcbiAgICAgIGNvbnN0IG1hc2tDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1hc2tDYW52YXNcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCBtYXNrQ3R4ID0gbWFza0NhbnZhcy5jb250ZXh0O1xuICAgICAgbWFza0N0eC5zYXZlKCk7XG4gICAgICBjb25zdCBpbWcgPSB0aGlzLmdldE9iamVjdChkYXRhLCBpbWFnZSk7XG4gICAgICBwdXRCaW5hcnlJbWFnZU1hc2sobWFza0N0eCwgaW1nKTtcbiAgICAgIG1hc2tDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2UtaW5cIjtcbiAgICAgIG1hc2tDdHguZmlsbFN0eWxlID0gaXNQYXR0ZXJuRmlsbCA/IGZpbGxDb2xvci5nZXRQYXR0ZXJuKG1hc2tDdHgsIHRoaXMsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCksIFBhdGhUeXBlLkZJTEwpIDogZmlsbENvbG9yO1xuICAgICAgbWFza0N0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIG1hc2tDdHgucmVzdG9yZSgpO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0oLi4udHJhbnNmb3JtKTtcbiAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XG4gICAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBtYXNrQ2FudmFzLmNhbnZhcywgMCwgMCwgd2lkdGgsIGhlaWdodCwgMCwgLTEsIDEsIDEpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cbiAgcGFpbnRJbWFnZVhPYmplY3Qob2JqSWQpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW1nRGF0YSA9IHRoaXMuZ2V0T2JqZWN0KG9iaklkKTtcbiAgICBpZiAoIWltZ0RhdGEpIHtcbiAgICAgIHdhcm4oXCJEZXBlbmRlbnQgaW1hZ2UgaXNuJ3QgcmVhZHkgeWV0XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0KGltZ0RhdGEpO1xuICB9XG4gIHBhaW50SW1hZ2VYT2JqZWN0UmVwZWF0KG9iaklkLCBzY2FsZVgsIHNjYWxlWSwgcG9zaXRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGltZ0RhdGEgPSB0aGlzLmdldE9iamVjdChvYmpJZCk7XG4gICAgaWYgKCFpbWdEYXRhKSB7XG4gICAgICB3YXJuKFwiRGVwZW5kZW50IGltYWdlIGlzbid0IHJlYWR5IHlldFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgIGNvbnN0IG1hcCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBtYXAucHVzaCh7XG4gICAgICAgIHRyYW5zZm9ybTogW3NjYWxlWCwgMCwgMCwgc2NhbGVZLCBwb3NpdGlvbnNbaV0sIHBvc2l0aW9uc1tpICsgMV1dLFxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3OiB3aWR0aCxcbiAgICAgICAgaDogaGVpZ2h0XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5wYWludElubGluZUltYWdlWE9iamVjdEdyb3VwKGltZ0RhdGEsIG1hcCk7XG4gIH1cbiAgYXBwbHlUcmFuc2Zlck1hcHNUb0NhbnZhcyhjdHgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyAhPT0gXCJub25lXCIpIHtcbiAgICAgIGN0eC5maWx0ZXIgPSB0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzO1xuICAgICAgY3R4LmRyYXdJbWFnZShjdHguY2FudmFzLCAwLCAwKTtcbiAgICAgIGN0eC5maWx0ZXIgPSBcIm5vbmVcIjtcbiAgICB9XG4gICAgcmV0dXJuIGN0eC5jYW52YXM7XG4gIH1cbiAgYXBwbHlUcmFuc2Zlck1hcHNUb0JpdG1hcChpbWdEYXRhKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudC50cmFuc2Zlck1hcHMgPT09IFwibm9uZVwiKSB7XG4gICAgICByZXR1cm4gaW1nRGF0YS5iaXRtYXA7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGJpdG1hcCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGltZ0RhdGE7XG4gICAgY29uc3QgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpbmxpbmVJbWFnZVwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICB0bXBDdHguZmlsdGVyID0gdGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcztcbiAgICB0bXBDdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCk7XG4gICAgdG1wQ3R4LmZpbHRlciA9IFwibm9uZVwiO1xuICAgIHJldHVybiB0bXBDYW52YXMuY2FudmFzO1xuICB9XG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0KGltZ0RhdGEpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIHRoaXMuc2F2ZSgpO1xuICAgIGlmICghaXNOb2RlSlMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmlsdGVyXG4gICAgICB9ID0gY3R4O1xuICAgICAgaWYgKGZpbHRlciAhPT0gXCJub25lXCIgJiYgZmlsdGVyICE9PSBcIlwiKSB7XG4gICAgICAgIGN0eC5maWx0ZXIgPSBcIm5vbmVcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LnNjYWxlKDEgLyB3aWR0aCwgLTEgLyBoZWlnaHQpO1xuICAgIGxldCBpbWdUb1BhaW50O1xuICAgIGlmIChpbWdEYXRhLmJpdG1hcCkge1xuICAgICAgaW1nVG9QYWludCA9IHRoaXMuYXBwbHlUcmFuc2Zlck1hcHNUb0JpdG1hcChpbWdEYXRhKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gXCJmdW5jdGlvblwiICYmIGltZ0RhdGEgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCAhaW1nRGF0YS5kYXRhKSB7XG4gICAgICBpbWdUb1BhaW50ID0gaW1nRGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpbmxpbmVJbWFnZVwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgcHV0QmluYXJ5SW1hZ2VEYXRhKHRtcEN0eCwgaW1nRGF0YSk7XG4gICAgICBpbWdUb1BhaW50ID0gdGhpcy5hcHBseVRyYW5zZmVyTWFwc1RvQ2FudmFzKHRtcEN0eCk7XG4gICAgfVxuICAgIGNvbnN0IHNjYWxlZCA9IHRoaXMuX3NjYWxlSW1hZ2UoaW1nVG9QYWludCwgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSk7XG4gICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGdldEltYWdlU21vb3RoaW5nRW5hYmxlZChnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCksIGltZ0RhdGEuaW50ZXJwb2xhdGUpO1xuICAgIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhjdHgsIHNjYWxlZC5pbWcsIDAsIDAsIHNjYWxlZC5wYWludFdpZHRoLCBzY2FsZWQucGFpbnRIZWlnaHQsIDAsIC1oZWlnaHQsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICAgIHRoaXMucmVzdG9yZSgpO1xuICB9XG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXAoaW1nRGF0YSwgbWFwKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGxldCBpbWdUb1BhaW50O1xuICAgIGlmIChpbWdEYXRhLmJpdG1hcCkge1xuICAgICAgaW1nVG9QYWludCA9IGltZ0RhdGEuYml0bWFwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3ID0gaW1nRGF0YS53aWR0aDtcbiAgICAgIGNvbnN0IGggPSBpbWdEYXRhLmhlaWdodDtcbiAgICAgIGNvbnN0IHRtcENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiaW5saW5lSW1hZ2VcIiwgdywgaCk7XG4gICAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgIHB1dEJpbmFyeUltYWdlRGF0YSh0bXBDdHgsIGltZ0RhdGEpO1xuICAgICAgaW1nVG9QYWludCA9IHRoaXMuYXBwbHlUcmFuc2Zlck1hcHNUb0NhbnZhcyh0bXBDdHgpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIG1hcCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0oLi4uZW50cnkudHJhbnNmb3JtKTtcbiAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XG4gICAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBpbWdUb1BhaW50LCBlbnRyeS54LCBlbnRyeS55LCBlbnRyeS53LCBlbnRyeS5oLCAwLCAtMSwgMSwgMSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgfVxuICBwYWludFNvbGlkQ29sb3JJbWFnZU1hc2soKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG4gIG1hcmtQb2ludCh0YWcpIHt9XG4gIG1hcmtQb2ludFByb3BzKHRhZywgcHJvcGVydGllcykge31cbiAgYmVnaW5NYXJrZWRDb250ZW50KHRhZykge1xuICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnB1c2goe1xuICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGJlZ2luTWFya2VkQ29udGVudFByb3BzKHRhZywgcHJvcGVydGllcykge1xuICAgIGlmICh0YWcgPT09IFwiT0NcIikge1xuICAgICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucHVzaCh7XG4gICAgICAgIHZpc2libGU6IHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnLmlzVmlzaWJsZShwcm9wZXJ0aWVzKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnB1c2goe1xuICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5jb250ZW50VmlzaWJsZSA9IHRoaXMuaXNDb250ZW50VmlzaWJsZSgpO1xuICB9XG4gIGVuZE1hcmtlZENvbnRlbnQoKSB7XG4gICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucG9wKCk7XG4gICAgdGhpcy5jb250ZW50VmlzaWJsZSA9IHRoaXMuaXNDb250ZW50VmlzaWJsZSgpO1xuICB9XG4gIGJlZ2luQ29tcGF0KCkge31cbiAgZW5kQ29tcGF0KCkge31cbiAgY29uc3VtZVBhdGgoY2xpcEJveCkge1xuICAgIGNvbnN0IGlzRW1wdHkgPSB0aGlzLmN1cnJlbnQuaXNFbXB0eUNsaXAoKTtcbiAgICBpZiAodGhpcy5wZW5kaW5nQ2xpcCkge1xuICAgICAgdGhpcy5jdXJyZW50LnVwZGF0ZUNsaXBGcm9tUGF0aCgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucGVuZGluZ0NsaXApIHtcbiAgICAgIHRoaXMuY29tcG9zZShjbGlwQm94KTtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgaWYgKHRoaXMucGVuZGluZ0NsaXApIHtcbiAgICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2xpcCA9PT0gRU9fQ0xJUCkge1xuICAgICAgICAgIGN0eC5jbGlwKFwiZXZlbm9kZFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LnN0YXJ0TmV3UGF0aEFuZENsaXBCb3godGhpcy5jdXJyZW50LmNsaXBCb3gpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgfVxuICBnZXRTaW5nbGVQaXhlbFdpZHRoKCkge1xuICAgIGlmICghdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCkge1xuICAgICAgY29uc3QgbSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpO1xuICAgICAgaWYgKG1bMV0gPT09IDAgJiYgbVsyXSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gMSAvIE1hdGgubWluKE1hdGguYWJzKG1bMF0pLCBNYXRoLmFicyhtWzNdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhYnNEZXQgPSBNYXRoLmFicyhtWzBdICogbVszXSAtIG1bMl0gKiBtWzFdKTtcbiAgICAgICAgY29uc3Qgbm9ybVggPSBNYXRoLmh5cG90KG1bMF0sIG1bMl0pO1xuICAgICAgICBjb25zdCBub3JtWSA9IE1hdGguaHlwb3QobVsxXSwgbVszXSk7XG4gICAgICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBNYXRoLm1heChub3JtWCwgbm9ybVkpIC8gYWJzRGV0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aDtcbiAgfVxuICBnZXRTY2FsZUZvclN0cm9raW5nKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID09PSAtMSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsaW5lV2lkdGhcbiAgICAgIH0gPSB0aGlzLmN1cnJlbnQ7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGEsXG4gICAgICAgIGIsXG4gICAgICAgIGMsXG4gICAgICAgIGRcbiAgICAgIH0gPSB0aGlzLmN0eC5nZXRUcmFuc2Zvcm0oKTtcbiAgICAgIGxldCBzY2FsZVgsIHNjYWxlWTtcbiAgICAgIGlmIChiID09PSAwICYmIGMgPT09IDApIHtcbiAgICAgICAgY29uc3Qgbm9ybVggPSBNYXRoLmFicyhhKTtcbiAgICAgICAgY29uc3Qgbm9ybVkgPSBNYXRoLmFicyhkKTtcbiAgICAgICAgaWYgKG5vcm1YID09PSBub3JtWSkge1xuICAgICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIHNjYWxlWCA9IHNjYWxlWSA9IDEgLyBub3JtWDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVkTGluZVdpZHRoID0gbm9ybVggKiBsaW5lV2lkdGg7XG4gICAgICAgICAgICBzY2FsZVggPSBzY2FsZVkgPSBzY2FsZWRMaW5lV2lkdGggPCAxID8gMSAvIHNjYWxlZExpbmVXaWR0aCA6IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgIHNjYWxlWCA9IDEgLyBub3JtWDtcbiAgICAgICAgICBzY2FsZVkgPSAxIC8gbm9ybVk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgc2NhbGVkWExpbmVXaWR0aCA9IG5vcm1YICogbGluZVdpZHRoO1xuICAgICAgICAgIGNvbnN0IHNjYWxlZFlMaW5lV2lkdGggPSBub3JtWSAqIGxpbmVXaWR0aDtcbiAgICAgICAgICBzY2FsZVggPSBzY2FsZWRYTGluZVdpZHRoIDwgMSA/IDEgLyBzY2FsZWRYTGluZVdpZHRoIDogMTtcbiAgICAgICAgICBzY2FsZVkgPSBzY2FsZWRZTGluZVdpZHRoIDwgMSA/IDEgLyBzY2FsZWRZTGluZVdpZHRoIDogMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYWJzRGV0ID0gTWF0aC5hYnMoYSAqIGQgLSBiICogYyk7XG4gICAgICAgIGNvbnN0IG5vcm1YID0gTWF0aC5oeXBvdChhLCBiKTtcbiAgICAgICAgY29uc3Qgbm9ybVkgPSBNYXRoLmh5cG90KGMsIGQpO1xuICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgc2NhbGVYID0gbm9ybVkgLyBhYnNEZXQ7XG4gICAgICAgICAgc2NhbGVZID0gbm9ybVggLyBhYnNEZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgYmFzZUFyZWEgPSBsaW5lV2lkdGggKiBhYnNEZXQ7XG4gICAgICAgICAgc2NhbGVYID0gbm9ybVkgPiBiYXNlQXJlYSA/IG5vcm1ZIC8gYmFzZUFyZWEgOiAxO1xuICAgICAgICAgIHNjYWxlWSA9IG5vcm1YID4gYmFzZUFyZWEgPyBub3JtWCAvIGJhc2VBcmVhIDogMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IHNjYWxlWDtcbiAgICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMV0gPSBzY2FsZVk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nO1xuICB9XG4gIHJlc2NhbGVBbmRTdHJva2Uoc2F2ZVJlc3RvcmUpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdHhcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBsaW5lV2lkdGhcbiAgICB9ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IFtzY2FsZVgsIHNjYWxlWV0gPSB0aGlzLmdldFNjYWxlRm9yU3Ryb2tpbmcoKTtcbiAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoIHx8IDE7XG4gICAgaWYgKHNjYWxlWCA9PT0gMSAmJiBzY2FsZVkgPT09IDEpIHtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGFzaGVzID0gY3R4LmdldExpbmVEYXNoKCk7XG4gICAgaWYgKHNhdmVSZXN0b3JlKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgIH1cbiAgICBjdHguc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgIGlmIChkYXNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLm1heChzY2FsZVgsIHNjYWxlWSk7XG4gICAgICBjdHguc2V0TGluZURhc2goZGFzaGVzLm1hcCh4ID0+IHggLyBzY2FsZSkpO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0IC89IHNjYWxlO1xuICAgIH1cbiAgICBjdHguc3Ryb2tlKCk7XG4gICAgaWYgKHNhdmVSZXN0b3JlKSB7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBpc0NvbnRlbnRWaXNpYmxlKCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKCF0aGlzLm1hcmtlZENvbnRlbnRTdGFja1tpXS52aXNpYmxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmZvciAoY29uc3Qgb3AgaW4gT1BTKSB7XG4gIGlmIChDYW52YXNHcmFwaGljcy5wcm90b3R5cGVbb3BdICE9PSB1bmRlZmluZWQpIHtcbiAgICBDYW52YXNHcmFwaGljcy5wcm90b3R5cGVbT1BTW29wXV0gPSBDYW52YXNHcmFwaGljcy5wcm90b3R5cGVbb3BdO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3dvcmtlcl9vcHRpb25zLmpzXG5jbGFzcyBHbG9iYWxXb3JrZXJPcHRpb25zIHtcbiAgc3RhdGljICNwb3J0ID0gbnVsbDtcbiAgc3RhdGljICNzcmMgPSBcIlwiO1xuICBzdGF0aWMgZ2V0IHdvcmtlclBvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3BvcnQ7XG4gIH1cbiAgc3RhdGljIHNldCB3b3JrZXJQb3J0KHZhbCkge1xuICAgIGlmICghKHR5cGVvZiBXb3JrZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgdmFsIGluc3RhbmNlb2YgV29ya2VyKSAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYHdvcmtlclBvcnRgIHR5cGUuXCIpO1xuICAgIH1cbiAgICB0aGlzLiNwb3J0ID0gdmFsO1xuICB9XG4gIHN0YXRpYyBnZXQgd29ya2VyU3JjKCkge1xuICAgIHJldHVybiB0aGlzLiNzcmM7XG4gIH1cbiAgc3RhdGljIHNldCB3b3JrZXJTcmModmFsKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYHdvcmtlclNyY2AgdHlwZS5cIik7XG4gICAgfVxuICAgIHRoaXMuI3NyYyA9IHZhbDtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9tZXRhZGF0YS5qc1xuXG5jbGFzcyBNZXRhZGF0YSB7XG4gICNtZXRhZGF0YU1hcDtcbiAgI2RhdGE7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwYXJzZWREYXRhLFxuICAgIHJhd0RhdGFcbiAgfSkge1xuICAgIHRoaXMuI21ldGFkYXRhTWFwID0gcGFyc2VkRGF0YTtcbiAgICB0aGlzLiNkYXRhID0gcmF3RGF0YTtcbiAgfVxuICBnZXRSYXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RhdGE7XG4gIH1cbiAgZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy4jbWV0YWRhdGFNYXAuZ2V0KG5hbWUpID8/IG51bGw7XG4gIH1cbiAgZ2V0QWxsKCkge1xuICAgIHJldHVybiBvYmplY3RGcm9tTWFwKHRoaXMuI21ldGFkYXRhTWFwKTtcbiAgfVxuICBoYXMobmFtZSkge1xuICAgIHJldHVybiB0aGlzLiNtZXRhZGF0YU1hcC5oYXMobmFtZSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvb3B0aW9uYWxfY29udGVudF9jb25maWcuanNcblxuXG5jb25zdCBJTlRFUk5BTCA9IFN5bWJvbChcIklOVEVSTkFMXCIpO1xuY2xhc3MgT3B0aW9uYWxDb250ZW50R3JvdXAge1xuICAjaXNEaXNwbGF5ID0gZmFsc2U7XG4gICNpc1ByaW50ID0gZmFsc2U7XG4gICN1c2VyU2V0ID0gZmFsc2U7XG4gICN2aXNpYmxlID0gdHJ1ZTtcbiAgY29uc3RydWN0b3IocmVuZGVyaW5nSW50ZW50LCB7XG4gICAgbmFtZSxcbiAgICBpbnRlbnQsXG4gICAgdXNhZ2UsXG4gICAgcmJHcm91cHNcbiAgfSkge1xuICAgIHRoaXMuI2lzRGlzcGxheSA9ICEhKHJlbmRlcmluZ0ludGVudCAmIFJlbmRlcmluZ0ludGVudEZsYWcuRElTUExBWSk7XG4gICAgdGhpcy4jaXNQcmludCA9ICEhKHJlbmRlcmluZ0ludGVudCAmIFJlbmRlcmluZ0ludGVudEZsYWcuUFJJTlQpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5pbnRlbnQgPSBpbnRlbnQ7XG4gICAgdGhpcy51c2FnZSA9IHVzYWdlO1xuICAgIHRoaXMucmJHcm91cHMgPSByYkdyb3VwcztcbiAgfVxuICBnZXQgdmlzaWJsZSgpIHtcbiAgICBpZiAodGhpcy4jdXNlclNldCkge1xuICAgICAgcmV0dXJuIHRoaXMuI3Zpc2libGU7XG4gICAgfVxuICAgIGlmICghdGhpcy4jdmlzaWJsZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwcmludCxcbiAgICAgIHZpZXdcbiAgICB9ID0gdGhpcy51c2FnZTtcbiAgICBpZiAodGhpcy4jaXNEaXNwbGF5KSB7XG4gICAgICByZXR1cm4gdmlldz8udmlld1N0YXRlICE9PSBcIk9GRlwiO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jaXNQcmludCkge1xuICAgICAgcmV0dXJuIHByaW50Py5wcmludFN0YXRlICE9PSBcIk9GRlwiO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBfc2V0VmlzaWJsZShpbnRlcm5hbCwgdmlzaWJsZSwgdXNlclNldCA9IGZhbHNlKSB7XG4gICAgaWYgKGludGVybmFsICE9PSBJTlRFUk5BTCkge1xuICAgICAgdW5yZWFjaGFibGUoXCJJbnRlcm5hbCBtZXRob2QgYF9zZXRWaXNpYmxlYCBjYWxsZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLiN1c2VyU2V0ID0gdXNlclNldDtcbiAgICB0aGlzLiN2aXNpYmxlID0gdmlzaWJsZTtcbiAgfVxufVxuY2xhc3MgT3B0aW9uYWxDb250ZW50Q29uZmlnIHtcbiAgI2NhY2hlZEdldEhhc2ggPSBudWxsO1xuICAjZ3JvdXBzID0gbmV3IE1hcCgpO1xuICAjaW5pdGlhbEhhc2ggPSBudWxsO1xuICAjb3JkZXIgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihkYXRhLCByZW5kZXJpbmdJbnRlbnQgPSBSZW5kZXJpbmdJbnRlbnRGbGFnLkRJU1BMQVkpIHtcbiAgICB0aGlzLnJlbmRlcmluZ0ludGVudCA9IHJlbmRlcmluZ0ludGVudDtcbiAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgIHRoaXMuY3JlYXRvciA9IG51bGw7XG4gICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5uYW1lID0gZGF0YS5uYW1lO1xuICAgIHRoaXMuY3JlYXRvciA9IGRhdGEuY3JlYXRvcjtcbiAgICB0aGlzLiNvcmRlciA9IGRhdGEub3JkZXI7XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBkYXRhLmdyb3Vwcykge1xuICAgICAgdGhpcy4jZ3JvdXBzLnNldChncm91cC5pZCwgbmV3IE9wdGlvbmFsQ29udGVudEdyb3VwKHJlbmRlcmluZ0ludGVudCwgZ3JvdXApKTtcbiAgICB9XG4gICAgaWYgKGRhdGEuYmFzZVN0YXRlID09PSBcIk9GRlwiKSB7XG4gICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIHRoaXMuI2dyb3Vwcy52YWx1ZXMoKSkge1xuICAgICAgICBncm91cC5fc2V0VmlzaWJsZShJTlRFUk5BTCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IG9uIG9mIGRhdGEub24pIHtcbiAgICAgIHRoaXMuI2dyb3Vwcy5nZXQob24pLl9zZXRWaXNpYmxlKElOVEVSTkFMLCB0cnVlKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBvZmYgb2YgZGF0YS5vZmYpIHtcbiAgICAgIHRoaXMuI2dyb3Vwcy5nZXQob2ZmKS5fc2V0VmlzaWJsZShJTlRFUk5BTCwgZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLiNpbml0aWFsSGFzaCA9IHRoaXMuZ2V0SGFzaCgpO1xuICB9XG4gICNldmFsdWF0ZVZpc2liaWxpdHlFeHByZXNzaW9uKGFycmF5KSB7XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgb3BlcmF0b3IgPSBhcnJheVswXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaV07XG4gICAgICBsZXQgc3RhdGU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50KSkge1xuICAgICAgICBzdGF0ZSA9IHRoaXMuI2V2YWx1YXRlVmlzaWJpbGl0eUV4cHJlc3Npb24oZWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuI2dyb3Vwcy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgc3RhdGUgPSB0aGlzLiNncm91cHMuZ2V0KGVsZW1lbnQpLnZpc2libGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtlbGVtZW50fWApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSBcIkFuZFwiOlxuICAgICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJPclwiOlxuICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTm90XCI6XG4gICAgICAgICAgcmV0dXJuICFzdGF0ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wZXJhdG9yID09PSBcIkFuZFwiO1xuICB9XG4gIGlzVmlzaWJsZShncm91cCkge1xuICAgIGlmICh0aGlzLiNncm91cHMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghZ3JvdXApIHtcbiAgICAgIGluZm8oXCJPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAudHlwZSA9PT0gXCJPQ0dcIikge1xuICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGdyb3VwLmlkKSkge1xuICAgICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtncm91cC5pZH1gKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4jZ3JvdXBzLmdldChncm91cC5pZCkudmlzaWJsZTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwiT0NNRFwiKSB7XG4gICAgICBpZiAoZ3JvdXAuZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcy4jZXZhbHVhdGVWaXNpYmlsaXR5RXhwcmVzc2lvbihncm91cC5leHByZXNzaW9uKTtcbiAgICAgIH1cbiAgICAgIGlmICghZ3JvdXAucG9saWN5IHx8IGdyb3VwLnBvbGljeSA9PT0gXCJBbnlPblwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgd2FybihgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnBvbGljeSA9PT0gXCJBbGxPblwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgd2FybihgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuZ2V0KGlkKS52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChncm91cC5wb2xpY3kgPT09IFwiQW55T2ZmXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBncm91cC5pZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnBvbGljeSA9PT0gXCJBbGxPZmZcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGdyb3VwLmlkcykge1xuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHdhcm4oYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLiNncm91cHMuZ2V0KGlkKS52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgd2FybihgVW5rbm93biBvcHRpb25hbCBjb250ZW50IHBvbGljeSAke2dyb3VwLnBvbGljeX0uYCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgd2FybihgVW5rbm93biBncm91cCB0eXBlICR7Z3JvdXAudHlwZX0uYCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc2V0VmlzaWJpbGl0eShpZCwgdmlzaWJsZSA9IHRydWUsIHByZXNlcnZlUkIgPSB0cnVlKSB7XG4gICAgY29uc3QgZ3JvdXAgPSB0aGlzLiNncm91cHMuZ2V0KGlkKTtcbiAgICBpZiAoIWdyb3VwKSB7XG4gICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByZXNlcnZlUkIgJiYgdmlzaWJsZSAmJiBncm91cC5yYkdyb3Vwcy5sZW5ndGgpIHtcbiAgICAgIGZvciAoY29uc3QgcmJHcm91cCBvZiBncm91cC5yYkdyb3Vwcykge1xuICAgICAgICBmb3IgKGNvbnN0IG90aGVySWQgb2YgcmJHcm91cCkge1xuICAgICAgICAgIGlmIChvdGhlcklkICE9PSBpZCkge1xuICAgICAgICAgICAgdGhpcy4jZ3JvdXBzLmdldChvdGhlcklkKT8uX3NldFZpc2libGUoSU5URVJOQUwsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZ3JvdXAuX3NldFZpc2libGUoSU5URVJOQUwsICEhdmlzaWJsZSwgdHJ1ZSk7XG4gICAgdGhpcy4jY2FjaGVkR2V0SGFzaCA9IG51bGw7XG4gIH1cbiAgc2V0T0NHU3RhdGUoe1xuICAgIHN0YXRlLFxuICAgIHByZXNlcnZlUkJcbiAgfSkge1xuICAgIGxldCBvcGVyYXRvcjtcbiAgICBmb3IgKGNvbnN0IGVsZW0gb2Ygc3RhdGUpIHtcbiAgICAgIHN3aXRjaCAoZWxlbSkge1xuICAgICAgICBjYXNlIFwiT05cIjpcbiAgICAgICAgY2FzZSBcIk9GRlwiOlxuICAgICAgICBjYXNlIFwiVG9nZ2xlXCI6XG4gICAgICAgICAgb3BlcmF0b3IgPSBlbGVtO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZ3JvdXAgPSB0aGlzLiNncm91cHMuZ2V0KGVsZW0pO1xuICAgICAgaWYgKCFncm91cCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSBcIk9OXCI6XG4gICAgICAgICAgdGhpcy5zZXRWaXNpYmlsaXR5KGVsZW0sIHRydWUsIHByZXNlcnZlUkIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiT0ZGXCI6XG4gICAgICAgICAgdGhpcy5zZXRWaXNpYmlsaXR5KGVsZW0sIGZhbHNlLCBwcmVzZXJ2ZVJCKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlRvZ2dsZVwiOlxuICAgICAgICAgIHRoaXMuc2V0VmlzaWJpbGl0eShlbGVtLCAhZ3JvdXAudmlzaWJsZSwgcHJlc2VydmVSQik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2NhY2hlZEdldEhhc2ggPSBudWxsO1xuICB9XG4gIGdldCBoYXNJbml0aWFsVmlzaWJpbGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaW5pdGlhbEhhc2ggPT09IG51bGwgfHwgdGhpcy5nZXRIYXNoKCkgPT09IHRoaXMuI2luaXRpYWxIYXNoO1xuICB9XG4gIGdldE9yZGVyKCkge1xuICAgIGlmICghdGhpcy4jZ3JvdXBzLnNpemUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy4jb3JkZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLiNvcmRlci5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gWy4uLnRoaXMuI2dyb3Vwcy5rZXlzKCldO1xuICB9XG4gIGdldEdyb3VwcygpIHtcbiAgICByZXR1cm4gdGhpcy4jZ3JvdXBzLnNpemUgPiAwID8gb2JqZWN0RnJvbU1hcCh0aGlzLiNncm91cHMpIDogbnVsbDtcbiAgfVxuICBnZXRHcm91cChpZCkge1xuICAgIHJldHVybiB0aGlzLiNncm91cHMuZ2V0KGlkKSB8fCBudWxsO1xuICB9XG4gIGdldEhhc2goKSB7XG4gICAgaWYgKHRoaXMuI2NhY2hlZEdldEhhc2ggIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLiNjYWNoZWRHZXRIYXNoO1xuICAgIH1cbiAgICBjb25zdCBoYXNoID0gbmV3IE11cm11ckhhc2gzXzY0KCk7XG4gICAgZm9yIChjb25zdCBbaWQsIGdyb3VwXSBvZiB0aGlzLiNncm91cHMpIHtcbiAgICAgIGhhc2gudXBkYXRlKGAke2lkfToke2dyb3VwLnZpc2libGV9YCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNjYWNoZWRHZXRIYXNoID0gaGFzaC5oZXhkaWdlc3QoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS90cmFuc3BvcnRfc3RyZWFtLmpzXG5cblxuY2xhc3MgUERGRGF0YVRyYW5zcG9ydFN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHBkZkRhdGFSYW5nZVRyYW5zcG9ydCwge1xuICAgIGRpc2FibGVSYW5nZSA9IGZhbHNlLFxuICAgIGRpc2FibGVTdHJlYW0gPSBmYWxzZVxuICB9KSB7XG4gICAgYXNzZXJ0KHBkZkRhdGFSYW5nZVRyYW5zcG9ydCwgJ1BERkRhdGFUcmFuc3BvcnRTdHJlYW0gLSBtaXNzaW5nIHJlcXVpcmVkIFwicGRmRGF0YVJhbmdlVHJhbnNwb3J0XCIgYXJndW1lbnQuJyk7XG4gICAgY29uc3Qge1xuICAgICAgbGVuZ3RoLFxuICAgICAgaW5pdGlhbERhdGEsXG4gICAgICBwcm9ncmVzc2l2ZURvbmUsXG4gICAgICBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZVxuICAgIH0gPSBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQ7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmtzID0gW107XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lID0gcHJvZ3Jlc3NpdmVEb25lO1xuICAgIHRoaXMuX2NvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU7XG4gICAgaWYgKGluaXRpYWxEYXRhPy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBpbml0aWFsRGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgaW5pdGlhbERhdGEuYnl0ZUxlbmd0aCA9PT0gaW5pdGlhbERhdGEuYnVmZmVyLmJ5dGVMZW5ndGggPyBpbml0aWFsRGF0YS5idWZmZXIgOiBuZXcgVWludDhBcnJheShpbml0aWFsRGF0YSkuYnVmZmVyO1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmtzLnB1c2goYnVmZmVyKTtcbiAgICB9XG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0ID0gcGRmRGF0YVJhbmdlVHJhbnNwb3J0O1xuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIWRpc2FibGVTdHJlYW07XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9ICFkaXNhYmxlUmFuZ2U7XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IGxlbmd0aDtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZWFkZXJzID0gW107XG4gICAgcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFkZFJhbmdlTGlzdGVuZXIoKGJlZ2luLCBjaHVuaykgPT4ge1xuICAgICAgdGhpcy5fb25SZWNlaXZlRGF0YSh7XG4gICAgICAgIGJlZ2luLFxuICAgICAgICBjaHVua1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFkZFByb2dyZXNzTGlzdGVuZXIoKGxvYWRlZCwgdG90YWwpID0+IHtcbiAgICAgIHRoaXMuX29uUHJvZ3Jlc3Moe1xuICAgICAgICBsb2FkZWQsXG4gICAgICAgIHRvdGFsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXIoY2h1bmsgPT4ge1xuICAgICAgdGhpcy5fb25SZWNlaXZlRGF0YSh7XG4gICAgICAgIGNodW5rXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgdGhpcy5fb25Qcm9ncmVzc2l2ZURvbmUoKTtcbiAgICB9KTtcbiAgICBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQudHJhbnNwb3J0UmVhZHkoKTtcbiAgfVxuICBfb25SZWNlaXZlRGF0YSh7XG4gICAgYmVnaW4sXG4gICAgY2h1bmtcbiAgfSkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGNodW5rIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBjaHVuay5ieXRlTGVuZ3RoID09PSBjaHVuay5idWZmZXIuYnl0ZUxlbmd0aCA/IGNodW5rLmJ1ZmZlciA6IG5ldyBVaW50OEFycmF5KGNodW5rKS5idWZmZXI7XG4gICAgaWYgKGJlZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcikge1xuICAgICAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlci5fZW5xdWV1ZShidWZmZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcXVldWVkQ2h1bmtzLnB1c2goYnVmZmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZm91bmQgPSB0aGlzLl9yYW5nZVJlYWRlcnMuc29tZShmdW5jdGlvbiAocmFuZ2VSZWFkZXIpIHtcbiAgICAgICAgaWYgKHJhbmdlUmVhZGVyLl9iZWdpbiAhPT0gYmVnaW4pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmFuZ2VSZWFkZXIuX2VucXVldWUoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICAgIGFzc2VydChmb3VuZCwgXCJfb25SZWNlaXZlRGF0YSAtIG5vIGBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXJgIGluc3RhbmNlIGZvdW5kLlwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0IF9wcm9ncmVzc2l2ZURhdGFMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5fbG9hZGVkID8/IDA7XG4gIH1cbiAgX29uUHJvZ3Jlc3MoZXZ0KSB7XG4gICAgaWYgKGV2dC50b3RhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9yYW5nZVJlYWRlcnNbMF0/Lm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICAgIHRvdGFsOiBldnQudG90YWxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfb25Qcm9ncmVzc2l2ZURvbmUoKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LnByb2dyZXNzaXZlRG9uZSgpO1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlRG9uZSA9IHRydWU7XG4gIH1cbiAgX3JlbW92ZVJhbmdlUmVhZGVyKHJlYWRlcikge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9yYW5nZVJlYWRlcnMuaW5kZXhPZihyZWFkZXIpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRoaXMuX3JhbmdlUmVhZGVycy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgYXNzZXJ0KCF0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciwgXCJQREZEYXRhVHJhbnNwb3J0U3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgIGNvbnN0IHF1ZXVlZENodW5rcyA9IHRoaXMuX3F1ZXVlZENodW5rcztcbiAgICB0aGlzLl9xdWV1ZWRDaHVua3MgPSBudWxsO1xuICAgIHJldHVybiBuZXcgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJlYWRlcih0aGlzLCBxdWV1ZWRDaHVua3MsIHRoaXMuX3Byb2dyZXNzaXZlRG9uZSwgdGhpcy5fY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUpO1xuICB9XG4gIGdldFJhbmdlUmVhZGVyKGJlZ2luLCBlbmQpIHtcbiAgICBpZiAoZW5kIDw9IHRoaXMuX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXIodGhpcywgYmVnaW4sIGVuZCk7XG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LnJlcXVlc3REYXRhUmFuZ2UoYmVnaW4sIGVuZCk7XG4gICAgdGhpcy5fcmFuZ2VSZWFkZXJzLnB1c2gocmVhZGVyKTtcbiAgICByZXR1cm4gcmVhZGVyO1xuICB9XG4gIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiB0aGlzLl9yYW5nZVJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFib3J0KCk7XG4gIH1cbn1cbmNsYXNzIFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIHF1ZXVlZENodW5rcywgcHJvZ3Jlc3NpdmVEb25lID0gZmFsc2UsIGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gbnVsbCkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9kb25lID0gcHJvZ3Jlc3NpdmVEb25lIHx8IGZhbHNlO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gaXNQZGZGaWxlKGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lKSA/IGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lIDogbnVsbDtcbiAgICB0aGlzLl9xdWV1ZWRDaHVua3MgPSBxdWV1ZWRDaHVua3MgfHwgW107XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICBmb3IgKGNvbnN0IGNodW5rIG9mIHRoaXMuX3F1ZXVlZENodW5rcykge1xuICAgICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgdGhpcy5faGVhZGVyc1JlYWR5ID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgc3RyZWFtLl9mdWxsUmVxdWVzdFJlYWRlciA9IHRoaXM7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBfZW5xdWV1ZShjaHVuaykge1xuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rcy5wdXNoKGNodW5rKTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gIH1cbiAgZ2V0IGhlYWRlcnNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhZGVyc1JlYWR5O1xuICB9XG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmVhbS5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmVhbS5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGNvbnRlbnRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmVhbS5fY29udGVudExlbmd0aDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGlmICh0aGlzLl9xdWV1ZWRDaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9xdWV1ZWRDaHVua3Muc2hpZnQoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuICAgIHJldHVybiByZXF1ZXN0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gIH1cbiAgcHJvZ3Jlc3NpdmVEb25lKCkge1xuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICB9XG59XG5jbGFzcyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIGJlZ2luLCBlbmQpIHtcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fYmVnaW4gPSBiZWdpbjtcbiAgICB0aGlzLl9lbmQgPSBlbmQ7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgX2VucXVldWUoY2h1bmspIHtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IGNodW5rO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZXF1ZXN0c0NhcGFiaWxpdHkgPSB0aGlzLl9yZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgcmVxdWVzdHNDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgdGhpcy5fc3RyZWFtLl9yZW1vdmVSYW5nZVJlYWRlcih0aGlzKTtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgaWYgKHRoaXMuX3F1ZXVlZENodW5rKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuX3F1ZXVlZENodW5rO1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0Q2FwYWJpbGl0eSk7XG4gICAgcmV0dXJuIHJlcXVlc3RDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9zdHJlYW0uX3JlbW92ZVJhbmdlUmVhZGVyKHRoaXMpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2NvbnRlbnRfZGlzcG9zaXRpb24uanNcblxuZnVuY3Rpb24gZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyKGNvbnRlbnREaXNwb3NpdGlvbikge1xuICBsZXQgbmVlZHNFbmNvZGluZ0ZpeHVwID0gdHJ1ZTtcbiAgbGV0IHRtcCA9IHRvUGFyYW1SZWdFeHAoXCJmaWxlbmFtZVxcXFwqXCIsIFwiaVwiKS5leGVjKGNvbnRlbnREaXNwb3NpdGlvbik7XG4gIGlmICh0bXApIHtcbiAgICB0bXAgPSB0bXBbMV07XG4gICAgbGV0IGZpbGVuYW1lID0gcmZjMjYxNnVucXVvdGUodG1wKTtcbiAgICBmaWxlbmFtZSA9IHVuZXNjYXBlKGZpbGVuYW1lKTtcbiAgICBmaWxlbmFtZSA9IHJmYzU5ODdkZWNvZGUoZmlsZW5hbWUpO1xuICAgIGZpbGVuYW1lID0gcmZjMjA0N2RlY29kZShmaWxlbmFtZSk7XG4gICAgcmV0dXJuIGZpeHVwRW5jb2RpbmcoZmlsZW5hbWUpO1xuICB9XG4gIHRtcCA9IHJmYzIyMzFnZXRwYXJhbShjb250ZW50RGlzcG9zaXRpb24pO1xuICBpZiAodG1wKSB7XG4gICAgY29uc3QgZmlsZW5hbWUgPSByZmMyMDQ3ZGVjb2RlKHRtcCk7XG4gICAgcmV0dXJuIGZpeHVwRW5jb2RpbmcoZmlsZW5hbWUpO1xuICB9XG4gIHRtcCA9IHRvUGFyYW1SZWdFeHAoXCJmaWxlbmFtZVwiLCBcImlcIikuZXhlYyhjb250ZW50RGlzcG9zaXRpb24pO1xuICBpZiAodG1wKSB7XG4gICAgdG1wID0gdG1wWzFdO1xuICAgIGxldCBmaWxlbmFtZSA9IHJmYzI2MTZ1bnF1b3RlKHRtcCk7XG4gICAgZmlsZW5hbWUgPSByZmMyMDQ3ZGVjb2RlKGZpbGVuYW1lKTtcbiAgICByZXR1cm4gZml4dXBFbmNvZGluZyhmaWxlbmFtZSk7XG4gIH1cbiAgZnVuY3Rpb24gdG9QYXJhbVJlZ0V4cChhdHRyaWJ1dGVQYXR0ZXJuLCBmbGFncykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiKD86Xnw7KVxcXFxzKlwiICsgYXR0cmlidXRlUGF0dGVybiArIFwiXFxcXHMqPVxcXFxzKlwiICsgXCIoXCIgKyAnW15cIjtcXFxcc11bXjtcXFxcc10qJyArIFwifFwiICsgJ1wiKD86W15cIlxcXFxcXFxcXXxcXFxcXFxcXFwiPykrXCI/JyArIFwiKVwiLCBmbGFncyk7XG4gIH1cbiAgZnVuY3Rpb24gdGV4dGRlY29kZShlbmNvZGluZywgdmFsdWUpIHtcbiAgICBpZiAoZW5jb2RpbmcpIHtcbiAgICAgIGlmICghL15bXFx4MDAtXFx4RkZdKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoZW5jb2RpbmcsIHtcbiAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gc3RyaW5nVG9CeXRlcyh2YWx1ZSk7XG4gICAgICAgIHZhbHVlID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyKTtcbiAgICAgICAgbmVlZHNFbmNvZGluZ0ZpeHVwID0gZmFsc2U7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBmaXh1cEVuY29kaW5nKHZhbHVlKSB7XG4gICAgaWYgKG5lZWRzRW5jb2RpbmdGaXh1cCAmJiAvW1xceDgwLVxceGZmXS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdGV4dGRlY29kZShcInV0Zi04XCIsIHZhbHVlKTtcbiAgICAgIGlmIChuZWVkc0VuY29kaW5nRml4dXApIHtcbiAgICAgICAgdmFsdWUgPSB0ZXh0ZGVjb2RlKFwiaXNvLTg4NTktMVwiLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiByZmMyMjMxZ2V0cGFyYW0oY29udGVudERpc3Bvc2l0aW9uU3RyKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgIGxldCBtYXRjaDtcbiAgICBjb25zdCBpdGVyID0gdG9QYXJhbVJlZ0V4cChcImZpbGVuYW1lXFxcXCooKD8hMFxcXFxkKVxcXFxkKykoXFxcXCo/KVwiLCBcImlnXCIpO1xuICAgIHdoaWxlICgobWF0Y2ggPSBpdGVyLmV4ZWMoY29udGVudERpc3Bvc2l0aW9uU3RyKSkgIT09IG51bGwpIHtcbiAgICAgIGxldCBbLCBuLCBxdW90LCBwYXJ0XSA9IG1hdGNoO1xuICAgICAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgICAgIGlmIChuIGluIG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG1hdGNoZXNbbl0gPSBbcXVvdCwgcGFydF07XG4gICAgfVxuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBtYXRjaGVzLmxlbmd0aDsgKytuKSB7XG4gICAgICBpZiAoIShuIGluIG1hdGNoZXMpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGV0IFtxdW90LCBwYXJ0XSA9IG1hdGNoZXNbbl07XG4gICAgICBwYXJ0ID0gcmZjMjYxNnVucXVvdGUocGFydCk7XG4gICAgICBpZiAocXVvdCkge1xuICAgICAgICBwYXJ0ID0gdW5lc2NhcGUocGFydCk7XG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgcGFydCA9IHJmYzU5ODdkZWNvZGUocGFydCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzI2MTZ1bnF1b3RlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJ1wiJykpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gdmFsdWUuc2xpY2UoMSkuc3BsaXQoJ1xcXFxcIicpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBxdW90aW5kZXggPSBwYXJ0c1tpXS5pbmRleE9mKCdcIicpO1xuICAgICAgICBpZiAocXVvdGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHBhcnRzW2ldID0gcGFydHNbaV0uc2xpY2UoMCwgcXVvdGluZGV4KTtcbiAgICAgICAgICBwYXJ0cy5sZW5ndGggPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0c1tpXSA9IHBhcnRzW2ldLnJlcGxhY2VBbGwoL1xcXFwoLikvZywgXCIkMVwiKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gcGFydHMuam9pbignXCInKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzU5ODdkZWNvZGUoZXh0dmFsdWUpIHtcbiAgICBjb25zdCBlbmNvZGluZ2VuZCA9IGV4dHZhbHVlLmluZGV4T2YoXCInXCIpO1xuICAgIGlmIChlbmNvZGluZ2VuZCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBleHR2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgZW5jb2RpbmcgPSBleHR2YWx1ZS5zbGljZSgwLCBlbmNvZGluZ2VuZCk7XG4gICAgY29uc3QgbGFuZ3ZhbHVlID0gZXh0dmFsdWUuc2xpY2UoZW5jb2RpbmdlbmQgKyAxKTtcbiAgICBjb25zdCB2YWx1ZSA9IGxhbmd2YWx1ZS5yZXBsYWNlKC9eW14nXSonLywgXCJcIik7XG4gICAgcmV0dXJuIHRleHRkZWNvZGUoZW5jb2RpbmcsIHZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiByZmMyMDQ3ZGVjb2RlKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZS5zdGFydHNXaXRoKFwiPT9cIikgfHwgL1tcXHgwMC1cXHgxOVxceDgwLVxceGZmXS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2VBbGwoLz1cXD8oW1xcdy1dKilcXD8oW1FxQmJdKVxcPygoPzpbXj9dfFxcPyg/IT0pKSopXFw/PS9nLCBmdW5jdGlvbiAobWF0Y2hlcywgY2hhcnNldCwgZW5jb2RpbmcsIHRleHQpIHtcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gXCJxXCIgfHwgZW5jb2RpbmcgPT09IFwiUVwiKSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2VBbGwoXCJfXCIsIFwiIFwiKTtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZUFsbCgvPShbMC05YS1mQS1GXXsyfSkvZywgZnVuY3Rpb24gKG1hdGNoLCBoZXgpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChoZXgsIDE2KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGV4dGRlY29kZShjaGFyc2V0LCB0ZXh0KTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHRleHQgPSBhdG9iKHRleHQpO1xuICAgICAgfSBjYXRjaCB7fVxuICAgICAgcmV0dXJuIHRleHRkZWNvZGUoY2hhcnNldCwgdGV4dCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L25ldHdvcmtfdXRpbHMuanNcblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUhlYWRlcnMoaXNIdHRwLCBodHRwSGVhZGVycykge1xuICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgaWYgKCFpc0h0dHAgfHwgIWh0dHBIZWFkZXJzIHx8IHR5cGVvZiBodHRwSGVhZGVycyAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBoZWFkZXJzO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGh0dHBIZWFkZXJzKSB7XG4gICAgY29uc3QgdmFsID0gaHR0cEhlYWRlcnNba2V5XTtcbiAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5mdW5jdGlvbiBnZXRSZXNwb25zZU9yaWdpbih1cmwpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFVSTCh1cmwpLm9yaWdpbjtcbiAgfSBjYXRjaCB7fVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKHtcbiAgcmVzcG9uc2VIZWFkZXJzLFxuICBpc0h0dHAsXG4gIHJhbmdlQ2h1bmtTaXplLFxuICBkaXNhYmxlUmFuZ2Vcbn0pIHtcbiAgY29uc3QgcmV0dXJuVmFsdWVzID0ge1xuICAgIGFsbG93UmFuZ2VSZXF1ZXN0czogZmFsc2UsXG4gICAgc3VnZ2VzdGVkTGVuZ3RoOiB1bmRlZmluZWRcbiAgfTtcbiAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQocmVzcG9uc2VIZWFkZXJzLmdldChcIkNvbnRlbnQtTGVuZ3RoXCIpLCAxMCk7XG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihsZW5ndGgpKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICByZXR1cm5WYWx1ZXMuc3VnZ2VzdGVkTGVuZ3RoID0gbGVuZ3RoO1xuICBpZiAobGVuZ3RoIDw9IDIgKiByYW5nZUNodW5rU2l6ZSkge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgaWYgKGRpc2FibGVSYW5nZSB8fCAhaXNIdHRwKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICBpZiAocmVzcG9uc2VIZWFkZXJzLmdldChcIkFjY2VwdC1SYW5nZXNcIikgIT09IFwiYnl0ZXNcIikge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgY29uc3QgY29udGVudEVuY29kaW5nID0gcmVzcG9uc2VIZWFkZXJzLmdldChcIkNvbnRlbnQtRW5jb2RpbmdcIikgfHwgXCJpZGVudGl0eVwiO1xuICBpZiAoY29udGVudEVuY29kaW5nICE9PSBcImlkZW50aXR5XCIpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIHJldHVyblZhbHVlcy5hbGxvd1JhbmdlUmVxdWVzdHMgPSB0cnVlO1xuICByZXR1cm4gcmV0dXJuVmFsdWVzO1xufVxuZnVuY3Rpb24gZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcihyZXNwb25zZUhlYWRlcnMpIHtcbiAgY29uc3QgY29udGVudERpc3Bvc2l0aW9uID0gcmVzcG9uc2VIZWFkZXJzLmdldChcIkNvbnRlbnQtRGlzcG9zaXRpb25cIik7XG4gIGlmIChjb250ZW50RGlzcG9zaXRpb24pIHtcbiAgICBsZXQgZmlsZW5hbWUgPSBnZXRGaWxlbmFtZUZyb21Db250ZW50RGlzcG9zaXRpb25IZWFkZXIoY29udGVudERpc3Bvc2l0aW9uKTtcbiAgICBpZiAoZmlsZW5hbWUuaW5jbHVkZXMoXCIlXCIpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmaWxlbmFtZSA9IGRlY29kZVVSSUNvbXBvbmVudChmaWxlbmFtZSk7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfVxuICAgIGlmIChpc1BkZkZpbGUoZmlsZW5hbWUpKSB7XG4gICAgICByZXR1cm4gZmlsZW5hbWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcihzdGF0dXMsIHVybCkge1xuICBpZiAoc3RhdHVzID09PSA0MDQgfHwgc3RhdHVzID09PSAwICYmIHVybC5zdGFydHNXaXRoKFwiZmlsZTpcIikpIHtcbiAgICByZXR1cm4gbmV3IE1pc3NpbmdQREZFeGNlcHRpb24oJ01pc3NpbmcgUERGIFwiJyArIHVybCArICdcIi4nKTtcbiAgfVxuICByZXR1cm4gbmV3IFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbihgVW5leHBlY3RlZCBzZXJ2ZXIgcmVzcG9uc2UgKCR7c3RhdHVzfSkgd2hpbGUgcmV0cmlldmluZyBQREYgXCIke3VybH1cIi5gLCBzdGF0dXMpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVSZXNwb25zZVN0YXR1cyhzdGF0dXMpIHtcbiAgcmV0dXJuIHN0YXR1cyA9PT0gMjAwIHx8IHN0YXR1cyA9PT0gMjA2O1xufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9mZXRjaF9zdHJlYW0uanNcblxuXG5mdW5jdGlvbiBjcmVhdGVGZXRjaE9wdGlvbnMoaGVhZGVycywgd2l0aENyZWRlbnRpYWxzLCBhYm9ydENvbnRyb2xsZXIpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgaGVhZGVycyxcbiAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgbW9kZTogXCJjb3JzXCIsXG4gICAgY3JlZGVudGlhbHM6IHdpdGhDcmVkZW50aWFscyA/IFwiaW5jbHVkZVwiIDogXCJzYW1lLW9yaWdpblwiLFxuICAgIHJlZGlyZWN0OiBcImZvbGxvd1wiXG4gIH07XG59XG5mdW5jdGlvbiBnZXRBcnJheUJ1ZmZlcih2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gdmFsLmJ1ZmZlcjtcbiAgfVxuICBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHdhcm4oYGdldEFycmF5QnVmZmVyIC0gdW5leHBlY3RlZCBkYXRhIGZvcm1hdDogJHt2YWx9YCk7XG4gIHJldHVybiBuZXcgVWludDhBcnJheSh2YWwpLmJ1ZmZlcjtcbn1cbmNsYXNzIFBERkZldGNoU3RyZWFtIHtcbiAgX3Jlc3BvbnNlT3JpZ2luID0gbnVsbDtcbiAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5pc0h0dHAgPSAvXmh0dHBzPzovaS50ZXN0KHNvdXJjZS51cmwpO1xuICAgIHRoaXMuaGVhZGVycyA9IGNyZWF0ZUhlYWRlcnModGhpcy5pc0h0dHAsIHNvdXJjZS5odHRwSGVhZGVycyk7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMgPSBbXTtcbiAgfVxuICBnZXQgX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Ll9sb2FkZWQgPz8gMDtcbiAgfVxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgIGFzc2VydCghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIFwiUERGRmV0Y2hTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBuZXcgUERGRmV0Y2hTdHJlYW1SZWFkZXIodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyO1xuICB9XG4gIGdldFJhbmdlUmVhZGVyKGJlZ2luLCBlbmQpIHtcbiAgICBpZiAoZW5kIDw9IHRoaXMuX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBQREZGZXRjaFN0cmVhbVJhbmdlUmVhZGVyKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgIHJldHVybiByZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFBERkZldGNoU3RyZWFtUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX3JlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgY29uc3Qgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSBzb3VyY2Uud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gc291cmNlLmRpc2FibGVSYW5nZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICBpZiAoIXRoaXMuX3JhbmdlQ2h1bmtTaXplICYmICF0aGlzLl9kaXNhYmxlUmFuZ2UpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlUmFuZ2U7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHN0cmVhbS5oZWFkZXJzKTtcbiAgICBjb25zdCB1cmwgPSBzb3VyY2UudXJsO1xuICAgIGZldGNoKHVybCwgY3JlYXRlRmV0Y2hPcHRpb25zKGhlYWRlcnMsIHRoaXMuX3dpdGhDcmVkZW50aWFscywgdGhpcy5fYWJvcnRDb250cm9sbGVyKSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICBzdHJlYW0uX3Jlc3BvbnNlT3JpZ2luID0gZ2V0UmVzcG9uc2VPcmlnaW4ocmVzcG9uc2UudXJsKTtcbiAgICAgIGlmICghdmFsaWRhdGVSZXNwb25zZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3IocmVzcG9uc2Uuc3RhdHVzLCB1cmwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlLmhlYWRlcnM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFsbG93UmFuZ2VSZXF1ZXN0cyxcbiAgICAgICAgc3VnZ2VzdGVkTGVuZ3RoXG4gICAgICB9ID0gdmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXMoe1xuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGlzSHR0cDogc3RyZWFtLmlzSHR0cCxcbiAgICAgICAgcmFuZ2VDaHVua1NpemU6IHRoaXMuX3JhbmdlQ2h1bmtTaXplLFxuICAgICAgICBkaXNhYmxlUmFuZ2U6IHRoaXMuX2Rpc2FibGVSYW5nZVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gYWxsb3dSYW5nZVJlcXVlc3RzO1xuICAgICAgdGhpcy5fY29udGVudExlbmd0aCA9IHN1Z2dlc3RlZExlbmd0aCB8fCB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICAgICAgdGhpcy5fZmlsZW5hbWUgPSBleHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKHJlc3BvbnNlSGVhZGVycyk7XG4gICAgICBpZiAoIXRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkICYmIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwobmV3IEFib3J0RXhjZXB0aW9uKFwiU3RyZWFtaW5nIGlzIGRpc2FibGVkLlwiKSk7XG4gICAgICB9XG4gICAgfSkuY2F0Y2godGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KTtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudExlbmd0aDtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIGRvbmVcbiAgICB9ID0gYXdhaXQgdGhpcy5fcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkLFxuICAgICAgdG90YWw6IHRoaXMuX2NvbnRlbnRMZW5ndGhcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGdldEFycmF5QnVmZmVyKHZhbHVlKSxcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fcmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgfVxufVxuY2xhc3MgUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSwgYmVnaW4sIGVuZCkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9yZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgY29uc3Qgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSBzb3VyY2Uud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gICAgdGhpcy5fYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhzdHJlYW0uaGVhZGVycyk7XG4gICAgaGVhZGVycy5hcHBlbmQoXCJSYW5nZVwiLCBgYnl0ZXM9JHtiZWdpbn0tJHtlbmQgLSAxfWApO1xuICAgIGNvbnN0IHVybCA9IHNvdXJjZS51cmw7XG4gICAgZmV0Y2godXJsLCBjcmVhdGVGZXRjaE9wdGlvbnMoaGVhZGVycywgdGhpcy5fd2l0aENyZWRlbnRpYWxzLCB0aGlzLl9hYm9ydENvbnRyb2xsZXIpKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlT3JpZ2luID0gZ2V0UmVzcG9uc2VPcmlnaW4ocmVzcG9uc2UudXJsKTtcbiAgICAgIGlmIChyZXNwb25zZU9yaWdpbiAhPT0gc3RyZWFtLl9yZXNwb25zZU9yaWdpbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHJhbmdlIHJlc3BvbnNlLW9yaWdpbiBcIiR7cmVzcG9uc2VPcmlnaW59XCIgdG8gbWF0Y2ggXCIke3N0cmVhbS5fcmVzcG9uc2VPcmlnaW59XCIuYCk7XG4gICAgICB9XG4gICAgICBpZiAoIXZhbGlkYXRlUmVzcG9uc2VTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICB0aHJvdyBjcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yKHJlc3BvbnNlLnN0YXR1cywgdXJsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIHRoaXMuX3JlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgfSkuY2F0Y2godGhpcy5fcmVhZENhcGFiaWxpdHkucmVqZWN0KTtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBhd2FpdCB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHZhbHVlLFxuICAgICAgZG9uZVxuICAgIH0gPSBhd2FpdCB0aGlzLl9yZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZG9uZVxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiB0aGlzLl9sb2FkZWRcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGdldEFycmF5QnVmZmVyKHZhbHVlKSxcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fcmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9uZXR3b3JrLmpzXG5cblxuY29uc3QgT0tfUkVTUE9OU0UgPSAyMDA7XG5jb25zdCBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0UgPSAyMDY7XG5mdW5jdGlvbiBuZXR3b3JrX2dldEFycmF5QnVmZmVyKHhocikge1xuICBjb25zdCBkYXRhID0geGhyLnJlc3BvbnNlO1xuICBpZiAodHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICByZXR1cm4gc3RyaW5nVG9CeXRlcyhkYXRhKS5idWZmZXI7XG59XG5jbGFzcyBOZXR3b3JrTWFuYWdlciB7XG4gIF9yZXNwb25zZU9yaWdpbiA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1cmwsXG4gICAgaHR0cEhlYWRlcnMsXG4gICAgd2l0aENyZWRlbnRpYWxzXG4gIH0pIHtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLmlzSHR0cCA9IC9eaHR0cHM/Oi9pLnRlc3QodXJsKTtcbiAgICB0aGlzLmhlYWRlcnMgPSBjcmVhdGVIZWFkZXJzKHRoaXMuaXNIdHRwLCBodHRwSGVhZGVycyk7XG4gICAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSB3aXRoQ3JlZGVudGlhbHMgfHwgZmFsc2U7XG4gICAgdGhpcy5jdXJyWGhySWQgPSAwO1xuICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICByZXF1ZXN0KGFyZ3MpIHtcbiAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBjb25zdCB4aHJJZCA9IHRoaXMuY3VyclhocklkKys7XG4gICAgY29uc3QgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF0gPSB7XG4gICAgICB4aHJcbiAgICB9O1xuICAgIHhoci5vcGVuKFwiR0VUXCIsIHRoaXMudXJsKTtcbiAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHM7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIHRoaXMuaGVhZGVycykge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0h0dHAgJiYgXCJiZWdpblwiIGluIGFyZ3MgJiYgXCJlbmRcIiBpbiBhcmdzKSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIlJhbmdlXCIsIGBieXRlcz0ke2FyZ3MuYmVnaW59LSR7YXJncy5lbmQgLSAxfWApO1xuICAgICAgcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMgPSBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzID0gT0tfUkVTUE9OU0U7XG4gICAgfVxuICAgIHhoci5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgYXNzZXJ0KGFyZ3Mub25FcnJvciwgXCJFeHBlY3RlZCBgb25FcnJvcmAgY2FsbGJhY2sgdG8gYmUgcHJvdmlkZWQuXCIpO1xuICAgIHhoci5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgYXJncy5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgIH07XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHRoaXMub25TdGF0ZUNoYW5nZS5iaW5kKHRoaXMsIHhocklkKTtcbiAgICB4aHIub25wcm9ncmVzcyA9IHRoaXMub25Qcm9ncmVzcy5iaW5kKHRoaXMsIHhocklkKTtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZCA9IGFyZ3Mub25IZWFkZXJzUmVjZWl2ZWQ7XG4gICAgcGVuZGluZ1JlcXVlc3Qub25Eb25lID0gYXJncy5vbkRvbmU7XG4gICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvciA9IGFyZ3Mub25FcnJvcjtcbiAgICBwZW5kaW5nUmVxdWVzdC5vblByb2dyZXNzID0gYXJncy5vblByb2dyZXNzO1xuICAgIHhoci5zZW5kKG51bGwpO1xuICAgIHJldHVybiB4aHJJZDtcbiAgfVxuICBvblByb2dyZXNzKHhocklkLCBldnQpIHtcbiAgICBjb25zdCBwZW5kaW5nUmVxdWVzdCA9IHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcbiAgICBpZiAoIXBlbmRpbmdSZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uUHJvZ3Jlc3M/LihldnQpO1xuICB9XG4gIG9uU3RhdGVDaGFuZ2UoeGhySWQsIGV2dCkge1xuICAgIGNvbnN0IHBlbmRpbmdSZXF1ZXN0ID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdO1xuICAgIGlmICghcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeGhyID0gcGVuZGluZ1JlcXVlc3QueGhyO1xuICAgIGlmICh4aHIucmVhZHlTdGF0ZSA+PSAyICYmIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkKSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZCgpO1xuICAgICAgZGVsZXRlIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkO1xuICAgIH1cbiAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEoeGhySWQgaW4gdGhpcy5wZW5kaW5nUmVxdWVzdHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgaWYgKHhoci5zdGF0dXMgPT09IDAgJiYgdGhpcy5pc0h0dHApIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHhoclN0YXR1cyA9IHhoci5zdGF0dXMgfHwgT0tfUkVTUE9OU0U7XG4gICAgY29uc3Qgb2tfcmVzcG9uc2Vfb25fcmFuZ2VfcmVxdWVzdCA9IHhoclN0YXR1cyA9PT0gT0tfUkVTUE9OU0UgJiYgcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMgPT09IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRTtcbiAgICBpZiAoIW9rX3Jlc3BvbnNlX29uX3JhbmdlX3JlcXVlc3QgJiYgeGhyU3RhdHVzICE9PSBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cykge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2h1bmsgPSBuZXR3b3JrX2dldEFycmF5QnVmZmVyKHhocik7XG4gICAgaWYgKHhoclN0YXR1cyA9PT0gUEFSVElBTF9DT05URU5UX1JFU1BPTlNFKSB7XG4gICAgICBjb25zdCByYW5nZUhlYWRlciA9IHhoci5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtUmFuZ2VcIik7XG4gICAgICBjb25zdCBtYXRjaGVzID0gL2J5dGVzIChcXGQrKS0oXFxkKylcXC8oXFxkKykvLmV4ZWMocmFuZ2VIZWFkZXIpO1xuICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgcGVuZGluZ1JlcXVlc3Qub25Eb25lKHtcbiAgICAgICAgICBiZWdpbjogcGFyc2VJbnQobWF0Y2hlc1sxXSwgMTApLFxuICAgICAgICAgIGNodW5rXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihgTWlzc2luZyBvciBpbnZhbGlkIFwiQ29udGVudC1SYW5nZVwiIGhlYWRlci5gKTtcbiAgICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcigwKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNodW5rKSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUoe1xuICAgICAgICBiZWdpbjogMCxcbiAgICAgICAgY2h1bmtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgIH1cbiAgfVxuICBnZXRSZXF1ZXN0WGhyKHhocklkKSB7XG4gICAgcmV0dXJuIHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXS54aHI7XG4gIH1cbiAgaXNQZW5kaW5nUmVxdWVzdCh4aHJJZCkge1xuICAgIHJldHVybiB4aHJJZCBpbiB0aGlzLnBlbmRpbmdSZXF1ZXN0cztcbiAgfVxuICBhYm9ydFJlcXVlc3QoeGhySWQpIHtcbiAgICBjb25zdCB4aHIgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF0ueGhyO1xuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgeGhyLmFib3J0KCk7XG4gIH1cbn1cbmNsYXNzIFBERk5ldHdvcmtTdHJlYW0ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5fbWFuYWdlciA9IG5ldyBOZXR3b3JrTWFuYWdlcihzb3VyY2UpO1xuICAgIHRoaXMuX3JhbmdlQ2h1bmtTaXplID0gc291cmNlLnJhbmdlQ2h1bmtTaXplO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzID0gW107XG4gIH1cbiAgX29uUmFuZ2VSZXF1ZXN0UmVhZGVyQ2xvc2VkKHJlYWRlcikge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLmluZGV4T2YocmVhZGVyKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbiAgZ2V0RnVsbFJlYWRlcigpIHtcbiAgICBhc3NlcnQoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERk5ldHdvcmtTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBuZXcgUERGTmV0d29ya1N0cmVhbUZ1bGxSZXF1ZXN0UmVhZGVyKHRoaXMuX21hbmFnZXIsIHRoaXMuX3NvdXJjZSk7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyO1xuICB9XG4gIGdldFJhbmdlUmVhZGVyKGJlZ2luLCBlbmQpIHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUERGTmV0d29ya1N0cmVhbVJhbmdlUmVxdWVzdFJlYWRlcih0aGlzLl9tYW5hZ2VyLCBiZWdpbiwgZW5kKTtcbiAgICByZWFkZXIub25DbG9zZWQgPSB0aGlzLl9vblJhbmdlUmVxdWVzdFJlYWRlckNsb3NlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgIHJldHVybiByZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFBERk5ldHdvcmtTdHJlYW1GdWxsUmVxdWVzdFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIsIHNvdXJjZSkge1xuICAgIHRoaXMuX21hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuX3VybCA9IHNvdXJjZS51cmw7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RJZCA9IG1hbmFnZXIucmVxdWVzdCh7XG4gICAgICBvbkhlYWRlcnNSZWNlaXZlZDogdGhpcy5fb25IZWFkZXJzUmVjZWl2ZWQuYmluZCh0aGlzKSxcbiAgICAgIG9uRG9uZTogdGhpcy5fb25Eb25lLmJpbmQodGhpcyksXG4gICAgICBvbkVycm9yOiB0aGlzLl9vbkVycm9yLmJpbmQodGhpcyksXG4gICAgICBvblByb2dyZXNzOiB0aGlzLl9vblByb2dyZXNzLmJpbmQodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHNvdXJjZS5kaXNhYmxlUmFuZ2UgfHwgZmFsc2U7XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jYWNoZWRDaHVua3MgPSBbXTtcbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBfb25IZWFkZXJzUmVjZWl2ZWQoKSB7XG4gICAgY29uc3QgZnVsbFJlcXVlc3RYaHJJZCA9IHRoaXMuX2Z1bGxSZXF1ZXN0SWQ7XG4gICAgY29uc3QgZnVsbFJlcXVlc3RYaHIgPSB0aGlzLl9tYW5hZ2VyLmdldFJlcXVlc3RYaHIoZnVsbFJlcXVlc3RYaHJJZCk7XG4gICAgdGhpcy5fbWFuYWdlci5fcmVzcG9uc2VPcmlnaW4gPSBnZXRSZXNwb25zZU9yaWdpbihmdWxsUmVxdWVzdFhoci5yZXNwb25zZVVSTCk7XG4gICAgY29uc3QgcmF3UmVzcG9uc2VIZWFkZXJzID0gZnVsbFJlcXVlc3RYaHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XG4gICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gbmV3IEhlYWRlcnMocmF3UmVzcG9uc2VIZWFkZXJzID8gcmF3UmVzcG9uc2VIZWFkZXJzLnRyaW1TdGFydCgpLnJlcGxhY2UoL1teXFxTIF0rJC8sIFwiXCIpLnNwbGl0KC9bXFxyXFxuXSsvKS5tYXAoeCA9PiB7XG4gICAgICBjb25zdCBba2V5LCAuLi52YWxdID0geC5zcGxpdChcIjogXCIpO1xuICAgICAgcmV0dXJuIFtrZXksIHZhbC5qb2luKFwiOiBcIildO1xuICAgIH0pIDogW10pO1xuICAgIGNvbnN0IHtcbiAgICAgIGFsbG93UmFuZ2VSZXF1ZXN0cyxcbiAgICAgIHN1Z2dlc3RlZExlbmd0aFxuICAgIH0gPSB2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyh7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICBpc0h0dHA6IHRoaXMuX21hbmFnZXIuaXNIdHRwLFxuICAgICAgcmFuZ2VDaHVua1NpemU6IHRoaXMuX3JhbmdlQ2h1bmtTaXplLFxuICAgICAgZGlzYWJsZVJhbmdlOiB0aGlzLl9kaXNhYmxlUmFuZ2VcbiAgICB9KTtcbiAgICBpZiAoYWxsb3dSYW5nZVJlcXVlc3RzKSB7XG4gICAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHN1Z2dlc3RlZExlbmd0aCB8fCB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcihyZXNwb25zZUhlYWRlcnMpO1xuICAgIGlmICh0aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLl9tYW5hZ2VyLmFib3J0UmVxdWVzdChmdWxsUmVxdWVzdFhocklkKTtcbiAgICB9XG4gICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIF9vbkRvbmUoZGF0YSkge1xuICAgIGlmIChkYXRhKSB7XG4gICAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgIHZhbHVlOiBkYXRhLmNodW5rLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkQ2h1bmtzLnB1c2goZGF0YS5jaHVuayk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGlmICh0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gIH1cbiAgX29uRXJyb3Ioc3RhdHVzKSB7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBjcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yKHN0YXR1cywgdGhpcy5fdXJsKTtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlamVjdCh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fY2FjaGVkQ2h1bmtzLmxlbmd0aCA9IDA7XG4gIH1cbiAgX29uUHJvZ3Jlc3MoZXZ0KSB7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgdG90YWw6IGV2dC5sZW5ndGhDb21wdXRhYmxlID8gZXZ0LnRvdGFsIDogdGhpcy5fY29udGVudExlbmd0aFxuICAgIH0pO1xuICB9XG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudExlbmd0aDtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY2FjaGVkQ2h1bmtzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY2FjaGVkQ2h1bmtzLnNoaWZ0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIGlmICh0aGlzLl9tYW5hZ2VyLmlzUGVuZGluZ1JlcXVlc3QodGhpcy5fZnVsbFJlcXVlc3RJZCkpIHtcbiAgICAgIHRoaXMuX21hbmFnZXIuYWJvcnRSZXF1ZXN0KHRoaXMuX2Z1bGxSZXF1ZXN0SWQpO1xuICAgIH1cbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gIH1cbn1cbmNsYXNzIFBERk5ldHdvcmtTdHJlYW1SYW5nZVJlcXVlc3RSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyLCBiZWdpbiwgZW5kKSB7XG4gICAgdGhpcy5fbWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5fdXJsID0gbWFuYWdlci51cmw7XG4gICAgdGhpcy5fcmVxdWVzdElkID0gbWFuYWdlci5yZXF1ZXN0KHtcbiAgICAgIGJlZ2luLFxuICAgICAgZW5kLFxuICAgICAgb25IZWFkZXJzUmVjZWl2ZWQ6IHRoaXMuX29uSGVhZGVyc1JlY2VpdmVkLmJpbmQodGhpcyksXG4gICAgICBvbkRvbmU6IHRoaXMuX29uRG9uZS5iaW5kKHRoaXMpLFxuICAgICAgb25FcnJvcjogdGhpcy5fb25FcnJvci5iaW5kKHRoaXMpLFxuICAgICAgb25Qcm9ncmVzczogdGhpcy5fb25Qcm9ncmVzcy5iaW5kKHRoaXMpXG4gICAgfSk7XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gICAgdGhpcy5vbkNsb3NlZCA9IG51bGw7XG4gIH1cbiAgX29uSGVhZGVyc1JlY2VpdmVkKCkge1xuICAgIGNvbnN0IHJlc3BvbnNlT3JpZ2luID0gZ2V0UmVzcG9uc2VPcmlnaW4odGhpcy5fbWFuYWdlci5nZXRSZXF1ZXN0WGhyKHRoaXMuX3JlcXVlc3RJZCk/LnJlc3BvbnNlVVJMKTtcbiAgICBpZiAocmVzcG9uc2VPcmlnaW4gIT09IHRoaXMuX21hbmFnZXIuX3Jlc3BvbnNlT3JpZ2luKSB7XG4gICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IG5ldyBFcnJvcihgRXhwZWN0ZWQgcmFuZ2UgcmVzcG9uc2Utb3JpZ2luIFwiJHtyZXNwb25zZU9yaWdpbn1cIiB0byBtYXRjaCBcIiR7dGhpcy5fbWFuYWdlci5fcmVzcG9uc2VPcmlnaW59XCIuYCk7XG4gICAgICB0aGlzLl9vbkVycm9yKDApO1xuICAgIH1cbiAgfVxuICBfY2xvc2UoKSB7XG4gICAgdGhpcy5vbkNsb3NlZD8uKHRoaXMpO1xuICB9XG4gIF9vbkRvbmUoZGF0YSkge1xuICAgIGNvbnN0IGNodW5rID0gZGF0YS5jaHVuaztcbiAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSB0aGlzLl9yZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IGNodW5rO1xuICAgIH1cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fY2xvc2UoKTtcbiAgfVxuICBfb25FcnJvcihzdGF0dXMpIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA/Pz0gY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcihzdGF0dXMsIHRoaXMuX3VybCk7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVqZWN0KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gIH1cbiAgX29uUHJvZ3Jlc3MoZXZ0KSB7XG4gICAgaWYgKCF0aGlzLmlzU3RyZWFtaW5nU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcXVldWVkQ2h1bmsgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bms7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIGlmICh0aGlzLl9tYW5hZ2VyLmlzUGVuZGluZ1JlcXVlc3QodGhpcy5fcmVxdWVzdElkKSkge1xuICAgICAgdGhpcy5fbWFuYWdlci5hYm9ydFJlcXVlc3QodGhpcy5fcmVxdWVzdElkKTtcbiAgICB9XG4gICAgdGhpcy5fY2xvc2UoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9ub2RlX3N0cmVhbS5qc1xuXG5jb25zdCB1cmxSZWdleCA9IC9eW2Etel1bYS16MC05XFwtKy5dKzovaTtcbmZ1bmN0aW9uIHBhcnNlVXJsT3JQYXRoKHNvdXJjZVVybCkge1xuICBpZiAodXJsUmVnZXgudGVzdChzb3VyY2VVcmwpKSB7XG4gICAgcmV0dXJuIG5ldyBVUkwoc291cmNlVXJsKTtcbiAgfVxuICBjb25zdCB1cmwgPSBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGUoXCJ1cmxcIik7XG4gIHJldHVybiBuZXcgVVJMKHVybC5wYXRoVG9GaWxlVVJMKHNvdXJjZVVybCkpO1xufVxuY2xhc3MgUERGTm9kZVN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMudXJsID0gcGFyc2VVcmxPclBhdGgoc291cmNlLnVybCk7XG4gICAgYXNzZXJ0KHRoaXMudXJsLnByb3RvY29sID09PSBcImZpbGU6XCIsIFwiUERGTm9kZVN0cmVhbSBvbmx5IHN1cHBvcnRzIGZpbGU6Ly8gVVJMcy5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMgPSBbXTtcbiAgfVxuICBnZXQgX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Ll9sb2FkZWQgPz8gMDtcbiAgfVxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgIGFzc2VydCghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIFwiUERGTm9kZVN0cmVhbS5nZXRGdWxsUmVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlwiKTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG5ldyBQREZOb2RlU3RyZWFtRnNGdWxsUmVhZGVyKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgfVxuICBnZXRSYW5nZVJlYWRlcihzdGFydCwgZW5kKSB7XG4gICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByYW5nZVJlYWRlciA9IG5ldyBQREZOb2RlU3RyZWFtRnNSYW5nZVJlYWRlcih0aGlzLCBzdGFydCwgZW5kKTtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnB1c2gocmFuZ2VSZWFkZXIpO1xuICAgIHJldHVybiByYW5nZVJlYWRlcjtcbiAgfVxuICBjYW5jZWxBbGxSZXF1ZXN0cyhyZWFzb24pIHtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5zbGljZSgwKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgUERGTm9kZVN0cmVhbUZzRnVsbFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHRoaXMuX3VybCA9IHN0cmVhbS51cmw7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gbnVsbDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gc291cmNlLmRpc2FibGVSYW5nZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICBpZiAoIXRoaXMuX3JhbmdlQ2h1bmtTaXplICYmICF0aGlzLl9kaXNhYmxlUmFuZ2UpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVSYW5nZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IG51bGw7XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIGNvbnN0IGZzID0gcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlKFwiZnNcIik7XG4gICAgZnMucHJvbWlzZXMubHN0YXQodGhpcy5fdXJsKS50aGVuKHN0YXQgPT4ge1xuICAgICAgdGhpcy5fY29udGVudExlbmd0aCA9IHN0YXQuc2l6ZTtcbiAgICAgIHRoaXMuX3NldFJlYWRhYmxlU3RyZWFtKGZzLmNyZWF0ZVJlYWRTdHJlYW0odGhpcy5fdXJsKSk7XG4gICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSwgZXJyb3IgPT4ge1xuICAgICAgaWYgKGVycm9yLmNvZGUgPT09IFwiRU5PRU5UXCIpIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgTWlzc2luZ1BERkV4Y2VwdGlvbihgTWlzc2luZyBQREYgXCIke3RoaXMuX3VybH1cIi5gKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gZXJyb3I7XG4gICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QoZXJyb3IpO1xuICAgIH0pO1xuICB9XG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudExlbmd0aDtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5fcmVhZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLl9zdG9yZWRFcnJvcjtcbiAgICB9XG4gICAgY29uc3QgY2h1bmsgPSB0aGlzLl9yZWFkYWJsZVN0cmVhbS5yZWFkKCk7XG4gICAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgcmV0dXJuIHRoaXMucmVhZCgpO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsubGVuZ3RoO1xuICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkLFxuICAgICAgdG90YWw6IHRoaXMuX2NvbnRlbnRMZW5ndGhcbiAgICB9KTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShjaHVuaykuYnVmZmVyO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogYnVmZmVyLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RyZWFtKSB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHJlYXNvbik7XG4gIH1cbiAgX2Vycm9yKHJlYXNvbikge1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gcmVhc29uO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuICBfc2V0UmVhZGFibGVTdHJlYW0ocmVhZGFibGVTdHJlYW0pIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IHJlYWRhYmxlU3RyZWFtO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwicmVhZGFibGVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgIHJlYWRhYmxlU3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZXJyb3JcIiwgcmVhc29uID0+IHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgfSk7XG4gICAgaWYgKCF0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCAmJiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLl9lcnJvcihuZXcgQWJvcnRFeGNlcHRpb24oXCJzdHJlYW1pbmcgaXMgZGlzYWJsZWRcIikpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgUERGTm9kZVN0cmVhbUZzUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLl91cmwgPSBzdHJlYW0udXJsO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gbnVsbDtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gICAgY29uc3QgZnMgPSBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGUoXCJmc1wiKTtcbiAgICB0aGlzLl9zZXRSZWFkYWJsZVN0cmVhbShmcy5jcmVhdGVSZWFkU3RyZWFtKHRoaXMuX3VybCwge1xuICAgICAgc3RhcnQsXG4gICAgICBlbmQ6IGVuZCAtIDFcbiAgICB9KSk7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX3JlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcmVhZGFibGVTdHJlYW0ucmVhZCgpO1xuICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgIHJldHVybiB0aGlzLnJlYWQoKTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZFxuICAgIH0pO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGNodW5rKS5idWZmZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBidWZmZXIsXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdHJlYW0pIHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kocmVhc29uKTtcbiAgfVxuICBfZXJyb3IocmVhc29uKSB7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSByZWFzb247XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIF9zZXRSZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gcmVhZGFibGVTdHJlYW07XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJyZWFkYWJsZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgcmVhZGFibGVTdHJlYW0uZGVzdHJveSgpO1xuICAgICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlcnJvclwiLCByZWFzb24gPT4ge1xuICAgICAgdGhpcy5fZXJyb3IocmVhc29uKTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS90ZXh0X2xheWVyLmpzXG5cblxuY29uc3QgTUFYX1RFWFRfRElWU19UT19SRU5ERVIgPSAxMDAwMDA7XG5jb25zdCBERUZBVUxUX0ZPTlRfU0laRSA9IDMwO1xuY29uc3QgREVGQVVMVF9GT05UX0FTQ0VOVCA9IDAuODtcbmNsYXNzIFRleHRMYXllciB7XG4gICNjYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICNjb250YWluZXIgPSBudWxsO1xuICAjZGlzYWJsZVByb2Nlc3NJdGVtcyA9IGZhbHNlO1xuICAjZm9udEluc3BlY3RvckVuYWJsZWQgPSAhIWdsb2JhbFRoaXMuRm9udEluc3BlY3Rvcj8uZW5hYmxlZDtcbiAgI2xhbmcgPSBudWxsO1xuICAjbGF5b3V0VGV4dFBhcmFtcyA9IG51bGw7XG4gICNwYWdlSGVpZ2h0ID0gMDtcbiAgI3BhZ2VXaWR0aCA9IDA7XG4gICNyZWFkZXIgPSBudWxsO1xuICAjcm9vdENvbnRhaW5lciA9IG51bGw7XG4gICNyb3RhdGlvbiA9IDA7XG4gICNzY2FsZSA9IDA7XG4gICNzdHlsZUNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgI3RleHRDb250ZW50SXRlbXNTdHIgPSBbXTtcbiAgI3RleHRDb250ZW50U291cmNlID0gbnVsbDtcbiAgI3RleHREaXZzID0gW107XG4gICN0ZXh0RGl2UHJvcGVydGllcyA9IG5ldyBXZWFrTWFwKCk7XG4gICN0cmFuc2Zvcm0gPSBudWxsO1xuICBzdGF0aWMgI2FzY2VudENhY2hlID0gbmV3IE1hcCgpO1xuICBzdGF0aWMgI2NhbnZhc0NvbnRleHRzID0gbmV3IE1hcCgpO1xuICBzdGF0aWMgI2NhbnZhc0N0eEZvbnRzID0gbmV3IFdlYWtNYXAoKTtcbiAgc3RhdGljICNtaW5Gb250U2l6ZSA9IG51bGw7XG4gIHN0YXRpYyAjcGVuZGluZ1RleHRMYXllcnMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0ZXh0Q29udGVudFNvdXJjZSxcbiAgICBjb250YWluZXIsXG4gICAgdmlld3BvcnRcbiAgfSkge1xuICAgIGlmICh0ZXh0Q29udGVudFNvdXJjZSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtKSB7XG4gICAgICB0aGlzLiN0ZXh0Q29udGVudFNvdXJjZSA9IHRleHRDb250ZW50U291cmNlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRleHRDb250ZW50U291cmNlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aGlzLiN0ZXh0Q29udGVudFNvdXJjZSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dENvbnRlbnRTb3VyY2UpO1xuICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gXCJ0ZXh0Q29udGVudFNvdXJjZVwiIHBhcmFtZXRlciBzcGVjaWZpZWQuJyk7XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lciA9IHRoaXMuI3Jvb3RDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy4jc2NhbGUgPSB2aWV3cG9ydC5zY2FsZSAqIChnbG9iYWxUaGlzLmRldmljZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgdGhpcy4jcm90YXRpb24gPSB2aWV3cG9ydC5yb3RhdGlvbjtcbiAgICB0aGlzLiNsYXlvdXRUZXh0UGFyYW1zID0ge1xuICAgICAgZGl2OiBudWxsLFxuICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgIGN0eDogbnVsbFxuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodCxcbiAgICAgIHBhZ2VYLFxuICAgICAgcGFnZVlcbiAgICB9ID0gdmlld3BvcnQucmF3RGltcztcbiAgICB0aGlzLiN0cmFuc2Zvcm0gPSBbMSwgMCwgMCwgLTEsIC1wYWdlWCwgcGFnZVkgKyBwYWdlSGVpZ2h0XTtcbiAgICB0aGlzLiNwYWdlV2lkdGggPSBwYWdlV2lkdGg7XG4gICAgdGhpcy4jcGFnZUhlaWdodCA9IHBhZ2VIZWlnaHQ7XG4gICAgVGV4dExheWVyLiNlbnN1cmVNaW5Gb250U2l6ZUNvbXB1dGVkKCk7XG4gICAgc2V0TGF5ZXJEaW1lbnNpb25zKGNvbnRhaW5lciwgdmlld3BvcnQpO1xuICAgIHRoaXMuI2NhcGFiaWxpdHkucHJvbWlzZS5maW5hbGx5KCgpID0+IHtcbiAgICAgIFRleHRMYXllci4jcGVuZGluZ1RleHRMYXllcnMuZGVsZXRlKHRoaXMpO1xuICAgICAgdGhpcy4jbGF5b3V0VGV4dFBhcmFtcyA9IG51bGw7XG4gICAgICB0aGlzLiNzdHlsZUNhY2hlID0gbnVsbDtcbiAgICB9KS5jYXRjaCgoKSA9PiB7fSk7XG4gIH1cbiAgc3RhdGljIGdldCBmb250RmFtaWx5TWFwKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzV2luZG93cyxcbiAgICAgIGlzRmlyZWZveFxuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJmb250RmFtaWx5TWFwXCIsIG5ldyBNYXAoW1tcInNhbnMtc2VyaWZcIiwgYCR7aXNXaW5kb3dzICYmIGlzRmlyZWZveCA/IFwiQ2FsaWJyaSwgXCIgOiBcIlwifXNhbnMtc2VyaWZgXSwgW1wibW9ub3NwYWNlXCIsIGAke2lzV2luZG93cyAmJiBpc0ZpcmVmb3ggPyBcIkx1Y2lkYSBDb25zb2xlLCBcIiA6IFwiXCJ9bW9ub3NwYWNlYF1dKSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHB1bXAgPSAoKSA9PiB7XG4gICAgICB0aGlzLiNyZWFkZXIucmVhZCgpLnRoZW4oKHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICB0aGlzLiNjYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbGFuZyA/Pz0gdmFsdWUubGFuZztcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLiNzdHlsZUNhY2hlLCB2YWx1ZS5zdHlsZXMpO1xuICAgICAgICB0aGlzLiNwcm9jZXNzSXRlbXModmFsdWUuaXRlbXMpO1xuICAgICAgICBwdW1wKCk7XG4gICAgICB9LCB0aGlzLiNjYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgfTtcbiAgICB0aGlzLiNyZWFkZXIgPSB0aGlzLiN0ZXh0Q29udGVudFNvdXJjZS5nZXRSZWFkZXIoKTtcbiAgICBUZXh0TGF5ZXIuI3BlbmRpbmdUZXh0TGF5ZXJzLmFkZCh0aGlzKTtcbiAgICBwdW1wKCk7XG4gICAgcmV0dXJuIHRoaXMuI2NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICB1cGRhdGUoe1xuICAgIHZpZXdwb3J0LFxuICAgIG9uQmVmb3JlID0gbnVsbFxuICB9KSB7XG4gICAgY29uc3Qgc2NhbGUgPSB2aWV3cG9ydC5zY2FsZSAqIChnbG9iYWxUaGlzLmRldmljZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgY29uc3Qgcm90YXRpb24gPSB2aWV3cG9ydC5yb3RhdGlvbjtcbiAgICBpZiAocm90YXRpb24gIT09IHRoaXMuI3JvdGF0aW9uKSB7XG4gICAgICBvbkJlZm9yZT8uKCk7XG4gICAgICB0aGlzLiNyb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgICAgc2V0TGF5ZXJEaW1lbnNpb25zKHRoaXMuI3Jvb3RDb250YWluZXIsIHtcbiAgICAgICAgcm90YXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NhbGUgIT09IHRoaXMuI3NjYWxlKSB7XG4gICAgICBvbkJlZm9yZT8uKCk7XG4gICAgICB0aGlzLiNzY2FsZSA9IHNjYWxlO1xuICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBkaXY6IG51bGwsXG4gICAgICAgIHByb3BlcnRpZXM6IG51bGwsXG4gICAgICAgIGN0eDogVGV4dExheWVyLiNnZXRDdHgodGhpcy4jbGFuZylcbiAgICAgIH07XG4gICAgICBmb3IgKGNvbnN0IGRpdiBvZiB0aGlzLiN0ZXh0RGl2cykge1xuICAgICAgICBwYXJhbXMucHJvcGVydGllcyA9IHRoaXMuI3RleHREaXZQcm9wZXJ0aWVzLmdldChkaXYpO1xuICAgICAgICBwYXJhbXMuZGl2ID0gZGl2O1xuICAgICAgICB0aGlzLiNsYXlvdXQocGFyYW1zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FuY2VsKCkge1xuICAgIGNvbnN0IGFib3J0RXggPSBuZXcgQWJvcnRFeGNlcHRpb24oXCJUZXh0TGF5ZXIgdGFzayBjYW5jZWxsZWQuXCIpO1xuICAgIHRoaXMuI3JlYWRlcj8uY2FuY2VsKGFib3J0RXgpLmNhdGNoKCgpID0+IHt9KTtcbiAgICB0aGlzLiNyZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuI2NhcGFiaWxpdHkucmVqZWN0KGFib3J0RXgpO1xuICB9XG4gIGdldCB0ZXh0RGl2cygpIHtcbiAgICByZXR1cm4gdGhpcy4jdGV4dERpdnM7XG4gIH1cbiAgZ2V0IHRleHRDb250ZW50SXRlbXNTdHIoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3RleHRDb250ZW50SXRlbXNTdHI7XG4gIH1cbiAgI3Byb2Nlc3NJdGVtcyhpdGVtcykge1xuICAgIGlmICh0aGlzLiNkaXNhYmxlUHJvY2Vzc0l0ZW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2xheW91dFRleHRQYXJhbXMuY3R4ID8/PSBUZXh0TGF5ZXIuI2dldEN0eCh0aGlzLiNsYW5nKTtcbiAgICBjb25zdCB0ZXh0RGl2cyA9IHRoaXMuI3RleHREaXZzLFxuICAgICAgdGV4dENvbnRlbnRJdGVtc1N0ciA9IHRoaXMuI3RleHRDb250ZW50SXRlbXNTdHI7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBpZiAodGV4dERpdnMubGVuZ3RoID4gTUFYX1RFWFRfRElWU19UT19SRU5ERVIpIHtcbiAgICAgICAgd2FybihcIklnbm9yaW5nIGFkZGl0aW9uYWwgdGV4dERpdnMgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXCIpO1xuICAgICAgICB0aGlzLiNkaXNhYmxlUHJvY2Vzc0l0ZW1zID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0uc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJiZWdpbk1hcmtlZENvbnRlbnRQcm9wc1wiIHx8IGl0ZW0udHlwZSA9PT0gXCJiZWdpbk1hcmtlZENvbnRlbnRcIikge1xuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuI2NvbnRhaW5lcjtcbiAgICAgICAgICB0aGlzLiNjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICB0aGlzLiNjb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm1hcmtlZENvbnRlbnRcIik7XG4gICAgICAgICAgaWYgKGl0ZW0uaWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBgJHtpdGVtLmlkfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnQuYXBwZW5kKHRoaXMuI2NvbnRhaW5lcik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSBcImVuZE1hcmtlZENvbnRlbnRcIikge1xuICAgICAgICAgIHRoaXMuI2NvbnRhaW5lciA9IHRoaXMuI2NvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGV4dENvbnRlbnRJdGVtc1N0ci5wdXNoKGl0ZW0uc3RyKTtcbiAgICAgIHRoaXMuI2FwcGVuZFRleHQoaXRlbSk7XG4gICAgfVxuICB9XG4gICNhcHBlbmRUZXh0KGdlb20pIHtcbiAgICBjb25zdCB0ZXh0RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgY29uc3QgdGV4dERpdlByb3BlcnRpZXMgPSB7XG4gICAgICBhbmdsZTogMCxcbiAgICAgIGNhbnZhc1dpZHRoOiAwLFxuICAgICAgaGFzVGV4dDogZ2VvbS5zdHIgIT09IFwiXCIsXG4gICAgICBoYXNFT0w6IGdlb20uaGFzRU9MLFxuICAgICAgZm9udFNpemU6IDBcbiAgICB9O1xuICAgIHRoaXMuI3RleHREaXZzLnB1c2godGV4dERpdik7XG4gICAgY29uc3QgdHggPSBVdGlsLnRyYW5zZm9ybSh0aGlzLiN0cmFuc2Zvcm0sIGdlb20udHJhbnNmb3JtKTtcbiAgICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKHR4WzFdLCB0eFswXSk7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLiNzdHlsZUNhY2hlW2dlb20uZm9udE5hbWVdO1xuICAgIGlmIChzdHlsZS52ZXJ0aWNhbCkge1xuICAgICAgYW5nbGUgKz0gTWF0aC5QSSAvIDI7XG4gICAgfVxuICAgIGxldCBmb250RmFtaWx5ID0gdGhpcy4jZm9udEluc3BlY3RvckVuYWJsZWQgJiYgc3R5bGUuZm9udFN1YnN0aXR1dGlvbiB8fCBzdHlsZS5mb250RmFtaWx5O1xuICAgIGZvbnRGYW1pbHkgPSBUZXh0TGF5ZXIuZm9udEZhbWlseU1hcC5nZXQoZm9udEZhbWlseSkgfHwgZm9udEZhbWlseTtcbiAgICBjb25zdCBmb250SGVpZ2h0ID0gTWF0aC5oeXBvdCh0eFsyXSwgdHhbM10pO1xuICAgIGNvbnN0IGZvbnRBc2NlbnQgPSBmb250SGVpZ2h0ICogVGV4dExheWVyLiNnZXRBc2NlbnQoZm9udEZhbWlseSwgdGhpcy4jbGFuZyk7XG4gICAgbGV0IGxlZnQsIHRvcDtcbiAgICBpZiAoYW5nbGUgPT09IDApIHtcbiAgICAgIGxlZnQgPSB0eFs0XTtcbiAgICAgIHRvcCA9IHR4WzVdIC0gZm9udEFzY2VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IHR4WzRdICsgZm9udEFzY2VudCAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgIHRvcCA9IHR4WzVdIC0gZm9udEFzY2VudCAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICB9XG4gICAgY29uc3Qgc2NhbGVGYWN0b3JTdHIgPSBcImNhbGModmFyKC0tc2NhbGUtZmFjdG9yKSpcIjtcbiAgICBjb25zdCBkaXZTdHlsZSA9IHRleHREaXYuc3R5bGU7XG4gICAgaWYgKHRoaXMuI2NvbnRhaW5lciA9PT0gdGhpcy4jcm9vdENvbnRhaW5lcikge1xuICAgICAgZGl2U3R5bGUubGVmdCA9IGAkeygxMDAgKiBsZWZ0IC8gdGhpcy4jcGFnZVdpZHRoKS50b0ZpeGVkKDIpfSVgO1xuICAgICAgZGl2U3R5bGUudG9wID0gYCR7KDEwMCAqIHRvcCAvIHRoaXMuI3BhZ2VIZWlnaHQpLnRvRml4ZWQoMil9JWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpdlN0eWxlLmxlZnQgPSBgJHtzY2FsZUZhY3RvclN0cn0ke2xlZnQudG9GaXhlZCgyKX1weClgO1xuICAgICAgZGl2U3R5bGUudG9wID0gYCR7c2NhbGVGYWN0b3JTdHJ9JHt0b3AudG9GaXhlZCgyKX1weClgO1xuICAgIH1cbiAgICBkaXZTdHlsZS5mb250U2l6ZSA9IGAke3NjYWxlRmFjdG9yU3RyfSR7KFRleHRMYXllci4jbWluRm9udFNpemUgKiBmb250SGVpZ2h0KS50b0ZpeGVkKDIpfXB4KWA7XG4gICAgZGl2U3R5bGUuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgdGV4dERpdlByb3BlcnRpZXMuZm9udFNpemUgPSBmb250SGVpZ2h0O1xuICAgIHRleHREaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcbiAgICB0ZXh0RGl2LnRleHRDb250ZW50ID0gZ2VvbS5zdHI7XG4gICAgdGV4dERpdi5kaXIgPSBnZW9tLmRpcjtcbiAgICBpZiAodGhpcy4jZm9udEluc3BlY3RvckVuYWJsZWQpIHtcbiAgICAgIHRleHREaXYuZGF0YXNldC5mb250TmFtZSA9IHN0eWxlLmZvbnRTdWJzdGl0dXRpb25Mb2FkZWROYW1lIHx8IGdlb20uZm9udE5hbWU7XG4gICAgfVxuICAgIGlmIChhbmdsZSAhPT0gMCkge1xuICAgICAgdGV4dERpdlByb3BlcnRpZXMuYW5nbGUgPSBhbmdsZSAqICgxODAgLyBNYXRoLlBJKTtcbiAgICB9XG4gICAgbGV0IHNob3VsZFNjYWxlVGV4dCA9IGZhbHNlO1xuICAgIGlmIChnZW9tLnN0ci5sZW5ndGggPiAxKSB7XG4gICAgICBzaG91bGRTY2FsZVRleHQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZ2VvbS5zdHIgIT09IFwiIFwiICYmIGdlb20udHJhbnNmb3JtWzBdICE9PSBnZW9tLnRyYW5zZm9ybVszXSkge1xuICAgICAgY29uc3QgYWJzU2NhbGVYID0gTWF0aC5hYnMoZ2VvbS50cmFuc2Zvcm1bMF0pLFxuICAgICAgICBhYnNTY2FsZVkgPSBNYXRoLmFicyhnZW9tLnRyYW5zZm9ybVszXSk7XG4gICAgICBpZiAoYWJzU2NhbGVYICE9PSBhYnNTY2FsZVkgJiYgTWF0aC5tYXgoYWJzU2NhbGVYLCBhYnNTY2FsZVkpIC8gTWF0aC5taW4oYWJzU2NhbGVYLCBhYnNTY2FsZVkpID4gMS41KSB7XG4gICAgICAgIHNob3VsZFNjYWxlVGV4dCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaG91bGRTY2FsZVRleHQpIHtcbiAgICAgIHRleHREaXZQcm9wZXJ0aWVzLmNhbnZhc1dpZHRoID0gc3R5bGUudmVydGljYWwgPyBnZW9tLmhlaWdodCA6IGdlb20ud2lkdGg7XG4gICAgfVxuICAgIHRoaXMuI3RleHREaXZQcm9wZXJ0aWVzLnNldCh0ZXh0RGl2LCB0ZXh0RGl2UHJvcGVydGllcyk7XG4gICAgdGhpcy4jbGF5b3V0VGV4dFBhcmFtcy5kaXYgPSB0ZXh0RGl2O1xuICAgIHRoaXMuI2xheW91dFRleHRQYXJhbXMucHJvcGVydGllcyA9IHRleHREaXZQcm9wZXJ0aWVzO1xuICAgIHRoaXMuI2xheW91dCh0aGlzLiNsYXlvdXRUZXh0UGFyYW1zKTtcbiAgICBpZiAodGV4dERpdlByb3BlcnRpZXMuaGFzVGV4dCkge1xuICAgICAgdGhpcy4jY29udGFpbmVyLmFwcGVuZCh0ZXh0RGl2KTtcbiAgICB9XG4gICAgaWYgKHRleHREaXZQcm9wZXJ0aWVzLmhhc0VPTCkge1xuICAgICAgY29uc3QgYnIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XG4gICAgICBici5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwicHJlc2VudGF0aW9uXCIpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLmFwcGVuZChicik7XG4gICAgfVxuICB9XG4gICNsYXlvdXQocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGl2LFxuICAgICAgcHJvcGVydGllcyxcbiAgICAgIGN0eFxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gZGl2O1xuICAgIGxldCB0cmFuc2Zvcm0gPSBcIlwiO1xuICAgIGlmIChUZXh0TGF5ZXIuI21pbkZvbnRTaXplID4gMSkge1xuICAgICAgdHJhbnNmb3JtID0gYHNjYWxlKCR7MSAvIFRleHRMYXllci4jbWluRm9udFNpemV9KWA7XG4gICAgfVxuICAgIGlmIChwcm9wZXJ0aWVzLmNhbnZhc1dpZHRoICE9PSAwICYmIHByb3BlcnRpZXMuaGFzVGV4dCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmb250RmFtaWx5XG4gICAgICB9ID0gc3R5bGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNhbnZhc1dpZHRoLFxuICAgICAgICBmb250U2l6ZVxuICAgICAgfSA9IHByb3BlcnRpZXM7XG4gICAgICBUZXh0TGF5ZXIuI2Vuc3VyZUN0eEZvbnQoY3R4LCBmb250U2l6ZSAqIHRoaXMuI3NjYWxlLCBmb250RmFtaWx5KTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGhcbiAgICAgIH0gPSBjdHgubWVhc3VyZVRleHQoZGl2LnRleHRDb250ZW50KTtcbiAgICAgIGlmICh3aWR0aCA+IDApIHtcbiAgICAgICAgdHJhbnNmb3JtID0gYHNjYWxlWCgke2NhbnZhc1dpZHRoICogdGhpcy4jc2NhbGUgLyB3aWR0aH0pICR7dHJhbnNmb3JtfWA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wZXJ0aWVzLmFuZ2xlICE9PSAwKSB7XG4gICAgICB0cmFuc2Zvcm0gPSBgcm90YXRlKCR7cHJvcGVydGllcy5hbmdsZX1kZWcpICR7dHJhbnNmb3JtfWA7XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm0ubGVuZ3RoID4gMCkge1xuICAgICAgc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy4jcGVuZGluZ1RleHRMYXllcnMuc2l6ZSA+IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYXNjZW50Q2FjaGUuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIGNhbnZhc1xuICAgIH0gb2YgdGhpcy4jY2FudmFzQ29udGV4dHMudmFsdWVzKCkpIHtcbiAgICAgIGNhbnZhcy5yZW1vdmUoKTtcbiAgICB9XG4gICAgdGhpcy4jY2FudmFzQ29udGV4dHMuY2xlYXIoKTtcbiAgfVxuICBzdGF0aWMgI2dldEN0eChsYW5nID0gbnVsbCkge1xuICAgIGxldCBjdHggPSB0aGlzLiNjYW52YXNDb250ZXh0cy5nZXQobGFuZyB8fD0gXCJcIik7XG4gICAgaWYgKCFjdHgpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICBjYW52YXMuY2xhc3NOYW1lID0gXCJoaWRkZW5DYW52YXNFbGVtZW50XCI7XG4gICAgICBjYW52YXMubGFuZyA9IGxhbmc7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChjYW52YXMpO1xuICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICAgIGFscGhhOiBmYWxzZSxcbiAgICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuI2NhbnZhc0NvbnRleHRzLnNldChsYW5nLCBjdHgpO1xuICAgICAgdGhpcy4jY2FudmFzQ3R4Rm9udHMuc2V0KGN0eCwge1xuICAgICAgICBzaXplOiAwLFxuICAgICAgICBmYW1pbHk6IFwiXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY3R4O1xuICB9XG4gIHN0YXRpYyAjZW5zdXJlQ3R4Rm9udChjdHgsIHNpemUsIGZhbWlseSkge1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuI2NhbnZhc0N0eEZvbnRzLmdldChjdHgpO1xuICAgIGlmIChzaXplID09PSBjYWNoZWQuc2l6ZSAmJiBmYW1pbHkgPT09IGNhY2hlZC5mYW1pbHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4LmZvbnQgPSBgJHtzaXplfXB4ICR7ZmFtaWx5fWA7XG4gICAgY2FjaGVkLnNpemUgPSBzaXplO1xuICAgIGNhY2hlZC5mYW1pbHkgPSBmYW1pbHk7XG4gIH1cbiAgc3RhdGljICNlbnN1cmVNaW5Gb250U2l6ZUNvbXB1dGVkKCkge1xuICAgIGlmICh0aGlzLiNtaW5Gb250U2l6ZSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICBkaXYuc3R5bGUubGluZUhlaWdodCA9IDE7XG4gICAgZGl2LnN0eWxlLmZvbnRTaXplID0gXCIxcHhcIjtcbiAgICBkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgZGl2LnRleHRDb250ZW50ID0gXCJYXCI7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoZGl2KTtcbiAgICB0aGlzLiNtaW5Gb250U2l6ZSA9IGRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgZGl2LnJlbW92ZSgpO1xuICB9XG4gIHN0YXRpYyAjZ2V0QXNjZW50KGZvbnRGYW1pbHksIGxhbmcpIHtcbiAgICBjb25zdCBjYWNoZWRBc2NlbnQgPSB0aGlzLiNhc2NlbnRDYWNoZS5nZXQoZm9udEZhbWlseSk7XG4gICAgaWYgKGNhY2hlZEFzY2VudCkge1xuICAgICAgcmV0dXJuIGNhY2hlZEFzY2VudDtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy4jZ2V0Q3R4KGxhbmcpO1xuICAgIGN0eC5jYW52YXMud2lkdGggPSBjdHguY2FudmFzLmhlaWdodCA9IERFRkFVTFRfRk9OVF9TSVpFO1xuICAgIHRoaXMuI2Vuc3VyZUN0eEZvbnQoY3R4LCBERUZBVUxUX0ZPTlRfU0laRSwgZm9udEZhbWlseSk7XG4gICAgY29uc3QgbWV0cmljcyA9IGN0eC5tZWFzdXJlVGV4dChcIlwiKTtcbiAgICBsZXQgYXNjZW50ID0gbWV0cmljcy5mb250Qm91bmRpbmdCb3hBc2NlbnQ7XG4gICAgbGV0IGRlc2NlbnQgPSBNYXRoLmFicyhtZXRyaWNzLmZvbnRCb3VuZGluZ0JveERlc2NlbnQpO1xuICAgIGlmIChhc2NlbnQpIHtcbiAgICAgIGNvbnN0IHJhdGlvID0gYXNjZW50IC8gKGFzY2VudCArIGRlc2NlbnQpO1xuICAgICAgdGhpcy4jYXNjZW50Q2FjaGUuc2V0KGZvbnRGYW1pbHksIHJhdGlvKTtcbiAgICAgIGN0eC5jYW52YXMud2lkdGggPSBjdHguY2FudmFzLmhlaWdodCA9IDA7XG4gICAgICByZXR1cm4gcmF0aW87XG4gICAgfVxuICAgIGN0eC5zdHJva2VTdHlsZSA9IFwicmVkXCI7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBERUZBVUxUX0ZPTlRfU0laRSwgREVGQVVMVF9GT05UX1NJWkUpO1xuICAgIGN0eC5zdHJva2VUZXh0KFwiZ1wiLCAwLCAwKTtcbiAgICBsZXQgcGl4ZWxzID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBERUZBVUxUX0ZPTlRfU0laRSwgREVGQVVMVF9GT05UX1NJWkUpLmRhdGE7XG4gICAgZGVzY2VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IHBpeGVscy5sZW5ndGggLSAxIC0gMzsgaSA+PSAwOyBpIC09IDQpIHtcbiAgICAgIGlmIChwaXhlbHNbaV0gPiAwKSB7XG4gICAgICAgIGRlc2NlbnQgPSBNYXRoLmNlaWwoaSAvIDQgLyBERUZBVUxUX0ZPTlRfU0laRSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIERFRkFVTFRfRk9OVF9TSVpFLCBERUZBVUxUX0ZPTlRfU0laRSk7XG4gICAgY3R4LnN0cm9rZVRleHQoXCJBXCIsIDAsIERFRkFVTFRfRk9OVF9TSVpFKTtcbiAgICBwaXhlbHMgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIERFRkFVTFRfRk9OVF9TSVpFLCBERUZBVUxUX0ZPTlRfU0laRSkuZGF0YTtcbiAgICBhc2NlbnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBpeGVscy5sZW5ndGg7IGkgPCBpaTsgaSArPSA0KSB7XG4gICAgICBpZiAocGl4ZWxzW2ldID4gMCkge1xuICAgICAgICBhc2NlbnQgPSBERUZBVUxUX0ZPTlRfU0laRSAtIE1hdGguZmxvb3IoaSAvIDQgLyBERUZBVUxUX0ZPTlRfU0laRSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguY2FudmFzLndpZHRoID0gY3R4LmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgIGNvbnN0IHJhdGlvID0gYXNjZW50ID8gYXNjZW50IC8gKGFzY2VudCArIGRlc2NlbnQpIDogREVGQVVMVF9GT05UX0FTQ0VOVDtcbiAgICB0aGlzLiNhc2NlbnRDYWNoZS5zZXQoZm9udEZhbWlseSwgcmF0aW8pO1xuICAgIHJldHVybiByYXRpbztcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS94ZmFfdGV4dC5qc1xuY2xhc3MgWGZhVGV4dCB7XG4gIHN0YXRpYyB0ZXh0Q29udGVudCh4ZmEpIHtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgIGl0ZW1zLFxuICAgICAgc3R5bGVzOiBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgfTtcbiAgICBmdW5jdGlvbiB3YWxrKG5vZGUpIHtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgc3RyID0gbnVsbDtcbiAgICAgIGNvbnN0IG5hbWUgPSBub2RlLm5hbWU7XG4gICAgICBpZiAobmFtZSA9PT0gXCIjdGV4dFwiKSB7XG4gICAgICAgIHN0ciA9IG5vZGUudmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKCFYZmFUZXh0LnNob3VsZEJ1aWxkVGV4dChuYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKG5vZGU/LmF0dHJpYnV0ZXM/LnRleHRDb250ZW50KSB7XG4gICAgICAgIHN0ciA9IG5vZGUuYXR0cmlidXRlcy50ZXh0Q29udGVudDtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSkge1xuICAgICAgICBzdHIgPSBub2RlLnZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0ciAhPT0gbnVsbCkge1xuICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICBzdHJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHdhbGsoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgICB3YWxrKHhmYSk7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuICBzdGF0aWMgc2hvdWxkQnVpbGRUZXh0KG5hbWUpIHtcbiAgICByZXR1cm4gIShuYW1lID09PSBcInRleHRhcmVhXCIgfHwgbmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwib3B0aW9uXCIgfHwgbmFtZSA9PT0gXCJzZWxlY3RcIik7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvYXBpLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY29uc3QgREVGQVVMVF9SQU5HRV9DSFVOS19TSVpFID0gNjU1MzY7XG5jb25zdCBSRU5ERVJJTkdfQ0FOQ0VMTEVEX1RJTUVPVVQgPSAxMDA7XG5jb25zdCBERUxBWUVEX0NMRUFOVVBfVElNRU9VVCA9IDUwMDA7XG5jb25zdCBEZWZhdWx0Q2FudmFzRmFjdG9yeSA9IGlzTm9kZUpTID8gTm9kZUNhbnZhc0ZhY3RvcnkgOiBET01DYW52YXNGYWN0b3J5O1xuY29uc3QgRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5ID0gaXNOb2RlSlMgPyBOb2RlQ01hcFJlYWRlckZhY3RvcnkgOiBET01DTWFwUmVhZGVyRmFjdG9yeTtcbmNvbnN0IERlZmF1bHRGaWx0ZXJGYWN0b3J5ID0gaXNOb2RlSlMgPyBOb2RlRmlsdGVyRmFjdG9yeSA6IERPTUZpbHRlckZhY3Rvcnk7XG5jb25zdCBEZWZhdWx0U3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBpc05vZGVKUyA/IE5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA6IERPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5O1xuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoc3JjID0ge30pIHtcbiAgaWYgKHR5cGVvZiBzcmMgPT09IFwic3RyaW5nXCIgfHwgc3JjIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgc3JjID0ge1xuICAgICAgdXJsOiBzcmNcbiAgICB9O1xuICB9IGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhzcmMpKSB7XG4gICAgc3JjID0ge1xuICAgICAgZGF0YTogc3JjXG4gICAgfTtcbiAgfVxuICBjb25zdCB0YXNrID0gbmV3IFBERkRvY3VtZW50TG9hZGluZ1Rhc2soKTtcbiAgY29uc3Qge1xuICAgIGRvY0lkXG4gIH0gPSB0YXNrO1xuICBjb25zdCB1cmwgPSBzcmMudXJsID8gZ2V0VXJsUHJvcChzcmMudXJsKSA6IG51bGw7XG4gIGNvbnN0IGRhdGEgPSBzcmMuZGF0YSA/IGdldERhdGFQcm9wKHNyYy5kYXRhKSA6IG51bGw7XG4gIGNvbnN0IGh0dHBIZWFkZXJzID0gc3JjLmh0dHBIZWFkZXJzIHx8IG51bGw7XG4gIGNvbnN0IHdpdGhDcmVkZW50aWFscyA9IHNyYy53aXRoQ3JlZGVudGlhbHMgPT09IHRydWU7XG4gIGNvbnN0IHBhc3N3b3JkID0gc3JjLnBhc3N3b3JkID8/IG51bGw7XG4gIGNvbnN0IHJhbmdlVHJhbnNwb3J0ID0gc3JjLnJhbmdlIGluc3RhbmNlb2YgUERGRGF0YVJhbmdlVHJhbnNwb3J0ID8gc3JjLnJhbmdlIDogbnVsbDtcbiAgY29uc3QgcmFuZ2VDaHVua1NpemUgPSBOdW1iZXIuaXNJbnRlZ2VyKHNyYy5yYW5nZUNodW5rU2l6ZSkgJiYgc3JjLnJhbmdlQ2h1bmtTaXplID4gMCA/IHNyYy5yYW5nZUNodW5rU2l6ZSA6IERFRkFVTFRfUkFOR0VfQ0hVTktfU0laRTtcbiAgbGV0IHdvcmtlciA9IHNyYy53b3JrZXIgaW5zdGFuY2VvZiBQREZXb3JrZXIgPyBzcmMud29ya2VyIDogbnVsbDtcbiAgY29uc3QgdmVyYm9zaXR5ID0gc3JjLnZlcmJvc2l0eTtcbiAgY29uc3QgZG9jQmFzZVVybCA9IHR5cGVvZiBzcmMuZG9jQmFzZVVybCA9PT0gXCJzdHJpbmdcIiAmJiAhaXNEYXRhU2NoZW1lKHNyYy5kb2NCYXNlVXJsKSA/IHNyYy5kb2NCYXNlVXJsIDogbnVsbDtcbiAgY29uc3QgY01hcFVybCA9IHR5cGVvZiBzcmMuY01hcFVybCA9PT0gXCJzdHJpbmdcIiA/IHNyYy5jTWFwVXJsIDogbnVsbDtcbiAgY29uc3QgY01hcFBhY2tlZCA9IHNyYy5jTWFwUGFja2VkICE9PSBmYWxzZTtcbiAgY29uc3QgQ01hcFJlYWRlckZhY3RvcnkgPSBzcmMuQ01hcFJlYWRlckZhY3RvcnkgfHwgRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5O1xuICBjb25zdCBzdGFuZGFyZEZvbnREYXRhVXJsID0gdHlwZW9mIHNyYy5zdGFuZGFyZEZvbnREYXRhVXJsID09PSBcInN0cmluZ1wiID8gc3JjLnN0YW5kYXJkRm9udERhdGFVcmwgOiBudWxsO1xuICBjb25zdCBTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IHNyYy5TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB8fCBEZWZhdWx0U3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG4gIGNvbnN0IGlnbm9yZUVycm9ycyA9IHNyYy5zdG9wQXRFcnJvcnMgIT09IHRydWU7XG4gIGNvbnN0IG1heEltYWdlU2l6ZSA9IE51bWJlci5pc0ludGVnZXIoc3JjLm1heEltYWdlU2l6ZSkgJiYgc3JjLm1heEltYWdlU2l6ZSA+IC0xID8gc3JjLm1heEltYWdlU2l6ZSA6IC0xO1xuICBjb25zdCBpc0V2YWxTdXBwb3J0ZWQgPSBzcmMuaXNFdmFsU3VwcG9ydGVkICE9PSBmYWxzZTtcbiAgY29uc3QgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQgPSB0eXBlb2Ygc3JjLmlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkID09PSBcImJvb2xlYW5cIiA/IHNyYy5pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCA6ICFpc05vZGVKUztcbiAgY29uc3QgaXNJbWFnZURlY29kZXJTdXBwb3J0ZWQgPSB0eXBlb2Ygc3JjLmlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkID09PSBcImJvb2xlYW5cIiA/IHNyYy5pc0ltYWdlRGVjb2RlclN1cHBvcnRlZCA6ICFpc05vZGVKUyAmJiAodXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybS5pc0ZpcmVmb3ggfHwgIWdsb2JhbFRoaXMuY2hyb21lKTtcbiAgY29uc3QgY2FudmFzTWF4QXJlYUluQnl0ZXMgPSBOdW1iZXIuaXNJbnRlZ2VyKHNyYy5jYW52YXNNYXhBcmVhSW5CeXRlcykgPyBzcmMuY2FudmFzTWF4QXJlYUluQnl0ZXMgOiAtMTtcbiAgY29uc3QgZGlzYWJsZUZvbnRGYWNlID0gdHlwZW9mIHNyYy5kaXNhYmxlRm9udEZhY2UgPT09IFwiYm9vbGVhblwiID8gc3JjLmRpc2FibGVGb250RmFjZSA6IGlzTm9kZUpTO1xuICBjb25zdCBmb250RXh0cmFQcm9wZXJ0aWVzID0gc3JjLmZvbnRFeHRyYVByb3BlcnRpZXMgPT09IHRydWU7XG4gIGNvbnN0IGVuYWJsZVhmYSA9IHNyYy5lbmFibGVYZmEgPT09IHRydWU7XG4gIGNvbnN0IG93bmVyRG9jdW1lbnQgPSBzcmMub3duZXJEb2N1bWVudCB8fCBnbG9iYWxUaGlzLmRvY3VtZW50O1xuICBjb25zdCBkaXNhYmxlUmFuZ2UgPSBzcmMuZGlzYWJsZVJhbmdlID09PSB0cnVlO1xuICBjb25zdCBkaXNhYmxlU3RyZWFtID0gc3JjLmRpc2FibGVTdHJlYW0gPT09IHRydWU7XG4gIGNvbnN0IGRpc2FibGVBdXRvRmV0Y2ggPSBzcmMuZGlzYWJsZUF1dG9GZXRjaCA9PT0gdHJ1ZTtcbiAgY29uc3QgcGRmQnVnID0gc3JjLnBkZkJ1ZyA9PT0gdHJ1ZTtcbiAgY29uc3QgQ2FudmFzRmFjdG9yeSA9IHNyYy5DYW52YXNGYWN0b3J5IHx8IERlZmF1bHRDYW52YXNGYWN0b3J5O1xuICBjb25zdCBGaWx0ZXJGYWN0b3J5ID0gc3JjLkZpbHRlckZhY3RvcnkgfHwgRGVmYXVsdEZpbHRlckZhY3Rvcnk7XG4gIGNvbnN0IGVuYWJsZUhXQSA9IHNyYy5lbmFibGVIV0EgPT09IHRydWU7XG4gIGNvbnN0IGxlbmd0aCA9IHJhbmdlVHJhbnNwb3J0ID8gcmFuZ2VUcmFuc3BvcnQubGVuZ3RoIDogc3JjLmxlbmd0aCA/PyBOYU47XG4gIGNvbnN0IHVzZVN5c3RlbUZvbnRzID0gdHlwZW9mIHNyYy51c2VTeXN0ZW1Gb250cyA9PT0gXCJib29sZWFuXCIgPyBzcmMudXNlU3lzdGVtRm9udHMgOiAhaXNOb2RlSlMgJiYgIWRpc2FibGVGb250RmFjZTtcbiAgY29uc3QgdXNlV29ya2VyRmV0Y2ggPSB0eXBlb2Ygc3JjLnVzZVdvcmtlckZldGNoID09PSBcImJvb2xlYW5cIiA/IHNyYy51c2VXb3JrZXJGZXRjaCA6IENNYXBSZWFkZXJGYWN0b3J5ID09PSBET01DTWFwUmVhZGVyRmFjdG9yeSAmJiBTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9PT0gRE9NU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgJiYgY01hcFVybCAmJiBzdGFuZGFyZEZvbnREYXRhVXJsICYmIGlzVmFsaWRGZXRjaFVybChjTWFwVXJsLCBkb2N1bWVudC5iYXNlVVJJKSAmJiBpc1ZhbGlkRmV0Y2hVcmwoc3RhbmRhcmRGb250RGF0YVVybCwgZG9jdW1lbnQuYmFzZVVSSSk7XG4gIGNvbnN0IHN0eWxlRWxlbWVudCA9IG51bGw7XG4gIHNldFZlcmJvc2l0eUxldmVsKHZlcmJvc2l0eSk7XG4gIGNvbnN0IHRyYW5zcG9ydEZhY3RvcnkgPSB7XG4gICAgY2FudmFzRmFjdG9yeTogbmV3IENhbnZhc0ZhY3Rvcnkoe1xuICAgICAgb3duZXJEb2N1bWVudCxcbiAgICAgIGVuYWJsZUhXQVxuICAgIH0pLFxuICAgIGZpbHRlckZhY3Rvcnk6IG5ldyBGaWx0ZXJGYWN0b3J5KHtcbiAgICAgIGRvY0lkLFxuICAgICAgb3duZXJEb2N1bWVudFxuICAgIH0pLFxuICAgIGNNYXBSZWFkZXJGYWN0b3J5OiB1c2VXb3JrZXJGZXRjaCA/IG51bGwgOiBuZXcgQ01hcFJlYWRlckZhY3Rvcnkoe1xuICAgICAgYmFzZVVybDogY01hcFVybCxcbiAgICAgIGlzQ29tcHJlc3NlZDogY01hcFBhY2tlZFxuICAgIH0pLFxuICAgIHN0YW5kYXJkRm9udERhdGFGYWN0b3J5OiB1c2VXb3JrZXJGZXRjaCA/IG51bGwgOiBuZXcgU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkoe1xuICAgICAgYmFzZVVybDogc3RhbmRhcmRGb250RGF0YVVybFxuICAgIH0pXG4gIH07XG4gIGlmICghd29ya2VyKSB7XG4gICAgY29uc3Qgd29ya2VyUGFyYW1zID0ge1xuICAgICAgdmVyYm9zaXR5LFxuICAgICAgcG9ydDogR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJQb3J0XG4gICAgfTtcbiAgICB3b3JrZXIgPSB3b3JrZXJQYXJhbXMucG9ydCA/IFBERldvcmtlci5mcm9tUG9ydCh3b3JrZXJQYXJhbXMpIDogbmV3IFBERldvcmtlcih3b3JrZXJQYXJhbXMpO1xuICAgIHRhc2suX3dvcmtlciA9IHdvcmtlcjtcbiAgfVxuICBjb25zdCBkb2NQYXJhbXMgPSB7XG4gICAgZG9jSWQsXG4gICAgYXBpVmVyc2lvbjogXCI0LjEwLjM4XCIsXG4gICAgZGF0YSxcbiAgICBwYXNzd29yZCxcbiAgICBkaXNhYmxlQXV0b0ZldGNoLFxuICAgIHJhbmdlQ2h1bmtTaXplLFxuICAgIGxlbmd0aCxcbiAgICBkb2NCYXNlVXJsLFxuICAgIGVuYWJsZVhmYSxcbiAgICBldmFsdWF0b3JPcHRpb25zOiB7XG4gICAgICBtYXhJbWFnZVNpemUsXG4gICAgICBkaXNhYmxlRm9udEZhY2UsXG4gICAgICBpZ25vcmVFcnJvcnMsXG4gICAgICBpc0V2YWxTdXBwb3J0ZWQsXG4gICAgICBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCxcbiAgICAgIGlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkLFxuICAgICAgY2FudmFzTWF4QXJlYUluQnl0ZXMsXG4gICAgICBmb250RXh0cmFQcm9wZXJ0aWVzLFxuICAgICAgdXNlU3lzdGVtRm9udHMsXG4gICAgICBjTWFwVXJsOiB1c2VXb3JrZXJGZXRjaCA/IGNNYXBVcmwgOiBudWxsLFxuICAgICAgc3RhbmRhcmRGb250RGF0YVVybDogdXNlV29ya2VyRmV0Y2ggPyBzdGFuZGFyZEZvbnREYXRhVXJsIDogbnVsbFxuICAgIH1cbiAgfTtcbiAgY29uc3QgdHJhbnNwb3J0UGFyYW1zID0ge1xuICAgIGRpc2FibGVGb250RmFjZSxcbiAgICBmb250RXh0cmFQcm9wZXJ0aWVzLFxuICAgIG93bmVyRG9jdW1lbnQsXG4gICAgcGRmQnVnLFxuICAgIHN0eWxlRWxlbWVudCxcbiAgICBsb2FkaW5nUGFyYW1zOiB7XG4gICAgICBkaXNhYmxlQXV0b0ZldGNoLFxuICAgICAgZW5hYmxlWGZhXG4gICAgfVxuICB9O1xuICB3b3JrZXIucHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGFzay5kZXN0cm95ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvYWRpbmcgYWJvcnRlZFwiKTtcbiAgICB9XG4gICAgaWYgKHdvcmtlci5kZXN0cm95ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpO1xuICAgIH1cbiAgICBjb25zdCB3b3JrZXJJZFByb21pc2UgPSB3b3JrZXIubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RG9jUmVxdWVzdFwiLCBkb2NQYXJhbXMsIGRhdGEgPyBbZGF0YS5idWZmZXJdIDogbnVsbCk7XG4gICAgbGV0IG5ldHdvcmtTdHJlYW07XG4gICAgaWYgKHJhbmdlVHJhbnNwb3J0KSB7XG4gICAgICBuZXR3b3JrU3RyZWFtID0gbmV3IFBERkRhdGFUcmFuc3BvcnRTdHJlYW0ocmFuZ2VUcmFuc3BvcnQsIHtcbiAgICAgICAgZGlzYWJsZVJhbmdlLFxuICAgICAgICBkaXNhYmxlU3RyZWFtXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFkYXRhKSB7XG4gICAgICBpZiAoIXVybCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXREb2N1bWVudCAtIG5vIGB1cmxgIHBhcmFtZXRlciBwcm92aWRlZC5cIik7XG4gICAgICB9XG4gICAgICBsZXQgTmV0d29ya1N0cmVhbTtcbiAgICAgIGlmIChpc05vZGVKUykge1xuICAgICAgICBpZiAoaXNWYWxpZEZldGNoVXJsKHVybCkpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGZldGNoID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBSZXNwb25zZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFwiYm9keVwiIGluIFJlc3BvbnNlLnByb3RvdHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImdldERvY3VtZW50IC0gdGhlIEZldGNoIEFQSSB3YXMgZGlzYWJsZWQgaW4gTm9kZS5qcywgc2VlIGAtLW5vLWV4cGVyaW1lbnRhbC1mZXRjaGAuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBOZXR3b3JrU3RyZWFtID0gUERGRmV0Y2hTdHJlYW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgTmV0d29ya1N0cmVhbSA9IFBERk5vZGVTdHJlYW07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE5ldHdvcmtTdHJlYW0gPSBpc1ZhbGlkRmV0Y2hVcmwodXJsKSA/IFBERkZldGNoU3RyZWFtIDogUERGTmV0d29ya1N0cmVhbTtcbiAgICAgIH1cbiAgICAgIG5ldHdvcmtTdHJlYW0gPSBuZXcgTmV0d29ya1N0cmVhbSh7XG4gICAgICAgIHVybCxcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBodHRwSGVhZGVycyxcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzLFxuICAgICAgICByYW5nZUNodW5rU2l6ZSxcbiAgICAgICAgZGlzYWJsZVJhbmdlLFxuICAgICAgICBkaXNhYmxlU3RyZWFtXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmtlcklkUHJvbWlzZS50aGVuKHdvcmtlcklkID0+IHtcbiAgICAgIGlmICh0YXNrLmRlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2FkaW5nIGFib3J0ZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAod29ya2VyLmRlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lc3NhZ2VIYW5kbGVyID0gbmV3IE1lc3NhZ2VIYW5kbGVyKGRvY0lkLCB3b3JrZXJJZCwgd29ya2VyLnBvcnQpO1xuICAgICAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFdvcmtlclRyYW5zcG9ydChtZXNzYWdlSGFuZGxlciwgdGFzaywgbmV0d29ya1N0cmVhbSwgdHJhbnNwb3J0UGFyYW1zLCB0cmFuc3BvcnRGYWN0b3J5KTtcbiAgICAgIHRhc2suX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLnNlbmQoXCJSZWFkeVwiLCBudWxsKTtcbiAgICB9KTtcbiAgfSkuY2F0Y2godGFzay5fY2FwYWJpbGl0eS5yZWplY3QpO1xuICByZXR1cm4gdGFzaztcbn1cbmZ1bmN0aW9uIGdldFVybFByb3AodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICByZXR1cm4gdmFsLmhyZWY7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFVSTCh2YWwsIHdpbmRvdy5sb2NhdGlvbikuaHJlZjtcbiAgfSBjYXRjaCB7XG4gICAgaWYgKGlzTm9kZUpTICYmIHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUERGIHVybCBkYXRhOiBcIiArIFwiZWl0aGVyIHN0cmluZyBvciBVUkwtb2JqZWN0IGlzIGV4cGVjdGVkIGluIHRoZSB1cmwgcHJvcGVydHkuXCIpO1xufVxuZnVuY3Rpb24gZ2V0RGF0YVByb3AodmFsKSB7XG4gIGlmIChpc05vZGVKUyAmJiB0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiICYmIHZhbCBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIGJpbmFyeSBkYXRhIGFzIGBVaW50OEFycmF5YCwgcmF0aGVyIHRoYW4gYEJ1ZmZlcmAuXCIpO1xuICB9XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIHZhbC5ieXRlTGVuZ3RoID09PSB2YWwuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHN0cmluZ1RvQnl0ZXModmFsKTtcbiAgfVxuICBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiAhaXNOYU4odmFsPy5sZW5ndGgpKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBQREYgYmluYXJ5IGRhdGE6IGVpdGhlciBUeXBlZEFycmF5LCBcIiArIFwic3RyaW5nLCBvciBhcnJheS1saWtlIG9iamVjdCBpcyBleHBlY3RlZCBpbiB0aGUgZGF0YSBwcm9wZXJ0eS5cIik7XG59XG5mdW5jdGlvbiBpc1JlZlByb3h5KHJlZikge1xuICByZXR1cm4gdHlwZW9mIHJlZiA9PT0gXCJvYmplY3RcIiAmJiBOdW1iZXIuaXNJbnRlZ2VyKHJlZj8ubnVtKSAmJiByZWYubnVtID49IDAgJiYgTnVtYmVyLmlzSW50ZWdlcihyZWY/LmdlbikgJiYgcmVmLmdlbiA+PSAwO1xufVxuY2xhc3MgUERGRG9jdW1lbnRMb2FkaW5nVGFzayB7XG4gIHN0YXRpYyAjZG9jSWQgPSAwO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9jYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICB0aGlzLl93b3JrZXIgPSBudWxsO1xuICAgIHRoaXMuZG9jSWQgPSBgZCR7UERGRG9jdW1lbnRMb2FkaW5nVGFzay4jZG9jSWQrK31gO1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5vblBhc3N3b3JkID0gbnVsbDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIGdldCBwcm9taXNlKCkge1xuICAgIHJldHVybiB0aGlzLl9jYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgYXN5bmMgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLl93b3JrZXI/LnBvcnQpIHtcbiAgICAgICAgdGhpcy5fd29ya2VyLl9wZW5kaW5nRGVzdHJveSA9IHRydWU7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLl90cmFuc3BvcnQ/LmRlc3Ryb3koKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgaWYgKHRoaXMuX3dvcmtlcj8ucG9ydCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fd29ya2VyLl9wZW5kaW5nRGVzdHJveTtcbiAgICAgIH1cbiAgICAgIHRocm93IGV4O1xuICAgIH1cbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMuX3dvcmtlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG4gIH1cbn1cbmNsYXNzIFBERkRhdGFSYW5nZVRyYW5zcG9ydCB7XG4gIGNvbnN0cnVjdG9yKGxlbmd0aCwgaW5pdGlhbERhdGEsIHByb2dyZXNzaXZlRG9uZSA9IGZhbHNlLCBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IG51bGwpIHtcbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB0aGlzLmluaXRpYWxEYXRhID0gaW5pdGlhbERhdGE7XG4gICAgdGhpcy5wcm9ncmVzc2l2ZURvbmUgPSBwcm9ncmVzc2l2ZURvbmU7XG4gICAgdGhpcy5jb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lO1xuICAgIHRoaXMuX3JhbmdlTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fcHJvZ3Jlc3NMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgfVxuICBhZGRSYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcmFuZ2VMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cbiAgYWRkUHJvZ3Jlc3NMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuX3Byb2dyZXNzTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIGFkZFByb2dyZXNzaXZlUmVhZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIGFkZFByb2dyZXNzaXZlRG9uZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIG9uRGF0YVJhbmdlKGJlZ2luLCBjaHVuaykge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fcmFuZ2VMaXN0ZW5lcnMpIHtcbiAgICAgIGxpc3RlbmVyKGJlZ2luLCBjaHVuayk7XG4gICAgfVxuICB9XG4gIG9uRGF0YVByb2dyZXNzKGxvYWRlZCwgdG90YWwpIHtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fcHJvZ3Jlc3NMaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXIobG9hZGVkLCB0b3RhbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgb25EYXRhUHJvZ3Jlc3NpdmVSZWFkKGNodW5rKSB7XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuX3Byb2dyZXNzaXZlUmVhZExpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lcihjaHVuayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgb25EYXRhUHJvZ3Jlc3NpdmVEb25lKCkge1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLl9wcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB0cmFuc3BvcnRSZWFkeSgpIHtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIHJlcXVlc3REYXRhUmFuZ2UoYmVnaW4sIGVuZCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIFBERkRhdGFSYW5nZVRyYW5zcG9ydC5yZXF1ZXN0RGF0YVJhbmdlXCIpO1xuICB9XG4gIGFib3J0KCkge31cbn1cbmNsYXNzIFBERkRvY3VtZW50UHJveHkge1xuICBjb25zdHJ1Y3RvcihwZGZJbmZvLCB0cmFuc3BvcnQpIHtcbiAgICB0aGlzLl9wZGZJbmZvID0gcGRmSW5mbztcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIH1cbiAgZ2V0IGFubm90YXRpb25TdG9yYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuYW5ub3RhdGlvblN0b3JhZ2U7XG4gIH1cbiAgZ2V0IGNhbnZhc0ZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5jYW52YXNGYWN0b3J5O1xuICB9XG4gIGdldCBmaWx0ZXJGYWN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZmlsdGVyRmFjdG9yeTtcbiAgfVxuICBnZXQgbnVtUGFnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BkZkluZm8ubnVtUGFnZXM7XG4gIH1cbiAgZ2V0IGZpbmdlcnByaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGRmSW5mby5maW5nZXJwcmludHM7XG4gIH1cbiAgZ2V0IGlzUHVyZVhmYSgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNQdXJlWGZhXCIsICEhdGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhKTtcbiAgfVxuICBnZXQgYWxsWGZhSHRtbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhO1xuICB9XG4gIGdldFBhZ2UocGFnZU51bWJlcikge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZShwYWdlTnVtYmVyKTtcbiAgfVxuICBnZXRQYWdlSW5kZXgocmVmKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlSW5kZXgocmVmKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREZXN0aW5hdGlvbnMoKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbihpZCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RGVzdGluYXRpb24oaWQpO1xuICB9XG4gIGdldFBhZ2VMYWJlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlTGFiZWxzKCk7XG4gIH1cbiAgZ2V0UGFnZUxheW91dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VMYXlvdXQoKTtcbiAgfVxuICBnZXRQYWdlTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VNb2RlKCk7XG4gIH1cbiAgZ2V0Vmlld2VyUHJlZmVyZW5jZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRWaWV3ZXJQcmVmZXJlbmNlcygpO1xuICB9XG4gIGdldE9wZW5BY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRPcGVuQWN0aW9uKCk7XG4gIH1cbiAgZ2V0QXR0YWNobWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRBdHRhY2htZW50cygpO1xuICB9XG4gIGdldEpTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERvY0pTQWN0aW9ucygpO1xuICB9XG4gIGdldE91dGxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRPdXRsaW5lKCk7XG4gIH1cbiAgZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKHtcbiAgICBpbnRlbnQgPSBcImRpc3BsYXlcIlxuICB9ID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICByZW5kZXJpbmdJbnRlbnRcbiAgICB9ID0gdGhpcy5fdHJhbnNwb3J0LmdldFJlbmRlcmluZ0ludGVudChpbnRlbnQpO1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKHJlbmRlcmluZ0ludGVudCk7XG4gIH1cbiAgZ2V0UGVybWlzc2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQZXJtaXNzaW9ucygpO1xuICB9XG4gIGdldE1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0TWV0YWRhdGEoKTtcbiAgfVxuICBnZXRNYXJrSW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE1hcmtJbmZvKCk7XG4gIH1cbiAgZ2V0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERhdGEoKTtcbiAgfVxuICBzYXZlRG9jdW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5zYXZlRG9jdW1lbnQoKTtcbiAgfVxuICBnZXREb3dubG9hZEluZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5kb3dubG9hZEluZm9DYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2xlYW51cChrZWVwTG9hZGVkRm9udHMgPSBmYWxzZSkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuc3RhcnRDbGVhbnVwKGtlZXBMb2FkZWRGb250cyB8fCB0aGlzLmlzUHVyZVhmYSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkaW5nVGFzay5kZXN0cm95KCk7XG4gIH1cbiAgY2FjaGVkUGFnZU51bWJlcihyZWYpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmNhY2hlZFBhZ2VOdW1iZXIocmVmKTtcbiAgfVxuICBnZXQgbG9hZGluZ1BhcmFtcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmxvYWRpbmdQYXJhbXM7XG4gIH1cbiAgZ2V0IGxvYWRpbmdUYXNrKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQubG9hZGluZ1Rhc2s7XG4gIH1cbiAgZ2V0RmllbGRPYmplY3RzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RmllbGRPYmplY3RzKCk7XG4gIH1cbiAgaGFzSlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuaGFzSlNBY3Rpb25zKCk7XG4gIH1cbiAgZ2V0Q2FsY3VsYXRpb25PcmRlcklkcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldENhbGN1bGF0aW9uT3JkZXJJZHMoKTtcbiAgfVxufVxuY2xhc3MgUERGUGFnZVByb3h5IHtcbiAgI2RlbGF5ZWRDbGVhbnVwVGltZW91dCA9IG51bGw7XG4gICNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICBjb25zdHJ1Y3RvcihwYWdlSW5kZXgsIHBhZ2VJbmZvLCB0cmFuc3BvcnQsIHBkZkJ1ZyA9IGZhbHNlKSB7XG4gICAgdGhpcy5fcGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgIHRoaXMuX3BhZ2VJbmZvID0gcGFnZUluZm87XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIHRoaXMuX3N0YXRzID0gcGRmQnVnID8gbmV3IFN0YXRUaW1lcigpIDogbnVsbDtcbiAgICB0aGlzLl9wZGZCdWcgPSBwZGZCdWc7XG4gICAgdGhpcy5jb21tb25PYmpzID0gdHJhbnNwb3J0LmNvbW1vbk9ianM7XG4gICAgdGhpcy5vYmpzID0gbmV3IFBERk9iamVjdHMoKTtcbiAgICB0aGlzLl9tYXliZUNsZWFudXBBZnRlclJlbmRlciA9IGZhbHNlO1xuICAgIHRoaXMuX2ludGVudFN0YXRlcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICB9XG4gIGdldCBwYWdlTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5kZXggKyAxO1xuICB9XG4gIGdldCByb3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnJvdGF0ZTtcbiAgfVxuICBnZXQgcmVmKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby5yZWY7XG4gIH1cbiAgZ2V0IHVzZXJVbml0KCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby51c2VyVW5pdDtcbiAgfVxuICBnZXQgdmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZm8udmlldztcbiAgfVxuICBnZXRWaWV3cG9ydCh7XG4gICAgc2NhbGUsXG4gICAgcm90YXRpb24gPSB0aGlzLnJvdGF0ZSxcbiAgICBvZmZzZXRYID0gMCxcbiAgICBvZmZzZXRZID0gMCxcbiAgICBkb250RmxpcCA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHJldHVybiBuZXcgUGFnZVZpZXdwb3J0KHtcbiAgICAgIHZpZXdCb3g6IHRoaXMudmlldyxcbiAgICAgIHVzZXJVbml0OiB0aGlzLnVzZXJVbml0LFxuICAgICAgc2NhbGUsXG4gICAgICByb3RhdGlvbixcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZLFxuICAgICAgZG9udEZsaXBcbiAgICB9KTtcbiAgfVxuICBnZXRBbm5vdGF0aW9ucyh7XG4gICAgaW50ZW50ID0gXCJkaXNwbGF5XCJcbiAgfSA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVuZGVyaW5nSW50ZW50XG4gICAgfSA9IHRoaXMuX3RyYW5zcG9ydC5nZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50KTtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldEFubm90YXRpb25zKHRoaXMuX3BhZ2VJbmRleCwgcmVuZGVyaW5nSW50ZW50KTtcbiAgfVxuICBnZXRKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlSlNBY3Rpb25zKHRoaXMuX3BhZ2VJbmRleCk7XG4gIH1cbiAgZ2V0IGZpbHRlckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5maWx0ZXJGYWN0b3J5O1xuICB9XG4gIGdldCBpc1B1cmVYZmEoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzUHVyZVhmYVwiLCAhIXRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYSk7XG4gIH1cbiAgYXN5bmMgZ2V0WGZhKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmE/LmNoaWxkcmVuW3RoaXMuX3BhZ2VJbmRleF0gfHwgbnVsbDtcbiAgfVxuICByZW5kZXIoe1xuICAgIGNhbnZhc0NvbnRleHQsXG4gICAgdmlld3BvcnQsXG4gICAgaW50ZW50ID0gXCJkaXNwbGF5XCIsXG4gICAgYW5ub3RhdGlvbk1vZGUgPSBBbm5vdGF0aW9uTW9kZS5FTkFCTEUsXG4gICAgdHJhbnNmb3JtID0gbnVsbCxcbiAgICBiYWNrZ3JvdW5kID0gbnVsbCxcbiAgICBvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlID0gbnVsbCxcbiAgICBhbm5vdGF0aW9uQ2FudmFzTWFwID0gbnVsbCxcbiAgICBwYWdlQ29sb3JzID0gbnVsbCxcbiAgICBwcmludEFubm90YXRpb25TdG9yYWdlID0gbnVsbCxcbiAgICBpc0VkaXRpbmcgPSBmYWxzZVxuICB9KSB7XG4gICAgdGhpcy5fc3RhdHM/LnRpbWUoXCJPdmVyYWxsXCIpO1xuICAgIGNvbnN0IGludGVudEFyZ3MgPSB0aGlzLl90cmFuc3BvcnQuZ2V0UmVuZGVyaW5nSW50ZW50KGludGVudCwgYW5ub3RhdGlvbk1vZGUsIHByaW50QW5ub3RhdGlvblN0b3JhZ2UsIGlzRWRpdGluZyk7XG4gICAgY29uc3Qge1xuICAgICAgcmVuZGVyaW5nSW50ZW50LFxuICAgICAgY2FjaGVLZXlcbiAgICB9ID0gaW50ZW50QXJncztcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICAgIHRoaXMuI2Fib3J0RGVsYXllZENsZWFudXAoKTtcbiAgICBvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlIHx8PSB0aGlzLl90cmFuc3BvcnQuZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKHJlbmRlcmluZ0ludGVudCk7XG4gICAgbGV0IGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChjYWNoZUtleSk7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZSkge1xuICAgICAgaW50ZW50U3RhdGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5faW50ZW50U3RhdGVzLnNldChjYWNoZUtleSwgaW50ZW50U3RhdGUpO1xuICAgIH1cbiAgICBpZiAoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQpO1xuICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGludGVudFByaW50ID0gISEocmVuZGVyaW5nSW50ZW50ICYgUmVuZGVyaW5nSW50ZW50RmxhZy5QUklOVCk7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5KSB7XG4gICAgICBpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QgPSB7XG4gICAgICAgIGZuQXJyYXk6IFtdLFxuICAgICAgICBhcmdzQXJyYXk6IFtdLFxuICAgICAgICBsYXN0Q2h1bms6IGZhbHNlLFxuICAgICAgICBzZXBhcmF0ZUFubm90czogbnVsbFxuICAgICAgfTtcbiAgICAgIHRoaXMuX3N0YXRzPy50aW1lKFwiUGFnZSBSZXF1ZXN0XCIpO1xuICAgICAgdGhpcy5fcHVtcE9wZXJhdG9yTGlzdChpbnRlbnRBcmdzKTtcbiAgICB9XG4gICAgY29uc3QgY29tcGxldGUgPSBlcnJvciA9PiB7XG4gICAgICBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5kZWxldGUoaW50ZXJuYWxSZW5kZXJUYXNrKTtcbiAgICAgIGlmICh0aGlzLl9tYXliZUNsZWFudXBBZnRlclJlbmRlciB8fCBpbnRlbnRQcmludCkge1xuICAgICAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLiN0cnlDbGVhbnVwKCFpbnRlbnRQcmludCk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmNhcGFiaWxpdHkucmVqZWN0KGVycm9yKTtcbiAgICAgICAgdGhpcy5fYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgICAgICAgIGludGVudFN0YXRlLFxuICAgICAgICAgIHJlYXNvbjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKGVycm9yKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVybmFsUmVuZGVyVGFzay5jYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9zdGF0cykge1xuICAgICAgICB0aGlzLl9zdGF0cy50aW1lRW5kKFwiUmVuZGVyaW5nXCIpO1xuICAgICAgICB0aGlzLl9zdGF0cy50aW1lRW5kKFwiT3ZlcmFsbFwiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuU3RhdHM/LmVuYWJsZWQpIHtcbiAgICAgICAgICBnbG9iYWxUaGlzLlN0YXRzLmFkZCh0aGlzLnBhZ2VOdW1iZXIsIHRoaXMuX3N0YXRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW50ZXJuYWxSZW5kZXJUYXNrID0gbmV3IEludGVybmFsUmVuZGVyVGFzayh7XG4gICAgICBjYWxsYmFjazogY29tcGxldGUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgY2FudmFzQ29udGV4dCxcbiAgICAgICAgdmlld3BvcnQsXG4gICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgYmFja2dyb3VuZFxuICAgICAgfSxcbiAgICAgIG9ianM6IHRoaXMub2JqcyxcbiAgICAgIGNvbW1vbk9ianM6IHRoaXMuY29tbW9uT2JqcyxcbiAgICAgIGFubm90YXRpb25DYW52YXNNYXAsXG4gICAgICBvcGVyYXRvckxpc3Q6IGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5fcGFnZUluZGV4LFxuICAgICAgY2FudmFzRmFjdG9yeTogdGhpcy5fdHJhbnNwb3J0LmNhbnZhc0ZhY3RvcnksXG4gICAgICBmaWx0ZXJGYWN0b3J5OiB0aGlzLl90cmFuc3BvcnQuZmlsdGVyRmFjdG9yeSxcbiAgICAgIHVzZVJlcXVlc3RBbmltYXRpb25GcmFtZTogIWludGVudFByaW50LFxuICAgICAgcGRmQnVnOiB0aGlzLl9wZGZCdWcsXG4gICAgICBwYWdlQ29sb3JzXG4gICAgfSk7XG4gICAgKGludGVudFN0YXRlLnJlbmRlclRhc2tzIHx8PSBuZXcgU2V0KCkpLmFkZChpbnRlcm5hbFJlbmRlclRhc2spO1xuICAgIGNvbnN0IHJlbmRlclRhc2sgPSBpbnRlcm5hbFJlbmRlclRhc2sudGFzaztcbiAgICBQcm9taXNlLmFsbChbaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eS5wcm9taXNlLCBvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlXSkudGhlbigoW3RyYW5zcGFyZW5jeSwgb3B0aW9uYWxDb250ZW50Q29uZmlnXSkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0YXRzPy50aW1lKFwiUmVuZGVyaW5nXCIpO1xuICAgICAgaWYgKCEob3B0aW9uYWxDb250ZW50Q29uZmlnLnJlbmRlcmluZ0ludGVudCAmIHJlbmRlcmluZ0ludGVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCB1c2UgdGhlIHNhbWUgYGludGVudGAtYXJndW1lbnQgd2hlbiBjYWxsaW5nIHRoZSBgUERGUGFnZVByb3h5LnJlbmRlcmAgXCIgKyBcImFuZCBgUERGRG9jdW1lbnRQcm94eS5nZXRPcHRpb25hbENvbnRlbnRDb25maWdgIG1ldGhvZHMuXCIpO1xuICAgICAgfVxuICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmluaXRpYWxpemVHcmFwaGljcyh7XG4gICAgICAgIHRyYW5zcGFyZW5jeSxcbiAgICAgICAgb3B0aW9uYWxDb250ZW50Q29uZmlnXG4gICAgICB9KTtcbiAgICAgIGludGVybmFsUmVuZGVyVGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkKCk7XG4gICAgfSkuY2F0Y2goY29tcGxldGUpO1xuICAgIHJldHVybiByZW5kZXJUYXNrO1xuICB9XG4gIGdldE9wZXJhdG9yTGlzdCh7XG4gICAgaW50ZW50ID0gXCJkaXNwbGF5XCIsXG4gICAgYW5ub3RhdGlvbk1vZGUgPSBBbm5vdGF0aW9uTW9kZS5FTkFCTEUsXG4gICAgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA9IG51bGwsXG4gICAgaXNFZGl0aW5nID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgZnVuY3Rpb24gb3BlcmF0b3JMaXN0Q2hhbmdlZCgpIHtcbiAgICAgIGlmIChpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QubGFzdENodW5rKSB7XG4gICAgICAgIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5LnJlc29sdmUoaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0KTtcbiAgICAgICAgaW50ZW50U3RhdGUucmVuZGVyVGFza3MuZGVsZXRlKG9wTGlzdFRhc2spO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbnRlbnRBcmdzID0gdGhpcy5fdHJhbnNwb3J0LmdldFJlbmRlcmluZ0ludGVudChpbnRlbnQsIGFubm90YXRpb25Nb2RlLCBwcmludEFubm90YXRpb25TdG9yYWdlLCBpc0VkaXRpbmcsIHRydWUpO1xuICAgIGxldCBpbnRlbnRTdGF0ZSA9IHRoaXMuX2ludGVudFN0YXRlcy5nZXQoaW50ZW50QXJncy5jYWNoZUtleSk7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZSkge1xuICAgICAgaW50ZW50U3RhdGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5faW50ZW50U3RhdGVzLnNldChpbnRlbnRBcmdzLmNhY2hlS2V5LCBpbnRlbnRTdGF0ZSk7XG4gICAgfVxuICAgIGxldCBvcExpc3RUYXNrO1xuICAgIGlmICghaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkpIHtcbiAgICAgIG9wTGlzdFRhc2sgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgb3BMaXN0VGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkID0gb3BlcmF0b3JMaXN0Q2hhbmdlZDtcbiAgICAgIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICAoaW50ZW50U3RhdGUucmVuZGVyVGFza3MgfHw9IG5ldyBTZXQoKSkuYWRkKG9wTGlzdFRhc2spO1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0ID0ge1xuICAgICAgICBmbkFycmF5OiBbXSxcbiAgICAgICAgYXJnc0FycmF5OiBbXSxcbiAgICAgICAgbGFzdENodW5rOiBmYWxzZSxcbiAgICAgICAgc2VwYXJhdGVBbm5vdHM6IG51bGxcbiAgICAgIH07XG4gICAgICB0aGlzLl9zdGF0cz8udGltZShcIlBhZ2UgUmVxdWVzdFwiKTtcbiAgICAgIHRoaXMuX3B1bXBPcGVyYXRvckxpc3QoaW50ZW50QXJncyk7XG4gICAgfVxuICAgIHJldHVybiBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIHN0cmVhbVRleHRDb250ZW50KHtcbiAgICBpbmNsdWRlTWFya2VkQ29udGVudCA9IGZhbHNlLFxuICAgIGRpc2FibGVOb3JtYWxpemF0aW9uID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgVEVYVF9DT05URU5UX0NIVU5LX1NJWkUgPSAxMDA7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFN0cmVhbShcIkdldFRleHRDb250ZW50XCIsIHtcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5fcGFnZUluZGV4LFxuICAgICAgaW5jbHVkZU1hcmtlZENvbnRlbnQ6IGluY2x1ZGVNYXJrZWRDb250ZW50ID09PSB0cnVlLFxuICAgICAgZGlzYWJsZU5vcm1hbGl6YXRpb246IGRpc2FibGVOb3JtYWxpemF0aW9uID09PSB0cnVlXG4gICAgfSwge1xuICAgICAgaGlnaFdhdGVyTWFyazogVEVYVF9DT05URU5UX0NIVU5LX1NJWkUsXG4gICAgICBzaXplKHRleHRDb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0ZXh0Q29udGVudC5pdGVtcy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0VGV4dENvbnRlbnQocGFyYW1zID0ge30pIHtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRYZmEoKS50aGVuKHhmYSA9PiBYZmFUZXh0LnRleHRDb250ZW50KHhmYSkpO1xuICAgIH1cbiAgICBjb25zdCByZWFkYWJsZVN0cmVhbSA9IHRoaXMuc3RyZWFtVGV4dENvbnRlbnQocGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gcHVtcCgpIHtcbiAgICAgICAgcmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uICh7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9KSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHJlc29sdmUodGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZXh0Q29udGVudC5sYW5nID8/PSB2YWx1ZS5sYW5nO1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24odGV4dENvbnRlbnQuc3R5bGVzLCB2YWx1ZS5zdHlsZXMpO1xuICAgICAgICAgIHRleHRDb250ZW50Lml0ZW1zLnB1c2goLi4udmFsdWUuaXRlbXMpO1xuICAgICAgICAgIHB1bXAoKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlYWRhYmxlU3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgY29uc3QgdGV4dENvbnRlbnQgPSB7XG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgc3R5bGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICBsYW5nOiBudWxsXG4gICAgICB9O1xuICAgICAgcHVtcCgpO1xuICAgIH0pO1xuICB9XG4gIGdldFN0cnVjdFRyZWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRTdHJ1Y3RUcmVlKHRoaXMuX3BhZ2VJbmRleCk7XG4gIH1cbiAgX2Rlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIGNvbnN0IHdhaXRPbiA9IFtdO1xuICAgIGZvciAoY29uc3QgaW50ZW50U3RhdGUgb2YgdGhpcy5faW50ZW50U3RhdGVzLnZhbHVlcygpKSB7XG4gICAgICB0aGlzLl9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgICAgIGludGVudFN0YXRlLFxuICAgICAgICByZWFzb246IG5ldyBFcnJvcihcIlBhZ2Ugd2FzIGRlc3Ryb3llZC5cIiksXG4gICAgICAgIGZvcmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGlmIChpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgaW50ZXJuYWxSZW5kZXJUYXNrIG9mIGludGVudFN0YXRlLnJlbmRlclRhc2tzKSB7XG4gICAgICAgIHdhaXRPbi5wdXNoKGludGVybmFsUmVuZGVyVGFzay5jb21wbGV0ZWQpO1xuICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2suY2FuY2VsKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMub2Jqcy5jbGVhcigpO1xuICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gICAgdGhpcy4jYWJvcnREZWxheWVkQ2xlYW51cCgpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbCh3YWl0T24pO1xuICB9XG4gIGNsZWFudXAocmVzZXRTdGF0cyA9IGZhbHNlKSB7XG4gICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSB0cnVlO1xuICAgIGNvbnN0IHN1Y2Nlc3MgPSB0aGlzLiN0cnlDbGVhbnVwKGZhbHNlKTtcbiAgICBpZiAocmVzZXRTdGF0cyAmJiBzdWNjZXNzKSB7XG4gICAgICB0aGlzLl9zdGF0cyAmJj0gbmV3IFN0YXRUaW1lcigpO1xuICAgIH1cbiAgICByZXR1cm4gc3VjY2VzcztcbiAgfVxuICAjdHJ5Q2xlYW51cChkZWxheWVkID0gZmFsc2UpIHtcbiAgICB0aGlzLiNhYm9ydERlbGF5ZWRDbGVhbnVwKCk7XG4gICAgaWYgKCF0aGlzLiNwZW5kaW5nQ2xlYW51cCB8fCB0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGVsYXllZCkge1xuICAgICAgdGhpcy4jZGVsYXllZENsZWFudXBUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuI2RlbGF5ZWRDbGVhbnVwVGltZW91dCA9IG51bGw7XG4gICAgICAgIHRoaXMuI3RyeUNsZWFudXAoZmFsc2UpO1xuICAgICAgfSwgREVMQVlFRF9DTEVBTlVQX1RJTUVPVVQpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHJlbmRlclRhc2tzLFxuICAgICAgb3BlcmF0b3JMaXN0XG4gICAgfSBvZiB0aGlzLl9pbnRlbnRTdGF0ZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChyZW5kZXJUYXNrcy5zaXplID4gMCB8fCAhb3BlcmF0b3JMaXN0Lmxhc3RDaHVuaykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2ludGVudFN0YXRlcy5jbGVhcigpO1xuICAgIHRoaXMub2Jqcy5jbGVhcigpO1xuICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgI2Fib3J0RGVsYXllZENsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuI2RlbGF5ZWRDbGVhbnVwVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2RlbGF5ZWRDbGVhbnVwVGltZW91dCk7XG4gICAgICB0aGlzLiNkZWxheWVkQ2xlYW51cFRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBfc3RhcnRSZW5kZXJQYWdlKHRyYW5zcGFyZW5jeSwgY2FjaGVLZXkpIHtcbiAgICBjb25zdCBpbnRlbnRTdGF0ZSA9IHRoaXMuX2ludGVudFN0YXRlcy5nZXQoY2FjaGVLZXkpO1xuICAgIGlmICghaW50ZW50U3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc3RhdHM/LnRpbWVFbmQoXCJQYWdlIFJlcXVlc3RcIik7XG4gICAgaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eT8ucmVzb2x2ZSh0cmFuc3BhcmVuY3kpO1xuICB9XG4gIF9yZW5kZXJQYWdlQ2h1bmsob3BlcmF0b3JMaXN0Q2h1bmssIGludGVudFN0YXRlKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gb3BlcmF0b3JMaXN0Q2h1bmsubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LmZuQXJyYXkucHVzaChvcGVyYXRvckxpc3RDaHVuay5mbkFycmF5W2ldKTtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5hcmdzQXJyYXkucHVzaChvcGVyYXRvckxpc3RDaHVuay5hcmdzQXJyYXlbaV0pO1xuICAgIH1cbiAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QubGFzdENodW5rID0gb3BlcmF0b3JMaXN0Q2h1bmsubGFzdENodW5rO1xuICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5zZXBhcmF0ZUFubm90cyA9IG9wZXJhdG9yTGlzdENodW5rLnNlcGFyYXRlQW5ub3RzO1xuICAgIGZvciAoY29uc3QgaW50ZXJuYWxSZW5kZXJUYXNrIG9mIGludGVudFN0YXRlLnJlbmRlclRhc2tzKSB7XG4gICAgICBpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0Q2hhbmdlZCgpO1xuICAgIH1cbiAgICBpZiAob3BlcmF0b3JMaXN0Q2h1bmsubGFzdENodW5rKSB7XG4gICAgICB0aGlzLiN0cnlDbGVhbnVwKHRydWUpO1xuICAgIH1cbiAgfVxuICBfcHVtcE9wZXJhdG9yTGlzdCh7XG4gICAgcmVuZGVyaW5nSW50ZW50LFxuICAgIGNhY2hlS2V5LFxuICAgIGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlLFxuICAgIG1vZGlmaWVkSWRzXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBtYXAsXG4gICAgICB0cmFuc2ZlclxuICAgIH0gPSBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZTtcbiAgICBjb25zdCByZWFkYWJsZVN0cmVhbSA9IHRoaXMuX3RyYW5zcG9ydC5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFN0cmVhbShcIkdldE9wZXJhdG9yTGlzdFwiLCB7XG4gICAgICBwYWdlSW5kZXg6IHRoaXMuX3BhZ2VJbmRleCxcbiAgICAgIGludGVudDogcmVuZGVyaW5nSW50ZW50LFxuICAgICAgY2FjaGVLZXksXG4gICAgICBhbm5vdGF0aW9uU3RvcmFnZTogbWFwLFxuICAgICAgbW9kaWZpZWRJZHNcbiAgICB9LCB0cmFuc2Zlcik7XG4gICAgY29uc3QgcmVhZGVyID0gcmVhZGFibGVTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgY29uc3QgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGNhY2hlS2V5KTtcbiAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSByZWFkZXI7XG4gICAgY29uc3QgcHVtcCA9ICgpID0+IHtcbiAgICAgIHJlYWRlci5yZWFkKCkudGhlbigoe1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZG9uZVxuICAgICAgfSkgPT4ge1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90cmFuc3BvcnQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbmRlclBhZ2VDaHVuayh2YWx1ZSwgaW50ZW50U3RhdGUpO1xuICAgICAgICBwdW1wKCk7XG4gICAgICB9LCByZWFzb24gPT4ge1xuICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0KSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0Lmxhc3RDaHVuayA9IHRydWU7XG4gICAgICAgICAgZm9yIChjb25zdCBpbnRlcm5hbFJlbmRlclRhc2sgb2YgaW50ZW50U3RhdGUucmVuZGVyVGFza3MpIHtcbiAgICAgICAgICAgIGludGVybmFsUmVuZGVyVGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuI3RyeUNsZWFudXAodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5LnJlamVjdChyZWFzb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5KSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHB1bXAoKTtcbiAgfVxuICBfYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgIGludGVudFN0YXRlLFxuICAgIHJlYXNvbixcbiAgICBmb3JjZSA9IGZhbHNlXG4gIH0pIHtcbiAgICBpZiAoIWludGVudFN0YXRlLnN0cmVhbVJlYWRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQpO1xuICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIGlmICghZm9yY2UpIHtcbiAgICAgIGlmIChpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5zaXplID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocmVhc29uIGluc3RhbmNlb2YgUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uKSB7XG4gICAgICAgIGxldCBkZWxheSA9IFJFTkRFUklOR19DQU5DRUxMRURfVElNRU9VVDtcbiAgICAgICAgaWYgKHJlYXNvbi5leHRyYURlbGF5ID4gMCAmJiByZWFzb24uZXh0cmFEZWxheSA8IDEwMDApIHtcbiAgICAgICAgICBkZWxheSArPSByZWFzb24uZXh0cmFEZWxheTtcbiAgICAgICAgfVxuICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgICAgICAgICAgaW50ZW50U3RhdGUsXG4gICAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgICBmb3JjZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyLmNhbmNlbChuZXcgQWJvcnRFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UpKS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gbnVsbDtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtjdXJDYWNoZUtleSwgY3VySW50ZW50U3RhdGVdIG9mIHRoaXMuX2ludGVudFN0YXRlcykge1xuICAgICAgaWYgKGN1ckludGVudFN0YXRlID09PSBpbnRlbnRTdGF0ZSkge1xuICAgICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuZGVsZXRlKGN1ckNhY2hlS2V5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2xlYW51cCgpO1xuICB9XG4gIGdldCBzdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHM7XG4gIH1cbn1cbmNsYXNzIExvb3BiYWNrUG9ydCB7XG4gICNsaXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICNkZWZlcnJlZCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICBwb3N0TWVzc2FnZShvYmosIHRyYW5zZmVyKSB7XG4gICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICBkYXRhOiBzdHJ1Y3R1cmVkQ2xvbmUob2JqLCB0cmFuc2ZlciA/IHtcbiAgICAgICAgdHJhbnNmZXJcbiAgICAgIH0gOiBudWxsKVxuICAgIH07XG4gICAgdGhpcy4jZGVmZXJyZWQudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IFtsaXN0ZW5lcl0gb2YgdGhpcy4jbGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIsIG9wdGlvbnMgPSBudWxsKSB7XG4gICAgbGV0IHJtQWJvcnQgPSBudWxsO1xuICAgIGlmIChvcHRpb25zPy5zaWduYWwgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHdhcm4oXCJMb29wYmFja1BvcnQgLSBjYW5ub3QgdXNlIGFuIGBhYm9ydGVkYCBzaWduYWwuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvbkFib3J0ID0gKCkgPT4gdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKTtcbiAgICAgIHJtQWJvcnQgPSAoKSA9PiBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICB9XG4gICAgdGhpcy4jbGlzdGVuZXJzLnNldChsaXN0ZW5lciwgcm1BYm9ydCk7XG4gIH1cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IHJtQWJvcnQgPSB0aGlzLiNsaXN0ZW5lcnMuZ2V0KGxpc3RlbmVyKTtcbiAgICBybUFib3J0Py4oKTtcbiAgICB0aGlzLiNsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgfVxuICB0ZXJtaW5hdGUoKSB7XG4gICAgZm9yIChjb25zdCBbLCBybUFib3J0XSBvZiB0aGlzLiNsaXN0ZW5lcnMpIHtcbiAgICAgIHJtQWJvcnQ/LigpO1xuICAgIH1cbiAgICB0aGlzLiNsaXN0ZW5lcnMuY2xlYXIoKTtcbiAgfVxufVxuY2xhc3MgUERGV29ya2VyIHtcbiAgc3RhdGljICNmYWtlV29ya2VySWQgPSAwO1xuICBzdGF0aWMgI2lzV29ya2VyRGlzYWJsZWQgPSBmYWxzZTtcbiAgc3RhdGljICN3b3JrZXJQb3J0cztcbiAgc3RhdGljIHtcbiAgICBpZiAoaXNOb2RlSlMpIHtcbiAgICAgIHRoaXMuI2lzV29ya2VyRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMgfHw9IFwiLi9wZGYud29ya2VyLm1qc1wiO1xuICAgIH1cbiAgICB0aGlzLl9pc1NhbWVPcmlnaW4gPSAoYmFzZVVybCwgb3RoZXJVcmwpID0+IHtcbiAgICAgIGxldCBiYXNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYmFzZSA9IG5ldyBVUkwoYmFzZVVybCk7XG4gICAgICAgIGlmICghYmFzZS5vcmlnaW4gfHwgYmFzZS5vcmlnaW4gPT09IFwibnVsbFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3RoZXIgPSBuZXcgVVJMKG90aGVyVXJsLCBiYXNlKTtcbiAgICAgIHJldHVybiBiYXNlLm9yaWdpbiA9PT0gb3RoZXIub3JpZ2luO1xuICAgIH07XG4gICAgdGhpcy5fY3JlYXRlQ0ROV3JhcHBlciA9IHVybCA9PiB7XG4gICAgICBjb25zdCB3cmFwcGVyID0gYGF3YWl0IGltcG9ydChcIiR7dXJsfVwiKTtgO1xuICAgICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW3dyYXBwZXJdLCB7XG4gICAgICAgIHR5cGU6IFwidGV4dC9qYXZhc2NyaXB0XCJcbiAgICAgIH0pKTtcbiAgICB9O1xuICB9XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBuYW1lID0gbnVsbCxcbiAgICBwb3J0ID0gbnVsbCxcbiAgICB2ZXJib3NpdHkgPSBnZXRWZXJib3NpdHlMZXZlbCgpXG4gIH0gPSB7fSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnZlcmJvc2l0eSA9IHZlcmJvc2l0eTtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9wb3J0ID0gbnVsbDtcbiAgICB0aGlzLl93ZWJXb3JrZXIgPSBudWxsO1xuICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbnVsbDtcbiAgICBpZiAocG9ydCkge1xuICAgICAgaWYgKFBERldvcmtlci4jd29ya2VyUG9ydHM/Lmhhcyhwb3J0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIG1vcmUgdGhhbiBvbmUgUERGV29ya2VyIHBlciBwb3J0LlwiKTtcbiAgICAgIH1cbiAgICAgIChQREZXb3JrZXIuI3dvcmtlclBvcnRzIHx8PSBuZXcgV2Vha01hcCgpKS5zZXQocG9ydCwgdGhpcyk7XG4gICAgICB0aGlzLl9pbml0aWFsaXplRnJvbVBvcnQocG9ydCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxpemUoKTtcbiAgfVxuICBnZXQgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgI3Jlc29sdmUoKSB7XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB0aGlzLl9tZXNzYWdlSGFuZGxlci5zZW5kKFwiY29uZmlndXJlXCIsIHtcbiAgICAgIHZlcmJvc2l0eTogdGhpcy52ZXJib3NpdHlcbiAgICB9KTtcbiAgfVxuICBnZXQgcG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9ydDtcbiAgfVxuICBnZXQgbWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lc3NhZ2VIYW5kbGVyO1xuICB9XG4gIF9pbml0aWFsaXplRnJvbVBvcnQocG9ydCkge1xuICAgIHRoaXMuX3BvcnQgPSBwb3J0O1xuICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbmV3IE1lc3NhZ2VIYW5kbGVyKFwibWFpblwiLCBcIndvcmtlclwiLCBwb3J0KTtcbiAgICB0aGlzLl9tZXNzYWdlSGFuZGxlci5vbihcInJlYWR5XCIsIGZ1bmN0aW9uICgpIHt9KTtcbiAgICB0aGlzLiNyZXNvbHZlKCk7XG4gIH1cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgaWYgKFBERldvcmtlci4jaXNXb3JrZXJEaXNhYmxlZCB8fCBQREZXb3JrZXIuI21haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlcikge1xuICAgICAgdGhpcy5fc2V0dXBGYWtlV29ya2VyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB7XG4gICAgICB3b3JrZXJTcmNcbiAgICB9ID0gUERGV29ya2VyO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIVBERldvcmtlci5faXNTYW1lT3JpZ2luKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCB3b3JrZXJTcmMpKSB7XG4gICAgICAgIHdvcmtlclNyYyA9IFBERldvcmtlci5fY3JlYXRlQ0ROV3JhcHBlcihuZXcgVVJMKHdvcmtlclNyYywgd2luZG93LmxvY2F0aW9uKS5ocmVmKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyU3JjLCB7XG4gICAgICAgIHR5cGU6IFwibW9kdWxlXCJcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSBuZXcgTWVzc2FnZUhhbmRsZXIoXCJtYWluXCIsIFwid29ya2VyXCIsIHdvcmtlcik7XG4gICAgICBjb25zdCB0ZXJtaW5hdGVFYXJseSA9ICgpID0+IHtcbiAgICAgICAgYWMuYWJvcnQoKTtcbiAgICAgICAgbWVzc2FnZUhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5yZWplY3QobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NldHVwRmFrZVdvcmtlcigpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsICgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLl93ZWJXb3JrZXIpIHtcbiAgICAgICAgICB0ZXJtaW5hdGVFYXJseSgpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbDogYWMuc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwidGVzdFwiLCBkYXRhID0+IHtcbiAgICAgICAgYWMuYWJvcnQoKTtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkIHx8ICFkYXRhKSB7XG4gICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIgPSBtZXNzYWdlSGFuZGxlcjtcbiAgICAgICAgdGhpcy5fcG9ydCA9IHdvcmtlcjtcbiAgICAgICAgdGhpcy5fd2ViV29ya2VyID0gd29ya2VyO1xuICAgICAgICB0aGlzLiNyZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwicmVhZHlcIiwgZGF0YSA9PiB7XG4gICAgICAgIGFjLmFib3J0KCk7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHRlcm1pbmF0ZUVhcmx5KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2VuZFRlc3QoKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgdGhpcy5fc2V0dXBGYWtlV29ya2VyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc2VuZFRlc3QgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRlc3RPYmogPSBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlSGFuZGxlci5zZW5kKFwidGVzdFwiLCB0ZXN0T2JqLCBbdGVzdE9iai5idWZmZXJdKTtcbiAgICAgIH07XG4gICAgICBzZW5kVGVzdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gY2F0Y2gge1xuICAgICAgaW5mbyhcIlRoZSB3b3JrZXIgaGFzIGJlZW4gZGlzYWJsZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLl9zZXR1cEZha2VXb3JrZXIoKTtcbiAgfVxuICBfc2V0dXBGYWtlV29ya2VyKCkge1xuICAgIGlmICghUERGV29ya2VyLiNpc1dvcmtlckRpc2FibGVkKSB7XG4gICAgICB3YXJuKFwiU2V0dGluZyB1cCBmYWtlIHdvcmtlci5cIik7XG4gICAgICBQREZXb3JrZXIuI2lzV29ya2VyRGlzYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBQREZXb3JrZXIuX3NldHVwRmFrZVdvcmtlckdsb2JhbC50aGVuKFdvcmtlck1lc3NhZ2VIYW5kbGVyID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9ydCA9IG5ldyBMb29wYmFja1BvcnQoKTtcbiAgICAgIHRoaXMuX3BvcnQgPSBwb3J0O1xuICAgICAgY29uc3QgaWQgPSBgZmFrZSR7UERGV29ya2VyLiNmYWtlV29ya2VySWQrK31gO1xuICAgICAgY29uc3Qgd29ya2VySGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcihpZCArIFwiX3dvcmtlclwiLCBpZCwgcG9ydCk7XG4gICAgICBXb3JrZXJNZXNzYWdlSGFuZGxlci5zZXR1cCh3b3JrZXJIYW5kbGVyLCBwb3J0KTtcbiAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbmV3IE1lc3NhZ2VIYW5kbGVyKGlkLCBpZCArIFwiX3dvcmtlclwiLCBwb3J0KTtcbiAgICAgIHRoaXMuI3Jlc29sdmUoKTtcbiAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlamVjdChuZXcgRXJyb3IoYFNldHRpbmcgdXAgZmFrZSB3b3JrZXIgZmFpbGVkOiBcIiR7cmVhc29uLm1lc3NhZ2V9XCIuYCkpO1xuICAgIH0pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMuX3dlYldvcmtlcj8udGVybWluYXRlKCk7XG4gICAgdGhpcy5fd2ViV29ya2VyID0gbnVsbDtcbiAgICBQREZXb3JrZXIuI3dvcmtlclBvcnRzPy5kZWxldGUodGhpcy5fcG9ydCk7XG4gICAgdGhpcy5fcG9ydCA9IG51bGw7XG4gICAgdGhpcy5fbWVzc2FnZUhhbmRsZXI/LmRlc3Ryb3koKTtcbiAgICB0aGlzLl9tZXNzYWdlSGFuZGxlciA9IG51bGw7XG4gIH1cbiAgc3RhdGljIGZyb21Qb3J0KHBhcmFtcykge1xuICAgIGlmICghcGFyYW1zPy5wb3J0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQREZXb3JrZXIuZnJvbVBvcnQgLSBpbnZhbGlkIG1ldGhvZCBzaWduYXR1cmUuXCIpO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZWRQb3J0ID0gdGhpcy4jd29ya2VyUG9ydHM/LmdldChwYXJhbXMucG9ydCk7XG4gICAgaWYgKGNhY2hlZFBvcnQpIHtcbiAgICAgIGlmIChjYWNoZWRQb3J0Ll9wZW5kaW5nRGVzdHJveSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQREZXb3JrZXIuZnJvbVBvcnQgLSB0aGUgd29ya2VyIGlzIGJlaW5nIGRlc3Ryb3llZC5cXG5cIiArIFwiUGxlYXNlIHJlbWVtYmVyIHRvIGF3YWl0IGBQREZEb2N1bWVudExvYWRpbmdUYXNrLmRlc3Ryb3koKWAtY2FsbHMuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhY2hlZFBvcnQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUERGV29ya2VyKHBhcmFtcyk7XG4gIH1cbiAgc3RhdGljIGdldCB3b3JrZXJTcmMoKSB7XG4gICAgaWYgKEdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjKSB7XG4gICAgICByZXR1cm4gR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmM7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm8gXCJHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyY1wiIHNwZWNpZmllZC4nKTtcbiAgfVxuICBzdGF0aWMgZ2V0ICNtYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnbG9iYWxUaGlzLnBkZmpzV29ya2VyPy5Xb3JrZXJNZXNzYWdlSGFuZGxlciB8fCBudWxsO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgX3NldHVwRmFrZVdvcmtlckdsb2JhbCgpIHtcbiAgICBjb25zdCBsb2FkZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAodGhpcy4jbWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNtYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXI7XG4gICAgICB9XG4gICAgICBjb25zdCB3b3JrZXIgPSBhd2FpdCBpbXBvcnQoLyp3ZWJwYWNrSWdub3JlOiB0cnVlKi90aGlzLndvcmtlclNyYyk7XG4gICAgICByZXR1cm4gd29ya2VyLldvcmtlck1lc3NhZ2VIYW5kbGVyO1xuICAgIH07XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9zZXR1cEZha2VXb3JrZXJHbG9iYWxcIiwgbG9hZGVyKCkpO1xuICB9XG59XG5jbGFzcyBXb3JrZXJUcmFuc3BvcnQge1xuICAjbWV0aG9kUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICNwYWdlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICNwYWdlUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICNwYWdlUmVmQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICNwYXNzd29yZENhcGFiaWxpdHkgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlSGFuZGxlciwgbG9hZGluZ1Rhc2ssIG5ldHdvcmtTdHJlYW0sIHBhcmFtcywgZmFjdG9yeSkge1xuICAgIHRoaXMubWVzc2FnZUhhbmRsZXIgPSBtZXNzYWdlSGFuZGxlcjtcbiAgICB0aGlzLmxvYWRpbmdUYXNrID0gbG9hZGluZ1Rhc2s7XG4gICAgdGhpcy5jb21tb25PYmpzID0gbmV3IFBERk9iamVjdHMoKTtcbiAgICB0aGlzLmZvbnRMb2FkZXIgPSBuZXcgRm9udExvYWRlcih7XG4gICAgICBvd25lckRvY3VtZW50OiBwYXJhbXMub3duZXJEb2N1bWVudCxcbiAgICAgIHN0eWxlRWxlbWVudDogcGFyYW1zLnN0eWxlRWxlbWVudFxuICAgIH0pO1xuICAgIHRoaXMubG9hZGluZ1BhcmFtcyA9IHBhcmFtcy5sb2FkaW5nUGFyYW1zO1xuICAgIHRoaXMuX3BhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBmYWN0b3J5LmNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5maWx0ZXJGYWN0b3J5ID0gZmFjdG9yeS5maWx0ZXJGYWN0b3J5O1xuICAgIHRoaXMuY01hcFJlYWRlckZhY3RvcnkgPSBmYWN0b3J5LmNNYXBSZWFkZXJGYWN0b3J5O1xuICAgIHRoaXMuc3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBmYWN0b3J5LnN0YW5kYXJkRm9udERhdGFGYWN0b3J5O1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eSA9IG51bGw7XG4gICAgdGhpcy5fbmV0d29ya1N0cmVhbSA9IG5ldHdvcmtTdHJlYW07XG4gICAgdGhpcy5fZnVsbFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbGFzdFByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLmRvd25sb2FkSW5mb0NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLnNldHVwTWVzc2FnZUhhbmRsZXIoKTtcbiAgfVxuICAjY2FjaGVTaW1wbGVNZXRob2QobmFtZSwgZGF0YSA9IG51bGwpIHtcbiAgICBjb25zdCBjYWNoZWRQcm9taXNlID0gdGhpcy4jbWV0aG9kUHJvbWlzZXMuZ2V0KG5hbWUpO1xuICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKG5hbWUsIGRhdGEpO1xuICAgIHRoaXMuI21ldGhvZFByb21pc2VzLnNldChuYW1lLCBwcm9taXNlKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBnZXQgYW5ub3RhdGlvblN0b3JhZ2UoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImFubm90YXRpb25TdG9yYWdlXCIsIG5ldyBBbm5vdGF0aW9uU3RvcmFnZSgpKTtcbiAgfVxuICBnZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50LCBhbm5vdGF0aW9uTW9kZSA9IEFubm90YXRpb25Nb2RlLkVOQUJMRSwgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA9IG51bGwsIGlzRWRpdGluZyA9IGZhbHNlLCBpc09wTGlzdCA9IGZhbHNlKSB7XG4gICAgbGV0IHJlbmRlcmluZ0ludGVudCA9IFJlbmRlcmluZ0ludGVudEZsYWcuRElTUExBWTtcbiAgICBsZXQgYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGUgPSBTZXJpYWxpemFibGVFbXB0eTtcbiAgICBzd2l0Y2ggKGludGVudCkge1xuICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgPSBSZW5kZXJpbmdJbnRlbnRGbGFnLkFOWTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGlzcGxheVwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwcmludFwiOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgPSBSZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHdhcm4oYGdldFJlbmRlcmluZ0ludGVudCAtIGludmFsaWQgaW50ZW50OiAke2ludGVudH1gKTtcbiAgICB9XG4gICAgY29uc3QgYW5ub3RhdGlvblN0b3JhZ2UgPSByZW5kZXJpbmdJbnRlbnQgJiBSZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UICYmIHByaW50QW5ub3RhdGlvblN0b3JhZ2UgaW5zdGFuY2VvZiBQcmludEFubm90YXRpb25TdG9yYWdlID8gcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA6IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgc3dpdGNoIChhbm5vdGF0aW9uTW9kZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uTW9kZS5ESVNBQkxFOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgKz0gUmVuZGVyaW5nSW50ZW50RmxhZy5BTk5PVEFUSU9OU19ESVNBQkxFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbk1vZGUuRU5BQkxFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbk1vZGUuRU5BQkxFX0ZPUk1TOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgKz0gUmVuZGVyaW5nSW50ZW50RmxhZy5BTk5PVEFUSU9OU19GT1JNUztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25Nb2RlLkVOQUJMRV9TVE9SQUdFOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgKz0gUmVuZGVyaW5nSW50ZW50RmxhZy5BTk5PVEFUSU9OU19TVE9SQUdFO1xuICAgICAgICBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSA9IGFubm90YXRpb25TdG9yYWdlLnNlcmlhbGl6YWJsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB3YXJuKGBnZXRSZW5kZXJpbmdJbnRlbnQgLSBpbnZhbGlkIGFubm90YXRpb25Nb2RlOiAke2Fubm90YXRpb25Nb2RlfWApO1xuICAgIH1cbiAgICBpZiAoaXNFZGl0aW5nKSB7XG4gICAgICByZW5kZXJpbmdJbnRlbnQgKz0gUmVuZGVyaW5nSW50ZW50RmxhZy5JU19FRElUSU5HO1xuICAgIH1cbiAgICBpZiAoaXNPcExpc3QpIHtcbiAgICAgIHJlbmRlcmluZ0ludGVudCArPSBSZW5kZXJpbmdJbnRlbnRGbGFnLk9QTElTVDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgaWRzOiBtb2RpZmllZElkcyxcbiAgICAgIGhhc2g6IG1vZGlmaWVkSWRzSGFzaFxuICAgIH0gPSBhbm5vdGF0aW9uU3RvcmFnZS5tb2RpZmllZElkcztcbiAgICBjb25zdCBjYWNoZUtleUJ1ZiA9IFtyZW5kZXJpbmdJbnRlbnQsIGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlLmhhc2gsIG1vZGlmaWVkSWRzSGFzaF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbmRlcmluZ0ludGVudCxcbiAgICAgIGNhY2hlS2V5OiBjYWNoZUtleUJ1Zi5qb2luKFwiX1wiKSxcbiAgICAgIGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlLFxuICAgICAgbW9kaWZpZWRJZHNcbiAgICB9O1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveUNhcGFiaWxpdHkpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfVxuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5Py5yZWplY3QobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWQgZHVyaW5nIG9uUGFzc3dvcmQgY2FsbGJhY2tcIikpO1xuICAgIGNvbnN0IHdhaXRPbiA9IFtdO1xuICAgIGZvciAoY29uc3QgcGFnZSBvZiB0aGlzLiNwYWdlQ2FjaGUudmFsdWVzKCkpIHtcbiAgICAgIHdhaXRPbi5wdXNoKHBhZ2UuX2Rlc3Ryb3koKSk7XG4gICAgfVxuICAgIHRoaXMuI3BhZ2VDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuI3BhZ2VQcm9taXNlcy5jbGVhcigpO1xuICAgIHRoaXMuI3BhZ2VSZWZDYWNoZS5jbGVhcigpO1xuICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KFwiYW5ub3RhdGlvblN0b3JhZ2VcIikpIHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UucmVzZXRNb2RpZmllZCgpO1xuICAgIH1cbiAgICBjb25zdCB0ZXJtaW5hdGVkID0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJUZXJtaW5hdGVcIiwgbnVsbCk7XG4gICAgd2FpdE9uLnB1c2godGVybWluYXRlZCk7XG4gICAgUHJvbWlzZS5hbGwod2FpdE9uKS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuY29tbW9uT2Jqcy5jbGVhcigpO1xuICAgICAgdGhpcy5mb250TG9hZGVyLmNsZWFyKCk7XG4gICAgICB0aGlzLiNtZXRob2RQcm9taXNlcy5jbGVhcigpO1xuICAgICAgdGhpcy5maWx0ZXJGYWN0b3J5LmRlc3Ryb3koKTtcbiAgICAgIFRleHRMYXllci5jbGVhbnVwKCk7XG4gICAgICB0aGlzLl9uZXR3b3JrU3RyZWFtPy5jYW5jZWxBbGxSZXF1ZXN0cyhuZXcgQWJvcnRFeGNlcHRpb24oXCJXb3JrZXIgd2FzIHRlcm1pbmF0ZWQuXCIpKTtcbiAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXI/LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXIgPSBudWxsO1xuICAgICAgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSwgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eS5yZWplY3QpO1xuICAgIHJldHVybiB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgc2V0dXBNZXNzYWdlSGFuZGxlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZXNzYWdlSGFuZGxlcixcbiAgICAgIGxvYWRpbmdUYXNrXG4gICAgfSA9IHRoaXM7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJHZXRSZWFkZXJcIiwgKGRhdGEsIHNpbmspID0+IHtcbiAgICAgIGFzc2VydCh0aGlzLl9uZXR3b3JrU3RyZWFtLCBcIkdldFJlYWRlciAtIG5vIGBJUERGU3RyZWFtYCBpbnN0YW5jZSBhdmFpbGFibGUuXCIpO1xuICAgICAgdGhpcy5fZnVsbFJlYWRlciA9IHRoaXMuX25ldHdvcmtTdHJlYW0uZ2V0RnVsbFJlYWRlcigpO1xuICAgICAgdGhpcy5fZnVsbFJlYWRlci5vblByb2dyZXNzID0gZXZ0ID0+IHtcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzID0ge1xuICAgICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZCxcbiAgICAgICAgICB0b3RhbDogZXZ0LnRvdGFsXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgc2luay5vblB1bGwgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2Z1bGxSZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH0pIHtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3NlcnQodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciwgXCJHZXRSZWFkZXIgLSBleHBlY3RlZCBhbiBBcnJheUJ1ZmZlci5cIik7XG4gICAgICAgICAgc2luay5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHZhbHVlKSwgMSwgW3ZhbHVlXSk7XG4gICAgICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgc2luay5lcnJvcihyZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBzaW5rLm9uQ2FuY2VsID0gcmVhc29uID0+IHtcbiAgICAgICAgdGhpcy5fZnVsbFJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICAgICAgc2luay5yZWFkeS5jYXRjaChyZWFkeVJlYXNvbiA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IHJlYWR5UmVhc29uO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJSZWFkZXJIZWFkZXJzUmVhZHlcIiwgYXN5bmMgZGF0YSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLl9mdWxsUmVhZGVyLmhlYWRlcnNSZWFkeTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaXNTdHJlYW1pbmdTdXBwb3J0ZWQsXG4gICAgICAgIGlzUmFuZ2VTdXBwb3J0ZWQsXG4gICAgICAgIGNvbnRlbnRMZW5ndGhcbiAgICAgIH0gPSB0aGlzLl9mdWxsUmVhZGVyO1xuICAgICAgaWYgKCFpc1N0cmVhbWluZ1N1cHBvcnRlZCB8fCAhaXNSYW5nZVN1cHBvcnRlZCkge1xuICAgICAgICBpZiAodGhpcy5fbGFzdFByb2dyZXNzKSB7XG4gICAgICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcz8uKHRoaXMuX2xhc3RQcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZnVsbFJlYWRlci5vblByb2dyZXNzID0gZXZ0ID0+IHtcbiAgICAgICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzPy4oe1xuICAgICAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNTdHJlYW1pbmdTdXBwb3J0ZWQsXG4gICAgICAgIGlzUmFuZ2VTdXBwb3J0ZWQsXG4gICAgICAgIGNvbnRlbnRMZW5ndGhcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJHZXRSYW5nZVJlYWRlclwiLCAoZGF0YSwgc2luaykgPT4ge1xuICAgICAgYXNzZXJ0KHRoaXMuX25ldHdvcmtTdHJlYW0sIFwiR2V0UmFuZ2VSZWFkZXIgLSBubyBgSVBERlN0cmVhbWAgaW5zdGFuY2UgYXZhaWxhYmxlLlwiKTtcbiAgICAgIGNvbnN0IHJhbmdlUmVhZGVyID0gdGhpcy5fbmV0d29ya1N0cmVhbS5nZXRSYW5nZVJlYWRlcihkYXRhLmJlZ2luLCBkYXRhLmVuZCk7XG4gICAgICBpZiAoIXJhbmdlUmVhZGVyKSB7XG4gICAgICAgIHNpbmsuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2luay5vblB1bGwgPSAoKSA9PiB7XG4gICAgICAgIHJhbmdlUmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uICh7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9KSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHNpbmsuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXNzZXJ0KHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIsIFwiR2V0UmFuZ2VSZWFkZXIgLSBleHBlY3RlZCBhbiBBcnJheUJ1ZmZlci5cIik7XG4gICAgICAgICAgc2luay5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHZhbHVlKSwgMSwgW3ZhbHVlXSk7XG4gICAgICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgc2luay5lcnJvcihyZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBzaW5rLm9uQ2FuY2VsID0gcmVhc29uID0+IHtcbiAgICAgICAgcmFuZ2VSZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgICAgIHNpbmsucmVhZHkuY2F0Y2gocmVhZHlSZWFzb24gPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyByZWFkeVJlYXNvbjtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiR2V0RG9jXCIsICh7XG4gICAgICBwZGZJbmZvXG4gICAgfSkgPT4ge1xuICAgICAgdGhpcy5fbnVtUGFnZXMgPSBwZGZJbmZvLm51bVBhZ2VzO1xuICAgICAgdGhpcy5faHRtbEZvclhmYSA9IHBkZkluZm8uaHRtbEZvclhmYTtcbiAgICAgIGRlbGV0ZSBwZGZJbmZvLmh0bWxGb3JYZmE7XG4gICAgICBsb2FkaW5nVGFzay5fY2FwYWJpbGl0eS5yZXNvbHZlKG5ldyBQREZEb2N1bWVudFByb3h5KHBkZkluZm8sIHRoaXMpKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkRvY0V4Y2VwdGlvblwiLCBleCA9PiB7XG4gICAgICBsb2FkaW5nVGFzay5fY2FwYWJpbGl0eS5yZWplY3Qod3JhcFJlYXNvbihleCkpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiUGFzc3dvcmRSZXF1ZXN0XCIsIGV4ID0+IHtcbiAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFsb2FkaW5nVGFzay5vblBhc3N3b3JkKSB7XG4gICAgICAgICAgdGhyb3cgd3JhcFJlYXNvbihleCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBkYXRlUGFzc3dvcmQgPSBwYXNzd29yZCA9PiB7XG4gICAgICAgICAgaWYgKHBhc3N3b3JkIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5yZWplY3QocGFzc3dvcmQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgICAgIHBhc3N3b3JkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxvYWRpbmdUYXNrLm9uUGFzc3dvcmQodXBkYXRlUGFzc3dvcmQsIGV4LmNvZGUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5yZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkRhdGFMb2FkZWRcIiwgZGF0YSA9PiB7XG4gICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGRhdGEubGVuZ3RoLFxuICAgICAgICB0b3RhbDogZGF0YS5sZW5ndGhcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kb3dubG9hZEluZm9DYXBhYmlsaXR5LnJlc29sdmUoZGF0YSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJTdGFydFJlbmRlclBhZ2VcIiwgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFnZSA9IHRoaXMuI3BhZ2VDYWNoZS5nZXQoZGF0YS5wYWdlSW5kZXgpO1xuICAgICAgcGFnZS5fc3RhcnRSZW5kZXJQYWdlKGRhdGEudHJhbnNwYXJlbmN5LCBkYXRhLmNhY2hlS2V5KTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcImNvbW1vbm9ialwiLCAoW2lkLCB0eXBlLCBleHBvcnRlZERhdGFdKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb21tb25PYmpzLmhhcyhpZCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcIkZvbnRcIjpcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBkaXNhYmxlRm9udEZhY2UsXG4gICAgICAgICAgICBmb250RXh0cmFQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgcGRmQnVnXG4gICAgICAgICAgfSA9IHRoaXMuX3BhcmFtcztcbiAgICAgICAgICBpZiAoXCJlcnJvclwiIGluIGV4cG9ydGVkRGF0YSkge1xuICAgICAgICAgICAgY29uc3QgZXhwb3J0ZWRFcnJvciA9IGV4cG9ydGVkRGF0YS5lcnJvcjtcbiAgICAgICAgICAgIHdhcm4oYEVycm9yIGR1cmluZyBmb250IGxvYWRpbmc6ICR7ZXhwb3J0ZWRFcnJvcn1gKTtcbiAgICAgICAgICAgIHRoaXMuY29tbW9uT2Jqcy5yZXNvbHZlKGlkLCBleHBvcnRlZEVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpbnNwZWN0Rm9udCA9IHBkZkJ1ZyAmJiBnbG9iYWxUaGlzLkZvbnRJbnNwZWN0b3I/LmVuYWJsZWQgPyAoZm9udCwgdXJsKSA9PiBnbG9iYWxUaGlzLkZvbnRJbnNwZWN0b3IuZm9udEFkZGVkKGZvbnQsIHVybCkgOiBudWxsO1xuICAgICAgICAgIGNvbnN0IGZvbnQgPSBuZXcgRm9udEZhY2VPYmplY3QoZXhwb3J0ZWREYXRhLCB7XG4gICAgICAgICAgICBkaXNhYmxlRm9udEZhY2UsXG4gICAgICAgICAgICBmb250RXh0cmFQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgaW5zcGVjdEZvbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmZvbnRMb2FkZXIuYmluZChmb250KS5jYXRjaCgoKSA9PiBtZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJGb250RmFsbGJhY2tcIiwge1xuICAgICAgICAgICAgaWRcbiAgICAgICAgICB9KSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWZvbnRFeHRyYVByb3BlcnRpZXMgJiYgZm9udC5kYXRhKSB7XG4gICAgICAgICAgICAgIGZvbnQuZGF0YSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgZm9udCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJDb3B5TG9jYWxJbWFnZVwiOlxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGltYWdlUmVmXG4gICAgICAgICAgfSA9IGV4cG9ydGVkRGF0YTtcbiAgICAgICAgICBhc3NlcnQoaW1hZ2VSZWYsIFwiVGhlIGltYWdlUmVmIG11c3QgYmUgZGVmaW5lZC5cIik7XG4gICAgICAgICAgZm9yIChjb25zdCBwYWdlUHJveHkgb2YgdGhpcy4jcGFnZUNhY2hlLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFssIGRhdGFdIG9mIHBhZ2VQcm94eS5vYmpzKSB7XG4gICAgICAgICAgICAgIGlmIChkYXRhPy5yZWYgIT09IGltYWdlUmVmKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFkYXRhLmRhdGFMZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgc3RydWN0dXJlZENsb25lKGRhdGEpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuZGF0YUxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJGb250UGF0aFwiOlxuICAgICAgICBjYXNlIFwiSW1hZ2VcIjpcbiAgICAgICAgY2FzZSBcIlBhdHRlcm5cIjpcbiAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgZXhwb3J0ZWREYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB1bmtub3duIGNvbW1vbiBvYmplY3QgdHlwZSAke3R5cGV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIm9ialwiLCAoW2lkLCBwYWdlSW5kZXgsIHR5cGUsIGltYWdlRGF0YV0pID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwYWdlUHJveHkgPSB0aGlzLiNwYWdlQ2FjaGUuZ2V0KHBhZ2VJbmRleCk7XG4gICAgICBpZiAocGFnZVByb3h5Lm9ianMuaGFzKGlkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocGFnZVByb3h5Ll9pbnRlbnRTdGF0ZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBpbWFnZURhdGE/LmJpdG1hcD8uY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJJbWFnZVwiOlxuICAgICAgICAgIHBhZ2VQcm94eS5vYmpzLnJlc29sdmUoaWQsIGltYWdlRGF0YSk7XG4gICAgICAgICAgaWYgKGltYWdlRGF0YT8uZGF0YUxlbiA+IE1BWF9JTUFHRV9TSVpFX1RPX0NBQ0hFKSB7XG4gICAgICAgICAgICBwYWdlUHJveHkuX21heWJlQ2xlYW51cEFmdGVyUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJQYXR0ZXJuXCI6XG4gICAgICAgICAgcGFnZVByb3h5Lm9ianMucmVzb2x2ZShpZCwgaW1hZ2VEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB1bmtub3duIG9iamVjdCB0eXBlICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkRvY1Byb2dyZXNzXCIsIGRhdGEgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZGF0YS5sb2FkZWQsXG4gICAgICAgIHRvdGFsOiBkYXRhLnRvdGFsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkZldGNoQnVpbHRJbkNNYXBcIiwgYXN5bmMgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWQuXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmNNYXBSZWFkZXJGYWN0b3J5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNNYXBSZWFkZXJGYWN0b3J5IG5vdCBpbml0aWFsaXplZCwgc2VlIHRoZSBgdXNlV29ya2VyRmV0Y2hgIHBhcmFtZXRlci5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jTWFwUmVhZGVyRmFjdG9yeS5mZXRjaChkYXRhKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkZldGNoU3RhbmRhcmRGb250RGF0YVwiLCBhc3luYyBkYXRhID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZC5cIik7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc3RhbmRhcmRGb250RGF0YUZhY3RvcnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkgbm90IGluaXRpYWxpemVkLCBzZWUgdGhlIGB1c2VXb3JrZXJGZXRjaGAgcGFyYW1ldGVyLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnN0YW5kYXJkRm9udERhdGFGYWN0b3J5LmZldGNoKGRhdGEpO1xuICAgIH0pO1xuICB9XG4gIGdldERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RGF0YVwiLCBudWxsKTtcbiAgfVxuICBzYXZlRG9jdW1lbnQoKSB7XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2l6ZSA8PSAwKSB7XG4gICAgICB3YXJuKFwic2F2ZURvY3VtZW50IGNhbGxlZCB3aGlsZSBgYW5ub3RhdGlvblN0b3JhZ2VgIGlzIGVtcHR5LCBcIiArIFwicGxlYXNlIHVzZSB0aGUgZ2V0RGF0YS1tZXRob2QgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG1hcCxcbiAgICAgIHRyYW5zZmVyXG4gICAgfSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2VyaWFsaXphYmxlO1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIlNhdmVEb2N1bWVudFwiLCB7XG4gICAgICBpc1B1cmVYZmE6ICEhdGhpcy5faHRtbEZvclhmYSxcbiAgICAgIG51bVBhZ2VzOiB0aGlzLl9udW1QYWdlcyxcbiAgICAgIGFubm90YXRpb25TdG9yYWdlOiBtYXAsXG4gICAgICBmaWxlbmFtZTogdGhpcy5fZnVsbFJlYWRlcj8uZmlsZW5hbWUgPz8gbnVsbFxuICAgIH0sIHRyYW5zZmVyKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UucmVzZXRNb2RpZmllZCgpO1xuICAgIH0pO1xuICB9XG4gIGdldFBhZ2UocGFnZU51bWJlcikge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihwYWdlTnVtYmVyKSB8fCBwYWdlTnVtYmVyIDw9IDAgfHwgcGFnZU51bWJlciA+IHRoaXMuX251bVBhZ2VzKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBwYWdlIHJlcXVlc3QuXCIpKTtcbiAgICB9XG4gICAgY29uc3QgcGFnZUluZGV4ID0gcGFnZU51bWJlciAtIDEsXG4gICAgICBjYWNoZWRQcm9taXNlID0gdGhpcy4jcGFnZVByb21pc2VzLmdldChwYWdlSW5kZXgpO1xuICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZVwiLCB7XG4gICAgICBwYWdlSW5kZXhcbiAgICB9KS50aGVuKHBhZ2VJbmZvID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3BvcnQgZGVzdHJveWVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHBhZ2VJbmZvLnJlZlN0cikge1xuICAgICAgICB0aGlzLiNwYWdlUmVmQ2FjaGUuc2V0KHBhZ2VJbmZvLnJlZlN0ciwgcGFnZU51bWJlcik7XG4gICAgICB9XG4gICAgICBjb25zdCBwYWdlID0gbmV3IFBERlBhZ2VQcm94eShwYWdlSW5kZXgsIHBhZ2VJbmZvLCB0aGlzLCB0aGlzLl9wYXJhbXMucGRmQnVnKTtcbiAgICAgIHRoaXMuI3BhZ2VDYWNoZS5zZXQocGFnZUluZGV4LCBwYWdlKTtcbiAgICAgIHJldHVybiBwYWdlO1xuICAgIH0pO1xuICAgIHRoaXMuI3BhZ2VQcm9taXNlcy5zZXQocGFnZUluZGV4LCBwcm9taXNlKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBnZXRQYWdlSW5kZXgocmVmKSB7XG4gICAgaWYgKCFpc1JlZlByb3h5KHJlZikpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIHBhZ2VJbmRleCByZXF1ZXN0LlwiKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VJbmRleFwiLCB7XG4gICAgICBudW06IHJlZi5udW0sXG4gICAgICBnZW46IHJlZi5nZW5cbiAgICB9KTtcbiAgfVxuICBnZXRBbm5vdGF0aW9ucyhwYWdlSW5kZXgsIGludGVudCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldEFubm90YXRpb25zXCIsIHtcbiAgICAgIHBhZ2VJbmRleCxcbiAgICAgIGludGVudFxuICAgIH0pO1xuICB9XG4gIGdldEZpZWxkT2JqZWN0cygpIHtcbiAgICByZXR1cm4gdGhpcy4jY2FjaGVTaW1wbGVNZXRob2QoXCJHZXRGaWVsZE9iamVjdHNcIik7XG4gIH1cbiAgaGFzSlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLiNjYWNoZVNpbXBsZU1ldGhvZChcIkhhc0pTQWN0aW9uc1wiKTtcbiAgfVxuICBnZXRDYWxjdWxhdGlvbk9yZGVySWRzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldENhbGN1bGF0aW9uT3JkZXJJZHNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0RGVzdGluYXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldERlc3RpbmF0aW9uc1wiLCBudWxsKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbihpZCkge1xuICAgIGlmICh0eXBlb2YgaWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIGRlc3RpbmF0aW9uIHJlcXVlc3QuXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RGVzdGluYXRpb25cIiwge1xuICAgICAgaWRcbiAgICB9KTtcbiAgfVxuICBnZXRQYWdlTGFiZWxzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VMYWJlbHNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0UGFnZUxheW91dCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlTGF5b3V0XCIsIG51bGwpO1xuICB9XG4gIGdldFBhZ2VNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VNb2RlXCIsIG51bGwpO1xuICB9XG4gIGdldFZpZXdlclByZWZlcmVuY2VzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFZpZXdlclByZWZlcmVuY2VzXCIsIG51bGwpO1xuICB9XG4gIGdldE9wZW5BY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0T3BlbkFjdGlvblwiLCBudWxsKTtcbiAgfVxuICBnZXRBdHRhY2htZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRBdHRhY2htZW50c1wiLCBudWxsKTtcbiAgfVxuICBnZXREb2NKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlU2ltcGxlTWV0aG9kKFwiR2V0RG9jSlNBY3Rpb25zXCIpO1xuICB9XG4gIGdldFBhZ2VKU0FjdGlvbnMocGFnZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUpTQWN0aW9uc1wiLCB7XG4gICAgICBwYWdlSW5kZXhcbiAgICB9KTtcbiAgfVxuICBnZXRTdHJ1Y3RUcmVlKHBhZ2VJbmRleCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFN0cnVjdFRyZWVcIiwge1xuICAgICAgcGFnZUluZGV4XG4gICAgfSk7XG4gIH1cbiAgZ2V0T3V0bGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRPdXRsaW5lXCIsIG51bGwpO1xuICB9XG4gIGdldE9wdGlvbmFsQ29udGVudENvbmZpZyhyZW5kZXJpbmdJbnRlbnQpIHtcbiAgICByZXR1cm4gdGhpcy4jY2FjaGVTaW1wbGVNZXRob2QoXCJHZXRPcHRpb25hbENvbnRlbnRDb25maWdcIikudGhlbihkYXRhID0+IG5ldyBPcHRpb25hbENvbnRlbnRDb25maWcoZGF0YSwgcmVuZGVyaW5nSW50ZW50KSk7XG4gIH1cbiAgZ2V0UGVybWlzc2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGVybWlzc2lvbnNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0TWV0YWRhdGEoKSB7XG4gICAgY29uc3QgbmFtZSA9IFwiR2V0TWV0YWRhdGFcIixcbiAgICAgIGNhY2hlZFByb21pc2UgPSB0aGlzLiNtZXRob2RQcm9taXNlcy5nZXQobmFtZSk7XG4gICAgaWYgKGNhY2hlZFByb21pc2UpIHtcbiAgICAgIHJldHVybiBjYWNoZWRQcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UobmFtZSwgbnVsbCkudGhlbihyZXN1bHRzID0+ICh7XG4gICAgICBpbmZvOiByZXN1bHRzWzBdLFxuICAgICAgbWV0YWRhdGE6IHJlc3VsdHNbMV0gPyBuZXcgTWV0YWRhdGEocmVzdWx0c1sxXSkgOiBudWxsLFxuICAgICAgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU6IHRoaXMuX2Z1bGxSZWFkZXI/LmZpbGVuYW1lID8/IG51bGwsXG4gICAgICBjb250ZW50TGVuZ3RoOiB0aGlzLl9mdWxsUmVhZGVyPy5jb250ZW50TGVuZ3RoID8/IG51bGxcbiAgICB9KSk7XG4gICAgdGhpcy4jbWV0aG9kUHJvbWlzZXMuc2V0KG5hbWUsIHByb21pc2UpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGdldE1hcmtJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldE1hcmtJbmZvXCIsIG51bGwpO1xuICB9XG4gIGFzeW5jIHN0YXJ0Q2xlYW51cChrZWVwTG9hZGVkRm9udHMgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkNsZWFudXBcIiwgbnVsbCk7XG4gICAgZm9yIChjb25zdCBwYWdlIG9mIHRoaXMuI3BhZ2VDYWNoZS52YWx1ZXMoKSkge1xuICAgICAgY29uc3QgY2xlYW51cFN1Y2Nlc3NmdWwgPSBwYWdlLmNsZWFudXAoKTtcbiAgICAgIGlmICghY2xlYW51cFN1Y2Nlc3NmdWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdGFydENsZWFudXA6IFBhZ2UgJHtwYWdlLnBhZ2VOdW1iZXJ9IGlzIGN1cnJlbnRseSByZW5kZXJpbmcuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29tbW9uT2Jqcy5jbGVhcigpO1xuICAgIGlmICgha2VlcExvYWRlZEZvbnRzKSB7XG4gICAgICB0aGlzLmZvbnRMb2FkZXIuY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy4jbWV0aG9kUHJvbWlzZXMuY2xlYXIoKTtcbiAgICB0aGlzLmZpbHRlckZhY3RvcnkuZGVzdHJveSh0cnVlKTtcbiAgICBUZXh0TGF5ZXIuY2xlYW51cCgpO1xuICB9XG4gIGNhY2hlZFBhZ2VOdW1iZXIocmVmKSB7XG4gICAgaWYgKCFpc1JlZlByb3h5KHJlZikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZWZTdHIgPSByZWYuZ2VuID09PSAwID8gYCR7cmVmLm51bX1SYCA6IGAke3JlZi5udW19UiR7cmVmLmdlbn1gO1xuICAgIHJldHVybiB0aGlzLiNwYWdlUmVmQ2FjaGUuZ2V0KHJlZlN0cikgPz8gbnVsbDtcbiAgfVxufVxuY29uc3QgSU5JVElBTF9EQVRBID0gU3ltYm9sKFwiSU5JVElBTF9EQVRBXCIpO1xuY2xhc3MgUERGT2JqZWN0cyB7XG4gICNvYmpzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgI2Vuc3VyZU9iaihvYmpJZCkge1xuICAgIHJldHVybiB0aGlzLiNvYmpzW29iaklkXSB8fD0ge1xuICAgICAgLi4uUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCksXG4gICAgICBkYXRhOiBJTklUSUFMX0RBVEFcbiAgICB9O1xuICB9XG4gIGdldChvYmpJZCwgY2FsbGJhY2sgPSBudWxsKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBvYmogPSB0aGlzLiNlbnN1cmVPYmoob2JqSWQpO1xuICAgICAgb2JqLnByb21pc2UudGhlbigoKSA9PiBjYWxsYmFjayhvYmouZGF0YSkpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG9iaiA9IHRoaXMuI29ianNbb2JqSWRdO1xuICAgIGlmICghb2JqIHx8IG9iai5kYXRhID09PSBJTklUSUFMX0RBVEEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVxdWVzdGluZyBvYmplY3QgdGhhdCBpc24ndCByZXNvbHZlZCB5ZXQgJHtvYmpJZH0uYCk7XG4gICAgfVxuICAgIHJldHVybiBvYmouZGF0YTtcbiAgfVxuICBoYXMob2JqSWQpIHtcbiAgICBjb25zdCBvYmogPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICByZXR1cm4gISFvYmogJiYgb2JqLmRhdGEgIT09IElOSVRJQUxfREFUQTtcbiAgfVxuICBkZWxldGUob2JqSWQpIHtcbiAgICBjb25zdCBvYmogPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICBpZiAoIW9iaiB8fCBvYmouZGF0YSA9PT0gSU5JVElBTF9EQVRBKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXNvbHZlKG9iaklkLCBkYXRhID0gbnVsbCkge1xuICAgIGNvbnN0IG9iaiA9IHRoaXMuI2Vuc3VyZU9iaihvYmpJZCk7XG4gICAgb2JqLmRhdGEgPSBkYXRhO1xuICAgIG9iai5yZXNvbHZlKCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBvYmpJZCBpbiB0aGlzLiNvYmpzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGFcbiAgICAgIH0gPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICAgIGRhdGE/LmJpdG1hcD8uY2xvc2UoKTtcbiAgICB9XG4gICAgdGhpcy4jb2JqcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIGZvciAoY29uc3Qgb2JqSWQgaW4gdGhpcy4jb2Jqcykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhXG4gICAgICB9ID0gdGhpcy4jb2Jqc1tvYmpJZF07XG4gICAgICBpZiAoZGF0YSA9PT0gSU5JVElBTF9EQVRBKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgeWllbGQgW29iaklkLCBkYXRhXTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFJlbmRlclRhc2sge1xuICAjaW50ZXJuYWxSZW5kZXJUYXNrID0gbnVsbDtcbiAgY29uc3RydWN0b3IoaW50ZXJuYWxSZW5kZXJUYXNrKSB7XG4gICAgdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrID0gaW50ZXJuYWxSZW5kZXJUYXNrO1xuICAgIHRoaXMub25Db250aW51ZSA9IG51bGw7XG4gIH1cbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ludGVybmFsUmVuZGVyVGFzay5jYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKGV4dHJhRGVsYXkgPSAwKSB7XG4gICAgdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrLmNhbmNlbChudWxsLCBleHRyYURlbGF5KTtcbiAgfVxuICBnZXQgc2VwYXJhdGVBbm5vdHMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2VwYXJhdGVBbm5vdHNcbiAgICB9ID0gdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrLm9wZXJhdG9yTGlzdDtcbiAgICBpZiAoIXNlcGFyYXRlQW5ub3RzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25DYW52YXNNYXBcbiAgICB9ID0gdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrO1xuICAgIHJldHVybiBzZXBhcmF0ZUFubm90cy5mb3JtIHx8IHNlcGFyYXRlQW5ub3RzLmNhbnZhcyAmJiBhbm5vdGF0aW9uQ2FudmFzTWFwPy5zaXplID4gMDtcbiAgfVxufVxuY2xhc3MgSW50ZXJuYWxSZW5kZXJUYXNrIHtcbiAgI3JBRiA9IG51bGw7XG4gIHN0YXRpYyAjY2FudmFzSW5Vc2UgPSBuZXcgV2Vha1NldCgpO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY2FsbGJhY2ssXG4gICAgcGFyYW1zLFxuICAgIG9ianMsXG4gICAgY29tbW9uT2JqcyxcbiAgICBhbm5vdGF0aW9uQ2FudmFzTWFwLFxuICAgIG9wZXJhdG9yTGlzdCxcbiAgICBwYWdlSW5kZXgsXG4gICAgY2FudmFzRmFjdG9yeSxcbiAgICBmaWx0ZXJGYWN0b3J5LFxuICAgIHVzZVJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZhbHNlLFxuICAgIHBkZkJ1ZyA9IGZhbHNlLFxuICAgIHBhZ2VDb2xvcnMgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5vYmpzID0gb2JqcztcbiAgICB0aGlzLmNvbW1vbk9ianMgPSBjb21tb25PYmpzO1xuICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCA9IGFubm90YXRpb25DYW52YXNNYXA7XG4gICAgdGhpcy5vcGVyYXRvckxpc3RJZHggPSBudWxsO1xuICAgIHRoaXMub3BlcmF0b3JMaXN0ID0gb3BlcmF0b3JMaXN0O1xuICAgIHRoaXMuX3BhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBjYW52YXNGYWN0b3J5O1xuICAgIHRoaXMuZmlsdGVyRmFjdG9yeSA9IGZpbHRlckZhY3Rvcnk7XG4gICAgdGhpcy5fcGRmQnVnID0gcGRmQnVnO1xuICAgIHRoaXMucGFnZUNvbG9ycyA9IHBhZ2VDb2xvcnM7XG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2sgPSBudWxsO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMuX3VzZVJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHVzZVJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gdHJ1ZSAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5jYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy50YXNrID0gbmV3IFJlbmRlclRhc2sodGhpcyk7XG4gICAgdGhpcy5fY2FuY2VsQm91bmQgPSB0aGlzLmNhbmNlbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2NvbnRpbnVlQm91bmQgPSB0aGlzLl9jb250aW51ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3NjaGVkdWxlTmV4dEJvdW5kID0gdGhpcy5fc2NoZWR1bGVOZXh0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fbmV4dEJvdW5kID0gdGhpcy5fbmV4dC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2NhbnZhcyA9IHBhcmFtcy5jYW52YXNDb250ZXh0LmNhbnZhcztcbiAgfVxuICBnZXQgY29tcGxldGVkKCkge1xuICAgIHJldHVybiB0aGlzLmNhcGFiaWxpdHkucHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gIH1cbiAgaW5pdGlhbGl6ZUdyYXBoaWNzKHtcbiAgICB0cmFuc3BhcmVuY3kgPSBmYWxzZSxcbiAgICBvcHRpb25hbENvbnRlbnRDb25maWdcbiAgfSkge1xuICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY2FudmFzKSB7XG4gICAgICBpZiAoSW50ZXJuYWxSZW5kZXJUYXNrLiNjYW52YXNJblVzZS5oYXModGhpcy5fY2FudmFzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIHRoZSBzYW1lIGNhbnZhcyBkdXJpbmcgbXVsdGlwbGUgcmVuZGVyKCkgb3BlcmF0aW9ucy4gXCIgKyBcIlVzZSBkaWZmZXJlbnQgY2FudmFzIG9yIGVuc3VyZSBwcmV2aW91cyBvcGVyYXRpb25zIHdlcmUgXCIgKyBcImNhbmNlbGxlZCBvciBjb21wbGV0ZWQuXCIpO1xuICAgICAgfVxuICAgICAgSW50ZXJuYWxSZW5kZXJUYXNrLiNjYW52YXNJblVzZS5hZGQodGhpcy5fY2FudmFzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3BkZkJ1ZyAmJiBnbG9iYWxUaGlzLlN0ZXBwZXJNYW5hZ2VyPy5lbmFibGVkKSB7XG4gICAgICB0aGlzLnN0ZXBwZXIgPSBnbG9iYWxUaGlzLlN0ZXBwZXJNYW5hZ2VyLmNyZWF0ZSh0aGlzLl9wYWdlSW5kZXgpO1xuICAgICAgdGhpcy5zdGVwcGVyLmluaXQodGhpcy5vcGVyYXRvckxpc3QpO1xuICAgICAgdGhpcy5zdGVwcGVyLm5leHRCcmVha1BvaW50ID0gdGhpcy5zdGVwcGVyLmdldE5leHRCcmVha1BvaW50KCk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNhbnZhc0NvbnRleHQsXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIGJhY2tncm91bmRcbiAgICB9ID0gdGhpcy5wYXJhbXM7XG4gICAgdGhpcy5nZnggPSBuZXcgQ2FudmFzR3JhcGhpY3MoY2FudmFzQ29udGV4dCwgdGhpcy5jb21tb25PYmpzLCB0aGlzLm9ianMsIHRoaXMuY2FudmFzRmFjdG9yeSwgdGhpcy5maWx0ZXJGYWN0b3J5LCB7XG4gICAgICBvcHRpb25hbENvbnRlbnRDb25maWdcbiAgICB9LCB0aGlzLmFubm90YXRpb25DYW52YXNNYXAsIHRoaXMucGFnZUNvbG9ycyk7XG4gICAgdGhpcy5nZnguYmVnaW5EcmF3aW5nKHtcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgdHJhbnNwYXJlbmN5LFxuICAgICAgYmFja2dyb3VuZFxuICAgIH0pO1xuICAgIHRoaXMub3BlcmF0b3JMaXN0SWR4ID0gMDtcbiAgICB0aGlzLmdyYXBoaWNzUmVhZHkgPSB0cnVlO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrPy4oKTtcbiAgfVxuICBjYW5jZWwoZXJyb3IgPSBudWxsLCBleHRyYURlbGF5ID0gMCkge1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB0aGlzLmdmeD8uZW5kRHJhd2luZygpO1xuICAgIGlmICh0aGlzLiNyQUYpIHtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLiNyQUYpO1xuICAgICAgdGhpcy4jckFGID0gbnVsbDtcbiAgICB9XG4gICAgSW50ZXJuYWxSZW5kZXJUYXNrLiNjYW52YXNJblVzZS5kZWxldGUodGhpcy5fY2FudmFzKTtcbiAgICB0aGlzLmNhbGxiYWNrKGVycm9yIHx8IG5ldyBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24oYFJlbmRlcmluZyBjYW5jZWxsZWQsIHBhZ2UgJHt0aGlzLl9wYWdlSW5kZXggKyAxfWAsIGV4dHJhRGVsYXkpKTtcbiAgfVxuICBvcGVyYXRvckxpc3RDaGFuZ2VkKCkge1xuICAgIGlmICghdGhpcy5ncmFwaGljc1JlYWR5KSB7XG4gICAgICB0aGlzLmdyYXBoaWNzUmVhZHlDYWxsYmFjayB8fD0gdGhpcy5fY29udGludWVCb3VuZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGVwcGVyPy51cGRhdGVPcGVyYXRvckxpc3QodGhpcy5vcGVyYXRvckxpc3QpO1xuICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY29udGludWUoKTtcbiAgfVxuICBfY29udGludWUoKSB7XG4gICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMudGFzay5vbkNvbnRpbnVlKSB7XG4gICAgICB0aGlzLnRhc2sub25Db250aW51ZSh0aGlzLl9zY2hlZHVsZU5leHRCb3VuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NjaGVkdWxlTmV4dCgpO1xuICAgIH1cbiAgfVxuICBfc2NoZWR1bGVOZXh0KCkge1xuICAgIGlmICh0aGlzLl91c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHRoaXMuI3JBRiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0aGlzLiNyQUYgPSBudWxsO1xuICAgICAgICB0aGlzLl9uZXh0Qm91bmQoKS5jYXRjaCh0aGlzLl9jYW5jZWxCb3VuZCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbih0aGlzLl9uZXh0Qm91bmQpLmNhdGNoKHRoaXMuX2NhbmNlbEJvdW5kKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgX25leHQoKSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMub3BlcmF0b3JMaXN0SWR4ID0gdGhpcy5nZnguZXhlY3V0ZU9wZXJhdG9yTGlzdCh0aGlzLm9wZXJhdG9yTGlzdCwgdGhpcy5vcGVyYXRvckxpc3RJZHgsIHRoaXMuX2NvbnRpbnVlQm91bmQsIHRoaXMuc3RlcHBlcik7XG4gICAgaWYgKHRoaXMub3BlcmF0b3JMaXN0SWR4ID09PSB0aGlzLm9wZXJhdG9yTGlzdC5hcmdzQXJyYXkubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmspIHtcbiAgICAgICAgdGhpcy5nZnguZW5kRHJhd2luZygpO1xuICAgICAgICBJbnRlcm5hbFJlbmRlclRhc2suI2NhbnZhc0luVXNlLmRlbGV0ZSh0aGlzLl9jYW52YXMpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jb25zdCB2ZXJzaW9uID0gXCI0LjEwLjM4XCI7XG5jb25zdCBidWlsZCA9IFwiZjliZWEzOTdmXCI7XG5cbjsvLyAuL3NyYy9zaGFyZWQvc2NyaXB0aW5nX3V0aWxzLmpzXG5mdW5jdGlvbiBtYWtlQ29sb3JDb21wKG4pIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgbikpICogMjU1KS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpO1xufVxuZnVuY3Rpb24gc2NhbGVBbmRDbGFtcCh4KSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIDI1NSAqIHgpKTtcbn1cbmNsYXNzIENvbG9yQ29udmVydGVycyB7XG4gIHN0YXRpYyBDTVlLX0coW2MsIHksIG0sIGtdKSB7XG4gICAgcmV0dXJuIFtcIkdcIiwgMSAtIE1hdGgubWluKDEsIDAuMyAqIGMgKyAwLjU5ICogbSArIDAuMTEgKiB5ICsgayldO1xuICB9XG4gIHN0YXRpYyBHX0NNWUsoW2ddKSB7XG4gICAgcmV0dXJuIFtcIkNNWUtcIiwgMCwgMCwgMCwgMSAtIGddO1xuICB9XG4gIHN0YXRpYyBHX1JHQihbZ10pIHtcbiAgICByZXR1cm4gW1wiUkdCXCIsIGcsIGcsIGddO1xuICB9XG4gIHN0YXRpYyBHX3JnYihbZ10pIHtcbiAgICBnID0gc2NhbGVBbmRDbGFtcChnKTtcbiAgICByZXR1cm4gW2csIGcsIGddO1xuICB9XG4gIHN0YXRpYyBHX0hUTUwoW2ddKSB7XG4gICAgY29uc3QgRyA9IG1ha2VDb2xvckNvbXAoZyk7XG4gICAgcmV0dXJuIGAjJHtHfSR7R30ke0d9YDtcbiAgfVxuICBzdGF0aWMgUkdCX0coW3IsIGcsIGJdKSB7XG4gICAgcmV0dXJuIFtcIkdcIiwgMC4zICogciArIDAuNTkgKiBnICsgMC4xMSAqIGJdO1xuICB9XG4gIHN0YXRpYyBSR0JfcmdiKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNvbG9yLm1hcChzY2FsZUFuZENsYW1wKTtcbiAgfVxuICBzdGF0aWMgUkdCX0hUTUwoY29sb3IpIHtcbiAgICByZXR1cm4gYCMke2NvbG9yLm1hcChtYWtlQ29sb3JDb21wKS5qb2luKFwiXCIpfWA7XG4gIH1cbiAgc3RhdGljIFRfSFRNTCgpIHtcbiAgICByZXR1cm4gXCIjMDAwMDAwMDBcIjtcbiAgfVxuICBzdGF0aWMgVF9yZ2IoKSB7XG4gICAgcmV0dXJuIFtudWxsXTtcbiAgfVxuICBzdGF0aWMgQ01ZS19SR0IoW2MsIHksIG0sIGtdKSB7XG4gICAgcmV0dXJuIFtcIlJHQlwiLCAxIC0gTWF0aC5taW4oMSwgYyArIGspLCAxIC0gTWF0aC5taW4oMSwgbSArIGspLCAxIC0gTWF0aC5taW4oMSwgeSArIGspXTtcbiAgfVxuICBzdGF0aWMgQ01ZS19yZ2IoW2MsIHksIG0sIGtdKSB7XG4gICAgcmV0dXJuIFtzY2FsZUFuZENsYW1wKDEgLSBNYXRoLm1pbigxLCBjICsgaykpLCBzY2FsZUFuZENsYW1wKDEgLSBNYXRoLm1pbigxLCBtICsgaykpLCBzY2FsZUFuZENsYW1wKDEgLSBNYXRoLm1pbigxLCB5ICsgaykpXTtcbiAgfVxuICBzdGF0aWMgQ01ZS19IVE1MKGNvbXBvbmVudHMpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLkNNWUtfUkdCKGNvbXBvbmVudHMpLnNsaWNlKDEpO1xuICAgIHJldHVybiB0aGlzLlJHQl9IVE1MKHJnYik7XG4gIH1cbiAgc3RhdGljIFJHQl9DTVlLKFtyLCBnLCBiXSkge1xuICAgIGNvbnN0IGMgPSAxIC0gcjtcbiAgICBjb25zdCBtID0gMSAtIGc7XG4gICAgY29uc3QgeSA9IDEgLSBiO1xuICAgIGNvbnN0IGsgPSBNYXRoLm1pbihjLCBtLCB5KTtcbiAgICByZXR1cm4gW1wiQ01ZS1wiLCBjLCBtLCB5LCBrXTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9zdmdfZmFjdG9yeS5qc1xuXG5cbmNsYXNzIEJhc2VTVkdGYWN0b3J5IHtcbiAgY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHNraXBEaW1lbnNpb25zID0gZmFsc2UpIHtcbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBTVkcgZGltZW5zaW9uc1wiKTtcbiAgICB9XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5fY3JlYXRlU1ZHKFwic3ZnOnN2Z1wiKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwidmVyc2lvblwiLCBcIjEuMVwiKTtcbiAgICBpZiAoIXNraXBEaW1lbnNpb25zKSB7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgYCR7d2lkdGh9cHhgKTtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgYCR7aGVpZ2h0fXB4YCk7XG4gICAgfVxuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCIsIFwibm9uZVwiKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBgMCAwICR7d2lkdGh9ICR7aGVpZ2h0fWApO1xuICAgIHJldHVybiBzdmc7XG4gIH1cbiAgY3JlYXRlRWxlbWVudCh0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFNWRyBlbGVtZW50IHR5cGVcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVTVkcodHlwZSk7XG4gIH1cbiAgX2NyZWF0ZVNWRyh0eXBlKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYF9jcmVhdGVTVkdgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIERPTVNWR0ZhY3RvcnkgZXh0ZW5kcyBCYXNlU1ZHRmFjdG9yeSB7XG4gIF9jcmVhdGVTVkcodHlwZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCB0eXBlKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS94ZmFfbGF5ZXIuanNcblxuY2xhc3MgWGZhTGF5ZXIge1xuICBzdGF0aWMgc2V0dXBTdG9yYWdlKGh0bWwsIGlkLCBlbGVtZW50LCBzdG9yYWdlLCBpbnRlbnQpIHtcbiAgICBjb25zdCBzdG9yZWREYXRhID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcbiAgICBzd2l0Y2ggKGVsZW1lbnQubmFtZSkge1xuICAgICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgaHRtbC50ZXh0Q29udGVudCA9IHN0b3JlZERhdGEudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVudCA9PT0gXCJwcmludFwiKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImlucHV0XCI6XG4gICAgICAgIGlmIChlbGVtZW50LmF0dHJpYnV0ZXMudHlwZSA9PT0gXCJyYWRpb1wiIHx8IGVsZW1lbnQuYXR0cmlidXRlcy50eXBlID09PSBcImNoZWNrYm94XCIpIHtcbiAgICAgICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZSA9PT0gZWxlbWVudC5hdHRyaWJ1dGVzLnhmYU9uKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdG9yZWREYXRhLnZhbHVlID09PSBlbGVtZW50LmF0dHJpYnV0ZXMueGZhT2ZmKSB7XG4gICAgICAgICAgICBodG1sLnJlbW92ZUF0dHJpYnV0ZShcImNoZWNrZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnRlbnQgPT09IFwicHJpbnRcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBldmVudCA9PiB7XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQuY2hlY2tlZCA/IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ4ZmFPblwiKSA6IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ4ZmFPZmZcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIHN0b3JlZERhdGEudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW50ZW50ID09PSBcInByaW50XCIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgc3RvcmVkRGF0YS52YWx1ZSk7XG4gICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgZWxlbWVudC5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbi5hdHRyaWJ1dGVzLnZhbHVlID09PSBzdG9yZWREYXRhLnZhbHVlKSB7XG4gICAgICAgICAgICAgIG9wdGlvbi5hdHRyaWJ1dGVzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9uLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoXCJzZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICBkZWxldGUgb3B0aW9uLmF0dHJpYnV0ZXMuc2VsZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBjb25zdCBvcHRpb25zID0gZXZlbnQudGFyZ2V0Lm9wdGlvbnM7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25zLnNlbGVjdGVkSW5kZXggPT09IC0xID8gXCJcIiA6IG9wdGlvbnNbb3B0aW9ucy5zZWxlY3RlZEluZGV4XS52YWx1ZTtcbiAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBzZXRBdHRyaWJ1dGVzKHtcbiAgICBodG1sLFxuICAgIGVsZW1lbnQsXG4gICAgc3RvcmFnZSA9IG51bGwsXG4gICAgaW50ZW50LFxuICAgIGxpbmtTZXJ2aWNlXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfSA9IGVsZW1lbnQ7XG4gICAgY29uc3QgaXNIVE1MQW5jaG9yRWxlbWVudCA9IGh0bWwgaW5zdGFuY2VvZiBIVE1MQW5jaG9yRWxlbWVudDtcbiAgICBpZiAoYXR0cmlidXRlcy50eXBlID09PSBcInJhZGlvXCIpIHtcbiAgICAgIGF0dHJpYnV0ZXMubmFtZSA9IGAke2F0dHJpYnV0ZXMubmFtZX0tJHtpbnRlbnR9YDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZS5qb2luKFwiIFwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGF0YUlkXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpZFwiOlxuICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihodG1sLnN0eWxlLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0ZXh0Q29udGVudFwiOlxuICAgICAgICAgIGh0bWwudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWlzSFRNTEFuY2hvckVsZW1lbnQgfHwga2V5ICE9PSBcImhyZWZcIiAmJiBrZXkgIT09IFwibmV3V2luZG93XCIpIHtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzSFRNTEFuY2hvckVsZW1lbnQpIHtcbiAgICAgIGxpbmtTZXJ2aWNlLmFkZExpbmtBdHRyaWJ1dGVzKGh0bWwsIGF0dHJpYnV0ZXMuaHJlZiwgYXR0cmlidXRlcy5uZXdXaW5kb3cpO1xuICAgIH1cbiAgICBpZiAoc3RvcmFnZSAmJiBhdHRyaWJ1dGVzLmRhdGFJZCkge1xuICAgICAgdGhpcy5zZXR1cFN0b3JhZ2UoaHRtbCwgYXR0cmlidXRlcy5kYXRhSWQsIGVsZW1lbnQsIHN0b3JhZ2UpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgcmVuZGVyKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gcGFyYW1ldGVycy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBsaW5rU2VydmljZSA9IHBhcmFtZXRlcnMubGlua1NlcnZpY2U7XG4gICAgY29uc3Qgcm9vdCA9IHBhcmFtZXRlcnMueGZhSHRtbDtcbiAgICBjb25zdCBpbnRlbnQgPSBwYXJhbWV0ZXJzLmludGVudCB8fCBcImRpc3BsYXlcIjtcbiAgICBjb25zdCByb290SHRtbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocm9vdC5uYW1lKTtcbiAgICBpZiAocm9vdC5hdHRyaWJ1dGVzKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICBodG1sOiByb290SHRtbCxcbiAgICAgICAgZWxlbWVudDogcm9vdCxcbiAgICAgICAgaW50ZW50LFxuICAgICAgICBsaW5rU2VydmljZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGlzTm90Rm9yUmljaFRleHQgPSBpbnRlbnQgIT09IFwicmljaFRleHRcIjtcbiAgICBjb25zdCByb290RGl2ID0gcGFyYW1ldGVycy5kaXY7XG4gICAgcm9vdERpdi5hcHBlbmQocm9vdEh0bWwpO1xuICAgIGlmIChwYXJhbWV0ZXJzLnZpZXdwb3J0KSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBgbWF0cml4KCR7cGFyYW1ldGVycy52aWV3cG9ydC50cmFuc2Zvcm0uam9pbihcIixcIil9KWA7XG4gICAgICByb290RGl2LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB9XG4gICAgaWYgKGlzTm90Rm9yUmljaFRleHQpIHtcbiAgICAgIHJvb3REaXYuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJ4ZmFMYXllciB4ZmFGb250XCIpO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0RGl2cyA9IFtdO1xuICAgIGlmIChyb290LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHJvb3QudmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJvb3QudmFsdWUpO1xuICAgICAgICByb290SHRtbC5hcHBlbmQobm9kZSk7XG4gICAgICAgIGlmIChpc05vdEZvclJpY2hUZXh0ICYmIFhmYVRleHQuc2hvdWxkQnVpbGRUZXh0KHJvb3QubmFtZSkpIHtcbiAgICAgICAgICB0ZXh0RGl2cy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0RGl2c1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc3RhY2sgPSBbW3Jvb3QsIC0xLCByb290SHRtbF1dO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBbcGFyZW50LCBpLCBodG1sXSA9IHN0YWNrLmF0KC0xKTtcbiAgICAgIGlmIChpICsgMSA9PT0gcGFyZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZCA9IHBhcmVudC5jaGlsZHJlblsrK3N0YWNrLmF0KC0xKVsxXV07XG4gICAgICBpZiAoY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWVcbiAgICAgIH0gPSBjaGlsZDtcbiAgICAgIGlmIChuYW1lID09PSBcIiN0ZXh0XCIpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNoaWxkLnZhbHVlKTtcbiAgICAgICAgdGV4dERpdnMucHVzaChub2RlKTtcbiAgICAgICAgaHRtbC5hcHBlbmQobm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGRIdG1sID0gY2hpbGQ/LmF0dHJpYnV0ZXM/LnhtbG5zID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGNoaWxkLmF0dHJpYnV0ZXMueG1sbnMsIG5hbWUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbiAgICAgIGh0bWwuYXBwZW5kKGNoaWxkSHRtbCk7XG4gICAgICBpZiAoY2hpbGQuYXR0cmlidXRlcykge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgIGh0bWw6IGNoaWxkSHRtbCxcbiAgICAgICAgICBlbGVtZW50OiBjaGlsZCxcbiAgICAgICAgICBzdG9yYWdlLFxuICAgICAgICAgIGludGVudCxcbiAgICAgICAgICBsaW5rU2VydmljZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5jaGlsZHJlbj8ubGVuZ3RoID4gMCkge1xuICAgICAgICBzdGFjay5wdXNoKFtjaGlsZCwgLTEsIGNoaWxkSHRtbF0pO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC52YWx1ZSkge1xuICAgICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGQudmFsdWUpO1xuICAgICAgICBpZiAoaXNOb3RGb3JSaWNoVGV4dCAmJiBYZmFUZXh0LnNob3VsZEJ1aWxkVGV4dChuYW1lKSkge1xuICAgICAgICAgIHRleHREaXZzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRIdG1sLmFwcGVuZChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBlbCBvZiByb290RGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCIueGZhTm9uSW50ZXJhY3RpdmUgaW5wdXQsIC54ZmFOb25JbnRlcmFjdGl2ZSB0ZXh0YXJlYVwiKSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFwicmVhZE9ubHlcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0ZXh0RGl2c1xuICAgIH07XG4gIH1cbiAgc3RhdGljIHVwZGF0ZShwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gYG1hdHJpeCgke3BhcmFtZXRlcnMudmlld3BvcnQudHJhbnNmb3JtLmpvaW4oXCIsXCIpfSlgO1xuICAgIHBhcmFtZXRlcnMuZGl2LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBwYXJhbWV0ZXJzLmRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9hbm5vdGF0aW9uX2xheWVyLmpzXG5cblxuXG5cblxuXG5jb25zdCBERUZBVUxUX1RBQl9JTkRFWCA9IDEwMDA7XG5jb25zdCBhbm5vdGF0aW9uX2xheWVyX0RFRkFVTFRfRk9OVF9TSVpFID0gOTtcbmNvbnN0IEdldEVsZW1lbnRzQnlOYW1lU2V0ID0gbmV3IFdlYWtTZXQoKTtcbmZ1bmN0aW9uIGdldFJlY3REaW1zKHJlY3QpIHtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdFsyXSAtIHJlY3RbMF0sXG4gICAgaGVpZ2h0OiByZWN0WzNdIC0gcmVjdFsxXVxuICB9O1xufVxuY2xhc3MgQW5ub3RhdGlvbkVsZW1lbnRGYWN0b3J5IHtcbiAgc3RhdGljIGNyZWF0ZShwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3Qgc3VidHlwZSA9IHBhcmFtZXRlcnMuZGF0YS5hbm5vdGF0aW9uVHlwZTtcbiAgICBzd2l0Y2ggKHN1YnR5cGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuTElOSzpcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5rQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlRFWFQ6XG4gICAgICAgIHJldHVybiBuZXcgVGV4dEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5XSURHRVQ6XG4gICAgICAgIGNvbnN0IGZpZWxkVHlwZSA9IHBhcmFtZXRlcnMuZGF0YS5maWVsZFR5cGU7XG4gICAgICAgIHN3aXRjaCAoZmllbGRUeXBlKSB7XG4gICAgICAgICAgY2FzZSBcIlR4XCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICBjYXNlIFwiQnRuXCI6XG4gICAgICAgICAgICBpZiAocGFyYW1ldGVycy5kYXRhLnJhZGlvQnV0dG9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1ldGVycy5kYXRhLmNoZWNrQm94KSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hlY2tib3hXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHVzaEJ1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgIGNhc2UgXCJDaFwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaG9pY2VXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICBjYXNlIFwiU2lnXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZVdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlBPUFVQOlxuICAgICAgICByZXR1cm4gbmV3IFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLkZSRUVURVhUOlxuICAgICAgICByZXR1cm4gbmV3IEZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLkxJTkU6XG4gICAgICAgIHJldHVybiBuZXcgTGluZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5TUVVBUkU6XG4gICAgICAgIHJldHVybiBuZXcgU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLkNJUkNMRTpcbiAgICAgICAgcmV0dXJuIG5ldyBDaXJjbGVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuUE9MWUxJTkU6XG4gICAgICAgIHJldHVybiBuZXcgUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuQ0FSRVQ6XG4gICAgICAgIHJldHVybiBuZXcgQ2FyZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuSU5LOlxuICAgICAgICByZXR1cm4gbmV3IElua0Fubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5QT0xZR09OOlxuICAgICAgICByZXR1cm4gbmV3IFBvbHlnb25Bbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuSElHSExJR0hUOlxuICAgICAgICByZXR1cm4gbmV3IEhpZ2hsaWdodEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5VTkRFUkxJTkU6XG4gICAgICAgIHJldHVybiBuZXcgVW5kZXJsaW5lQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlNRVUlHR0xZOlxuICAgICAgICByZXR1cm4gbmV3IFNxdWlnZ2x5QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlNUUklLRU9VVDpcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJpa2VPdXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuU1RBTVA6XG4gICAgICAgIHJldHVybiBuZXcgU3RhbXBBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuRklMRUFUVEFDSE1FTlQ6XG4gICAgICAgIHJldHVybiBuZXcgRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuZXcgQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICN1cGRhdGVzID0gbnVsbDtcbiAgI2hhc0JvcmRlciA9IGZhbHNlO1xuICAjcG9wdXBFbGVtZW50ID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycywge1xuICAgIGlzUmVuZGVyYWJsZSA9IGZhbHNlLFxuICAgIGlnbm9yZUJvcmRlciA9IGZhbHNlLFxuICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5pc1JlbmRlcmFibGUgPSBpc1JlbmRlcmFibGU7XG4gICAgdGhpcy5kYXRhID0gcGFyYW1ldGVycy5kYXRhO1xuICAgIHRoaXMubGF5ZXIgPSBwYXJhbWV0ZXJzLmxheWVyO1xuICAgIHRoaXMubGlua1NlcnZpY2UgPSBwYXJhbWV0ZXJzLmxpbmtTZXJ2aWNlO1xuICAgIHRoaXMuZG93bmxvYWRNYW5hZ2VyID0gcGFyYW1ldGVycy5kb3dubG9hZE1hbmFnZXI7XG4gICAgdGhpcy5pbWFnZVJlc291cmNlc1BhdGggPSBwYXJhbWV0ZXJzLmltYWdlUmVzb3VyY2VzUGF0aDtcbiAgICB0aGlzLnJlbmRlckZvcm1zID0gcGFyYW1ldGVycy5yZW5kZXJGb3JtcztcbiAgICB0aGlzLnN2Z0ZhY3RvcnkgPSBwYXJhbWV0ZXJzLnN2Z0ZhY3Rvcnk7XG4gICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZSA9IHBhcmFtZXRlcnMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgdGhpcy5lbmFibGVTY3JpcHRpbmcgPSBwYXJhbWV0ZXJzLmVuYWJsZVNjcmlwdGluZztcbiAgICB0aGlzLmhhc0pTQWN0aW9ucyA9IHBhcmFtZXRlcnMuaGFzSlNBY3Rpb25zO1xuICAgIHRoaXMuX2ZpZWxkT2JqZWN0cyA9IHBhcmFtZXRlcnMuZmllbGRPYmplY3RzO1xuICAgIHRoaXMucGFyZW50ID0gcGFyYW1ldGVycy5wYXJlbnQ7XG4gICAgaWYgKGlzUmVuZGVyYWJsZSkge1xuICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLl9jcmVhdGVDb250YWluZXIoaWdub3JlQm9yZGVyKTtcbiAgICB9XG4gICAgaWYgKGNyZWF0ZVF1YWRyaWxhdGVyYWxzKSB7XG4gICAgICB0aGlzLl9jcmVhdGVRdWFkcmlsYXRlcmFscygpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgX2hhc1BvcHVwRGF0YSh7XG4gICAgdGl0bGVPYmosXG4gICAgY29udGVudHNPYmosXG4gICAgcmljaFRleHRcbiAgfSkge1xuICAgIHJldHVybiAhISh0aXRsZU9iaj8uc3RyIHx8IGNvbnRlbnRzT2JqPy5zdHIgfHwgcmljaFRleHQ/LnN0cik7XG4gIH1cbiAgZ2V0IF9pc0VkaXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuaXNFZGl0YWJsZTtcbiAgfVxuICBnZXQgaGFzUG9wdXBEYXRhKCkge1xuICAgIHJldHVybiBBbm5vdGF0aW9uRWxlbWVudC5faGFzUG9wdXBEYXRhKHRoaXMuZGF0YSk7XG4gIH1cbiAgdXBkYXRlRWRpdGVkKHBhcmFtcykge1xuICAgIGlmICghdGhpcy5jb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jdXBkYXRlcyB8fD0ge1xuICAgICAgcmVjdDogdGhpcy5kYXRhLnJlY3Quc2xpY2UoMClcbiAgICB9O1xuICAgIGNvbnN0IHtcbiAgICAgIHJlY3RcbiAgICB9ID0gcGFyYW1zO1xuICAgIGlmIChyZWN0KSB7XG4gICAgICB0aGlzLiNzZXRSZWN0RWRpdGVkKHJlY3QpO1xuICAgIH1cbiAgICB0aGlzLiNwb3B1cEVsZW1lbnQ/LnBvcHVwLnVwZGF0ZUVkaXRlZChwYXJhbXMpO1xuICB9XG4gIHJlc2V0RWRpdGVkKCkge1xuICAgIGlmICghdGhpcy4jdXBkYXRlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNzZXRSZWN0RWRpdGVkKHRoaXMuI3VwZGF0ZXMucmVjdCk7XG4gICAgdGhpcy4jcG9wdXBFbGVtZW50Py5wb3B1cC5yZXNldEVkaXRlZCgpO1xuICAgIHRoaXMuI3VwZGF0ZXMgPSBudWxsO1xuICB9XG4gICNzZXRSZWN0RWRpdGVkKHJlY3QpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXI6IHtcbiAgICAgICAgc3R5bGVcbiAgICAgIH0sXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHJlY3Q6IGN1cnJlbnRSZWN0LFxuICAgICAgICByb3RhdGlvblxuICAgICAgfSxcbiAgICAgIHBhcmVudDoge1xuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICAgICAgICBwYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgY3VycmVudFJlY3Q/LnNwbGljZSgwLCA0LCAuLi5yZWN0KTtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRSZWN0RGltcyhyZWN0KTtcbiAgICBzdHlsZS5sZWZ0ID0gYCR7MTAwICogKHJlY3RbMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGh9JWA7XG4gICAgc3R5bGUudG9wID0gYCR7MTAwICogKHBhZ2VIZWlnaHQgLSByZWN0WzNdICsgcGFnZVkpIC8gcGFnZUhlaWdodH0lYDtcbiAgICBpZiAocm90YXRpb24gPT09IDApIHtcbiAgICAgIHN0eWxlLndpZHRoID0gYCR7MTAwICogd2lkdGggLyBwYWdlV2lkdGh9JWA7XG4gICAgICBzdHlsZS5oZWlnaHQgPSBgJHsxMDAgKiBoZWlnaHQgLyBwYWdlSGVpZ2h0fSVgO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFJvdGF0aW9uKHJvdGF0aW9uKTtcbiAgICB9XG4gIH1cbiAgX2NyZWF0ZUNvbnRhaW5lcihpZ25vcmVCb3JkZXIpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgcGFyZW50OiB7XG4gICAgICAgIHBhZ2UsXG4gICAgICAgIHZpZXdwb3J0XG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIik7XG4gICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtYW5ub3RhdGlvbi1pZFwiLCBkYXRhLmlkKTtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQpKSB7XG4gICAgICBjb250YWluZXIudGFiSW5kZXggPSBERUZBVUxUX1RBQl9JTkRFWDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gY29udGFpbmVyO1xuICAgIHN0eWxlLnpJbmRleCA9IHRoaXMucGFyZW50LnpJbmRleCsrO1xuICAgIGlmIChkYXRhLmFsdGVybmF0aXZlVGV4dCkge1xuICAgICAgY29udGFpbmVyLnRpdGxlID0gZGF0YS5hbHRlcm5hdGl2ZVRleHQ7XG4gICAgfVxuICAgIGlmIChkYXRhLm5vUm90YXRlKSB7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm5vcm90YXRlXCIpO1xuICAgIH1cbiAgICBpZiAoIWRhdGEucmVjdCB8fCB0aGlzIGluc3RhbmNlb2YgUG9wdXBBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICByb3RhdGlvblxuICAgICAgfSA9IGRhdGE7XG4gICAgICBpZiAoIWRhdGEuaGFzT3duQ2FudmFzICYmIHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgIHRoaXMuc2V0Um90YXRpb24ocm90YXRpb24sIGNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRSZWN0RGltcyhkYXRhLnJlY3QpO1xuICAgIGlmICghaWdub3JlQm9yZGVyICYmIGRhdGEuYm9yZGVyU3R5bGUud2lkdGggPiAwKSB7XG4gICAgICBzdHlsZS5ib3JkZXJXaWR0aCA9IGAke2RhdGEuYm9yZGVyU3R5bGUud2lkdGh9cHhgO1xuICAgICAgY29uc3QgaG9yaXpvbnRhbFJhZGl1cyA9IGRhdGEuYm9yZGVyU3R5bGUuaG9yaXpvbnRhbENvcm5lclJhZGl1cztcbiAgICAgIGNvbnN0IHZlcnRpY2FsUmFkaXVzID0gZGF0YS5ib3JkZXJTdHlsZS52ZXJ0aWNhbENvcm5lclJhZGl1cztcbiAgICAgIGlmIChob3Jpem9udGFsUmFkaXVzID4gMCB8fCB2ZXJ0aWNhbFJhZGl1cyA+IDApIHtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gYGNhbGMoJHtob3Jpem9udGFsUmFkaXVzfXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSkgLyBjYWxjKCR7dmVydGljYWxSYWRpdXN9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpKWA7XG4gICAgICAgIHN0eWxlLmJvcmRlclJhZGl1cyA9IHJhZGl1cztcbiAgICAgIH0gZWxzZSBpZiAodGhpcyBpbnN0YW5jZW9mIFJhZGlvQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gYGNhbGMoJHt3aWR0aH1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpIC8gY2FsYygke2hlaWdodH1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYDtcbiAgICAgICAgc3R5bGUuYm9yZGVyUmFkaXVzID0gcmFkaXVzO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChkYXRhLmJvcmRlclN0eWxlLnN0eWxlKSB7XG4gICAgICAgIGNhc2UgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5TT0xJRDpcbiAgICAgICAgICBzdHlsZS5ib3JkZXJTdHlsZSA9IFwic29saWRcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLkRBU0hFRDpcbiAgICAgICAgICBzdHlsZS5ib3JkZXJTdHlsZSA9IFwiZGFzaGVkXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5CRVZFTEVEOlxuICAgICAgICAgIHdhcm4oXCJVbmltcGxlbWVudGVkIGJvcmRlciBzdHlsZTogYmV2ZWxlZFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLklOU0VUOlxuICAgICAgICAgIHdhcm4oXCJVbmltcGxlbWVudGVkIGJvcmRlciBzdHlsZTogaW5zZXRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5VTkRFUkxJTkU6XG4gICAgICAgICAgc3R5bGUuYm9yZGVyQm90dG9tU3R5bGUgPSBcInNvbGlkXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBib3JkZXJDb2xvciA9IGRhdGEuYm9yZGVyQ29sb3IgfHwgbnVsbDtcbiAgICAgIGlmIChib3JkZXJDb2xvcikge1xuICAgICAgICB0aGlzLiNoYXNCb3JkZXIgPSB0cnVlO1xuICAgICAgICBzdHlsZS5ib3JkZXJDb2xvciA9IFV0aWwubWFrZUhleENvbG9yKGJvcmRlckNvbG9yWzBdIHwgMCwgYm9yZGVyQ29sb3JbMV0gfCAwLCBib3JkZXJDb2xvclsyXSB8IDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUuYm9yZGVyV2lkdGggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZWN0ID0gVXRpbC5ub3JtYWxpemVSZWN0KFtkYXRhLnJlY3RbMF0sIHBhZ2Uudmlld1szXSAtIGRhdGEucmVjdFsxXSArIHBhZ2Uudmlld1sxXSwgZGF0YS5yZWN0WzJdLCBwYWdlLnZpZXdbM10gLSBkYXRhLnJlY3RbM10gKyBwYWdlLnZpZXdbMV1dKTtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0LFxuICAgICAgcGFnZVgsXG4gICAgICBwYWdlWVxuICAgIH0gPSB2aWV3cG9ydC5yYXdEaW1zO1xuICAgIHN0eWxlLmxlZnQgPSBgJHsxMDAgKiAocmVjdFswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aH0lYDtcbiAgICBzdHlsZS50b3AgPSBgJHsxMDAgKiAocmVjdFsxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgY29uc3Qge1xuICAgICAgcm90YXRpb25cbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoZGF0YS5oYXNPd25DYW52YXMgfHwgcm90YXRpb24gPT09IDApIHtcbiAgICAgIHN0eWxlLndpZHRoID0gYCR7MTAwICogd2lkdGggLyBwYWdlV2lkdGh9JWA7XG4gICAgICBzdHlsZS5oZWlnaHQgPSBgJHsxMDAgKiBoZWlnaHQgLyBwYWdlSGVpZ2h0fSVgO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFJvdGF0aW9uKHJvdGF0aW9uLCBjb250YWluZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9XG4gIHNldFJvdGF0aW9uKGFuZ2xlLCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcikge1xuICAgIGlmICghdGhpcy5kYXRhLnJlY3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodFxuICAgIH0gPSB0aGlzLnBhcmVudC52aWV3cG9ydC5yYXdEaW1zO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKHRoaXMuZGF0YS5yZWN0KTtcbiAgICBsZXQgZWxlbWVudFdpZHRoLCBlbGVtZW50SGVpZ2h0O1xuICAgIGlmIChhbmdsZSAlIDE4MCA9PT0gMCkge1xuICAgICAgZWxlbWVudFdpZHRoID0gMTAwICogd2lkdGggLyBwYWdlV2lkdGg7XG4gICAgICBlbGVtZW50SGVpZ2h0ID0gMTAwICogaGVpZ2h0IC8gcGFnZUhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudFdpZHRoID0gMTAwICogaGVpZ2h0IC8gcGFnZVdpZHRoO1xuICAgICAgZWxlbWVudEhlaWdodCA9IDEwMCAqIHdpZHRoIC8gcGFnZUhlaWdodDtcbiAgICB9XG4gICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gYCR7ZWxlbWVudFdpZHRofSVgO1xuICAgIGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBgJHtlbGVtZW50SGVpZ2h0fSVgO1xuICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1haW4tcm90YXRpb25cIiwgKDM2MCAtIGFuZ2xlKSAlIDM2MCk7XG4gIH1cbiAgZ2V0IF9jb21tb25BY3Rpb25zKCkge1xuICAgIGNvbnN0IHNldENvbG9yID0gKGpzTmFtZSwgc3R5bGVOYW1lLCBldmVudCkgPT4ge1xuICAgICAgY29uc3QgY29sb3IgPSBldmVudC5kZXRhaWxbanNOYW1lXTtcbiAgICAgIGNvbnN0IGNvbG9yVHlwZSA9IGNvbG9yWzBdO1xuICAgICAgY29uc3QgY29sb3JBcnJheSA9IGNvbG9yLnNsaWNlKDEpO1xuICAgICAgZXZlbnQudGFyZ2V0LnN0eWxlW3N0eWxlTmFtZV0gPSBDb2xvckNvbnZlcnRlcnNbYCR7Y29sb3JUeXBlfV9IVE1MYF0oY29sb3JBcnJheSk7XG4gICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKHRoaXMuZGF0YS5pZCwge1xuICAgICAgICBbc3R5bGVOYW1lXTogQ29sb3JDb252ZXJ0ZXJzW2Ake2NvbG9yVHlwZX1fcmdiYF0oY29sb3JBcnJheSlcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9jb21tb25BY3Rpb25zXCIsIHtcbiAgICAgIGRpc3BsYXk6IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGRpc3BsYXlcbiAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgY29uc3QgaGlkZGVuID0gZGlzcGxheSAlIDIgPT09IDE7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSBoaWRkZW4gPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCI7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgbm9WaWV3OiBoaWRkZW4sXG4gICAgICAgICAgbm9QcmludDogZGlzcGxheSA9PT0gMSB8fCBkaXNwbGF5ID09PSAyXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHByaW50OiBldmVudCA9PiB7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgbm9QcmludDogIWV2ZW50LmRldGFpbC5wcmludFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBoaWRkZW46IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGhpZGRlblxuICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gaGlkZGVuID8gXCJoaWRkZW5cIiA6IFwidmlzaWJsZVwiO1xuICAgICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKHRoaXMuZGF0YS5pZCwge1xuICAgICAgICAgIG5vUHJpbnQ6IGhpZGRlbixcbiAgICAgICAgICBub1ZpZXc6IGhpZGRlblxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBmb2N1czogZXZlbnQgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGV2ZW50LnRhcmdldC5mb2N1cyh7XG4gICAgICAgICAgcHJldmVudFNjcm9sbDogZmFsc2VcbiAgICAgICAgfSksIDApO1xuICAgICAgfSxcbiAgICAgIHVzZXJOYW1lOiBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnRhcmdldC50aXRsZSA9IGV2ZW50LmRldGFpbC51c2VyTmFtZTtcbiAgICAgIH0sXG4gICAgICByZWFkb25seTogZXZlbnQgPT4ge1xuICAgICAgICBldmVudC50YXJnZXQuZGlzYWJsZWQgPSBldmVudC5kZXRhaWwucmVhZG9ubHk7XG4gICAgICB9LFxuICAgICAgcmVxdWlyZWQ6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5fc2V0UmVxdWlyZWQoZXZlbnQudGFyZ2V0LCBldmVudC5kZXRhaWwucmVxdWlyZWQpO1xuICAgICAgfSxcbiAgICAgIGJnQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJiZ0NvbG9yXCIsIFwiYmFja2dyb3VuZENvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBmaWxsQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJmaWxsQ29sb3JcIiwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGZnQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJmZ0NvbG9yXCIsIFwiY29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIHRleHRDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcInRleHRDb2xvclwiLCBcImNvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBib3JkZXJDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImJvcmRlckNvbG9yXCIsIFwiYm9yZGVyQ29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIHN0cm9rZUNvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwic3Ryb2tlQ29sb3JcIiwgXCJib3JkZXJDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgcm90YXRpb246IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYW5nbGUgPSBldmVudC5kZXRhaWwucm90YXRpb247XG4gICAgICAgIHRoaXMuc2V0Um90YXRpb24oYW5nbGUpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKHRoaXMuZGF0YS5pZCwge1xuICAgICAgICAgIHJvdGF0aW9uOiBhbmdsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpIHtcbiAgICBjb25zdCBjb21tb25BY3Rpb25zID0gdGhpcy5fY29tbW9uQWN0aW9ucztcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoanNFdmVudC5kZXRhaWwpKSB7XG4gICAgICBjb25zdCBhY3Rpb24gPSBhY3Rpb25zW25hbWVdIHx8IGNvbW1vbkFjdGlvbnNbbmFtZV07XG4gICAgICBhY3Rpb24/Lihqc0V2ZW50KTtcbiAgICB9XG4gIH1cbiAgX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGVsZW1lbnQpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlU2NyaXB0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0b3JlZERhdGEgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlLmdldFJhd1ZhbHVlKHRoaXMuZGF0YS5pZCk7XG4gICAgaWYgKCFzdG9yZWREYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbW1vbkFjdGlvbnMgPSB0aGlzLl9jb21tb25BY3Rpb25zO1xuICAgIGZvciAoY29uc3QgW2FjdGlvbk5hbWUsIGRldGFpbF0gb2YgT2JqZWN0LmVudHJpZXMoc3RvcmVkRGF0YSkpIHtcbiAgICAgIGNvbnN0IGFjdGlvbiA9IGNvbW1vbkFjdGlvbnNbYWN0aW9uTmFtZV07XG4gICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50UHJveHkgPSB7XG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBbYWN0aW9uTmFtZV06IGRldGFpbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGFyZ2V0OiBlbGVtZW50XG4gICAgICAgIH07XG4gICAgICAgIGFjdGlvbihldmVudFByb3h5KTtcbiAgICAgICAgZGVsZXRlIHN0b3JlZERhdGFbYWN0aW9uTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9jcmVhdGVRdWFkcmlsYXRlcmFscygpIHtcbiAgICBpZiAoIXRoaXMuY29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHF1YWRQb2ludHNcbiAgICB9ID0gdGhpcy5kYXRhO1xuICAgIGlmICghcXVhZFBvaW50cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbcmVjdEJsWCwgcmVjdEJsWSwgcmVjdFRyWCwgcmVjdFRyWV0gPSB0aGlzLmRhdGEucmVjdC5tYXAoeCA9PiBNYXRoLmZyb3VuZCh4KSk7XG4gICAgaWYgKHF1YWRQb2ludHMubGVuZ3RoID09PSA4KSB7XG4gICAgICBjb25zdCBbdHJYLCB0clksIGJsWCwgYmxZXSA9IHF1YWRQb2ludHMuc3ViYXJyYXkoMiwgNik7XG4gICAgICBpZiAocmVjdFRyWCA9PT0gdHJYICYmIHJlY3RUclkgPT09IHRyWSAmJiByZWN0QmxYID09PSBibFggJiYgcmVjdEJsWSA9PT0gYmxZKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy5jb250YWluZXI7XG4gICAgbGV0IHN2Z0J1ZmZlcjtcbiAgICBpZiAodGhpcy4jaGFzQm9yZGVyKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGJvcmRlckNvbG9yLFxuICAgICAgICBib3JkZXJXaWR0aFxuICAgICAgfSA9IHN0eWxlO1xuICAgICAgc3R5bGUuYm9yZGVyV2lkdGggPSAwO1xuICAgICAgc3ZnQnVmZmVyID0gW1widXJsKCdkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCxcIiwgYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiYCwgYCBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMSAxXCI+YCwgYDxnIGZpbGw9XCJ0cmFuc3BhcmVudFwiIHN0cm9rZT1cIiR7Ym9yZGVyQ29sb3J9XCIgc3Ryb2tlLXdpZHRoPVwiJHtib3JkZXJXaWR0aH1cIj5gXTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoYXNCb3JkZXJcIik7XG4gICAgfVxuICAgIGNvbnN0IHdpZHRoID0gcmVjdFRyWCAtIHJlY3RCbFg7XG4gICAgY29uc3QgaGVpZ2h0ID0gcmVjdFRyWSAtIHJlY3RCbFk7XG4gICAgY29uc3Qge1xuICAgICAgc3ZnRmFjdG9yeVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN2ZyA9IHN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Z1wiKTtcbiAgICBzdmcuY2xhc3NMaXN0LmFkZChcInF1YWRyaWxhdGVyYWxzQ29udGFpbmVyXCIpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCAwKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIDApO1xuICAgIGNvbnN0IGRlZnMgPSBzdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIpO1xuICAgIHN2Zy5hcHBlbmQoZGVmcyk7XG4gICAgY29uc3QgY2xpcFBhdGggPSBzdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJjbGlwUGF0aFwiKTtcbiAgICBjb25zdCBpZCA9IGBjbGlwcGF0aF8ke3RoaXMuZGF0YS5pZH1gO1xuICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZShcImlkXCIsIGlkKTtcbiAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGUoXCJjbGlwUGF0aFVuaXRzXCIsIFwib2JqZWN0Qm91bmRpbmdCb3hcIik7XG4gICAgZGVmcy5hcHBlbmQoY2xpcFBhdGgpO1xuICAgIGZvciAobGV0IGkgPSAyLCBpaSA9IHF1YWRQb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gOCkge1xuICAgICAgY29uc3QgdHJYID0gcXVhZFBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHRyWSA9IHF1YWRQb2ludHNbaSArIDFdO1xuICAgICAgY29uc3QgYmxYID0gcXVhZFBvaW50c1tpICsgMl07XG4gICAgICBjb25zdCBibFkgPSBxdWFkUG9pbnRzW2kgKyAzXTtcbiAgICAgIGNvbnN0IHJlY3QgPSBzdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIpO1xuICAgICAgY29uc3QgeCA9IChibFggLSByZWN0QmxYKSAvIHdpZHRoO1xuICAgICAgY29uc3QgeSA9IChyZWN0VHJZIC0gdHJZKSAvIGhlaWdodDtcbiAgICAgIGNvbnN0IHJlY3RXaWR0aCA9ICh0clggLSBibFgpIC8gd2lkdGg7XG4gICAgICBjb25zdCByZWN0SGVpZ2h0ID0gKHRyWSAtIGJsWSkgLyBoZWlnaHQ7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcInhcIiwgeCk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcInlcIiwgeSk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHJlY3RXaWR0aCk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCByZWN0SGVpZ2h0KTtcbiAgICAgIGNsaXBQYXRoLmFwcGVuZChyZWN0KTtcbiAgICAgIHN2Z0J1ZmZlcj8ucHVzaChgPHJlY3QgdmVjdG9yLWVmZmVjdD1cIm5vbi1zY2FsaW5nLXN0cm9rZVwiIHg9XCIke3h9XCIgeT1cIiR7eX1cIiB3aWR0aD1cIiR7cmVjdFdpZHRofVwiIGhlaWdodD1cIiR7cmVjdEhlaWdodH1cIi8+YCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNoYXNCb3JkZXIpIHtcbiAgICAgIHN2Z0J1ZmZlci5wdXNoKGA8L2c+PC9zdmc+JylgKTtcbiAgICAgIHN0eWxlLmJhY2tncm91bmRJbWFnZSA9IHN2Z0J1ZmZlci5qb2luKFwiXCIpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5jbGlwUGF0aCA9IGB1cmwoIyR7aWR9KWA7XG4gIH1cbiAgX2NyZWF0ZVBvcHVwKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGFcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBwb3B1cCA9IHRoaXMuI3BvcHVwRWxlbWVudCA9IG5ldyBQb3B1cEFubm90YXRpb25FbGVtZW50KHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgY29sb3I6IGRhdGEuY29sb3IsXG4gICAgICAgIHRpdGxlT2JqOiBkYXRhLnRpdGxlT2JqLFxuICAgICAgICBtb2RpZmljYXRpb25EYXRlOiBkYXRhLm1vZGlmaWNhdGlvbkRhdGUsXG4gICAgICAgIGNvbnRlbnRzT2JqOiBkYXRhLmNvbnRlbnRzT2JqLFxuICAgICAgICByaWNoVGV4dDogZGF0YS5yaWNoVGV4dCxcbiAgICAgICAgcGFyZW50UmVjdDogZGF0YS5yZWN0LFxuICAgICAgICBib3JkZXJTdHlsZTogMCxcbiAgICAgICAgaWQ6IGBwb3B1cF8ke2RhdGEuaWR9YCxcbiAgICAgICAgcm90YXRpb246IGRhdGEucm90YXRpb25cbiAgICAgIH0sXG4gICAgICBwYXJlbnQ6IHRoaXMucGFyZW50LFxuICAgICAgZWxlbWVudHM6IFt0aGlzXVxuICAgIH0pO1xuICAgIHRoaXMucGFyZW50LmRpdi5hcHBlbmQocG9wdXAucmVuZGVyKCkpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgQW5ub3RhdGlvbkVsZW1lbnQucmVuZGVyYCBjYWxsZWRcIik7XG4gIH1cbiAgX2dldEVsZW1lbnRzQnlOYW1lKG5hbWUsIHNraXBJZCA9IG51bGwpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXTtcbiAgICBpZiAodGhpcy5fZmllbGRPYmplY3RzKSB7XG4gICAgICBjb25zdCBmaWVsZE9iaiA9IHRoaXMuX2ZpZWxkT2JqZWN0c1tuYW1lXTtcbiAgICAgIGlmIChmaWVsZE9iaikge1xuICAgICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgICBwYWdlLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGV4cG9ydFZhbHVlc1xuICAgICAgICB9IG9mIGZpZWxkT2JqKSB7XG4gICAgICAgICAgaWYgKHBhZ2UgPT09IC0xKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlkID09PSBza2lwSWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBleHBvcnRWYWx1ZSA9IHR5cGVvZiBleHBvcnRWYWx1ZXMgPT09IFwic3RyaW5nXCIgPyBleHBvcnRWYWx1ZXMgOiBudWxsO1xuICAgICAgICAgIGNvbnN0IGRvbUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1lbGVtZW50LWlkPVwiJHtpZH1cIl1gKTtcbiAgICAgICAgICBpZiAoZG9tRWxlbWVudCAmJiAhR2V0RWxlbWVudHNCeU5hbWVTZXQuaGFzKGRvbUVsZW1lbnQpKSB7XG4gICAgICAgICAgICB3YXJuKGBfZ2V0RWxlbWVudHNCeU5hbWUgLSBlbGVtZW50IG5vdCBhbGxvd2VkOiAke2lkfWApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgZXhwb3J0VmFsdWUsXG4gICAgICAgICAgICBkb21FbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmaWVsZHM7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZG9tRWxlbWVudCBvZiBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShuYW1lKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBleHBvcnRWYWx1ZVxuICAgICAgfSA9IGRvbUVsZW1lbnQ7XG4gICAgICBjb25zdCBpZCA9IGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIpO1xuICAgICAgaWYgKGlkID09PSBza2lwSWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIUdldEVsZW1lbnRzQnlOYW1lU2V0Lmhhcyhkb21FbGVtZW50KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZpZWxkcy5wdXNoKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGV4cG9ydFZhbHVlLFxuICAgICAgICBkb21FbGVtZW50XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkcztcbiAgfVxuICBzaG93KCkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5lcikge1xuICAgICAgdGhpcy5jb250YWluZXIuaGlkZGVuID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMucG9wdXA/Lm1heWJlU2hvdygpO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5oaWRkZW4gPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLnBvcHVwPy5mb3JjZUhpZGUoKTtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIGNvbnN0IHRyaWdnZXJzID0gdGhpcy5nZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHJpZ2dlcnMpKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdHJpZ2dlcnMpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlcnMuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gICAgfVxuICB9XG4gIF9lZGl0T25Eb3VibGVDbGljaygpIHtcbiAgICBpZiAoIXRoaXMuX2lzRWRpdGFibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYW5ub3RhdGlvbkVkaXRvclR5cGU6IG1vZGUsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGlkOiBlZGl0SWRcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiZGJsY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ybW9kZVwiLCB7XG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgZWRpdElkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgTGlua0Fubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzLCBvcHRpb25zID0gbnVsbCkge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogISFvcHRpb25zPy5pZ25vcmVCb3JkZXIsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuaXNUb29sdGlwT25seSA9IHBhcmFtZXRlcnMuZGF0YS5pc1Rvb2x0aXBPbmx5O1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgbGlua1NlcnZpY2VcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgbGluay5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgZGF0YS5pZCk7XG4gICAgbGV0IGlzQm91bmQgPSBmYWxzZTtcbiAgICBpZiAoZGF0YS51cmwpIHtcbiAgICAgIGxpbmtTZXJ2aWNlLmFkZExpbmtBdHRyaWJ1dGVzKGxpbmssIGRhdGEudXJsLCBkYXRhLm5ld1dpbmRvdyk7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuYWN0aW9uKSB7XG4gICAgICB0aGlzLl9iaW5kTmFtZWRBY3Rpb24obGluaywgZGF0YS5hY3Rpb24pO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhLmF0dGFjaG1lbnQpIHtcbiAgICAgIHRoaXMuI2JpbmRBdHRhY2htZW50KGxpbmssIGRhdGEuYXR0YWNobWVudCwgZGF0YS5hdHRhY2htZW50RGVzdCk7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuc2V0T0NHU3RhdGUpIHtcbiAgICAgIHRoaXMuI2JpbmRTZXRPQ0dTdGF0ZShsaW5rLCBkYXRhLnNldE9DR1N0YXRlKTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5kZXN0KSB7XG4gICAgICB0aGlzLl9iaW5kTGluayhsaW5rLCBkYXRhLmRlc3QpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkYXRhLmFjdGlvbnMgJiYgKGRhdGEuYWN0aW9ucy5BY3Rpb24gfHwgZGF0YS5hY3Rpb25zW1wiTW91c2UgVXBcIl0gfHwgZGF0YS5hY3Rpb25zW1wiTW91c2UgRG93blwiXSkgJiYgdGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fYmluZEpTQWN0aW9uKGxpbmssIGRhdGEpO1xuICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnJlc2V0Rm9ybSkge1xuICAgICAgICB0aGlzLl9iaW5kUmVzZXRGb3JtQWN0aW9uKGxpbmssIGRhdGEucmVzZXRGb3JtKTtcbiAgICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNUb29sdGlwT25seSAmJiAhaXNCb3VuZCkge1xuICAgICAgICB0aGlzLl9iaW5kTGluayhsaW5rLCBcIlwiKTtcbiAgICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJsaW5rQW5ub3RhdGlvblwiKTtcbiAgICBpZiAoaXNCb3VuZCkge1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGxpbmspO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgI3NldEludGVybmFsTGluaygpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLWludGVybmFsLWxpbmtcIiwgXCJcIik7XG4gIH1cbiAgX2JpbmRMaW5rKGxpbmssIGRlc3RpbmF0aW9uKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXREZXN0aW5hdGlvbkhhc2goZGVzdGluYXRpb24pO1xuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIGlmIChkZXN0aW5hdGlvbikge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmdvVG9EZXN0aW5hdGlvbihkZXN0aW5hdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBpZiAoZGVzdGluYXRpb24gfHwgZGVzdGluYXRpb24gPT09IFwiXCIpIHtcbiAgICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICAgIH1cbiAgfVxuICBfYmluZE5hbWVkQWN0aW9uKGxpbmssIGFjdGlvbikge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIHRoaXMubGlua1NlcnZpY2UuZXhlY3V0ZU5hbWVkQWN0aW9uKGFjdGlvbik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgfVxuICAjYmluZEF0dGFjaG1lbnQobGluaywgYXR0YWNobWVudCwgZGVzdCA9IG51bGwpIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldEFuY2hvclVybChcIlwiKTtcbiAgICBpZiAoYXR0YWNobWVudC5kZXNjcmlwdGlvbikge1xuICAgICAgbGluay50aXRsZSA9IGF0dGFjaG1lbnQuZGVzY3JpcHRpb247XG4gICAgfVxuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIHRoaXMuZG93bmxvYWRNYW5hZ2VyPy5vcGVuT3JEb3dubG9hZERhdGEoYXR0YWNobWVudC5jb250ZW50LCBhdHRhY2htZW50LmZpbGVuYW1lLCBkZXN0KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gICNiaW5kU2V0T0NHU3RhdGUobGluaywgYWN0aW9uKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5saW5rU2VydmljZS5leGVjdXRlU2V0T0NHU3RhdGUoYWN0aW9uKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gIF9iaW5kSlNBY3Rpb24obGluaywgZGF0YSkge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoW1tcIkFjdGlvblwiLCBcIm9uY2xpY2tcIl0sIFtcIk1vdXNlIFVwXCIsIFwib25tb3VzZXVwXCJdLCBbXCJNb3VzZSBEb3duXCIsIFwib25tb3VzZWRvd25cIl1dKTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoZGF0YS5hY3Rpb25zKSkge1xuICAgICAgY29uc3QganNOYW1lID0gbWFwLmdldChuYW1lKTtcbiAgICAgIGlmICghanNOYW1lKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGlua1tqc05hbWVdID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkOiBkYXRhLmlkLFxuICAgICAgICAgICAgbmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghbGluay5vbmNsaWNrKSB7XG4gICAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gIH1cbiAgX2JpbmRSZXNldEZvcm1BY3Rpb24obGluaywgcmVzZXRGb3JtKSB7XG4gICAgY29uc3Qgb3RoZXJDbGlja0FjdGlvbiA9IGxpbmsub25jbGljaztcbiAgICBpZiAoIW90aGVyQ2xpY2tBY3Rpb24pIHtcbiAgICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIH1cbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgICBpZiAoIXRoaXMuX2ZpZWxkT2JqZWN0cykge1xuICAgICAgd2FybihgX2JpbmRSZXNldEZvcm1BY3Rpb24gLSBcInJlc2V0Rm9ybVwiIGFjdGlvbiBub3Qgc3VwcG9ydGVkLCBgICsgXCJlbnN1cmUgdGhhdCB0aGUgYGZpZWxkT2JqZWN0c2AgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLlwiKTtcbiAgICAgIGlmICghb3RoZXJDbGlja0FjdGlvbikge1xuICAgICAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgb3RoZXJDbGlja0FjdGlvbj8uKCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZpZWxkczogcmVzZXRGb3JtRmllbGRzLFxuICAgICAgICByZWZzOiByZXNldEZvcm1SZWZzLFxuICAgICAgICBpbmNsdWRlXG4gICAgICB9ID0gcmVzZXRGb3JtO1xuICAgICAgY29uc3QgYWxsRmllbGRzID0gW107XG4gICAgICBpZiAocmVzZXRGb3JtRmllbGRzLmxlbmd0aCAhPT0gMCB8fCByZXNldEZvcm1SZWZzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBjb25zdCBmaWVsZElkcyA9IG5ldyBTZXQocmVzZXRGb3JtUmVmcyk7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIHJlc2V0Rm9ybUZpZWxkcykge1xuICAgICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuX2ZpZWxkT2JqZWN0c1tmaWVsZE5hbWVdIHx8IFtdO1xuICAgICAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICAgICAgaWRcbiAgICAgICAgICB9IG9mIGZpZWxkcykge1xuICAgICAgICAgICAgZmllbGRJZHMuYWRkKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBmaWVsZHMgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9maWVsZE9iamVjdHMpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZElkcy5oYXMoZmllbGQuaWQpID09PSBpbmNsdWRlKSB7XG4gICAgICAgICAgICAgIGFsbEZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGRzIG9mIE9iamVjdC52YWx1ZXModGhpcy5fZmllbGRPYmplY3RzKSkge1xuICAgICAgICAgIGFsbEZpZWxkcy5wdXNoKC4uLmZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgICAgY29uc3QgYWxsSWRzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGFsbEZpZWxkcykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IGZpZWxkO1xuICAgICAgICBhbGxJZHMucHVzaChpZCk7XG4gICAgICAgIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQuZGVmYXVsdFZhbHVlIHx8IFwiXCI7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImNoZWNrYm94XCI6XG4gICAgICAgICAgY2FzZSBcInJhZGlvYnV0dG9uXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQuZGVmYXVsdFZhbHVlID09PSBmaWVsZC5leHBvcnRWYWx1ZXM7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImNvbWJvYm94XCI6XG4gICAgICAgICAgY2FzZSBcImxpc3Rib3hcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5kZWZhdWx0VmFsdWUgfHwgXCJcIjtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9tRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWVsZW1lbnQtaWQ9XCIke2lkfVwiXWApO1xuICAgICAgICBpZiAoIWRvbUVsZW1lbnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmICghR2V0RWxlbWVudHNCeU5hbWVTZXQuaGFzKGRvbUVsZW1lbnQpKSB7XG4gICAgICAgICAgd2FybihgX2JpbmRSZXNldEZvcm1BY3Rpb24gLSBlbGVtZW50IG5vdCBhbGxvd2VkOiAke2lkfWApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGRvbUVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJyZXNldGZvcm1cIikpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nKSB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQ6IFwiYXBwXCIsXG4gICAgICAgICAgICBpZHM6IGFsbElkcyxcbiAgICAgICAgICAgIG5hbWU6IFwiUmVzZXRGb3JtXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH1cbn1cbmNsYXNzIFRleHRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidGV4dEFubm90YXRpb25cIik7XG4gICAgY29uc3QgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgIGltYWdlLnNyYyA9IHRoaXMuaW1hZ2VSZXNvdXJjZXNQYXRoICsgXCJhbm5vdGF0aW9uLVwiICsgdGhpcy5kYXRhLm5hbWUudG9Mb3dlckNhc2UoKSArIFwiLnN2Z1wiO1xuICAgIGltYWdlLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLXRleHQtYW5ub3RhdGlvbi10eXBlXCIpO1xuICAgIGltYWdlLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1hcmdzXCIsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHR5cGU6IHRoaXMuZGF0YS5uYW1lXG4gICAgfSkpO1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoaW1hZ2UpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgc2hvd0VsZW1lbnRBbmRIaWRlQ2FudmFzKGVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5kYXRhLmhhc093bkNhbnZhcykge1xuICAgICAgaWYgKGVsZW1lbnQucHJldmlvdXNTaWJsaW5nPy5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIikge1xuICAgICAgICBlbGVtZW50LnByZXZpb3VzU2libGluZy5oaWRkZW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgX2dldEtleU1vZGlmaWVyKGV2ZW50KSB7XG4gICAgcmV0dXJuIHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm0uaXNNYWMgPyBldmVudC5tZXRhS2V5IDogZXZlbnQuY3RybEtleTtcbiAgfVxuICBfc2V0RXZlbnRMaXN0ZW5lcihlbGVtZW50LCBlbGVtZW50RGF0YSwgYmFzZU5hbWUsIGV2ZW50TmFtZSwgdmFsdWVHZXR0ZXIpIHtcbiAgICBpZiAoYmFzZU5hbWUuaW5jbHVkZXMoXCJtb3VzZVwiKSkge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGJhc2VOYW1lLCBldmVudCA9PiB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQ6IHRoaXMuZGF0YS5pZCxcbiAgICAgICAgICAgIG5hbWU6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZUdldHRlcihldmVudCksXG4gICAgICAgICAgICBzaGlmdDogZXZlbnQuc2hpZnRLZXksXG4gICAgICAgICAgICBtb2RpZmllcjogdGhpcy5fZ2V0S2V5TW9kaWZpZXIoZXZlbnQpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoYmFzZU5hbWUsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGJhc2VOYW1lID09PSBcImJsdXJcIikge1xuICAgICAgICAgIGlmICghZWxlbWVudERhdGEuZm9jdXNlZCB8fCAhZXZlbnQucmVsYXRlZFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50RGF0YS5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoYmFzZU5hbWUgPT09IFwiZm9jdXNcIikge1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5mb2N1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsdWVHZXR0ZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZDogdGhpcy5kYXRhLmlkLFxuICAgICAgICAgICAgbmFtZTogZXZlbnROYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlR2V0dGVyKGV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBuYW1lcywgZ2V0dGVyKSB7XG4gICAgZm9yIChjb25zdCBbYmFzZU5hbWUsIGV2ZW50TmFtZV0gb2YgbmFtZXMpIHtcbiAgICAgIGlmIChldmVudE5hbWUgPT09IFwiQWN0aW9uXCIgfHwgdGhpcy5kYXRhLmFjdGlvbnM/LltldmVudE5hbWVdKSB7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiRm9jdXNcIiB8fCBldmVudE5hbWUgPT09IFwiQmx1clwiKSB7XG4gICAgICAgICAgZWxlbWVudERhdGEgfHw9IHtcbiAgICAgICAgICAgIGZvY3VzZWQ6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBiYXNlTmFtZSwgZXZlbnROYW1lLCBnZXR0ZXIpO1xuICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcIkZvY3VzXCIgJiYgIXRoaXMuZGF0YS5hY3Rpb25zPy5CbHVyKSB7XG4gICAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcihlbGVtZW50LCBlbGVtZW50RGF0YSwgXCJibHVyXCIsIFwiQmx1clwiLCBudWxsKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudE5hbWUgPT09IFwiQmx1clwiICYmICF0aGlzLmRhdGEuYWN0aW9ucz8uRm9jdXMpIHtcbiAgICAgICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBcImZvY3VzXCIsIFwiRm9jdXNcIiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3NldEJhY2tncm91bmRDb2xvcihlbGVtZW50KSB7XG4gICAgY29uc3QgY29sb3IgPSB0aGlzLmRhdGEuYmFja2dyb3VuZENvbG9yIHx8IG51bGw7XG4gICAgZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvciA9PT0gbnVsbCA/IFwidHJhbnNwYXJlbnRcIiA6IFV0aWwubWFrZUhleENvbG9yKGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0pO1xuICB9XG4gIF9zZXRUZXh0U3R5bGUoZWxlbWVudCkge1xuICAgIGNvbnN0IFRFWFRfQUxJR05NRU5UID0gW1wibGVmdFwiLCBcImNlbnRlclwiLCBcInJpZ2h0XCJdO1xuICAgIGNvbnN0IHtcbiAgICAgIGZvbnRDb2xvclxuICAgIH0gPSB0aGlzLmRhdGEuZGVmYXVsdEFwcGVhcmFuY2VEYXRhO1xuICAgIGNvbnN0IGZvbnRTaXplID0gdGhpcy5kYXRhLmRlZmF1bHRBcHBlYXJhbmNlRGF0YS5mb250U2l6ZSB8fCBhbm5vdGF0aW9uX2xheWVyX0RFRkFVTFRfRk9OVF9TSVpFO1xuICAgIGNvbnN0IHN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgICBsZXQgY29tcHV0ZWRGb250U2l6ZTtcbiAgICBjb25zdCBCT1JERVJfU0laRSA9IDI7XG4gICAgY29uc3Qgcm91bmRUb09uZURlY2ltYWwgPSB4ID0+IE1hdGgucm91bmQoMTAgKiB4KSAvIDEwO1xuICAgIGlmICh0aGlzLmRhdGEubXVsdGlMaW5lKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmFicyh0aGlzLmRhdGEucmVjdFszXSAtIHRoaXMuZGF0YS5yZWN0WzFdIC0gQk9SREVSX1NJWkUpO1xuICAgICAgY29uc3QgbnVtYmVyT2ZMaW5lcyA9IE1hdGgucm91bmQoaGVpZ2h0IC8gKExJTkVfRkFDVE9SICogZm9udFNpemUpKSB8fCAxO1xuICAgICAgY29uc3QgbGluZUhlaWdodCA9IGhlaWdodCAvIG51bWJlck9mTGluZXM7XG4gICAgICBjb21wdXRlZEZvbnRTaXplID0gTWF0aC5taW4oZm9udFNpemUsIHJvdW5kVG9PbmVEZWNpbWFsKGxpbmVIZWlnaHQgLyBMSU5FX0ZBQ1RPUikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmFicyh0aGlzLmRhdGEucmVjdFszXSAtIHRoaXMuZGF0YS5yZWN0WzFdIC0gQk9SREVSX1NJWkUpO1xuICAgICAgY29tcHV0ZWRGb250U2l6ZSA9IE1hdGgubWluKGZvbnRTaXplLCByb3VuZFRvT25lRGVjaW1hbChoZWlnaHQgLyBMSU5FX0ZBQ1RPUikpO1xuICAgIH1cbiAgICBzdHlsZS5mb250U2l6ZSA9IGBjYWxjKCR7Y29tcHV0ZWRGb250U2l6ZX1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYDtcbiAgICBzdHlsZS5jb2xvciA9IFV0aWwubWFrZUhleENvbG9yKGZvbnRDb2xvclswXSwgZm9udENvbG9yWzFdLCBmb250Q29sb3JbMl0pO1xuICAgIGlmICh0aGlzLmRhdGEudGV4dEFsaWdubWVudCAhPT0gbnVsbCkge1xuICAgICAgc3R5bGUudGV4dEFsaWduID0gVEVYVF9BTElHTk1FTlRbdGhpcy5kYXRhLnRleHRBbGlnbm1lbnRdO1xuICAgIH1cbiAgfVxuICBfc2V0UmVxdWlyZWQoZWxlbWVudCwgaXNSZXF1aXJlZCkge1xuICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcInJlcXVpcmVkXCIsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtcmVxdWlyZWRcIiwgaXNSZXF1aXJlZCk7XG4gIH1cbn1cbmNsYXNzIFRleHRXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGNvbnN0IGlzUmVuZGVyYWJsZSA9IHBhcmFtZXRlcnMucmVuZGVyRm9ybXMgfHwgcGFyYW1ldGVycy5kYXRhLmhhc093bkNhbnZhcyB8fCAhcGFyYW1ldGVycy5kYXRhLmhhc0FwcGVhcmFuY2UgJiYgISFwYXJhbWV0ZXJzLmRhdGEuZmllbGRWYWx1ZTtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGVcbiAgICB9KTtcbiAgfVxuICBzZXRQcm9wZXJ0eU9uU2libGluZ3MoYmFzZSwga2V5LCB2YWx1ZSwga2V5SW5TdG9yYWdlKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuX2dldEVsZW1lbnRzQnlOYW1lKGJhc2UubmFtZSwgYmFzZS5pZCkpIHtcbiAgICAgIGlmIChlbGVtZW50LmRvbUVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5kb21FbGVtZW50W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoZWxlbWVudC5pZCwge1xuICAgICAgICBba2V5SW5TdG9yYWdlXTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgY29uc3QgaWQgPSB0aGlzLmRhdGEuaWQ7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInRleHRXaWRnZXRBbm5vdGF0aW9uXCIpO1xuICAgIGxldCBlbGVtZW50ID0gbnVsbDtcbiAgICBpZiAodGhpcy5yZW5kZXJGb3Jtcykge1xuICAgICAgY29uc3Qgc3RvcmVkRGF0YSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgICAgdmFsdWU6IHRoaXMuZGF0YS5maWVsZFZhbHVlXG4gICAgICB9KTtcbiAgICAgIGxldCB0ZXh0Q29udGVudCA9IHN0b3JlZERhdGEudmFsdWUgfHwgXCJcIjtcbiAgICAgIGNvbnN0IG1heExlbiA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgICAgY2hhckxpbWl0OiB0aGlzLmRhdGEubWF4TGVuXG4gICAgICB9KS5jaGFyTGltaXQ7XG4gICAgICBpZiAobWF4TGVuICYmIHRleHRDb250ZW50Lmxlbmd0aCA+IG1heExlbikge1xuICAgICAgICB0ZXh0Q29udGVudCA9IHRleHRDb250ZW50LnNsaWNlKDAsIG1heExlbik7XG4gICAgICB9XG4gICAgICBsZXQgZmllbGRGb3JtYXR0ZWRWYWx1ZXMgPSBzdG9yZWREYXRhLmZvcm1hdHRlZFZhbHVlIHx8IHRoaXMuZGF0YS50ZXh0Q29udGVudD8uam9pbihcIlxcblwiKSB8fCBudWxsO1xuICAgICAgaWYgKGZpZWxkRm9ybWF0dGVkVmFsdWVzICYmIHRoaXMuZGF0YS5jb21iKSB7XG4gICAgICAgIGZpZWxkRm9ybWF0dGVkVmFsdWVzID0gZmllbGRGb3JtYXR0ZWRWYWx1ZXMucmVwbGFjZUFsbCgvXFxzKy9nLCBcIlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVsZW1lbnREYXRhID0ge1xuICAgICAgICB1c2VyVmFsdWU6IHRleHRDb250ZW50LFxuICAgICAgICBmb3JtYXR0ZWRWYWx1ZTogZmllbGRGb3JtYXR0ZWRWYWx1ZXMsXG4gICAgICAgIGxhc3RDb21taXR0ZWRWYWx1ZTogbnVsbCxcbiAgICAgICAgY29tbWl0S2V5OiAxLFxuICAgICAgICBmb2N1c2VkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmRhdGEubXVsdGlMaW5lKSB7XG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIik7XG4gICAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSBmaWVsZEZvcm1hdHRlZFZhbHVlcyA/PyB0ZXh0Q29udGVudDtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5kb05vdFNjcm9sbCkge1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGUub3ZlcmZsb3dZID0gXCJoaWRkZW5cIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgZWxlbWVudC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgZmllbGRGb3JtYXR0ZWRWYWx1ZXMgPz8gdGV4dENvbnRlbnQpO1xuICAgICAgICBpZiAodGhpcy5kYXRhLmRvTm90U2Nyb2xsKSB7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZS5vdmVyZmxvd1ggPSBcImhpZGRlblwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kYXRhLmhhc093bkNhbnZhcykge1xuICAgICAgICBlbGVtZW50LmhpZGRlbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoZWxlbWVudCk7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBpZCk7XG4gICAgICBlbGVtZW50LmRpc2FibGVkID0gdGhpcy5kYXRhLnJlYWRPbmx5O1xuICAgICAgZWxlbWVudC5uYW1lID0gdGhpcy5kYXRhLmZpZWxkTmFtZTtcbiAgICAgIGVsZW1lbnQudGFiSW5kZXggPSBERUZBVUxUX1RBQl9JTkRFWDtcbiAgICAgIHRoaXMuX3NldFJlcXVpcmVkKGVsZW1lbnQsIHRoaXMuZGF0YS5yZXF1aXJlZCk7XG4gICAgICBpZiAobWF4TGVuKSB7XG4gICAgICAgIGVsZW1lbnQubWF4TGVuZ3RoID0gbWF4TGVuO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRQcm9wZXJ0eU9uU2libGluZ3MoZWxlbWVudCwgXCJ2YWx1ZVwiLCBldmVudC50YXJnZXQudmFsdWUsIFwidmFsdWVcIik7XG4gICAgICAgIGVsZW1lbnREYXRhLmZvcm1hdHRlZFZhbHVlID0gbnVsbDtcbiAgICAgIH0pO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRmb3JtXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gdGhpcy5kYXRhLmRlZmF1bHRGaWVsZFZhbHVlID8/IFwiXCI7XG4gICAgICAgIGVsZW1lbnQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIGVsZW1lbnREYXRhLmZvcm1hdHRlZFZhbHVlID0gbnVsbDtcbiAgICAgIH0pO1xuICAgICAgbGV0IGJsdXJMaXN0ZW5lciA9IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGZvcm1hdHRlZFZhbHVlXG4gICAgICAgIH0gPSBlbGVtZW50RGF0YTtcbiAgICAgICAgaWYgKGZvcm1hdHRlZFZhbHVlICE9PSBudWxsICYmIGZvcm1hdHRlZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBmb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC50YXJnZXQuc2Nyb2xsTGVmdCA9IDA7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoZWxlbWVudERhdGEuZm9jdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB0YXJnZXRcbiAgICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLnVzZXJWYWx1ZSkge1xuICAgICAgICAgICAgdGFyZ2V0LnZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50RGF0YS5sYXN0Q29tbWl0dGVkVmFsdWUgPSB0YXJnZXQudmFsdWU7XG4gICAgICAgICAgZWxlbWVudERhdGEuY29tbWl0S2V5ID0gMTtcbiAgICAgICAgICBpZiAoIXRoaXMuZGF0YS5hY3Rpb25zPy5Gb2N1cykge1xuICAgICAgICAgICAgZWxlbWVudERhdGEuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgICAgdGhpcy5zaG93RWxlbWVudEFuZEhpZGVDYW52YXMoanNFdmVudC50YXJnZXQpO1xuICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgICAgICAgICB2YWx1ZShldmVudCkge1xuICAgICAgICAgICAgICBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSBldmVudC5kZXRhaWwudmFsdWUgPz8gXCJcIjtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBlbGVtZW50RGF0YS51c2VyVmFsdWUudG9TdHJpbmcoKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZVxuICAgICAgICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgICBlbGVtZW50RGF0YS5mb3JtYXR0ZWRWYWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZm9ybWF0dGVkVmFsdWUgIT09IG51bGwgJiYgZm9ybWF0dGVkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBldmVudC50YXJnZXQgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBmb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VsUmFuZ2UoZXZlbnQpIHtcbiAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnNldFNlbGVjdGlvblJhbmdlKC4uLmV2ZW50LmRldGFpbC5zZWxSYW5nZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hhckxpbWl0OiBldmVudCA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBjaGFyTGltaXRcbiAgICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgICAgICAgIGlmIChjaGFyTGltaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwibWF4TGVuZ3RoXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwibWF4TGVuZ3RoXCIsIGNoYXJMaW1pdCk7XG4gICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGVsZW1lbnREYXRhLnVzZXJWYWx1ZTtcbiAgICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS5sZW5ndGggPD0gY2hhckxpbWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgY2hhckxpbWl0KTtcbiAgICAgICAgICAgICAgdGFyZ2V0LnZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgIHdpbGxDb21taXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICBjb21taXRLZXk6IDEsXG4gICAgICAgICAgICAgICAgICBzZWxTdGFydDogdGFyZ2V0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgc2VsRW5kOiB0YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIGVsZW1lbnREYXRhLmNvbW1pdEtleSA9IDE7XG4gICAgICAgICAgbGV0IGNvbW1pdEtleSA9IC0xO1xuICAgICAgICAgIGlmIChldmVudC5rZXkgPT09IFwiRXNjYXBlXCIpIHtcbiAgICAgICAgICAgIGNvbW1pdEtleSA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09IFwiRW50ZXJcIiAmJiAhdGhpcy5kYXRhLm11bHRpTGluZSkge1xuICAgICAgICAgICAgY29tbWl0S2V5ID0gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gXCJUYWJcIikge1xuICAgICAgICAgICAgZWxlbWVudERhdGEuY29tbWl0S2V5ID0gMztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbW1pdEtleSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5sYXN0Q29tbWl0dGVkVmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICB3aWxsQ29tbWl0OiB0cnVlLFxuICAgICAgICAgICAgICBjb21taXRLZXksXG4gICAgICAgICAgICAgIHNlbFN0YXJ0OiBldmVudC50YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgIHNlbEVuZDogZXZlbnQudGFyZ2V0LnNlbGVjdGlvbkVuZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgX2JsdXJMaXN0ZW5lciA9IGJsdXJMaXN0ZW5lcjtcbiAgICAgICAgYmx1ckxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBldmVudCA9PiB7XG4gICAgICAgICAgaWYgKCFlbGVtZW50RGF0YS5mb2N1c2VkIHx8ICFldmVudC5yZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5kYXRhLmFjdGlvbnM/LkJsdXIpIHtcbiAgICAgICAgICAgIGVsZW1lbnREYXRhLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgIGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5sYXN0Q29tbWl0dGVkVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgd2lsbENvbW1pdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb21taXRLZXk6IGVsZW1lbnREYXRhLmNvbW1pdEtleSxcbiAgICAgICAgICAgICAgICBzZWxTdGFydDogZXZlbnQudGFyZ2V0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICAgIHNlbEVuZDogZXZlbnQudGFyZ2V0LnNlbGVjdGlvbkVuZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2JsdXJMaXN0ZW5lcihldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5kYXRhLmFjdGlvbnM/LktleXN0cm9rZSkge1xuICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgICAgfSA9IGV2ZW50O1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgIHNlbGVjdGlvbkVuZFxuICAgICAgICAgICAgfSA9IHRhcmdldDtcbiAgICAgICAgICAgIGxldCBzZWxTdGFydCA9IHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICBzZWxFbmQgPSBzZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LmlucHV0VHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlV29yZEJhY2t3YXJkXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5zdWJzdHJpbmcoMCwgc2VsZWN0aW9uU3RhcnQpLm1hdGNoKC9cXHcqW15cXHddKiQvKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxTdGFydCAtPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVXb3JkRm9yd2FyZFwiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdmFsdWUuc3Vic3RyaW5nKHNlbGVjdGlvblN0YXJ0KS5tYXRjaCgvXlteXFx3XSpcXHcqLyk7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsRW5kICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiOlxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCA9PT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICBzZWxTdGFydCAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZUNvbnRlbnRGb3J3YXJkXCI6XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID09PSBzZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgIHNlbEVuZCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgY2hhbmdlOiBkYXRhIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgd2lsbENvbW1pdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2VsU3RhcnQsXG4gICAgICAgICAgICAgICAgc2VsRW5kXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBbW1wiZm9jdXNcIiwgXCJGb2N1c1wiXSwgW1wiYmx1clwiLCBcIkJsdXJcIl0sIFtcIm1vdXNlZG93blwiLCBcIk1vdXNlIERvd25cIl0sIFtcIm1vdXNlZW50ZXJcIiwgXCJNb3VzZSBFbnRlclwiXSwgW1wibW91c2VsZWF2ZVwiLCBcIk1vdXNlIEV4aXRcIl0sIFtcIm1vdXNldXBcIiwgXCJNb3VzZSBVcFwiXV0sIGV2ZW50ID0+IGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoYmx1ckxpc3RlbmVyKSB7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgYmx1ckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRhdGEuY29tYikge1xuICAgICAgICBjb25zdCBmaWVsZFdpZHRoID0gdGhpcy5kYXRhLnJlY3RbMl0gLSB0aGlzLmRhdGEucmVjdFswXTtcbiAgICAgICAgY29uc3QgY29tYldpZHRoID0gZmllbGRXaWR0aCAvIG1heExlbjtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiY29tYlwiKTtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5sZXR0ZXJTcGFjaW5nID0gYGNhbGMoJHtjb21iV2lkdGh9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpIC0gMWNoKWA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IHRoaXMuZGF0YS5maWVsZFZhbHVlO1xuICAgICAgZWxlbWVudC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gXCJtaWRkbGVcIjtcbiAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwidGFibGUtY2VsbFwiO1xuICAgICAgaWYgKHRoaXMuZGF0YS5oYXNPd25DYW52YXMpIHtcbiAgICAgICAgZWxlbWVudC5oaWRkZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9zZXRUZXh0U3R5bGUoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKGVsZW1lbnQpO1xuICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGVsZW1lbnQpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChlbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFNpZ25hdHVyZVdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiAhIXBhcmFtZXRlcnMuZGF0YS5oYXNPd25DYW52YXNcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgQ2hlY2tib3hXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogcGFyYW1ldGVycy5yZW5kZXJGb3Jtc1xuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IGlkID0gZGF0YS5pZDtcbiAgICBsZXQgdmFsdWUgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICB2YWx1ZTogZGF0YS5leHBvcnRWYWx1ZSA9PT0gZGF0YS5maWVsZFZhbHVlXG4gICAgfSkudmFsdWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdmFsdWUgPSB2YWx1ZSAhPT0gXCJPZmZcIjtcbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiYnV0dG9uV2lkZ2V0QW5ub3RhdGlvblwiLCBcImNoZWNrQm94XCIpO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgR2V0RWxlbWVudHNCeU5hbWVTZXQuYWRkKGVsZW1lbnQpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGlkKTtcbiAgICBlbGVtZW50LmRpc2FibGVkID0gZGF0YS5yZWFkT25seTtcbiAgICB0aGlzLl9zZXRSZXF1aXJlZChlbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuICAgIGVsZW1lbnQudHlwZSA9IFwiY2hlY2tib3hcIjtcbiAgICBlbGVtZW50Lm5hbWUgPSBkYXRhLmZpZWxkTmFtZTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCB0cnVlKTtcbiAgICB9XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJleHBvcnRWYWx1ZVwiLCBkYXRhLmV4cG9ydFZhbHVlKTtcbiAgICBlbGVtZW50LnRhYkluZGV4ID0gREVGQVVMVF9UQUJfSU5ERVg7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgY2hlY2tlZFxuICAgICAgfSA9IGV2ZW50LnRhcmdldDtcbiAgICAgIGZvciAoY29uc3QgY2hlY2tib3ggb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUobmFtZSwgaWQpKSB7XG4gICAgICAgIGNvbnN0IGN1ckNoZWNrZWQgPSBjaGVja2VkICYmIGNoZWNrYm94LmV4cG9ydFZhbHVlID09PSBkYXRhLmV4cG9ydFZhbHVlO1xuICAgICAgICBpZiAoY2hlY2tib3guZG9tRWxlbWVudCkge1xuICAgICAgICAgIGNoZWNrYm94LmRvbUVsZW1lbnQuY2hlY2tlZCA9IGN1ckNoZWNrZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShjaGVja2JveC5pZCwge1xuICAgICAgICAgIHZhbHVlOiBjdXJDaGVja2VkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZTogY2hlY2tlZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRmb3JtXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IGRhdGEuZGVmYXVsdEZpZWxkVmFsdWUgfHwgXCJPZmZcIjtcbiAgICAgIGV2ZW50LnRhcmdldC5jaGVja2VkID0gZGVmYXVsdFZhbHVlID09PSBkYXRhLmV4cG9ydFZhbHVlO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgICAgICAgdmFsdWUoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5jaGVja2VkID0gZXZlbnQuZGV0YWlsLnZhbHVlICE9PSBcIk9mZlwiO1xuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LmNoZWNrZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVycyhlbGVtZW50LCBudWxsLCBbW1wiY2hhbmdlXCIsIFwiVmFsaWRhdGVcIl0sIFtcImNoYW5nZVwiLCBcIkFjdGlvblwiXSwgW1wiZm9jdXNcIiwgXCJGb2N1c1wiXSwgW1wiYmx1clwiLCBcIkJsdXJcIl0sIFtcIm1vdXNlZG93blwiLCBcIk1vdXNlIERvd25cIl0sIFtcIm1vdXNlZW50ZXJcIiwgXCJNb3VzZSBFbnRlclwiXSwgW1wibW91c2VsZWF2ZVwiLCBcIk1vdXNlIEV4aXRcIl0sIFtcIm1vdXNldXBcIiwgXCJNb3VzZSBVcFwiXV0sIGV2ZW50ID0+IGV2ZW50LnRhcmdldC5jaGVja2VkKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKGVsZW1lbnQpO1xuICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGVsZW1lbnQpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChlbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFJhZGlvQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHBhcmFtZXRlcnMucmVuZGVyRm9ybXNcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImJ1dHRvbldpZGdldEFubm90YXRpb25cIiwgXCJyYWRpb0J1dHRvblwiKTtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IGlkID0gZGF0YS5pZDtcbiAgICBsZXQgdmFsdWUgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICB2YWx1ZTogZGF0YS5maWVsZFZhbHVlID09PSBkYXRhLmJ1dHRvblZhbHVlXG4gICAgfSkudmFsdWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdmFsdWUgPSB2YWx1ZSAhPT0gZGF0YS5idXR0b25WYWx1ZTtcbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGZvciAoY29uc3QgcmFkaW8gb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUoZGF0YS5maWVsZE5hbWUsIGlkKSkge1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKHJhZGlvLmlkLCB7XG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIEdldEVsZW1lbnRzQnlOYW1lU2V0LmFkZChlbGVtZW50KTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBpZCk7XG4gICAgZWxlbWVudC5kaXNhYmxlZCA9IGRhdGEucmVhZE9ubHk7XG4gICAgdGhpcy5fc2V0UmVxdWlyZWQoZWxlbWVudCwgdGhpcy5kYXRhLnJlcXVpcmVkKTtcbiAgICBlbGVtZW50LnR5cGUgPSBcInJhZGlvXCI7XG4gICAgZWxlbWVudC5uYW1lID0gZGF0YS5maWVsZE5hbWU7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIGVsZW1lbnQudGFiSW5kZXggPSBERUZBVUxUX1RBQl9JTkRFWDtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lLFxuICAgICAgICBjaGVja2VkXG4gICAgICB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgZm9yIChjb25zdCByYWRpbyBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShuYW1lLCBpZCkpIHtcbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShyYWRpby5pZCwge1xuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgdmFsdWU6IGNoZWNrZWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0Zm9ybVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBkYXRhLmRlZmF1bHRGaWVsZFZhbHVlO1xuICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPSBkZWZhdWx0VmFsdWUgIT09IG51bGwgJiYgZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgZGVmYXVsdFZhbHVlID09PSBkYXRhLmJ1dHRvblZhbHVlO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgY29uc3QgcGRmQnV0dG9uVmFsdWUgPSBkYXRhLmJ1dHRvblZhbHVlO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgICAgICAgdmFsdWU6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrZWQgPSBwZGZCdXR0b25WYWx1ZSA9PT0gZXZlbnQuZGV0YWlsLnZhbHVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCByYWRpbyBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShldmVudC50YXJnZXQubmFtZSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgY3VyQ2hlY2tlZCA9IGNoZWNrZWQgJiYgcmFkaW8uaWQgPT09IGlkO1xuICAgICAgICAgICAgICBpZiAocmFkaW8uZG9tRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJhZGlvLmRvbUVsZW1lbnQuY2hlY2tlZCA9IGN1ckNoZWNrZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShyYWRpby5pZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJDaGVja2VkXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVycyhlbGVtZW50LCBudWxsLCBbW1wiY2hhbmdlXCIsIFwiVmFsaWRhdGVcIl0sIFtcImNoYW5nZVwiLCBcIkFjdGlvblwiXSwgW1wiZm9jdXNcIiwgXCJGb2N1c1wiXSwgW1wiYmx1clwiLCBcIkJsdXJcIl0sIFtcIm1vdXNlZG93blwiLCBcIk1vdXNlIERvd25cIl0sIFtcIm1vdXNlZW50ZXJcIiwgXCJNb3VzZSBFbnRlclwiXSwgW1wibW91c2VsZWF2ZVwiLCBcIk1vdXNlIEV4aXRcIl0sIFtcIm1vdXNldXBcIiwgXCJNb3VzZSBVcFwiXV0sIGV2ZW50ID0+IGV2ZW50LnRhcmdldC5jaGVja2VkKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKGVsZW1lbnQpO1xuICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGVsZW1lbnQpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChlbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFB1c2hCdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIExpbmtBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpZ25vcmVCb3JkZXI6IHBhcmFtZXRlcnMuZGF0YS5oYXNBcHBlYXJhbmNlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHN1cGVyLnJlbmRlcigpO1xuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiYnV0dG9uV2lkZ2V0QW5ub3RhdGlvblwiLCBcInB1c2hCdXR0b25cIik7XG4gICAgY29uc3QgbGlua0VsZW1lbnQgPSBjb250YWluZXIubGFzdENoaWxkO1xuICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucyAmJiBsaW5rRWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMobGlua0VsZW1lbnQpO1xuICAgICAgbGlua0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZyb21zYW5kYm94XCIsIGpzRXZlbnQgPT4ge1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goe30sIGpzRXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIENob2ljZVdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJjaG9pY2VXaWRnZXRBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGlkID0gdGhpcy5kYXRhLmlkO1xuICAgIGNvbnN0IHN0b3JlZERhdGEgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICB2YWx1ZTogdGhpcy5kYXRhLmZpZWxkVmFsdWVcbiAgICB9KTtcbiAgICBjb25zdCBzZWxlY3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKTtcbiAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoc2VsZWN0RWxlbWVudCk7XG4gICAgc2VsZWN0RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgaWQpO1xuICAgIHNlbGVjdEVsZW1lbnQuZGlzYWJsZWQgPSB0aGlzLmRhdGEucmVhZE9ubHk7XG4gICAgdGhpcy5fc2V0UmVxdWlyZWQoc2VsZWN0RWxlbWVudCwgdGhpcy5kYXRhLnJlcXVpcmVkKTtcbiAgICBzZWxlY3RFbGVtZW50Lm5hbWUgPSB0aGlzLmRhdGEuZmllbGROYW1lO1xuICAgIHNlbGVjdEVsZW1lbnQudGFiSW5kZXggPSBERUZBVUxUX1RBQl9JTkRFWDtcbiAgICBsZXQgYWRkQW5FbXB0eUVudHJ5ID0gdGhpcy5kYXRhLmNvbWJvICYmIHRoaXMuZGF0YS5vcHRpb25zLmxlbmd0aCA+IDA7XG4gICAgaWYgKCF0aGlzLmRhdGEuY29tYm8pIHtcbiAgICAgIHNlbGVjdEVsZW1lbnQuc2l6ZSA9IHRoaXMuZGF0YS5vcHRpb25zLmxlbmd0aDtcbiAgICAgIGlmICh0aGlzLmRhdGEubXVsdGlTZWxlY3QpIHtcbiAgICAgICAgc2VsZWN0RWxlbWVudC5tdWx0aXBsZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0Zm9ybVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSB0aGlzLmRhdGEuZGVmYXVsdEZpZWxkVmFsdWU7XG4gICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBzZWxlY3RFbGVtZW50Lm9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gb3B0aW9uLnZhbHVlID09PSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBvcHRpb24gb2YgdGhpcy5kYXRhLm9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IG9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgb3B0aW9uRWxlbWVudC50ZXh0Q29udGVudCA9IG9wdGlvbi5kaXNwbGF5VmFsdWU7XG4gICAgICBvcHRpb25FbGVtZW50LnZhbHVlID0gb3B0aW9uLmV4cG9ydFZhbHVlO1xuICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUuaW5jbHVkZXMob3B0aW9uLmV4cG9ydFZhbHVlKSkge1xuICAgICAgICBvcHRpb25FbGVtZW50LnNldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIsIHRydWUpO1xuICAgICAgICBhZGRBbkVtcHR5RW50cnkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHNlbGVjdEVsZW1lbnQuYXBwZW5kKG9wdGlvbkVsZW1lbnQpO1xuICAgIH1cbiAgICBsZXQgcmVtb3ZlRW1wdHlFbnRyeSA9IG51bGw7XG4gICAgaWYgKGFkZEFuRW1wdHlFbnRyeSkge1xuICAgICAgY29uc3Qgbm9uZU9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgbm9uZU9wdGlvbkVsZW1lbnQudmFsdWUgPSBcIiBcIjtcbiAgICAgIG5vbmVPcHRpb25FbGVtZW50LnNldEF0dHJpYnV0ZShcImhpZGRlblwiLCB0cnVlKTtcbiAgICAgIG5vbmVPcHRpb25FbGVtZW50LnNldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIsIHRydWUpO1xuICAgICAgc2VsZWN0RWxlbWVudC5wcmVwZW5kKG5vbmVPcHRpb25FbGVtZW50KTtcbiAgICAgIHJlbW92ZUVtcHR5RW50cnkgPSAoKSA9PiB7XG4gICAgICAgIG5vbmVPcHRpb25FbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCByZW1vdmVFbXB0eUVudHJ5KTtcbiAgICAgICAgcmVtb3ZlRW1wdHlFbnRyeSA9IG51bGw7XG4gICAgICB9O1xuICAgICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgcmVtb3ZlRW1wdHlFbnRyeSk7XG4gICAgfVxuICAgIGNvbnN0IGdldFZhbHVlID0gaXNFeHBvcnQgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGlzRXhwb3J0ID8gXCJ2YWx1ZVwiIDogXCJ0ZXh0Q29udGVudFwiO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvcHRpb25zLFxuICAgICAgICBtdWx0aXBsZVxuICAgICAgfSA9IHNlbGVjdEVsZW1lbnQ7XG4gICAgICBpZiAoIW11bHRpcGxlKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnNlbGVjdGVkSW5kZXggPT09IC0xID8gbnVsbCA6IG9wdGlvbnNbb3B0aW9ucy5zZWxlY3RlZEluZGV4XVtuYW1lXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwob3B0aW9ucywgb3B0aW9uID0+IG9wdGlvbi5zZWxlY3RlZCkubWFwKG9wdGlvbiA9PiBvcHRpb25bbmFtZV0pO1xuICAgIH07XG4gICAgbGV0IHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgIGNvbnN0IGdldEl0ZW1zID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IGV2ZW50LnRhcmdldC5vcHRpb25zO1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChvcHRpb25zLCBvcHRpb24gPT4gKHtcbiAgICAgICAgZGlzcGxheVZhbHVlOiBvcHRpb24udGV4dENvbnRlbnQsXG4gICAgICAgIGV4cG9ydFZhbHVlOiBvcHRpb24udmFsdWVcbiAgICAgIH0pKTtcbiAgICB9O1xuICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgICAgICAgdmFsdWUoZXZlbnQpIHtcbiAgICAgICAgICAgIHJlbW92ZUVtcHR5RW50cnk/LigpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBldmVudC5kZXRhaWwudmFsdWU7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBuZXcgU2V0KEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIHNlbGVjdEVsZW1lbnQub3B0aW9ucykge1xuICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZXMuaGFzKG9wdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG11bHRpcGxlU2VsZWN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxlY3RFbGVtZW50Lm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbW92ZShldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHNlbGVjdEVsZW1lbnQub3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZXZlbnQuZGV0YWlsLnJlbW92ZTtcbiAgICAgICAgICAgIG9wdGlvbnNbaW5kZXhdLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZShpbmRleCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGkgPSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4LmNhbGwob3B0aW9ucywgb3B0aW9uID0+IG9wdGlvbi5zZWxlY3RlZCk7XG4gICAgICAgICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKSxcbiAgICAgICAgICAgICAgaXRlbXM6IGdldEl0ZW1zKGV2ZW50KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsZWFyKGV2ZW50KSB7XG4gICAgICAgICAgICB3aGlsZSAoc2VsZWN0RWxlbWVudC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5yZW1vdmUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICBpdGVtczogW11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnNlcnQoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgIGRpc3BsYXlWYWx1ZSxcbiAgICAgICAgICAgICAgZXhwb3J0VmFsdWVcbiAgICAgICAgICAgIH0gPSBldmVudC5kZXRhaWwuaW5zZXJ0O1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0Q2hpbGQgPSBzZWxlY3RFbGVtZW50LmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgb3B0aW9uRWxlbWVudC50ZXh0Q29udGVudCA9IGRpc3BsYXlWYWx1ZTtcbiAgICAgICAgICAgIG9wdGlvbkVsZW1lbnQudmFsdWUgPSBleHBvcnRWYWx1ZTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RDaGlsZCkge1xuICAgICAgICAgICAgICBzZWxlY3RDaGlsZC5iZWZvcmUob3B0aW9uRWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LmFwcGVuZChvcHRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpLFxuICAgICAgICAgICAgICBpdGVtczogZ2V0SXRlbXMoZXZlbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaXRlbXMoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgaXRlbXNcbiAgICAgICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgICAgICB3aGlsZSAoc2VsZWN0RWxlbWVudC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5yZW1vdmUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlWYWx1ZSxcbiAgICAgICAgICAgICAgICBleHBvcnRWYWx1ZVxuICAgICAgICAgICAgICB9ID0gaXRlbTtcbiAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgICAgICAgIG9wdGlvbkVsZW1lbnQudGV4dENvbnRlbnQgPSBkaXNwbGF5VmFsdWU7XG4gICAgICAgICAgICAgIG9wdGlvbkVsZW1lbnQudmFsdWUgPSBleHBvcnRWYWx1ZTtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5hcHBlbmQob3B0aW9uRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0RWxlbWVudC5vcHRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5vcHRpb25zWzBdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpLFxuICAgICAgICAgICAgICBpdGVtczogZ2V0SXRlbXMoZXZlbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaW5kaWNlcyhldmVudCkge1xuICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IG5ldyBTZXQoZXZlbnQuZGV0YWlsLmluZGljZXMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgZXZlbnQudGFyZ2V0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gaW5kaWNlcy5oYXMob3B0aW9uLmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZWRpdGFibGUoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5kaXNhYmxlZCA9ICFldmVudC5kZXRhaWwuZWRpdGFibGU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCk7XG4gICAgICB9KTtcbiAgICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgZXhwb3J0VmFsdWUgPSBnZXRWYWx1ZSh0cnVlKTtcbiAgICAgICAgY29uc3QgY2hhbmdlID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgdmFsdWU6IGV4cG9ydFZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgIHZhbHVlOiBzZWxlY3RlZFZhbHVlcyxcbiAgICAgICAgICAgIGNoYW5nZSxcbiAgICAgICAgICAgIGNoYW5nZUV4OiBleHBvcnRWYWx1ZSxcbiAgICAgICAgICAgIHdpbGxDb21taXQ6IGZhbHNlLFxuICAgICAgICAgICAgY29tbWl0S2V5OiAxLFxuICAgICAgICAgICAga2V5RG93bjogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVycyhzZWxlY3RFbGVtZW50LCBudWxsLCBbW1wiZm9jdXNcIiwgXCJGb2N1c1wiXSwgW1wiYmx1clwiLCBcIkJsdXJcIl0sIFtcIm1vdXNlZG93blwiLCBcIk1vdXNlIERvd25cIl0sIFtcIm1vdXNlZW50ZXJcIiwgXCJNb3VzZSBFbnRlclwiXSwgW1wibW91c2VsZWF2ZVwiLCBcIk1vdXNlIEV4aXRcIl0sIFtcIm1vdXNldXBcIiwgXCJNb3VzZSBVcFwiXSwgW1wiaW5wdXRcIiwgXCJBY3Rpb25cIl0sIFtcImlucHV0XCIsIFwiVmFsaWRhdGVcIl1dLCBldmVudCA9PiBldmVudC50YXJnZXQudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5kYXRhLmNvbWJvKSB7XG4gICAgICB0aGlzLl9zZXRUZXh0U3R5bGUoc2VsZWN0RWxlbWVudCk7XG4gICAgfSBlbHNlIHt9XG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKHNlbGVjdEVsZW1lbnQpO1xuICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKHNlbGVjdEVsZW1lbnQpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzZWxlY3RFbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgZWxlbWVudHNcbiAgICB9ID0gcGFyYW1ldGVycztcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IEFubm90YXRpb25FbGVtZW50Ll9oYXNQb3B1cERhdGEoZGF0YSlcbiAgICB9KTtcbiAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgdGhpcy5wb3B1cCA9IG51bGw7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJwb3B1cEFubm90YXRpb25cIik7XG4gICAgY29uc3QgcG9wdXAgPSB0aGlzLnBvcHVwID0gbmV3IFBvcHVwRWxlbWVudCh7XG4gICAgICBjb250YWluZXI6IHRoaXMuY29udGFpbmVyLFxuICAgICAgY29sb3I6IHRoaXMuZGF0YS5jb2xvcixcbiAgICAgIHRpdGxlT2JqOiB0aGlzLmRhdGEudGl0bGVPYmosXG4gICAgICBtb2RpZmljYXRpb25EYXRlOiB0aGlzLmRhdGEubW9kaWZpY2F0aW9uRGF0ZSxcbiAgICAgIGNvbnRlbnRzT2JqOiB0aGlzLmRhdGEuY29udGVudHNPYmosXG4gICAgICByaWNoVGV4dDogdGhpcy5kYXRhLnJpY2hUZXh0LFxuICAgICAgcmVjdDogdGhpcy5kYXRhLnJlY3QsXG4gICAgICBwYXJlbnRSZWN0OiB0aGlzLmRhdGEucGFyZW50UmVjdCB8fCBudWxsLFxuICAgICAgcGFyZW50OiB0aGlzLnBhcmVudCxcbiAgICAgIGVsZW1lbnRzOiB0aGlzLmVsZW1lbnRzLFxuICAgICAgb3BlbjogdGhpcy5kYXRhLm9wZW5cbiAgICB9KTtcbiAgICBjb25zdCBlbGVtZW50SWRzID0gW107XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuZWxlbWVudHMpIHtcbiAgICAgIGVsZW1lbnQucG9wdXAgPSBwb3B1cDtcbiAgICAgIGVsZW1lbnQuY29udGFpbmVyLmFyaWFIYXNQb3B1cCA9IFwiZGlhbG9nXCI7XG4gICAgICBlbGVtZW50SWRzLnB1c2goZWxlbWVudC5kYXRhLmlkKTtcbiAgICAgIGVsZW1lbnQuYWRkSGlnaGxpZ2h0QXJlYSgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWNvbnRyb2xzXCIsIGVsZW1lbnRJZHMubWFwKGlkID0+IGAke0Fubm90YXRpb25QcmVmaXh9JHtpZH1gKS5qb2luKFwiLFwiKSk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBQb3B1cEVsZW1lbnQge1xuICAjYm91bmRLZXlEb3duID0gdGhpcy4ja2V5RG93bi5iaW5kKHRoaXMpO1xuICAjYm91bmRIaWRlID0gdGhpcy4jaGlkZS5iaW5kKHRoaXMpO1xuICAjYm91bmRTaG93ID0gdGhpcy4jc2hvdy5iaW5kKHRoaXMpO1xuICAjYm91bmRUb2dnbGUgPSB0aGlzLiN0b2dnbGUuYmluZCh0aGlzKTtcbiAgI2NvbG9yID0gbnVsbDtcbiAgI2NvbnRhaW5lciA9IG51bGw7XG4gICNjb250ZW50c09iaiA9IG51bGw7XG4gICNkYXRlT2JqID0gbnVsbDtcbiAgI2VsZW1lbnRzID0gbnVsbDtcbiAgI3BhcmVudCA9IG51bGw7XG4gICNwYXJlbnRSZWN0ID0gbnVsbDtcbiAgI3Bpbm5lZCA9IGZhbHNlO1xuICAjcG9wdXAgPSBudWxsO1xuICAjcG9zaXRpb24gPSBudWxsO1xuICAjcmVjdCA9IG51bGw7XG4gICNyaWNoVGV4dCA9IG51bGw7XG4gICN0aXRsZU9iaiA9IG51bGw7XG4gICN1cGRhdGVzID0gbnVsbDtcbiAgI3dhc1Zpc2libGUgPSBmYWxzZTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbnRhaW5lcixcbiAgICBjb2xvcixcbiAgICBlbGVtZW50cyxcbiAgICB0aXRsZU9iaixcbiAgICBtb2RpZmljYXRpb25EYXRlLFxuICAgIGNvbnRlbnRzT2JqLFxuICAgIHJpY2hUZXh0LFxuICAgIHBhcmVudCxcbiAgICByZWN0LFxuICAgIHBhcmVudFJlY3QsXG4gICAgb3BlblxuICB9KSB7XG4gICAgdGhpcy4jY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuI3RpdGxlT2JqID0gdGl0bGVPYmo7XG4gICAgdGhpcy4jY29udGVudHNPYmogPSBjb250ZW50c09iajtcbiAgICB0aGlzLiNyaWNoVGV4dCA9IHJpY2hUZXh0O1xuICAgIHRoaXMuI3BhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLiNjb2xvciA9IGNvbG9yO1xuICAgIHRoaXMuI3JlY3QgPSByZWN0O1xuICAgIHRoaXMuI3BhcmVudFJlY3QgPSBwYXJlbnRSZWN0O1xuICAgIHRoaXMuI2VsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgdGhpcy4jZGF0ZU9iaiA9IFBERkRhdGVTdHJpbmcudG9EYXRlT2JqZWN0KG1vZGlmaWNhdGlvbkRhdGUpO1xuICAgIHRoaXMudHJpZ2dlciA9IGVsZW1lbnRzLmZsYXRNYXAoZSA9PiBlLmdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSk7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMudHJpZ2dlcikge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jYm91bmRUb2dnbGUpO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCB0aGlzLiNib3VuZFNob3cpO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLiNib3VuZEhpZGUpO1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwicG9wdXBUcmlnZ2VyQXJlYVwiKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICBlbGVtZW50LmNvbnRhaW5lcj8uYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlEb3duKTtcbiAgICB9XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IHRydWU7XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIHRoaXMuI3RvZ2dsZSgpO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuI3BvcHVwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBvcHVwID0gdGhpcy4jcG9wdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHBvcHVwLmNsYXNzTmFtZSA9IFwicG9wdXBcIjtcbiAgICBpZiAodGhpcy4jY29sb3IpIHtcbiAgICAgIGNvbnN0IGJhc2VDb2xvciA9IHBvcHVwLnN0eWxlLm91dGxpbmVDb2xvciA9IFV0aWwubWFrZUhleENvbG9yKC4uLnRoaXMuI2NvbG9yKTtcbiAgICAgIGlmIChDU1Muc3VwcG9ydHMoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiY29sb3ItbWl4KGluIHNyZ2IsIHJlZCAzMCUsIHdoaXRlKVwiKSkge1xuICAgICAgICBwb3B1cC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBgY29sb3ItbWl4KGluIHNyZ2IsICR7YmFzZUNvbG9yfSAzMCUsIHdoaXRlKWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBCQUNLR1JPVU5EX0VOTElHSFQgPSAwLjc7XG4gICAgICAgIHBvcHVwLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFV0aWwubWFrZUhleENvbG9yKC4uLnRoaXMuI2NvbG9yLm1hcChjID0+IE1hdGguZmxvb3IoQkFDS0dST1VORF9FTkxJR0hUICogKDI1NSAtIGMpICsgYykpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgaGVhZGVyLmNsYXNzTmFtZSA9IFwiaGVhZGVyXCI7XG4gICAgY29uc3QgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaDFcIik7XG4gICAgaGVhZGVyLmFwcGVuZCh0aXRsZSk7XG4gICAgKHtcbiAgICAgIGRpcjogdGl0bGUuZGlyLFxuICAgICAgc3RyOiB0aXRsZS50ZXh0Q29udGVudFxuICAgIH0gPSB0aGlzLiN0aXRsZU9iaik7XG4gICAgcG9wdXAuYXBwZW5kKGhlYWRlcik7XG4gICAgaWYgKHRoaXMuI2RhdGVPYmopIHtcbiAgICAgIGNvbnN0IG1vZGlmaWNhdGlvbkRhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGUuY2xhc3NMaXN0LmFkZChcInBvcHVwRGF0ZVwiKTtcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGUuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtYW5ub3RhdGlvbi1kYXRlLXRpbWUtc3RyaW5nXCIpO1xuICAgICAgbW9kaWZpY2F0aW9uRGF0ZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4tYXJnc1wiLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGRhdGVPYmo6IHRoaXMuI2RhdGVPYmoudmFsdWVPZigpXG4gICAgICB9KSk7XG4gICAgICBoZWFkZXIuYXBwZW5kKG1vZGlmaWNhdGlvbkRhdGUpO1xuICAgIH1cbiAgICBjb25zdCBodG1sID0gdGhpcy4jaHRtbDtcbiAgICBpZiAoaHRtbCkge1xuICAgICAgWGZhTGF5ZXIucmVuZGVyKHtcbiAgICAgICAgeGZhSHRtbDogaHRtbCxcbiAgICAgICAgaW50ZW50OiBcInJpY2hUZXh0XCIsXG4gICAgICAgIGRpdjogcG9wdXBcbiAgICAgIH0pO1xuICAgICAgcG9wdXAubGFzdENoaWxkLmNsYXNzTGlzdC5hZGQoXCJyaWNoVGV4dFwiLCBcInBvcHVwQ29udGVudFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29udGVudHMgPSB0aGlzLl9mb3JtYXRDb250ZW50cyh0aGlzLiNjb250ZW50c09iaik7XG4gICAgICBwb3B1cC5hcHBlbmQoY29udGVudHMpO1xuICAgIH1cbiAgICB0aGlzLiNjb250YWluZXIuYXBwZW5kKHBvcHVwKTtcbiAgfVxuICBnZXQgI2h0bWwoKSB7XG4gICAgY29uc3QgcmljaFRleHQgPSB0aGlzLiNyaWNoVGV4dDtcbiAgICBjb25zdCBjb250ZW50c09iaiA9IHRoaXMuI2NvbnRlbnRzT2JqO1xuICAgIGlmIChyaWNoVGV4dD8uc3RyICYmICghY29udGVudHNPYmo/LnN0ciB8fCBjb250ZW50c09iai5zdHIgPT09IHJpY2hUZXh0LnN0cikpIHtcbiAgICAgIHJldHVybiB0aGlzLiNyaWNoVGV4dC5odG1sIHx8IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCAjZm9udFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2h0bWw/LmF0dHJpYnV0ZXM/LnN0eWxlPy5mb250U2l6ZSB8fCAwO1xuICB9XG4gIGdldCAjZm9udENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLiNodG1sPy5hdHRyaWJ1dGVzPy5zdHlsZT8uY29sb3IgfHwgbnVsbDtcbiAgfVxuICAjbWFrZVBvcHVwQ29udGVudCh0ZXh0KSB7XG4gICAgY29uc3QgcG9wdXBMaW5lcyA9IFtdO1xuICAgIGNvbnN0IHBvcHVwQ29udGVudCA9IHtcbiAgICAgIHN0cjogdGV4dCxcbiAgICAgIGh0bWw6IHtcbiAgICAgICAgbmFtZTogXCJkaXZcIixcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIGRpcjogXCJhdXRvXCJcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgbmFtZTogXCJwXCIsXG4gICAgICAgICAgY2hpbGRyZW46IHBvcHVwTGluZXNcbiAgICAgICAgfV1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGxpbmVBdHRyaWJ1dGVzID0ge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgY29sb3I6IHRoaXMuI2ZvbnRDb2xvcixcbiAgICAgICAgZm9udFNpemU6IHRoaXMuI2ZvbnRTaXplID8gYGNhbGMoJHt0aGlzLiNmb250U2l6ZX1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYCA6IFwiXCJcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgbGluZSBvZiB0ZXh0LnNwbGl0KFwiXFxuXCIpKSB7XG4gICAgICBwb3B1cExpbmVzLnB1c2goe1xuICAgICAgICBuYW1lOiBcInNwYW5cIixcbiAgICAgICAgdmFsdWU6IGxpbmUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IGxpbmVBdHRyaWJ1dGVzXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcHVwQ29udGVudDtcbiAgfVxuICBfZm9ybWF0Q29udGVudHMoe1xuICAgIHN0cixcbiAgICBkaXJcbiAgfSkge1xuICAgIGNvbnN0IHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcbiAgICBwLmNsYXNzTGlzdC5hZGQoXCJwb3B1cENvbnRlbnRcIik7XG4gICAgcC5kaXIgPSBkaXI7XG4gICAgY29uc3QgbGluZXMgPSBzdHIuc3BsaXQoLyg/Olxcclxcbj98XFxuKS8pO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGxpbmVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgIHAuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxpbmUpKTtcbiAgICAgIGlmIChpIDwgaWkgLSAxKSB7XG4gICAgICAgIHAuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9XG4gICNrZXlEb3duKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmFsdEtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFbnRlclwiIHx8IGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIiAmJiB0aGlzLiNwaW5uZWQpIHtcbiAgICAgIHRoaXMuI3RvZ2dsZSgpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVFZGl0ZWQoe1xuICAgIHJlY3QsXG4gICAgcG9wdXBDb250ZW50XG4gIH0pIHtcbiAgICB0aGlzLiN1cGRhdGVzIHx8PSB7XG4gICAgICBjb250ZW50c09iajogdGhpcy4jY29udGVudHNPYmosXG4gICAgICByaWNoVGV4dDogdGhpcy4jcmljaFRleHRcbiAgICB9O1xuICAgIGlmIChyZWN0KSB7XG4gICAgICB0aGlzLiNwb3NpdGlvbiA9IG51bGw7XG4gICAgfVxuICAgIGlmIChwb3B1cENvbnRlbnQpIHtcbiAgICAgIHRoaXMuI3JpY2hUZXh0ID0gdGhpcy4jbWFrZVBvcHVwQ29udGVudChwb3B1cENvbnRlbnQpO1xuICAgICAgdGhpcy4jY29udGVudHNPYmogPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNwb3B1cD8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jcG9wdXAgPSBudWxsO1xuICB9XG4gIHJlc2V0RWRpdGVkKCkge1xuICAgIGlmICghdGhpcy4jdXBkYXRlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAoe1xuICAgICAgY29udGVudHNPYmo6IHRoaXMuI2NvbnRlbnRzT2JqLFxuICAgICAgcmljaFRleHQ6IHRoaXMuI3JpY2hUZXh0XG4gICAgfSA9IHRoaXMuI3VwZGF0ZXMpO1xuICAgIHRoaXMuI3VwZGF0ZXMgPSBudWxsO1xuICAgIHRoaXMuI3BvcHVwPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNwb3B1cCA9IG51bGw7XG4gICAgdGhpcy4jcG9zaXRpb24gPSBudWxsO1xuICB9XG4gICNzZXRQb3NpdGlvbigpIHtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcGFnZToge1xuICAgICAgICB2aWV3XG4gICAgICB9LFxuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgcmF3RGltczoge1xuICAgICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgICBwYWdlSGVpZ2h0LFxuICAgICAgICAgIHBhZ2VYLFxuICAgICAgICAgIHBhZ2VZXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9ID0gdGhpcy4jcGFyZW50O1xuICAgIGxldCB1c2VQYXJlbnRSZWN0ID0gISF0aGlzLiNwYXJlbnRSZWN0O1xuICAgIGxldCByZWN0ID0gdXNlUGFyZW50UmVjdCA/IHRoaXMuI3BhcmVudFJlY3QgOiB0aGlzLiNyZWN0O1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLiNlbGVtZW50cykge1xuICAgICAgaWYgKCFyZWN0IHx8IFV0aWwuaW50ZXJzZWN0KGVsZW1lbnQuZGF0YS5yZWN0LCByZWN0KSAhPT0gbnVsbCkge1xuICAgICAgICByZWN0ID0gZWxlbWVudC5kYXRhLnJlY3Q7XG4gICAgICAgIHVzZVBhcmVudFJlY3QgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgbm9ybWFsaXplZFJlY3QgPSBVdGlsLm5vcm1hbGl6ZVJlY3QoW3JlY3RbMF0sIHZpZXdbM10gLSByZWN0WzFdICsgdmlld1sxXSwgcmVjdFsyXSwgdmlld1szXSAtIHJlY3RbM10gKyB2aWV3WzFdXSk7XG4gICAgY29uc3QgSE9SSVpPTlRBTF9TUEFDRV9BRlRFUl9BTk5PVEFUSU9OID0gNTtcbiAgICBjb25zdCBwYXJlbnRXaWR0aCA9IHVzZVBhcmVudFJlY3QgPyByZWN0WzJdIC0gcmVjdFswXSArIEhPUklaT05UQUxfU1BBQ0VfQUZURVJfQU5OT1RBVElPTiA6IDA7XG4gICAgY29uc3QgcG9wdXBMZWZ0ID0gbm9ybWFsaXplZFJlY3RbMF0gKyBwYXJlbnRXaWR0aDtcbiAgICBjb25zdCBwb3B1cFRvcCA9IG5vcm1hbGl6ZWRSZWN0WzFdO1xuICAgIHRoaXMuI3Bvc2l0aW9uID0gWzEwMCAqIChwb3B1cExlZnQgLSBwYWdlWCkgLyBwYWdlV2lkdGgsIDEwMCAqIChwb3B1cFRvcCAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHRdO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuI2NvbnRhaW5lcjtcbiAgICBzdHlsZS5sZWZ0ID0gYCR7dGhpcy4jcG9zaXRpb25bMF19JWA7XG4gICAgc3R5bGUudG9wID0gYCR7dGhpcy4jcG9zaXRpb25bMV19JWA7XG4gIH1cbiAgI3RvZ2dsZSgpIHtcbiAgICB0aGlzLiNwaW5uZWQgPSAhdGhpcy4jcGlubmVkO1xuICAgIGlmICh0aGlzLiNwaW5uZWQpIHtcbiAgICAgIHRoaXMuI3Nob3coKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jYm91bmRUb2dnbGUpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kS2V5RG93bik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2hpZGUoKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jYm91bmRUb2dnbGUpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kS2V5RG93bik7XG4gICAgfVxuICB9XG4gICNzaG93KCkge1xuICAgIGlmICghdGhpcy4jcG9wdXApIHtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgIHRoaXMuI3NldFBvc2l0aW9uKCk7XG4gICAgICB0aGlzLiNjb250YWluZXIuaGlkZGVuID0gZmFsc2U7XG4gICAgICB0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4ID0gcGFyc2VJbnQodGhpcy4jY29udGFpbmVyLnN0eWxlLnpJbmRleCkgKyAxMDAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jcGlubmVkKSB7XG4gICAgICB0aGlzLiNjb250YWluZXIuY2xhc3NMaXN0LmFkZChcImZvY3VzZWRcIik7XG4gICAgfVxuICB9XG4gICNoaWRlKCkge1xuICAgIHRoaXMuI2NvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFwiZm9jdXNlZFwiKTtcbiAgICBpZiAodGhpcy4jcGlubmVkIHx8ICF0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb250YWluZXIuaGlkZGVuID0gdHJ1ZTtcbiAgICB0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4ID0gcGFyc2VJbnQodGhpcy4jY29udGFpbmVyLnN0eWxlLnpJbmRleCkgLSAxMDAwO1xuICB9XG4gIGZvcmNlSGlkZSgpIHtcbiAgICB0aGlzLiN3YXNWaXNpYmxlID0gdGhpcy5pc1Zpc2libGU7XG4gICAgaWYgKCF0aGlzLiN3YXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSB0cnVlO1xuICB9XG4gIG1heWJlU2hvdygpIHtcbiAgICBpZiAoIXRoaXMuI3dhc1Zpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNwb3B1cCkge1xuICAgICAgdGhpcy4jc2hvdygpO1xuICAgIH1cbiAgICB0aGlzLiN3YXNWaXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IGZhbHNlO1xuICB9XG4gIGdldCBpc1Zpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPT09IGZhbHNlO1xuICB9XG59XG5jbGFzcyBGcmVlVGV4dEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHBhcmFtZXRlcnMuZGF0YS50ZXh0Q29udGVudDtcbiAgICB0aGlzLnRleHRQb3NpdGlvbiA9IHBhcmFtZXRlcnMuZGF0YS50ZXh0UG9zaXRpb247XG4gICAgdGhpcy5hbm5vdGF0aW9uRWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhUO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiZnJlZVRleHRBbm5vdGF0aW9uXCIpO1xuICAgIGlmICh0aGlzLnRleHRDb250ZW50KSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZChcImFubm90YXRpb25UZXh0Q29udGVudFwiKTtcbiAgICAgIGNvbnRlbnQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImNvbW1lbnRcIik7XG4gICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGhpcy50ZXh0Q29udGVudCkge1xuICAgICAgICBjb25zdCBsaW5lU3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBsaW5lU3Bhbi50ZXh0Q29udGVudCA9IGxpbmU7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kKGxpbmVTcGFuKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChjb250ZW50KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuX2VkaXRPbkRvdWJsZUNsaWNrKCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBMaW5lQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNsaW5lID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibGluZUFubm90YXRpb25cIik7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRSZWN0RGltcyhkYXRhLnJlY3QpO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgY29uc3QgbGluZSA9IHRoaXMuI2xpbmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpsaW5lXCIpO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieDFcIiwgZGF0YS5yZWN0WzJdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbMF0pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieTFcIiwgZGF0YS5yZWN0WzNdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbMV0pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieDJcIiwgZGF0YS5yZWN0WzJdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbMl0pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieTJcIiwgZGF0YS5yZWN0WzNdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbM10pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGRhdGEuYm9yZGVyU3R5bGUud2lkdGggfHwgMSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKGxpbmUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2xpbmU7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNzcXVhcmUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzcXVhcmVBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZ2V0UmVjdERpbXMoZGF0YS5yZWN0KTtcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gZGF0YS5ib3JkZXJTdHlsZS53aWR0aDtcbiAgICBjb25zdCBzcXVhcmUgPSB0aGlzLiNzcXVhcmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyZWN0XCIpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJ4XCIsIGJvcmRlcldpZHRoIC8gMik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInlcIiwgYm9yZGVyV2lkdGggLyAyKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgd2lkdGggLSBib3JkZXJXaWR0aCk7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBoZWlnaHQgLSBib3JkZXJXaWR0aCk7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBib3JkZXJXaWR0aCB8fCAxKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKHNxdWFyZSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgaWYgKCFkYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jc3F1YXJlO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIENpcmNsZUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjY2lyY2xlID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiY2lyY2xlQW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKGRhdGEucmVjdCk7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBjb25zdCBib3JkZXJXaWR0aCA9IGRhdGEuYm9yZGVyU3R5bGUud2lkdGg7XG4gICAgY29uc3QgY2lyY2xlID0gdGhpcy4jY2lyY2xlID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6ZWxsaXBzZVwiKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwiY3hcIiwgd2lkdGggLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwiY3lcIiwgaGVpZ2h0IC8gMik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInJ4XCIsIHdpZHRoIC8gMiAtIGJvcmRlcldpZHRoIC8gMik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInJ5XCIsIGhlaWdodCAvIDIgLSBib3JkZXJXaWR0aCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgYm9yZGVyV2lkdGggfHwgMSk7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3ZnLmFwcGVuZChjaXJjbGUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NpcmNsZTtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG59XG5jbGFzcyBQb2x5bGluZUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjcG9seWxpbmUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5jb250YWluZXJDbGFzc05hbWUgPSBcInBvbHlsaW5lQW5ub3RhdGlvblwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudE5hbWUgPSBcInN2Zzpwb2x5bGluZVwiO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lKTtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIHJlY3QsXG4gICAgICAgIHZlcnRpY2VzLFxuICAgICAgICBib3JkZXJTdHlsZSxcbiAgICAgICAgcG9wdXBSZWZcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIXZlcnRpY2VzKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKHJlY3QpO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgbGV0IHBvaW50cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHggPSB2ZXJ0aWNlc1tpXSAtIHJlY3RbMF07XG4gICAgICBjb25zdCB5ID0gcmVjdFszXSAtIHZlcnRpY2VzW2kgKyAxXTtcbiAgICAgIHBvaW50cy5wdXNoKGAke3h9LCR7eX1gKTtcbiAgICB9XG4gICAgcG9pbnRzID0gcG9pbnRzLmpvaW4oXCIgXCIpO1xuICAgIGNvbnN0IHBvbHlsaW5lID0gdGhpcy4jcG9seWxpbmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudCh0aGlzLnN2Z0VsZW1lbnROYW1lKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJwb2ludHNcIiwgcG9pbnRzKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgYm9yZGVyU3R5bGUud2lkdGggfHwgMSk7XG4gICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHN2Zy5hcHBlbmQocG9seWxpbmUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIGlmICghcG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNwb2x5bGluZTtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG59XG5jbGFzcyBQb2x5Z29uQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBQb2x5bGluZUFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xuICAgIHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lID0gXCJwb2x5Z29uQW5ub3RhdGlvblwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudE5hbWUgPSBcInN2Zzpwb2x5Z29uXCI7XG4gIH1cbn1cbmNsYXNzIENhcmV0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImNhcmV0QW5ub3RhdGlvblwiKTtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBJbmtBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3BvbHlsaW5lc0dyb3VwRWxlbWVudCA9IG51bGw7XG4gICNwb2x5bGluZXMgPSBbXTtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lID0gXCJpbmtBbm5vdGF0aW9uXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlsaW5lXCI7XG4gICAgdGhpcy5hbm5vdGF0aW9uRWRpdG9yVHlwZSA9IHRoaXMuZGF0YS5pdCA9PT0gXCJJbmtIaWdobGlnaHRcIiA/IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCA6IEFubm90YXRpb25FZGl0b3JUeXBlLklOSztcbiAgfVxuICAjZ2V0VHJhbnNmb3JtKHJvdGF0aW9uLCByZWN0KSB7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGUoOTApIHRyYW5zbGF0ZSgkey1yZWN0WzBdfSwke3JlY3RbMV19KSBzY2FsZSgxLC0xKWAsXG4gICAgICAgICAgd2lkdGg6IHJlY3RbM10gLSByZWN0WzFdLFxuICAgICAgICAgIGhlaWdodDogcmVjdFsyXSAtIHJlY3RbMF1cbiAgICAgICAgfTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZSgxODApIHRyYW5zbGF0ZSgkey1yZWN0WzJdfSwke3JlY3RbMV19KSBzY2FsZSgxLC0xKWAsXG4gICAgICAgICAgd2lkdGg6IHJlY3RbMl0gLSByZWN0WzBdLFxuICAgICAgICAgIGhlaWdodDogcmVjdFszXSAtIHJlY3RbMV1cbiAgICAgICAgfTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZSgyNzApIHRyYW5zbGF0ZSgkey1yZWN0WzJdfSwke3JlY3RbM119KSBzY2FsZSgxLC0xKWAsXG4gICAgICAgICAgd2lkdGg6IHJlY3RbM10gLSByZWN0WzFdLFxuICAgICAgICAgIGhlaWdodDogcmVjdFsyXSAtIHJlY3RbMF1cbiAgICAgICAgfTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7LXJlY3RbMF19LCR7cmVjdFszXX0pIHNjYWxlKDEsLTEpYCxcbiAgICAgICAgICB3aWR0aDogcmVjdFsyXSAtIHJlY3RbMF0sXG4gICAgICAgICAgaGVpZ2h0OiByZWN0WzNdIC0gcmVjdFsxXVxuICAgICAgICB9O1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZCh0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSk7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YToge1xuICAgICAgICByZWN0LFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgaW5rTGlzdHMsXG4gICAgICAgIGJvcmRlclN0eWxlLFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuI2dldFRyYW5zZm9ybShyb3RhdGlvbiwgcmVjdCk7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBjb25zdCBnID0gdGhpcy4jcG9seWxpbmVzR3JvdXBFbGVtZW50ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6Z1wiKTtcbiAgICBzdmcuYXBwZW5kKGcpO1xuICAgIGcuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGJvcmRlclN0eWxlLndpZHRoIHx8IDEpO1xuICAgIGcuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWxpbmVjYXBcIiwgXCJyb3VuZFwiKTtcbiAgICBnLnNldEF0dHJpYnV0ZShcInN0cm9rZS1saW5lam9pblwiLCBcInJvdW5kXCIpO1xuICAgIGcuc2V0QXR0cmlidXRlKFwic3Ryb2tlLW1pdGVybGltaXRcIiwgMTApO1xuICAgIGcuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgZy5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgZy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbmtMaXN0cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjb25zdCBwb2x5bGluZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KHRoaXMuc3ZnRWxlbWVudE5hbWUpO1xuICAgICAgdGhpcy4jcG9seWxpbmVzLnB1c2gocG9seWxpbmUpO1xuICAgICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwicG9pbnRzXCIsIGlua0xpc3RzW2ldLmpvaW4oXCIsXCIpKTtcbiAgICAgIGcuYXBwZW5kKHBvbHlsaW5lKTtcbiAgICB9XG4gICAgaWYgKCFwb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgdGhpcy5fZWRpdE9uRG91YmxlQ2xpY2soKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgdXBkYXRlRWRpdGVkKHBhcmFtcykge1xuICAgIHN1cGVyLnVwZGF0ZUVkaXRlZChwYXJhbXMpO1xuICAgIGNvbnN0IHtcbiAgICAgIHRoaWNrbmVzcyxcbiAgICAgIHBvaW50cyxcbiAgICAgIHJlY3RcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGcgPSB0aGlzLiNwb2x5bGluZXNHcm91cEVsZW1lbnQ7XG4gICAgaWYgKHRoaWNrbmVzcyA+PSAwKSB7XG4gICAgICBnLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCB0aGlja25lc3MgfHwgMSk7XG4gICAgfVxuICAgIGlmIChwb2ludHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHRoaXMuI3BvbHlsaW5lcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIHRoaXMuI3BvbHlsaW5lc1tpXS5zZXRBdHRyaWJ1dGUoXCJwb2ludHNcIiwgcG9pbnRzW2ldLmpvaW4oXCIsXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlY3QpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9ID0gdGhpcy4jZ2V0VHJhbnNmb3JtKHRoaXMuZGF0YS5yb3RhdGlvbiwgcmVjdCk7XG4gICAgICBjb25zdCByb290ID0gZy5wYXJlbnRFbGVtZW50O1xuICAgICAgcm9vdC5zZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIsIGAwIDAgJHt3aWR0aH0gJHtoZWlnaHR9YCk7XG4gICAgICBnLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pO1xuICAgIH1cbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNwb2x5bGluZXM7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWUsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQ7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QW5ub3RhdGlvblwiKTtcbiAgICB0aGlzLl9lZGl0T25Eb3VibGVDbGljaygpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgVW5kZXJsaW5lQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWUsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInVuZGVybGluZUFubm90YXRpb25cIik7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBTcXVpZ2dseUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzcXVpZ2dseUFubm90YXRpb25cIik7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBTdHJpa2VPdXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZSxcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwic3RyaWtlb3V0QW5ub3RhdGlvblwiKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFN0YW1wQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmFubm90YXRpb25FZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVA7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzdGFtcEFubm90YXRpb25cIik7XG4gICAgdGhpcy5jb250YWluZXIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImltZ1wiKTtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5fZWRpdE9uRG91YmxlQ2xpY2soKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIEZpbGVBdHRhY2htZW50QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICN0cmlnZ2VyID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGZpbGVcbiAgICB9ID0gdGhpcy5kYXRhO1xuICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlLmZpbGVuYW1lO1xuICAgIHRoaXMuY29udGVudCA9IGZpbGUuY29udGVudDtcbiAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImZpbGVhdHRhY2htZW50YW5ub3RhdGlvblwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAuLi5maWxlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJmaWxlQXR0YWNobWVudEFubm90YXRpb25cIik7XG4gICAgY29uc3Qge1xuICAgICAgY29udGFpbmVyLFxuICAgICAgZGF0YVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCB0cmlnZ2VyO1xuICAgIGlmIChkYXRhLmhhc0FwcGVhcmFuY2UgfHwgZGF0YS5maWxsQWxwaGEgPT09IDApIHtcbiAgICAgIHRyaWdnZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmlnZ2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgIHRyaWdnZXIuc3JjID0gYCR7dGhpcy5pbWFnZVJlc291cmNlc1BhdGh9YW5ub3RhdGlvbi0key9wYXBlcmNsaXAvaS50ZXN0KGRhdGEubmFtZSkgPyBcInBhcGVyY2xpcFwiIDogXCJwdXNocGluXCJ9LnN2Z2A7XG4gICAgICBpZiAoZGF0YS5maWxsQWxwaGEgJiYgZGF0YS5maWxsQWxwaGEgPCAxKSB7XG4gICAgICAgIHRyaWdnZXIuc3R5bGUgPSBgZmlsdGVyOiBvcGFjaXR5KCR7TWF0aC5yb3VuZChkYXRhLmZpbGxBbHBoYSAqIDEwMCl9JSk7YDtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKFwiZGJsY2xpY2tcIiwgdGhpcy4jZG93bmxvYWQuYmluZCh0aGlzKSk7XG4gICAgdGhpcy4jdHJpZ2dlciA9IHRyaWdnZXI7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZXZ0ID0+IHtcbiAgICAgIGlmIChldnQua2V5ID09PSBcIkVudGVyXCIgJiYgKGlzTWFjID8gZXZ0Lm1ldGFLZXkgOiBldnQuY3RybEtleSkpIHtcbiAgICAgICAgdGhpcy4jZG93bmxvYWQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXIuY2xhc3NMaXN0LmFkZChcInBvcHVwVHJpZ2dlckFyZWFcIik7XG4gICAgfVxuICAgIGNvbnRhaW5lci5hcHBlbmQodHJpZ2dlcik7XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiN0cmlnZ2VyO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbiAgI2Rvd25sb2FkKCkge1xuICAgIHRoaXMuZG93bmxvYWRNYW5hZ2VyPy5vcGVuT3JEb3dubG9hZERhdGEodGhpcy5jb250ZW50LCB0aGlzLmZpbGVuYW1lKTtcbiAgfVxufVxuY2xhc3MgQW5ub3RhdGlvbkxheWVyIHtcbiAgI2FjY2Vzc2liaWxpdHlNYW5hZ2VyID0gbnVsbDtcbiAgI2Fubm90YXRpb25DYW52YXNNYXAgPSBudWxsO1xuICAjZWRpdGFibGVBbm5vdGF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgI3N0cnVjdFRyZWVMYXllciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkaXYsXG4gICAgYWNjZXNzaWJpbGl0eU1hbmFnZXIsXG4gICAgYW5ub3RhdGlvbkNhbnZhc01hcCxcbiAgICBhbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLFxuICAgIHBhZ2UsXG4gICAgdmlld3BvcnQsXG4gICAgc3RydWN0VHJlZUxheWVyXG4gIH0pIHtcbiAgICB0aGlzLmRpdiA9IGRpdjtcbiAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlciA9IGFjY2Vzc2liaWxpdHlNYW5hZ2VyO1xuICAgIHRoaXMuI2Fubm90YXRpb25DYW52YXNNYXAgPSBhbm5vdGF0aW9uQ2FudmFzTWFwO1xuICAgIHRoaXMuI3N0cnVjdFRyZWVMYXllciA9IHN0cnVjdFRyZWVMYXllciB8fCBudWxsO1xuICAgIHRoaXMucGFnZSA9IHBhZ2U7XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIHRoaXMuekluZGV4ID0gMDtcbiAgICB0aGlzLl9hbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyID0gYW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlcjtcbiAgfVxuICBoYXNFZGl0YWJsZUFubm90YXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLnNpemUgPiAwO1xuICB9XG4gIGFzeW5jICNhcHBlbmRFbGVtZW50KGVsZW1lbnQsIGlkKSB7XG4gICAgY29uc3QgY29udGVudEVsZW1lbnQgPSBlbGVtZW50LmZpcnN0Q2hpbGQgfHwgZWxlbWVudDtcbiAgICBjb25zdCBhbm5vdGF0aW9uSWQgPSBjb250ZW50RWxlbWVudC5pZCA9IGAke0Fubm90YXRpb25QcmVmaXh9JHtpZH1gO1xuICAgIGNvbnN0IGFyaWFBdHRyaWJ1dGVzID0gYXdhaXQgdGhpcy4jc3RydWN0VHJlZUxheWVyPy5nZXRBcmlhQXR0cmlidXRlcyhhbm5vdGF0aW9uSWQpO1xuICAgIGlmIChhcmlhQXR0cmlidXRlcykge1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYXJpYUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgY29udGVudEVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRpdi5hcHBlbmQoZWxlbWVudCk7XG4gICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXI/Lm1vdmVFbGVtZW50SW5ET00odGhpcy5kaXYsIGVsZW1lbnQsIGNvbnRlbnRFbGVtZW50LCBmYWxzZSk7XG4gIH1cbiAgYXN5bmMgcmVuZGVyKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25zXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCBsYXllciA9IHRoaXMuZGl2O1xuICAgIHNldExheWVyRGltZW5zaW9ucyhsYXllciwgdGhpcy52aWV3cG9ydCk7XG4gICAgY29uc3QgcG9wdXBUb0VsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGVsZW1lbnRQYXJhbXMgPSB7XG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgbGF5ZXIsXG4gICAgICBsaW5rU2VydmljZTogcGFyYW1zLmxpbmtTZXJ2aWNlLFxuICAgICAgZG93bmxvYWRNYW5hZ2VyOiBwYXJhbXMuZG93bmxvYWRNYW5hZ2VyLFxuICAgICAgaW1hZ2VSZXNvdXJjZXNQYXRoOiBwYXJhbXMuaW1hZ2VSZXNvdXJjZXNQYXRoIHx8IFwiXCIsXG4gICAgICByZW5kZXJGb3JtczogcGFyYW1zLnJlbmRlckZvcm1zICE9PSBmYWxzZSxcbiAgICAgIHN2Z0ZhY3Rvcnk6IG5ldyBET01TVkdGYWN0b3J5KCksXG4gICAgICBhbm5vdGF0aW9uU3RvcmFnZTogcGFyYW1zLmFubm90YXRpb25TdG9yYWdlIHx8IG5ldyBBbm5vdGF0aW9uU3RvcmFnZSgpLFxuICAgICAgZW5hYmxlU2NyaXB0aW5nOiBwYXJhbXMuZW5hYmxlU2NyaXB0aW5nID09PSB0cnVlLFxuICAgICAgaGFzSlNBY3Rpb25zOiBwYXJhbXMuaGFzSlNBY3Rpb25zLFxuICAgICAgZmllbGRPYmplY3RzOiBwYXJhbXMuZmllbGRPYmplY3RzLFxuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgZWxlbWVudHM6IG51bGxcbiAgICB9O1xuICAgIGZvciAoY29uc3QgZGF0YSBvZiBhbm5vdGF0aW9ucykge1xuICAgICAgaWYgKGRhdGEubm9IVE1MKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNQb3B1cEFubm90YXRpb24gPSBkYXRhLmFubm90YXRpb25UeXBlID09PSBBbm5vdGF0aW9uVHlwZS5QT1BVUDtcbiAgICAgIGlmICghaXNQb3B1cEFubm90YXRpb24pIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodFxuICAgICAgICB9ID0gZ2V0UmVjdERpbXMoZGF0YS5yZWN0KTtcbiAgICAgICAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBwb3B1cFRvRWxlbWVudHMuZ2V0KGRhdGEuaWQpO1xuICAgICAgICBpZiAoIWVsZW1lbnRzKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudFBhcmFtcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgICAgfVxuICAgICAgZWxlbWVudFBhcmFtcy5kYXRhID0gZGF0YTtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBBbm5vdGF0aW9uRWxlbWVudEZhY3RvcnkuY3JlYXRlKGVsZW1lbnRQYXJhbXMpO1xuICAgICAgaWYgKCFlbGVtZW50LmlzUmVuZGVyYWJsZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNQb3B1cEFubm90YXRpb24gJiYgZGF0YS5wb3B1cFJlZikge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHBvcHVwVG9FbGVtZW50cy5nZXQoZGF0YS5wb3B1cFJlZik7XG4gICAgICAgIGlmICghZWxlbWVudHMpIHtcbiAgICAgICAgICBwb3B1cFRvRWxlbWVudHMuc2V0KGRhdGEucG9wdXBSZWYsIFtlbGVtZW50XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcmVuZGVyZWQgPSBlbGVtZW50LnJlbmRlcigpO1xuICAgICAgaWYgKGRhdGEuaGlkZGVuKSB7XG4gICAgICAgIHJlbmRlcmVkLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy4jYXBwZW5kRWxlbWVudChyZW5kZXJlZCwgZGF0YS5pZCk7XG4gICAgICBpZiAoZWxlbWVudC5faXNFZGl0YWJsZSkge1xuICAgICAgICB0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLnNldChlbGVtZW50LmRhdGEuaWQsIGVsZW1lbnQpO1xuICAgICAgICB0aGlzLl9hbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyPy5yZW5kZXJBbm5vdGF0aW9uRWxlbWVudChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jc2V0QW5ub3RhdGlvbkNhbnZhc01hcCgpO1xuICB9XG4gIHVwZGF0ZSh7XG4gICAgdmlld3BvcnRcbiAgfSkge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5kaXY7XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIHNldExheWVyRGltZW5zaW9ucyhsYXllciwge1xuICAgICAgcm90YXRpb246IHZpZXdwb3J0LnJvdGF0aW9uXG4gICAgfSk7XG4gICAgdGhpcy4jc2V0QW5ub3RhdGlvbkNhbnZhc01hcCgpO1xuICAgIGxheWVyLmhpZGRlbiA9IGZhbHNlO1xuICB9XG4gICNzZXRBbm5vdGF0aW9uQ2FudmFzTWFwKCkge1xuICAgIGlmICghdGhpcy4jYW5ub3RhdGlvbkNhbnZhc01hcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXllciA9IHRoaXMuZGl2O1xuICAgIGZvciAoY29uc3QgW2lkLCBjYW52YXNdIG9mIHRoaXMuI2Fubm90YXRpb25DYW52YXNNYXApIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBsYXllci5xdWVyeVNlbGVjdG9yKGBbZGF0YS1hbm5vdGF0aW9uLWlkPVwiJHtpZH1cIl1gKTtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNhbnZhcy5jbGFzc05hbWUgPSBcImFubm90YXRpb25Db250ZW50XCI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZpcnN0Q2hpbGRcbiAgICAgIH0gPSBlbGVtZW50O1xuICAgICAgaWYgKCFmaXJzdENoaWxkKSB7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kKGNhbnZhcyk7XG4gICAgICB9IGVsc2UgaWYgKGZpcnN0Q2hpbGQubm9kZU5hbWUgPT09IFwiQ0FOVkFTXCIpIHtcbiAgICAgICAgZmlyc3RDaGlsZC5yZXBsYWNlV2l0aChjYW52YXMpO1xuICAgICAgfSBlbHNlIGlmICghZmlyc3RDaGlsZC5jbGFzc0xpc3QuY29udGFpbnMoXCJhbm5vdGF0aW9uQ29udGVudFwiKSkge1xuICAgICAgICBmaXJzdENoaWxkLmJlZm9yZShjYW52YXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlyc3RDaGlsZC5hZnRlcihjYW52YXMpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNhbm5vdGF0aW9uQ2FudmFzTWFwLmNsZWFyKCk7XG4gIH1cbiAgZ2V0RWRpdGFibGVBbm5vdGF0aW9ucygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLnZhbHVlcygpKTtcbiAgfVxuICBnZXRFZGl0YWJsZUFubm90YXRpb24oaWQpIHtcbiAgICByZXR1cm4gdGhpcy4jZWRpdGFibGVBbm5vdGF0aW9ucy5nZXQoaWQpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9mcmVldGV4dC5qc1xuXG5cblxuXG5jb25zdCBFT0xfUEFUVEVSTiA9IC9cXHJcXG4/fFxcbi9nO1xuY2xhc3MgRnJlZVRleHRFZGl0b3IgZXh0ZW5kcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2NvbG9yO1xuICAjY29udGVudCA9IFwiXCI7XG4gICNlZGl0b3JEaXZJZCA9IGAke3RoaXMuaWR9LWVkaXRvcmA7XG4gICNlZGl0TW9kZUFDID0gbnVsbDtcbiAgI2ZvbnRTaXplO1xuICBzdGF0aWMgX2ZyZWVUZXh0RGVmYXVsdENvbnRlbnQgPSBcIlwiO1xuICBzdGF0aWMgX2ludGVybmFsUGFkZGluZyA9IDA7XG4gIHN0YXRpYyBfZGVmYXVsdENvbG9yID0gbnVsbDtcbiAgc3RhdGljIF9kZWZhdWx0Rm9udFNpemUgPSAxMDtcbiAgc3RhdGljIGdldCBfa2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHByb3RvID0gRnJlZVRleHRFZGl0b3IucHJvdG90eXBlO1xuICAgIGNvbnN0IGFycm93Q2hlY2tlciA9IHNlbGYgPT4gc2VsZi5pc0VtcHR5KCk7XG4gICAgY29uc3Qgc21hbGwgPSBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLlRSQU5TTEFURV9TTUFMTDtcbiAgICBjb25zdCBiaWcgPSBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLlRSQU5TTEFURV9CSUc7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9rZXlib2FyZE1hbmFnZXJcIiwgbmV3IEtleWJvYXJkTWFuYWdlcihbW1tcImN0cmwrc1wiLCBcIm1hYyttZXRhK3NcIiwgXCJjdHJsK3BcIiwgXCJtYWMrbWV0YStwXCJdLCBwcm90by5jb21taXRPclJlbW92ZSwge1xuICAgICAgYnViYmxlczogdHJ1ZVxuICAgIH1dLCBbW1wiY3RybCtFbnRlclwiLCBcIm1hYyttZXRhK0VudGVyXCIsIFwiRXNjYXBlXCIsIFwibWFjK0VzY2FwZVwiXSwgcHJvdG8uY29tbWl0T3JSZW1vdmVdLCBbW1wiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93TGVmdFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbLXNtYWxsLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0xlZnRcIiwgXCJtYWMrc2hpZnQrQXJyb3dMZWZ0XCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFstYmlnLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dSaWdodFwiLCBcIm1hYytBcnJvd1JpZ2h0XCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFtzbWFsbCwgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dSaWdodFwiLCBcIm1hYytzaGlmdCtBcnJvd1JpZ2h0XCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFtiaWcsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd1VwXCIsIFwibWFjK0Fycm93VXBcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWzAsIC1zbWFsbF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dVcFwiLCBcIm1hYytzaGlmdCtBcnJvd1VwXCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFswLCAtYmlnXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dEb3duXCIsIFwibWFjK0Fycm93RG93blwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbMCwgc21hbGxdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93RG93blwiLCBcIm1hYytzaGlmdCtBcnJvd0Rvd25cIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWzAsIGJpZ10sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XV0pKTtcbiAgfVxuICBzdGF0aWMgX3R5cGUgPSBcImZyZWV0ZXh0XCI7XG4gIHN0YXRpYyBfZWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhUO1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBuYW1lOiBcImZyZWVUZXh0RWRpdG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLiNjb2xvciA9IHBhcmFtcy5jb2xvciB8fCBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdENvbG9yIHx8IEFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3I7XG4gICAgdGhpcy4jZm9udFNpemUgPSBwYXJhbXMuZm9udFNpemUgfHwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRGb250U2l6ZTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKTtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgICB0aGlzLl9pbnRlcm5hbFBhZGRpbmcgPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCItLWZyZWV0ZXh0LXBhZGRpbmdcIikpO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkU6XG4gICAgICAgIEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Rm9udFNpemUgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SOlxuICAgICAgICBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdENvbG9yID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRTpcbiAgICAgICAgdGhpcy4jdXBkYXRlRm9udFNpemUodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1I6XG4gICAgICAgIHRoaXMuI3VwZGF0ZUNvbG9yKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFLCBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdEZvbnRTaXplXSwgW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SLCBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdENvbG9yIHx8IEFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3JdXTtcbiAgfVxuICBnZXQgcHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkUsIHRoaXMuI2ZvbnRTaXplXSwgW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SLCB0aGlzLiNjb2xvcl1dO1xuICB9XG4gICN1cGRhdGVGb250U2l6ZShmb250U2l6ZSkge1xuICAgIGNvbnN0IHNldEZvbnRzaXplID0gc2l6ZSA9PiB7XG4gICAgICB0aGlzLmVkaXRvckRpdi5zdHlsZS5mb250U2l6ZSA9IGBjYWxjKCR7c2l6ZX1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYDtcbiAgICAgIHRoaXMudHJhbnNsYXRlKDAsIC0oc2l6ZSAtIHRoaXMuI2ZvbnRTaXplKSAqIHRoaXMucGFyZW50U2NhbGUpO1xuICAgICAgdGhpcy4jZm9udFNpemUgPSBzaXplO1xuICAgICAgdGhpcy4jc2V0RWRpdG9yRGltZW5zaW9ucygpO1xuICAgIH07XG4gICAgY29uc3Qgc2F2ZWRGb250c2l6ZSA9IHRoaXMuI2ZvbnRTaXplO1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiBzZXRGb250c2l6ZS5iaW5kKHRoaXMsIGZvbnRTaXplKSxcbiAgICAgIHVuZG86IHNldEZvbnRzaXplLmJpbmQodGhpcywgc2F2ZWRGb250c2l6ZSksXG4gICAgICBwb3N0OiB0aGlzLl91aU1hbmFnZXIudXBkYXRlVUkuYmluZCh0aGlzLl91aU1hbmFnZXIsIHRoaXMpLFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgI3VwZGF0ZUNvbG9yKGNvbG9yKSB7XG4gICAgY29uc3Qgc2V0Q29sb3IgPSBjb2wgPT4ge1xuICAgICAgdGhpcy4jY29sb3IgPSB0aGlzLmVkaXRvckRpdi5zdHlsZS5jb2xvciA9IGNvbDtcbiAgICB9O1xuICAgIGNvbnN0IHNhdmVkQ29sb3IgPSB0aGlzLiNjb2xvcjtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogc2V0Q29sb3IuYmluZCh0aGlzLCBjb2xvciksXG4gICAgICB1bmRvOiBzZXRDb2xvci5iaW5kKHRoaXMsIHNhdmVkQ29sb3IpLFxuICAgICAgcG9zdDogdGhpcy5fdWlNYW5hZ2VyLnVwZGF0ZVVJLmJpbmQodGhpcy5fdWlNYW5hZ2VyLCB0aGlzKSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1IsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgfVxuICBfdHJhbnNsYXRlRW1wdHkoeCwgeSkge1xuICAgIHRoaXMuX3VpTWFuYWdlci50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMoeCwgeSwgdHJ1ZSk7XG4gIH1cbiAgZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCkge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5wYXJlbnRTY2FsZTtcbiAgICByZXR1cm4gWy1GcmVlVGV4dEVkaXRvci5faW50ZXJuYWxQYWRkaW5nICogc2NhbGUsIC0oRnJlZVRleHRFZGl0b3IuX2ludGVybmFsUGFkZGluZyArIHRoaXMuI2ZvbnRTaXplKSAqIHNjYWxlXTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucmVidWlsZCgpO1xuICAgIGlmICh0aGlzLmRpdiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGQodGhpcyk7XG4gICAgfVxuICB9XG4gIGVuYWJsZUVkaXRNb2RlKCkge1xuICAgIGlmICh0aGlzLmlzSW5FZGl0TW9kZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFyZW50LnNldEVkaXRpbmdTdGF0ZShmYWxzZSk7XG4gICAgdGhpcy5wYXJlbnQudXBkYXRlVG9vbGJhcihBbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVCk7XG4gICAgc3VwZXIuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLm92ZXJsYXlEaXYuY2xhc3NMaXN0LnJlbW92ZShcImVuYWJsZWRcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuZGl2LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiKTtcbiAgICB0aGlzLiNlZGl0TW9kZUFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiNlZGl0TW9kZUFDKTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmVkaXRvckRpdktleWRvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuZWRpdG9yRGl2Rm9jdXMuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5lZGl0b3JEaXZCbHVyLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLmVkaXRvckRpdklucHV0LmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwYXN0ZVwiLCB0aGlzLmVkaXRvckRpdlBhc3RlLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gIGRpc2FibGVFZGl0TW9kZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNJbkVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQuc2V0RWRpdGluZ1N0YXRlKHRydWUpO1xuICAgIHN1cGVyLmRpc2FibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMub3ZlcmxheURpdi5jbGFzc0xpc3QuYWRkKFwiZW5hYmxlZFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIiwgdGhpcy4jZWRpdG9yRGl2SWQpO1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLiNlZGl0TW9kZUFDPy5hYm9ydCgpO1xuICAgIHRoaXMuI2VkaXRNb2RlQUMgPSBudWxsO1xuICAgIHRoaXMuZGl2LmZvY3VzKHtcbiAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICAgIHRoaXMucGFyZW50LmRpdi5jbGFzc0xpc3QuYWRkKFwiZnJlZXRleHRFZGl0aW5nXCIpO1xuICB9XG4gIGZvY3VzaW4oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2ZvY3VzRXZlbnRzQWxsb3dlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5mb2N1c2luKGV2ZW50KTtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmVkaXRvckRpdikge1xuICAgICAgdGhpcy5lZGl0b3JEaXYuZm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgb25jZUFkZGVkKGZvY3VzKSB7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgIGlmIChmb2N1cykge1xuICAgICAgdGhpcy5lZGl0b3JEaXYuZm9jdXMoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2luaXRpYWxPcHRpb25zPy5pc0NlbnRlcmVkKSB7XG4gICAgICB0aGlzLmNlbnRlcigpO1xuICAgIH1cbiAgICB0aGlzLl9pbml0aWFsT3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gIXRoaXMuZWRpdG9yRGl2IHx8IHRoaXMuZWRpdG9yRGl2LmlubmVyVGV4dC50cmltKCkgPT09IFwiXCI7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5zZXRFZGl0aW5nU3RhdGUodHJ1ZSk7XG4gICAgICB0aGlzLnBhcmVudC5kaXYuY2xhc3NMaXN0LmFkZChcImZyZWV0ZXh0RWRpdGluZ1wiKTtcbiAgICB9XG4gICAgc3VwZXIucmVtb3ZlKCk7XG4gIH1cbiAgI2V4dHJhY3RUZXh0KCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgIHRoaXMuZWRpdG9yRGl2Lm5vcm1hbGl6ZSgpO1xuICAgIGxldCBwcmV2Q2hpbGQgPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5lZGl0b3JEaXYuY2hpbGROb2Rlcykge1xuICAgICAgaWYgKHByZXZDaGlsZD8ubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFICYmIGNoaWxkLm5vZGVOYW1lID09PSBcIkJSXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBidWZmZXIucHVzaChGcmVlVGV4dEVkaXRvci4jZ2V0Tm9kZUNvbnRlbnQoY2hpbGQpKTtcbiAgICAgIHByZXZDaGlsZCA9IGNoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgI3NldEVkaXRvckRpbWVuc2lvbnMoKSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGxldCByZWN0O1xuICAgIGlmICh0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgcmVjdCA9IHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGN1cnJlbnRMYXllcixcbiAgICAgICAgZGl2XG4gICAgICB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHNhdmVkRGlzcGxheSA9IGRpdi5zdHlsZS5kaXNwbGF5O1xuICAgICAgY29uc3Qgc2F2ZWRWaXNpYmlsaXR5ID0gZGl2LmNsYXNzTGlzdC5jb250YWlucyhcImhpZGRlblwiKTtcbiAgICAgIGRpdi5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xuICAgICAgZGl2LnN0eWxlLmRpc3BsYXkgPSBcImhpZGRlblwiO1xuICAgICAgY3VycmVudExheWVyLmRpdi5hcHBlbmQodGhpcy5kaXYpO1xuICAgICAgcmVjdCA9IGRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGRpdi5yZW1vdmUoKTtcbiAgICAgIGRpdi5zdHlsZS5kaXNwbGF5ID0gc2F2ZWREaXNwbGF5O1xuICAgICAgZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJoaWRkZW5cIiwgc2F2ZWRWaXNpYmlsaXR5KTtcbiAgICB9XG4gICAgaWYgKHRoaXMucm90YXRpb24gJSAxODAgPT09IHRoaXMucGFyZW50Um90YXRpb24gJSAxODApIHtcbiAgICAgIHRoaXMud2lkdGggPSByZWN0LndpZHRoIC8gcGFyZW50V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHJlY3QuaGVpZ2h0IC8gcGFyZW50SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gcmVjdC5oZWlnaHQgLyBwYXJlbnRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gcmVjdC53aWR0aCAvIHBhcmVudEhlaWdodDtcbiAgICB9XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICB9XG4gIGNvbW1pdCgpIHtcbiAgICBpZiAoIXRoaXMuaXNJbkVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuY29tbWl0KCk7XG4gICAgdGhpcy5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICBjb25zdCBzYXZlZFRleHQgPSB0aGlzLiNjb250ZW50O1xuICAgIGNvbnN0IG5ld1RleHQgPSB0aGlzLiNjb250ZW50ID0gdGhpcy4jZXh0cmFjdFRleHQoKS50cmltRW5kKCk7XG4gICAgaWYgKHNhdmVkVGV4dCA9PT0gbmV3VGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZXRUZXh0ID0gdGV4dCA9PiB7XG4gICAgICB0aGlzLiNjb250ZW50ID0gdGV4dDtcbiAgICAgIGlmICghdGV4dCkge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLiNzZXRDb250ZW50KCk7XG4gICAgICB0aGlzLl91aU1hbmFnZXIucmVidWlsZCh0aGlzKTtcbiAgICAgIHRoaXMuI3NldEVkaXRvckRpbWVuc2lvbnMoKTtcbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgIHNldFRleHQobmV3VGV4dCk7XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICBzZXRUZXh0KHNhdmVkVGV4dCk7XG4gICAgICB9LFxuICAgICAgbXVzdEV4ZWM6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy4jc2V0RWRpdG9yRGltZW5zaW9ucygpO1xuICB9XG4gIHNob3VsZEdldEtleWJvYXJkRXZlbnRzKCkge1xuICAgIHJldHVybiB0aGlzLmlzSW5FZGl0TW9kZSgpO1xuICB9XG4gIGVudGVySW5FZGl0TW9kZSgpIHtcbiAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5lZGl0b3JEaXYuZm9jdXMoKTtcbiAgfVxuICBkYmxjbGljayhldmVudCkge1xuICAgIHRoaXMuZW50ZXJJbkVkaXRNb2RlKCk7XG4gIH1cbiAga2V5ZG93bihldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuZGl2ICYmIGV2ZW50LmtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICB0aGlzLmVudGVySW5FZGl0TW9kZSgpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgZWRpdG9yRGl2S2V5ZG93bihldmVudCkge1xuICAgIEZyZWVUZXh0RWRpdG9yLl9rZXlib2FyZE1hbmFnZXIuZXhlYyh0aGlzLCBldmVudCk7XG4gIH1cbiAgZWRpdG9yRGl2Rm9jdXMoZXZlbnQpIHtcbiAgICB0aGlzLmlzRWRpdGluZyA9IHRydWU7XG4gIH1cbiAgZWRpdG9yRGl2Qmx1cihldmVudCkge1xuICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gIH1cbiAgZWRpdG9yRGl2SW5wdXQoZXZlbnQpIHtcbiAgICB0aGlzLnBhcmVudC5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImZyZWV0ZXh0RWRpdGluZ1wiLCB0aGlzLmlzRW1wdHkoKSk7XG4gIH1cbiAgZGlzYWJsZUVkaXRpbmcoKSB7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImNvbW1lbnRcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1tdWx0aWxpbmVcIik7XG4gIH1cbiAgZW5hYmxlRWRpdGluZygpIHtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwidGV4dGJveFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLW11bHRpbGluZVwiLCB0cnVlKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgfVxuICAgIGxldCBiYXNlWCwgYmFzZVk7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIGJhc2VYID0gdGhpcy54O1xuICAgICAgYmFzZVkgPSB0aGlzLnk7XG4gICAgfVxuICAgIHN1cGVyLnJlbmRlcigpO1xuICAgIHRoaXMuZWRpdG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5jbGFzc05hbWUgPSBcImludGVybmFsXCI7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwiaWRcIiwgdGhpcy4jZWRpdG9yRGl2SWQpO1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWZyZWUtdGV4dDJcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWF0dHJzXCIsIFwiZGVmYXVsdC1jb250ZW50XCIpO1xuICAgIHRoaXMuZW5hYmxlRWRpdGluZygpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy5lZGl0b3JEaXY7XG4gICAgc3R5bGUuZm9udFNpemUgPSBgY2FsYygke3RoaXMuI2ZvbnRTaXplfXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSlgO1xuICAgIHN0eWxlLmNvbG9yID0gdGhpcy4jY29sb3I7XG4gICAgdGhpcy5kaXYuYXBwZW5kKHRoaXMuZWRpdG9yRGl2KTtcbiAgICB0aGlzLm92ZXJsYXlEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMub3ZlcmxheURpdi5jbGFzc0xpc3QuYWRkKFwib3ZlcmxheVwiLCBcImVuYWJsZWRcIik7XG4gICAgdGhpcy5kaXYuYXBwZW5kKHRoaXMub3ZlcmxheURpdik7XG4gICAgYmluZEV2ZW50cyh0aGlzLCB0aGlzLmRpdiwgW1wiZGJsY2xpY2tcIiwgXCJrZXlkb3duXCJdKTtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgfSA9IHRoaXMuX2luaXRpYWxEYXRhO1xuICAgICAgICBsZXQgW3R4LCB0eV0gPSB0aGlzLmdldEluaXRpYWxUcmFuc2xhdGlvbigpO1xuICAgICAgICBbdHgsIHR5XSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uVG9TY3JlZW4odHgsIHR5KTtcbiAgICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgICAgICBsZXQgcG9zWCwgcG9zWTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcG9zWCA9IGJhc2VYICsgKHBvc2l0aW9uWzBdIC0gcGFnZVgpIC8gcGFnZVdpZHRoO1xuICAgICAgICAgICAgcG9zWSA9IGJhc2VZICsgdGhpcy5oZWlnaHQgLSAocG9zaXRpb25bMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA5MDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCArIChwb3NpdGlvblswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSAtIChwb3NpdGlvblsxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICBbdHgsIHR5XSA9IFt0eSwgLXR4XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTgwOlxuICAgICAgICAgICAgcG9zWCA9IGJhc2VYIC0gdGhpcy53aWR0aCArIChwb3NpdGlvblswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSAtIChwb3NpdGlvblsxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICBbdHgsIHR5XSA9IFstdHgsIC10eV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI3MDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCArIChwb3NpdGlvblswXSAtIHBhZ2VYIC0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0KSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSArIChwb3NpdGlvblsxXSAtIHBhZ2VZIC0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aCkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgW3R4LCB0eV0gPSBbLXR5LCB0eF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEF0KHBvc1ggKiBwYXJlbnRXaWR0aCwgcG9zWSAqIHBhcmVudEhlaWdodCwgdHgsIHR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0QXQoYmFzZVggKiBwYXJlbnRXaWR0aCwgYmFzZVkgKiBwYXJlbnRIZWlnaHQsIHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgICAgfVxuICAgICAgdGhpcy4jc2V0Q29udGVudCgpO1xuICAgICAgdGhpcy5faXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgc3RhdGljICNnZXROb2RlQ29udGVudChub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSA/IG5vZGUubm9kZVZhbHVlIDogbm9kZS5pbm5lclRleHQpLnJlcGxhY2VBbGwoRU9MX1BBVFRFUk4sIFwiXCIpO1xuICB9XG4gIGVkaXRvckRpdlBhc3RlKGV2ZW50KSB7XG4gICAgY29uc3QgY2xpcGJvYXJkRGF0YSA9IGV2ZW50LmNsaXBib2FyZERhdGEgfHwgd2luZG93LmNsaXBib2FyZERhdGE7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZXNcbiAgICB9ID0gY2xpcGJvYXJkRGF0YTtcbiAgICBpZiAodHlwZXMubGVuZ3RoID09PSAxICYmIHR5cGVzWzBdID09PSBcInRleHQvcGxhaW5cIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHBhc3RlID0gRnJlZVRleHRFZGl0b3IuI2Rlc2VyaWFsaXplQ29udGVudChjbGlwYm9hcmREYXRhLmdldERhdGEoXCJ0ZXh0XCIpIHx8IFwiXCIpLnJlcGxhY2VBbGwoRU9MX1BBVFRFUk4sIFwiXFxuXCIpO1xuICAgIGlmICghcGFzdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghc2VsZWN0aW9uLnJhbmdlQ291bnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lZGl0b3JEaXYubm9ybWFsaXplKCk7XG4gICAgc2VsZWN0aW9uLmRlbGV0ZUZyb21Eb2N1bWVudCgpO1xuICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgaWYgKCFwYXN0ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShwYXN0ZSkpO1xuICAgICAgdGhpcy5lZGl0b3JEaXYubm9ybWFsaXplKCk7XG4gICAgICBzZWxlY3Rpb24uY29sbGFwc2VUb1N0YXJ0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0Q29udGFpbmVyLFxuICAgICAgc3RhcnRPZmZzZXRcbiAgICB9ID0gcmFuZ2U7XG4gICAgY29uc3QgYnVmZmVyQmVmb3JlID0gW107XG4gICAgY29uc3QgYnVmZmVyQWZ0ZXIgPSBbXTtcbiAgICBpZiAoc3RhcnRDb250YWluZXIubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBzdGFydENvbnRhaW5lci5wYXJlbnRFbGVtZW50O1xuICAgICAgYnVmZmVyQWZ0ZXIucHVzaChzdGFydENvbnRhaW5lci5ub2RlVmFsdWUuc2xpY2Uoc3RhcnRPZmZzZXQpLnJlcGxhY2VBbGwoRU9MX1BBVFRFUk4sIFwiXCIpKTtcbiAgICAgIGlmIChwYXJlbnQgIT09IHRoaXMuZWRpdG9yRGl2KSB7XG4gICAgICAgIGxldCBidWZmZXIgPSBidWZmZXJCZWZvcmU7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5lZGl0b3JEaXYuY2hpbGROb2Rlcykge1xuICAgICAgICAgIGlmIChjaGlsZCA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgICBidWZmZXIgPSBidWZmZXJBZnRlcjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWZmZXIucHVzaChGcmVlVGV4dEVkaXRvci4jZ2V0Tm9kZUNvbnRlbnQoY2hpbGQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnVmZmVyQmVmb3JlLnB1c2goc3RhcnRDb250YWluZXIubm9kZVZhbHVlLnNsaWNlKDAsIHN0YXJ0T2Zmc2V0KS5yZXBsYWNlQWxsKEVPTF9QQVRURVJOLCBcIlwiKSk7XG4gICAgfSBlbHNlIGlmIChzdGFydENvbnRhaW5lciA9PT0gdGhpcy5lZGl0b3JEaXYpIHtcbiAgICAgIGxldCBidWZmZXIgPSBidWZmZXJCZWZvcmU7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuZWRpdG9yRGl2LmNoaWxkTm9kZXMpIHtcbiAgICAgICAgaWYgKGkrKyA9PT0gc3RhcnRPZmZzZXQpIHtcbiAgICAgICAgICBidWZmZXIgPSBidWZmZXJBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXIucHVzaChGcmVlVGV4dEVkaXRvci4jZ2V0Tm9kZUNvbnRlbnQoY2hpbGQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jY29udGVudCA9IGAke2J1ZmZlckJlZm9yZS5qb2luKFwiXFxuXCIpfSR7cGFzdGV9JHtidWZmZXJBZnRlci5qb2luKFwiXFxuXCIpfWA7XG4gICAgdGhpcy4jc2V0Q29udGVudCgpO1xuICAgIGNvbnN0IG5ld1JhbmdlID0gbmV3IFJhbmdlKCk7XG4gICAgbGV0IGJlZm9yZUxlbmd0aCA9IGJ1ZmZlckJlZm9yZS5yZWR1Y2UoKGFjYywgbGluZSkgPT4gYWNjICsgbGluZS5sZW5ndGgsIDApO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgZmlyc3RDaGlsZFxuICAgIH0gb2YgdGhpcy5lZGl0b3JEaXYuY2hpbGROb2Rlcykge1xuICAgICAgaWYgKGZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGZpcnN0Q2hpbGQubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgICAgaWYgKGJlZm9yZUxlbmd0aCA8PSBsZW5ndGgpIHtcbiAgICAgICAgICBuZXdSYW5nZS5zZXRTdGFydChmaXJzdENoaWxkLCBiZWZvcmVMZW5ndGgpO1xuICAgICAgICAgIG5ld1JhbmdlLnNldEVuZChmaXJzdENoaWxkLCBiZWZvcmVMZW5ndGgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJlZm9yZUxlbmd0aCAtPSBsZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICBzZWxlY3Rpb24uYWRkUmFuZ2UobmV3UmFuZ2UpO1xuICB9XG4gICNzZXRDb250ZW50KCkge1xuICAgIHRoaXMuZWRpdG9yRGl2LnJlcGxhY2VDaGlsZHJlbigpO1xuICAgIGlmICghdGhpcy4jY29udGVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGhpcy4jY29udGVudC5zcGxpdChcIlxcblwiKSkge1xuICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGRpdi5hcHBlbmQobGluZSA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxpbmUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmFwcGVuZChkaXYpO1xuICAgIH1cbiAgfVxuICAjc2VyaWFsaXplQ29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY29udGVudC5yZXBsYWNlQWxsKFwiXFx4YTBcIiwgXCIgXCIpO1xuICB9XG4gIHN0YXRpYyAjZGVzZXJpYWxpemVDb250ZW50KGNvbnRlbnQpIHtcbiAgICByZXR1cm4gY29udGVudC5yZXBsYWNlQWxsKFwiIFwiLCBcIlxceGEwXCIpO1xuICB9XG4gIGdldCBjb250ZW50RGl2KCkge1xuICAgIHJldHVybiB0aGlzLmVkaXRvckRpdjtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBsZXQgaW5pdGlhbERhdGEgPSBudWxsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZGVmYXVsdEFwcGVhcmFuY2VEYXRhOiB7XG4gICAgICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRDb2xvclxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVjdCxcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwb3B1cFJlZlxuICAgICAgICB9LFxuICAgICAgICB0ZXh0Q29udGVudCxcbiAgICAgICAgdGV4dFBvc2l0aW9uLFxuICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgICBwYWdlTnVtYmVyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGlmICghdGV4dENvbnRlbnQgfHwgdGV4dENvbnRlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaW5pdGlhbERhdGEgPSBkYXRhID0ge1xuICAgICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQsXG4gICAgICAgIGNvbG9yOiBBcnJheS5mcm9tKGZvbnRDb2xvciksXG4gICAgICAgIGZvbnRTaXplLFxuICAgICAgICB2YWx1ZTogdGV4dENvbnRlbnQuam9pbihcIlxcblwiKSxcbiAgICAgICAgcG9zaXRpb246IHRleHRQb3NpdGlvbixcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlTnVtYmVyIC0gMSxcbiAgICAgICAgcmVjdDogcmVjdC5zbGljZSgwKSxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGlkLFxuICAgICAgICBkZWxldGVkOiBmYWxzZSxcbiAgICAgICAgcG9wdXBSZWZcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKTtcbiAgICBlZGl0b3IuI2ZvbnRTaXplID0gZGF0YS5mb250U2l6ZTtcbiAgICBlZGl0b3IuI2NvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoLi4uZGF0YS5jb2xvcik7XG4gICAgZWRpdG9yLiNjb250ZW50ID0gRnJlZVRleHRFZGl0b3IuI2Rlc2VyaWFsaXplQ29udGVudChkYXRhLnZhbHVlKTtcbiAgICBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IGRhdGEuaWQgfHwgbnVsbDtcbiAgICBlZGl0b3IuX2luaXRpYWxEYXRhID0gaW5pdGlhbERhdGE7XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWxldGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVEZWxldGVkKCk7XG4gICAgfVxuICAgIGNvbnN0IHBhZGRpbmcgPSBGcmVlVGV4dEVkaXRvci5faW50ZXJuYWxQYWRkaW5nICogdGhpcy5wYXJlbnRTY2FsZTtcbiAgICBjb25zdCByZWN0ID0gdGhpcy5nZXRSZWN0KHBhZGRpbmcsIHBhZGRpbmcpO1xuICAgIGNvbnN0IGNvbG9yID0gQW5ub3RhdGlvbkVkaXRvci5fY29sb3JNYW5hZ2VyLmNvbnZlcnQodGhpcy5pc0F0dGFjaGVkVG9ET00gPyBnZXRDb21wdXRlZFN0eWxlKHRoaXMuZWRpdG9yRGl2KS5jb2xvciA6IHRoaXMuI2NvbG9yKTtcbiAgICBjb25zdCBzZXJpYWxpemVkID0ge1xuICAgICAgYW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhULFxuICAgICAgY29sb3IsXG4gICAgICBmb250U2l6ZTogdGhpcy4jZm9udFNpemUsXG4gICAgICB2YWx1ZTogdGhpcy4jc2VyaWFsaXplQ29udGVudCgpLFxuICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgIHJlY3QsXG4gICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcbiAgICAgIHN0cnVjdFRyZWVQYXJlbnRJZDogdGhpcy5fc3RydWN0VHJlZVBhcmVudElkXG4gICAgfTtcbiAgICBpZiAoaXNGb3JDb3B5aW5nKSB7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiAhdGhpcy4jaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzZXJpYWxpemVkLmlkID0gdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gICNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWUsXG4gICAgICBmb250U2l6ZSxcbiAgICAgIGNvbG9yLFxuICAgICAgcGFnZUluZGV4XG4gICAgfSA9IHRoaXMuX2luaXRpYWxEYXRhO1xuICAgIHJldHVybiB0aGlzLl9oYXNCZWVuTW92ZWQgfHwgc2VyaWFsaXplZC52YWx1ZSAhPT0gdmFsdWUgfHwgc2VyaWFsaXplZC5mb250U2l6ZSAhPT0gZm9udFNpemUgfHwgc2VyaWFsaXplZC5jb2xvci5zb21lKChjLCBpKSA9PiBjICE9PSBjb2xvcltpXSkgfHwgc2VyaWFsaXplZC5wYWdlSW5kZXggIT09IHBhZ2VJbmRleDtcbiAgfVxuICByZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgY29uc3QgY29udGVudCA9IHN1cGVyLnJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pO1xuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSBjb250ZW50O1xuICAgIHN0eWxlLmZvbnRTaXplID0gYGNhbGMoJHt0aGlzLiNmb250U2l6ZX1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYDtcbiAgICBzdHlsZS5jb2xvciA9IHRoaXMuI2NvbG9yO1xuICAgIGNvbnRlbnQucmVwbGFjZUNoaWxkcmVuKCk7XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIHRoaXMuI2NvbnRlbnQuc3BsaXQoXCJcXG5cIikpIHtcbiAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBkaXYuYXBwZW5kKGxpbmUgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgICBjb250ZW50LmFwcGVuZChkaXYpO1xuICAgIH1cbiAgICBjb25zdCBwYWRkaW5nID0gRnJlZVRleHRFZGl0b3IuX2ludGVybmFsUGFkZGluZyAqIHRoaXMucGFyZW50U2NhbGU7XG4gICAgYW5ub3RhdGlvbi51cGRhdGVFZGl0ZWQoe1xuICAgICAgcmVjdDogdGhpcy5nZXRSZWN0KHBhZGRpbmcsIHBhZGRpbmcpLFxuICAgICAgcG9wdXBDb250ZW50OiB0aGlzLiNjb250ZW50XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgcmVzZXRBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgc3VwZXIucmVzZXRBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKTtcbiAgICBhbm5vdGF0aW9uLnJlc2V0RWRpdGVkKCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2RyYXdlcnMvb3V0bGluZS5qc1xuXG5jbGFzcyBPdXRsaW5lIHtcbiAgc3RhdGljIFBSRUNJU0lPTiA9IDFlLTQ7XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgdG9TVkdQYXRoYCBtdXN0IGJlIGltcGxlbWVudGVkLlwiKTtcbiAgfVxuICBnZXQgYm94KCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgZ2V0dGVyIGBib3hgIG11c3QgYmUgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG4gIHNlcmlhbGl6ZShfYmJveCwgX3JvdGF0aW9uKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYHNlcmlhbGl6ZWAgbXVzdCBiZSBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgc3RhdGljIF9yZXNjYWxlKHNyYywgdHgsIHR5LCBzeCwgc3ksIGRlc3QpIHtcbiAgICBkZXN0IHx8PSBuZXcgRmxvYXQzMkFycmF5KHNyYy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBkZXN0W2ldID0gdHggKyBzcmNbaV0gKiBzeDtcbiAgICAgIGRlc3RbaSArIDFdID0gdHkgKyBzcmNbaSArIDFdICogc3k7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9XG4gIHN0YXRpYyBfcmVzY2FsZUFuZFN3YXAoc3JjLCB0eCwgdHksIHN4LCBzeSwgZGVzdCkge1xuICAgIGRlc3QgfHw9IG5ldyBGbG9hdDMyQXJyYXkoc3JjLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3JjLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGRlc3RbaV0gPSB0eCArIHNyY1tpICsgMV0gKiBzeDtcbiAgICAgIGRlc3RbaSArIDFdID0gdHkgKyBzcmNbaV0gKiBzeTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cbiAgc3RhdGljIF90cmFuc2xhdGUoc3JjLCB0eCwgdHksIGRlc3QpIHtcbiAgICBkZXN0IHx8PSBuZXcgRmxvYXQzMkFycmF5KHNyYy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBkZXN0W2ldID0gdHggKyBzcmNbaV07XG4gICAgICBkZXN0W2kgKyAxXSA9IHR5ICsgc3JjW2kgKyAxXTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cbiAgc3RhdGljIHN2Z1JvdW5kKHgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh4ICogMTAwMDApO1xuICB9XG4gIHN0YXRpYyBfbm9ybWFsaXplUG9pbnQoeCwgeSwgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgcm90YXRpb24pIHtcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gWzEgLSB5IC8gcGFyZW50V2lkdGgsIHggLyBwYXJlbnRIZWlnaHRdO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbMSAtIHggLyBwYXJlbnRXaWR0aCwgMSAtIHkgLyBwYXJlbnRIZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeSAvIHBhcmVudFdpZHRoLCAxIC0geCAvIHBhcmVudEhlaWdodF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW3ggLyBwYXJlbnRXaWR0aCwgeSAvIHBhcmVudEhlaWdodF07XG4gICAgfVxuICB9XG4gIHN0YXRpYyBfbm9ybWFsaXplUGFnZVBvaW50KHgsIHksIHJvdGF0aW9uKSB7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geSwgeF07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geCwgMSAtIHldO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeSwgMSAtIHhdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUJlemllclBvaW50cyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgcmV0dXJuIFsoeDEgKyA1ICogeDIpIC8gNiwgKHkxICsgNSAqIHkyKSAvIDYsICg1ICogeDIgKyB4MykgLyA2LCAoNSAqIHkyICsgeTMpIC8gNiwgKHgyICsgeDMpIC8gMiwgKHkyICsgeTMpIC8gMl07XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2RyYXdlcnMvZnJlZWRyYXcuanNcblxuXG5jbGFzcyBGcmVlRHJhd091dGxpbmVyIHtcbiAgI2JveDtcbiAgI2JvdHRvbSA9IFtdO1xuICAjaW5uZXJNYXJnaW47XG4gICNpc0xUUjtcbiAgI3RvcCA9IFtdO1xuICAjbGFzdCA9IG5ldyBGbG9hdDMyQXJyYXkoMTgpO1xuICAjbGFzdFg7XG4gICNsYXN0WTtcbiAgI21pbjtcbiAgI21pbl9kaXN0O1xuICAjc2NhbGVGYWN0b3I7XG4gICN0aGlja25lc3M7XG4gICNwb2ludHMgPSBbXTtcbiAgc3RhdGljICNNSU5fRElTVCA9IDg7XG4gIHN0YXRpYyAjTUlOX0RJRkYgPSAyO1xuICBzdGF0aWMgI01JTiA9IEZyZWVEcmF3T3V0bGluZXIuI01JTl9ESVNUICsgRnJlZURyYXdPdXRsaW5lci4jTUlOX0RJRkY7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB4LFxuICAgIHlcbiAgfSwgYm94LCBzY2FsZUZhY3RvciwgdGhpY2tuZXNzLCBpc0xUUiwgaW5uZXJNYXJnaW4gPSAwKSB7XG4gICAgdGhpcy4jYm94ID0gYm94O1xuICAgIHRoaXMuI3RoaWNrbmVzcyA9IHRoaWNrbmVzcyAqIHNjYWxlRmFjdG9yO1xuICAgIHRoaXMuI2lzTFRSID0gaXNMVFI7XG4gICAgdGhpcy4jbGFzdC5zZXQoW05hTiwgTmFOLCBOYU4sIE5hTiwgeCwgeV0sIDYpO1xuICAgIHRoaXMuI2lubmVyTWFyZ2luID0gaW5uZXJNYXJnaW47XG4gICAgdGhpcy4jbWluX2Rpc3QgPSBGcmVlRHJhd091dGxpbmVyLiNNSU5fRElTVCAqIHNjYWxlRmFjdG9yO1xuICAgIHRoaXMuI21pbiA9IEZyZWVEcmF3T3V0bGluZXIuI01JTiAqIHNjYWxlRmFjdG9yO1xuICAgIHRoaXMuI3NjYWxlRmFjdG9yID0gc2NhbGVGYWN0b3I7XG4gICAgdGhpcy4jcG9pbnRzLnB1c2goeCwgeSk7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gaXNOYU4odGhpcy4jbGFzdFs4XSk7XG4gIH1cbiAgI2dldExhc3RDb29yZHMoKSB7XG4gICAgY29uc3QgbGFzdFRvcCA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoNCwgNik7XG4gICAgY29uc3QgbGFzdEJvdHRvbSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMTYsIDE4KTtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgcmV0dXJuIFsodGhpcy4jbGFzdFggKyAobGFzdFRvcFswXSAtIGxhc3RCb3R0b21bMF0pIC8gMiAtIHgpIC8gd2lkdGgsICh0aGlzLiNsYXN0WSArIChsYXN0VG9wWzFdIC0gbGFzdEJvdHRvbVsxXSkgLyAyIC0geSkgLyBoZWlnaHQsICh0aGlzLiNsYXN0WCArIChsYXN0Qm90dG9tWzBdIC0gbGFzdFRvcFswXSkgLyAyIC0geCkgLyB3aWR0aCwgKHRoaXMuI2xhc3RZICsgKGxhc3RCb3R0b21bMV0gLSBsYXN0VG9wWzFdKSAvIDIgLSB5KSAvIGhlaWdodF07XG4gIH1cbiAgYWRkKHtcbiAgICB4LFxuICAgIHlcbiAgfSkge1xuICAgIHRoaXMuI2xhc3RYID0geDtcbiAgICB0aGlzLiNsYXN0WSA9IHk7XG4gICAgY29uc3QgW2xheWVyWCwgbGF5ZXJZLCBsYXllcldpZHRoLCBsYXllckhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgbGV0IFt4MSwgeTEsIHgyLCB5Ml0gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDgsIDEyKTtcbiAgICBjb25zdCBkaWZmWCA9IHggLSB4MjtcbiAgICBjb25zdCBkaWZmWSA9IHkgLSB5MjtcbiAgICBjb25zdCBkID0gTWF0aC5oeXBvdChkaWZmWCwgZGlmZlkpO1xuICAgIGlmIChkIDwgdGhpcy4jbWluKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGRpZmZEID0gZCAtIHRoaXMuI21pbl9kaXN0O1xuICAgIGNvbnN0IEsgPSBkaWZmRCAvIGQ7XG4gICAgY29uc3Qgc2hpZnRYID0gSyAqIGRpZmZYO1xuICAgIGNvbnN0IHNoaWZ0WSA9IEsgKiBkaWZmWTtcbiAgICBsZXQgeDAgPSB4MTtcbiAgICBsZXQgeTAgPSB5MTtcbiAgICB4MSA9IHgyO1xuICAgIHkxID0geTI7XG4gICAgeDIgKz0gc2hpZnRYO1xuICAgIHkyICs9IHNoaWZ0WTtcbiAgICB0aGlzLiNwb2ludHM/LnB1c2goeCwgeSk7XG4gICAgY29uc3QgblggPSAtc2hpZnRZIC8gZGlmZkQ7XG4gICAgY29uc3QgblkgPSBzaGlmdFggLyBkaWZmRDtcbiAgICBjb25zdCB0aFggPSBuWCAqIHRoaXMuI3RoaWNrbmVzcztcbiAgICBjb25zdCB0aFkgPSBuWSAqIHRoaXMuI3RoaWNrbmVzcztcbiAgICB0aGlzLiNsYXN0LnNldCh0aGlzLiNsYXN0LnN1YmFycmF5KDIsIDgpLCAwKTtcbiAgICB0aGlzLiNsYXN0LnNldChbeDIgKyB0aFgsIHkyICsgdGhZXSwgNCk7XG4gICAgdGhpcy4jbGFzdC5zZXQodGhpcy4jbGFzdC5zdWJhcnJheSgxNCwgMTgpLCAxMik7XG4gICAgdGhpcy4jbGFzdC5zZXQoW3gyIC0gdGhYLCB5MiAtIHRoWV0sIDE2KTtcbiAgICBpZiAoaXNOYU4odGhpcy4jbGFzdFs2XSkpIHtcbiAgICAgIGlmICh0aGlzLiN0b3AubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuI2xhc3Quc2V0KFt4MSArIHRoWCwgeTEgKyB0aFldLCAyKTtcbiAgICAgICAgdGhpcy4jdG9wLnB1c2goTmFOLCBOYU4sIE5hTiwgTmFOLCAoeDEgKyB0aFggLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKHkxICsgdGhZIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0KTtcbiAgICAgICAgdGhpcy4jbGFzdC5zZXQoW3gxIC0gdGhYLCB5MSAtIHRoWV0sIDE0KTtcbiAgICAgICAgdGhpcy4jYm90dG9tLnB1c2goTmFOLCBOYU4sIE5hTiwgTmFOLCAoeDEgLSB0aFggLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKHkxIC0gdGhZIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI2xhc3Quc2V0KFt4MCwgeTAsIHgxLCB5MSwgeDIsIHkyXSwgNik7XG4gICAgICByZXR1cm4gIXRoaXMuaXNFbXB0eSgpO1xuICAgIH1cbiAgICB0aGlzLiNsYXN0LnNldChbeDAsIHkwLCB4MSwgeTEsIHgyLCB5Ml0sIDYpO1xuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hYnMoTWF0aC5hdGFuMih5MCAtIHkxLCB4MCAtIHgxKSAtIE1hdGguYXRhbjIoc2hpZnRZLCBzaGlmdFgpKTtcbiAgICBpZiAoYW5nbGUgPCBNYXRoLlBJIC8gMikge1xuICAgICAgW3gxLCB5MSwgeDIsIHkyXSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMiwgNik7XG4gICAgICB0aGlzLiN0b3AucHVzaChOYU4sIE5hTiwgTmFOLCBOYU4sICgoeDEgKyB4MikgLyAyIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoeTEgKyB5MikgLyAyIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0KTtcbiAgICAgIFt4MSwgeTEsIHgwLCB5MF0gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDE0LCAxOCk7XG4gICAgICB0aGlzLiNib3R0b20ucHVzaChOYU4sIE5hTiwgTmFOLCBOYU4sICgoeDAgKyB4MSkgLyAyIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoeTAgKyB5MSkgLyAyIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBbeDAsIHkwLCB4MSwgeTEsIHgyLCB5Ml0gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDAsIDYpO1xuICAgIHRoaXMuI3RvcC5wdXNoKCgoeDAgKyA1ICogeDEpIC8gNiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKHkwICsgNSAqIHkxKSAvIDYgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsICgoNSAqIHgxICsgeDIpIC8gNiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKDUgKiB5MSArIHkyKSAvIDYgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsICgoeDEgKyB4MikgLyAyIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoeTEgKyB5MikgLyAyIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0KTtcbiAgICBbeDIsIHkyLCB4MSwgeTEsIHgwLCB5MF0gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDEyLCAxOCk7XG4gICAgdGhpcy4jYm90dG9tLnB1c2goKCh4MCArIDUgKiB4MSkgLyA2IC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoeTAgKyA1ICogeTEpIC8gNiAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgKCg1ICogeDEgKyB4MikgLyA2IC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoNSAqIHkxICsgeTIpIC8gNiAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgKCh4MSArIHgyKSAvIDIgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCh5MSArIHkyKSAvIDIgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBjb25zdCB0b3AgPSB0aGlzLiN0b3A7XG4gICAgY29uc3QgYm90dG9tID0gdGhpcy4jYm90dG9tO1xuICAgIGlmIChpc05hTih0aGlzLiNsYXN0WzZdKSAmJiAhdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLiN0b1NWR1BhdGhUd29Qb2ludHMoKTtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgYnVmZmVyLnB1c2goYE0ke3RvcFs0XX0gJHt0b3BbNV19YCk7XG4gICAgZm9yIChsZXQgaSA9IDY7IGkgPCB0b3AubGVuZ3RoOyBpICs9IDYpIHtcbiAgICAgIGlmIChpc05hTih0b3BbaV0pKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBMJHt0b3BbaSArIDRdfSAke3RvcFtpICsgNV19YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXIucHVzaChgQyR7dG9wW2ldfSAke3RvcFtpICsgMV19ICR7dG9wW2kgKyAyXX0gJHt0b3BbaSArIDNdfSAke3RvcFtpICsgNF19ICR7dG9wW2kgKyA1XX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jdG9TVkdQYXRoRW5kKGJ1ZmZlcik7XG4gICAgZm9yIChsZXQgaSA9IGJvdHRvbS5sZW5ndGggLSA2OyBpID49IDY7IGkgLT0gNikge1xuICAgICAgaWYgKGlzTmFOKGJvdHRvbVtpXSkpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goYEwke2JvdHRvbVtpICsgNF19ICR7Ym90dG9tW2kgKyA1XX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBDJHtib3R0b21baV19ICR7Ym90dG9tW2kgKyAxXX0gJHtib3R0b21baSArIDJdfSAke2JvdHRvbVtpICsgM119ICR7Ym90dG9tW2kgKyA0XX0gJHtib3R0b21baSArIDVdfWApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiN0b1NWR1BhdGhTdGFydChidWZmZXIpO1xuICAgIHJldHVybiBidWZmZXIuam9pbihcIiBcIik7XG4gIH1cbiAgI3RvU1ZHUGF0aFR3b1BvaW50cygpIHtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgY29uc3QgW2xhc3RUb3BYLCBsYXN0VG9wWSwgbGFzdEJvdHRvbVgsIGxhc3RCb3R0b21ZXSA9IHRoaXMuI2dldExhc3RDb29yZHMoKTtcbiAgICByZXR1cm4gYE0keyh0aGlzLiNsYXN0WzJdIC0geCkgLyB3aWR0aH0gJHsodGhpcy4jbGFzdFszXSAtIHkpIC8gaGVpZ2h0fSBMJHsodGhpcy4jbGFzdFs0XSAtIHgpIC8gd2lkdGh9ICR7KHRoaXMuI2xhc3RbNV0gLSB5KSAvIGhlaWdodH0gTCR7bGFzdFRvcFh9ICR7bGFzdFRvcFl9IEwke2xhc3RCb3R0b21YfSAke2xhc3RCb3R0b21ZfSBMJHsodGhpcy4jbGFzdFsxNl0gLSB4KSAvIHdpZHRofSAkeyh0aGlzLiNsYXN0WzE3XSAtIHkpIC8gaGVpZ2h0fSBMJHsodGhpcy4jbGFzdFsxNF0gLSB4KSAvIHdpZHRofSAkeyh0aGlzLiNsYXN0WzE1XSAtIHkpIC8gaGVpZ2h0fSBaYDtcbiAgfVxuICAjdG9TVkdQYXRoU3RhcnQoYnVmZmVyKSB7XG4gICAgY29uc3QgYm90dG9tID0gdGhpcy4jYm90dG9tO1xuICAgIGJ1ZmZlci5wdXNoKGBMJHtib3R0b21bNF19ICR7Ym90dG9tWzVdfSBaYCk7XG4gIH1cbiAgI3RvU1ZHUGF0aEVuZChidWZmZXIpIHtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgY29uc3QgbGFzdFRvcCA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoNCwgNik7XG4gICAgY29uc3QgbGFzdEJvdHRvbSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMTYsIDE4KTtcbiAgICBjb25zdCBbbGFzdFRvcFgsIGxhc3RUb3BZLCBsYXN0Qm90dG9tWCwgbGFzdEJvdHRvbVldID0gdGhpcy4jZ2V0TGFzdENvb3JkcygpO1xuICAgIGJ1ZmZlci5wdXNoKGBMJHsobGFzdFRvcFswXSAtIHgpIC8gd2lkdGh9ICR7KGxhc3RUb3BbMV0gLSB5KSAvIGhlaWdodH0gTCR7bGFzdFRvcFh9ICR7bGFzdFRvcFl9IEwke2xhc3RCb3R0b21YfSAke2xhc3RCb3R0b21ZfSBMJHsobGFzdEJvdHRvbVswXSAtIHgpIC8gd2lkdGh9ICR7KGxhc3RCb3R0b21bMV0gLSB5KSAvIGhlaWdodH1gKTtcbiAgfVxuICBuZXdGcmVlRHJhd091dGxpbmUob3V0bGluZSwgcG9pbnRzLCBib3gsIHNjYWxlRmFjdG9yLCBpbm5lck1hcmdpbiwgaXNMVFIpIHtcbiAgICByZXR1cm4gbmV3IEZyZWVEcmF3T3V0bGluZShvdXRsaW5lLCBwb2ludHMsIGJveCwgc2NhbGVGYWN0b3IsIGlubmVyTWFyZ2luLCBpc0xUUik7XG4gIH1cbiAgZ2V0T3V0bGluZXMoKSB7XG4gICAgY29uc3QgdG9wID0gdGhpcy4jdG9wO1xuICAgIGNvbnN0IGJvdHRvbSA9IHRoaXMuI2JvdHRvbTtcbiAgICBjb25zdCBsYXN0ID0gdGhpcy4jbGFzdDtcbiAgICBjb25zdCBbbGF5ZXJYLCBsYXllclksIGxheWVyV2lkdGgsIGxheWVySGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICBjb25zdCBwb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KCh0aGlzLiNwb2ludHM/Lmxlbmd0aCA/PyAwKSArIDIpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGggLSAyOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgcG9pbnRzW2ldID0gKHRoaXMuI3BvaW50c1tpXSAtIGxheWVyWCkgLyBsYXllcldpZHRoO1xuICAgICAgcG9pbnRzW2kgKyAxXSA9ICh0aGlzLiNwb2ludHNbaSArIDFdIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0O1xuICAgIH1cbiAgICBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdID0gKHRoaXMuI2xhc3RYIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGg7XG4gICAgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSA9ICh0aGlzLiNsYXN0WSAtIGxheWVyWSkgLyBsYXllckhlaWdodDtcbiAgICBpZiAoaXNOYU4obGFzdFs2XSkgJiYgIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy4jZ2V0T3V0bGluZVR3b1BvaW50cyhwb2ludHMpO1xuICAgIH1cbiAgICBjb25zdCBvdXRsaW5lID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLiN0b3AubGVuZ3RoICsgMjQgKyB0aGlzLiNib3R0b20ubGVuZ3RoKTtcbiAgICBsZXQgTiA9IHRvcC5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyBpICs9IDIpIHtcbiAgICAgIGlmIChpc05hTih0b3BbaV0pKSB7XG4gICAgICAgIG91dGxpbmVbaV0gPSBvdXRsaW5lW2kgKyAxXSA9IE5hTjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBvdXRsaW5lW2ldID0gdG9wW2ldO1xuICAgICAgb3V0bGluZVtpICsgMV0gPSB0b3BbaSArIDFdO1xuICAgIH1cbiAgICBOID0gdGhpcy4jZ2V0T3V0bGluZUVuZChvdXRsaW5lLCBOKTtcbiAgICBmb3IgKGxldCBpID0gYm90dG9tLmxlbmd0aCAtIDY7IGkgPj0gNjsgaSAtPSA2KSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDY7IGogKz0gMikge1xuICAgICAgICBpZiAoaXNOYU4oYm90dG9tW2kgKyBqXSkpIHtcbiAgICAgICAgICBvdXRsaW5lW05dID0gb3V0bGluZVtOICsgMV0gPSBOYU47XG4gICAgICAgICAgTiArPSAyO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG91dGxpbmVbTl0gPSBib3R0b21baSArIGpdO1xuICAgICAgICBvdXRsaW5lW04gKyAxXSA9IGJvdHRvbVtpICsgaiArIDFdO1xuICAgICAgICBOICs9IDI7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2dldE91dGxpbmVTdGFydChvdXRsaW5lLCBOKTtcbiAgICByZXR1cm4gdGhpcy5uZXdGcmVlRHJhd091dGxpbmUob3V0bGluZSwgcG9pbnRzLCB0aGlzLiNib3gsIHRoaXMuI3NjYWxlRmFjdG9yLCB0aGlzLiNpbm5lck1hcmdpbiwgdGhpcy4jaXNMVFIpO1xuICB9XG4gICNnZXRPdXRsaW5lVHdvUG9pbnRzKHBvaW50cykge1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLiNsYXN0O1xuICAgIGNvbnN0IFtsYXllclgsIGxheWVyWSwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGNvbnN0IFtsYXN0VG9wWCwgbGFzdFRvcFksIGxhc3RCb3R0b21YLCBsYXN0Qm90dG9tWV0gPSB0aGlzLiNnZXRMYXN0Q29vcmRzKCk7XG4gICAgY29uc3Qgb3V0bGluZSA9IG5ldyBGbG9hdDMyQXJyYXkoMzYpO1xuICAgIG91dGxpbmUuc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIChsYXN0WzJdIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsIChsYXN0WzNdIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCBOYU4sIE5hTiwgTmFOLCBOYU4sIChsYXN0WzRdIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsIChsYXN0WzVdIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCBOYU4sIE5hTiwgTmFOLCBOYU4sIGxhc3RUb3BYLCBsYXN0VG9wWSwgTmFOLCBOYU4sIE5hTiwgTmFOLCBsYXN0Qm90dG9tWCwgbGFzdEJvdHRvbVksIE5hTiwgTmFOLCBOYU4sIE5hTiwgKGxhc3RbMTZdIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsIChsYXN0WzE3XSAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgTmFOLCBOYU4sIE5hTiwgTmFOLCAobGFzdFsxNF0gLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKGxhc3RbMTVdIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0XSwgMCk7XG4gICAgcmV0dXJuIHRoaXMubmV3RnJlZURyYXdPdXRsaW5lKG91dGxpbmUsIHBvaW50cywgdGhpcy4jYm94LCB0aGlzLiNzY2FsZUZhY3RvciwgdGhpcy4jaW5uZXJNYXJnaW4sIHRoaXMuI2lzTFRSKTtcbiAgfVxuICAjZ2V0T3V0bGluZVN0YXJ0KG91dGxpbmUsIHBvcykge1xuICAgIGNvbnN0IGJvdHRvbSA9IHRoaXMuI2JvdHRvbTtcbiAgICBvdXRsaW5lLnNldChbTmFOLCBOYU4sIE5hTiwgTmFOLCBib3R0b21bNF0sIGJvdHRvbVs1XV0sIHBvcyk7XG4gICAgcmV0dXJuIHBvcyArPSA2O1xuICB9XG4gICNnZXRPdXRsaW5lRW5kKG91dGxpbmUsIHBvcykge1xuICAgIGNvbnN0IGxhc3RUb3AgPSB0aGlzLiNsYXN0LnN1YmFycmF5KDQsIDYpO1xuICAgIGNvbnN0IGxhc3RCb3R0b20gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDE2LCAxOCk7XG4gICAgY29uc3QgW2xheWVyWCwgbGF5ZXJZLCBsYXllcldpZHRoLCBsYXllckhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgY29uc3QgW2xhc3RUb3BYLCBsYXN0VG9wWSwgbGFzdEJvdHRvbVgsIGxhc3RCb3R0b21ZXSA9IHRoaXMuI2dldExhc3RDb29yZHMoKTtcbiAgICBvdXRsaW5lLnNldChbTmFOLCBOYU4sIE5hTiwgTmFOLCAobGFzdFRvcFswXSAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAobGFzdFRvcFsxXSAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgTmFOLCBOYU4sIE5hTiwgTmFOLCBsYXN0VG9wWCwgbGFzdFRvcFksIE5hTiwgTmFOLCBOYU4sIE5hTiwgbGFzdEJvdHRvbVgsIGxhc3RCb3R0b21ZLCBOYU4sIE5hTiwgTmFOLCBOYU4sIChsYXN0Qm90dG9tWzBdIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsIChsYXN0Qm90dG9tWzFdIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0XSwgcG9zKTtcbiAgICByZXR1cm4gcG9zICs9IDI0O1xuICB9XG59XG5jbGFzcyBGcmVlRHJhd091dGxpbmUgZXh0ZW5kcyBPdXRsaW5lIHtcbiAgI2JveDtcbiAgI2Jib3ggPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAjaW5uZXJNYXJnaW47XG4gICNpc0xUUjtcbiAgI3BvaW50cztcbiAgI3NjYWxlRmFjdG9yO1xuICAjb3V0bGluZTtcbiAgY29uc3RydWN0b3Iob3V0bGluZSwgcG9pbnRzLCBib3gsIHNjYWxlRmFjdG9yLCBpbm5lck1hcmdpbiwgaXNMVFIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuI291dGxpbmUgPSBvdXRsaW5lO1xuICAgIHRoaXMuI3BvaW50cyA9IHBvaW50cztcbiAgICB0aGlzLiNib3ggPSBib3g7XG4gICAgdGhpcy4jc2NhbGVGYWN0b3IgPSBzY2FsZUZhY3RvcjtcbiAgICB0aGlzLiNpbm5lck1hcmdpbiA9IGlubmVyTWFyZ2luO1xuICAgIHRoaXMuI2lzTFRSID0gaXNMVFI7XG4gICAgdGhpcy5sYXN0UG9pbnQgPSBbTmFOLCBOYU5dO1xuICAgIHRoaXMuI2NvbXB1dGVNaW5NYXgoaXNMVFIpO1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2Jib3g7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gb3V0bGluZS5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBvdXRsaW5lW2ldID0gKG91dGxpbmVbaV0gLSB4KSAvIHdpZHRoO1xuICAgICAgb3V0bGluZVtpICsgMV0gPSAob3V0bGluZVtpICsgMV0gLSB5KSAvIGhlaWdodDtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIHBvaW50c1tpXSA9IChwb2ludHNbaV0gLSB4KSAvIHdpZHRoO1xuICAgICAgcG9pbnRzW2kgKyAxXSA9IChwb2ludHNbaSArIDFdIC0geSkgLyBoZWlnaHQ7XG4gICAgfVxuICB9XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICBjb25zdCBidWZmZXIgPSBbYE0ke3RoaXMuI291dGxpbmVbNF19ICR7dGhpcy4jb3V0bGluZVs1XX1gXTtcbiAgICBmb3IgKGxldCBpID0gNiwgaWkgPSB0aGlzLiNvdXRsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDYpIHtcbiAgICAgIGlmIChpc05hTih0aGlzLiNvdXRsaW5lW2ldKSkge1xuICAgICAgICBidWZmZXIucHVzaChgTCR7dGhpcy4jb3V0bGluZVtpICsgNF19ICR7dGhpcy4jb3V0bGluZVtpICsgNV19YCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnVmZmVyLnB1c2goYEMke3RoaXMuI291dGxpbmVbaV19ICR7dGhpcy4jb3V0bGluZVtpICsgMV19ICR7dGhpcy4jb3V0bGluZVtpICsgMl19ICR7dGhpcy4jb3V0bGluZVtpICsgM119ICR7dGhpcy4jb3V0bGluZVtpICsgNF19ICR7dGhpcy4jb3V0bGluZVtpICsgNV19YCk7XG4gICAgfVxuICAgIGJ1ZmZlci5wdXNoKFwiWlwiKTtcbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCIgXCIpO1xuICB9XG4gIHNlcmlhbGl6ZShbYmxYLCBibFksIHRyWCwgdHJZXSwgcm90YXRpb24pIHtcbiAgICBjb25zdCB3aWR0aCA9IHRyWCAtIGJsWDtcbiAgICBjb25zdCBoZWlnaHQgPSB0clkgLSBibFk7XG4gICAgbGV0IG91dGxpbmU7XG4gICAgbGV0IHBvaW50cztcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIG91dGxpbmUgPSBPdXRsaW5lLl9yZXNjYWxlKHRoaXMuI291dGxpbmUsIGJsWCwgdHJZLCB3aWR0aCwgLWhlaWdodCk7XG4gICAgICAgIHBvaW50cyA9IE91dGxpbmUuX3Jlc2NhbGUodGhpcy4jcG9pbnRzLCBibFgsIHRyWSwgd2lkdGgsIC1oZWlnaHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIG91dGxpbmUgPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcCh0aGlzLiNvdXRsaW5lLCBibFgsIGJsWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHBvaW50cyA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwKHRoaXMuI3BvaW50cywgYmxYLCBibFksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICBvdXRsaW5lID0gT3V0bGluZS5fcmVzY2FsZSh0aGlzLiNvdXRsaW5lLCB0clgsIGJsWSwgLXdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBwb2ludHMgPSBPdXRsaW5lLl9yZXNjYWxlKHRoaXMuI3BvaW50cywgdHJYLCBibFksIC13aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgb3V0bGluZSA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwKHRoaXMuI291dGxpbmUsIHRyWCwgdHJZLCAtd2lkdGgsIC1oZWlnaHQpO1xuICAgICAgICBwb2ludHMgPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcCh0aGlzLiNwb2ludHMsIHRyWCwgdHJZLCAtd2lkdGgsIC1oZWlnaHQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG91dGxpbmU6IEFycmF5LmZyb20ob3V0bGluZSksXG4gICAgICBwb2ludHM6IFtBcnJheS5mcm9tKHBvaW50cyldXG4gICAgfTtcbiAgfVxuICAjY29tcHV0ZU1pbk1heChpc0xUUikge1xuICAgIGNvbnN0IG91dGxpbmUgPSB0aGlzLiNvdXRsaW5lO1xuICAgIGxldCBsYXN0WCA9IG91dGxpbmVbNF07XG4gICAgbGV0IGxhc3RZID0gb3V0bGluZVs1XTtcbiAgICBsZXQgbWluWCA9IGxhc3RYO1xuICAgIGxldCBtaW5ZID0gbGFzdFk7XG4gICAgbGV0IG1heFggPSBsYXN0WDtcbiAgICBsZXQgbWF4WSA9IGxhc3RZO1xuICAgIGxldCBsYXN0UG9pbnRYID0gbGFzdFg7XG4gICAgbGV0IGxhc3RQb2ludFkgPSBsYXN0WTtcbiAgICBjb25zdCBsdHJDYWxsYmFjayA9IGlzTFRSID8gTWF0aC5tYXggOiBNYXRoLm1pbjtcbiAgICBmb3IgKGxldCBpID0gNiwgaWkgPSBvdXRsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDYpIHtcbiAgICAgIGlmIChpc05hTihvdXRsaW5lW2ldKSkge1xuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgb3V0bGluZVtpICsgNF0pO1xuICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgb3V0bGluZVtpICsgNV0pO1xuICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgb3V0bGluZVtpICsgNF0pO1xuICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgb3V0bGluZVtpICsgNV0pO1xuICAgICAgICBpZiAobGFzdFBvaW50WSA8IG91dGxpbmVbaSArIDVdKSB7XG4gICAgICAgICAgbGFzdFBvaW50WCA9IG91dGxpbmVbaSArIDRdO1xuICAgICAgICAgIGxhc3RQb2ludFkgPSBvdXRsaW5lW2kgKyA1XTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0UG9pbnRZID09PSBvdXRsaW5lW2kgKyA1XSkge1xuICAgICAgICAgIGxhc3RQb2ludFggPSBsdHJDYWxsYmFjayhsYXN0UG9pbnRYLCBvdXRsaW5lW2kgKyA0XSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJib3ggPSBVdGlsLmJlemllckJvdW5kaW5nQm94KGxhc3RYLCBsYXN0WSwgLi4ub3V0bGluZS5zbGljZShpLCBpICsgNikpO1xuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgYmJveFswXSk7XG4gICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBiYm94WzFdKTtcbiAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIGJib3hbMl0pO1xuICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgYmJveFszXSk7XG4gICAgICAgIGlmIChsYXN0UG9pbnRZIDwgYmJveFszXSkge1xuICAgICAgICAgIGxhc3RQb2ludFggPSBiYm94WzJdO1xuICAgICAgICAgIGxhc3RQb2ludFkgPSBiYm94WzNdO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RQb2ludFkgPT09IGJib3hbM10pIHtcbiAgICAgICAgICBsYXN0UG9pbnRYID0gbHRyQ2FsbGJhY2sobGFzdFBvaW50WCwgYmJveFsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RYID0gb3V0bGluZVtpICsgNF07XG4gICAgICBsYXN0WSA9IG91dGxpbmVbaSArIDVdO1xuICAgIH1cbiAgICBjb25zdCBiYm94ID0gdGhpcy4jYmJveDtcbiAgICBiYm94WzBdID0gbWluWCAtIHRoaXMuI2lubmVyTWFyZ2luO1xuICAgIGJib3hbMV0gPSBtaW5ZIC0gdGhpcy4jaW5uZXJNYXJnaW47XG4gICAgYmJveFsyXSA9IG1heFggLSBtaW5YICsgMiAqIHRoaXMuI2lubmVyTWFyZ2luO1xuICAgIGJib3hbM10gPSBtYXhZIC0gbWluWSArIDIgKiB0aGlzLiNpbm5lck1hcmdpbjtcbiAgICB0aGlzLmxhc3RQb2ludCA9IFtsYXN0UG9pbnRYLCBsYXN0UG9pbnRZXTtcbiAgfVxuICBnZXQgYm94KCkge1xuICAgIHJldHVybiB0aGlzLiNiYm94O1xuICB9XG4gIG5ld091dGxpbmVyKHBvaW50LCBib3gsIHNjYWxlRmFjdG9yLCB0aGlja25lc3MsIGlzTFRSLCBpbm5lck1hcmdpbiA9IDApIHtcbiAgICByZXR1cm4gbmV3IEZyZWVEcmF3T3V0bGluZXIocG9pbnQsIGJveCwgc2NhbGVGYWN0b3IsIHRoaWNrbmVzcywgaXNMVFIsIGlubmVyTWFyZ2luKTtcbiAgfVxuICBnZXROZXdPdXRsaW5lKHRoaWNrbmVzcywgaW5uZXJNYXJnaW4pIHtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNiYm94O1xuICAgIGNvbnN0IFtsYXllclgsIGxheWVyWSwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGNvbnN0IHN4ID0gd2lkdGggKiBsYXllcldpZHRoO1xuICAgIGNvbnN0IHN5ID0gaGVpZ2h0ICogbGF5ZXJIZWlnaHQ7XG4gICAgY29uc3QgdHggPSB4ICogbGF5ZXJXaWR0aCArIGxheWVyWDtcbiAgICBjb25zdCB0eSA9IHkgKiBsYXllckhlaWdodCArIGxheWVyWTtcbiAgICBjb25zdCBvdXRsaW5lciA9IHRoaXMubmV3T3V0bGluZXIoe1xuICAgICAgeDogdGhpcy4jcG9pbnRzWzBdICogc3ggKyB0eCxcbiAgICAgIHk6IHRoaXMuI3BvaW50c1sxXSAqIHN5ICsgdHlcbiAgICB9LCB0aGlzLiNib3gsIHRoaXMuI3NjYWxlRmFjdG9yLCB0aGlja25lc3MsIHRoaXMuI2lzTFRSLCBpbm5lck1hcmdpbiA/PyB0aGlzLiNpbm5lck1hcmdpbik7XG4gICAgZm9yIChsZXQgaSA9IDI7IGkgPCB0aGlzLiNwb2ludHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIG91dGxpbmVyLmFkZCh7XG4gICAgICAgIHg6IHRoaXMuI3BvaW50c1tpXSAqIHN4ICsgdHgsXG4gICAgICAgIHk6IHRoaXMuI3BvaW50c1tpICsgMV0gKiBzeSArIHR5XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dGxpbmVyLmdldE91dGxpbmVzKCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2RyYXdlcnMvaGlnaGxpZ2h0LmpzXG5cblxuY2xhc3MgSGlnaGxpZ2h0T3V0bGluZXIge1xuICAjYm94O1xuICAjbGFzdFBvaW50O1xuICAjdmVydGljYWxFZGdlcyA9IFtdO1xuICAjaW50ZXJ2YWxzID0gW107XG4gIGNvbnN0cnVjdG9yKGJveGVzLCBib3JkZXJXaWR0aCA9IDAsIGlubmVyTWFyZ2luID0gMCwgaXNMVFIgPSB0cnVlKSB7XG4gICAgbGV0IG1pblggPSBJbmZpbml0eTtcbiAgICBsZXQgbWF4WCA9IC1JbmZpbml0eTtcbiAgICBsZXQgbWluWSA9IEluZmluaXR5O1xuICAgIGxldCBtYXhZID0gLUluZmluaXR5O1xuICAgIGNvbnN0IE5VTUJFUl9PRl9ESUdJVFMgPSA0O1xuICAgIGNvbnN0IEVQU0lMT04gPSAxMCAqKiAtTlVNQkVSX09GX0RJR0lUUztcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9IG9mIGJveGVzKSB7XG4gICAgICBjb25zdCB4MSA9IE1hdGguZmxvb3IoKHggLSBib3JkZXJXaWR0aCkgLyBFUFNJTE9OKSAqIEVQU0lMT047XG4gICAgICBjb25zdCB4MiA9IE1hdGguY2VpbCgoeCArIHdpZHRoICsgYm9yZGVyV2lkdGgpIC8gRVBTSUxPTikgKiBFUFNJTE9OO1xuICAgICAgY29uc3QgeTEgPSBNYXRoLmZsb29yKCh5IC0gYm9yZGVyV2lkdGgpIC8gRVBTSUxPTikgKiBFUFNJTE9OO1xuICAgICAgY29uc3QgeTIgPSBNYXRoLmNlaWwoKHkgKyBoZWlnaHQgKyBib3JkZXJXaWR0aCkgLyBFUFNJTE9OKSAqIEVQU0lMT047XG4gICAgICBjb25zdCBsZWZ0ID0gW3gxLCB5MSwgeTIsIHRydWVdO1xuICAgICAgY29uc3QgcmlnaHQgPSBbeDIsIHkxLCB5MiwgZmFsc2VdO1xuICAgICAgdGhpcy4jdmVydGljYWxFZGdlcy5wdXNoKGxlZnQsIHJpZ2h0KTtcbiAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4MSk7XG4gICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeDIpO1xuICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkxKTtcbiAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5Mik7XG4gICAgfVxuICAgIGNvbnN0IGJib3hXaWR0aCA9IG1heFggLSBtaW5YICsgMiAqIGlubmVyTWFyZ2luO1xuICAgIGNvbnN0IGJib3hIZWlnaHQgPSBtYXhZIC0gbWluWSArIDIgKiBpbm5lck1hcmdpbjtcbiAgICBjb25zdCBzaGlmdGVkTWluWCA9IG1pblggLSBpbm5lck1hcmdpbjtcbiAgICBjb25zdCBzaGlmdGVkTWluWSA9IG1pblkgLSBpbm5lck1hcmdpbjtcbiAgICBjb25zdCBsYXN0RWRnZSA9IHRoaXMuI3ZlcnRpY2FsRWRnZXMuYXQoaXNMVFIgPyAtMSA6IC0yKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBbbGFzdEVkZ2VbMF0sIGxhc3RFZGdlWzJdXTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgdGhpcy4jdmVydGljYWxFZGdlcykge1xuICAgICAgY29uc3QgW3gsIHkxLCB5Ml0gPSBlZGdlO1xuICAgICAgZWRnZVswXSA9ICh4IC0gc2hpZnRlZE1pblgpIC8gYmJveFdpZHRoO1xuICAgICAgZWRnZVsxXSA9ICh5MSAtIHNoaWZ0ZWRNaW5ZKSAvIGJib3hIZWlnaHQ7XG4gICAgICBlZGdlWzJdID0gKHkyIC0gc2hpZnRlZE1pblkpIC8gYmJveEhlaWdodDtcbiAgICB9XG4gICAgdGhpcy4jYm94ID0gbmV3IEZsb2F0MzJBcnJheShbc2hpZnRlZE1pblgsIHNoaWZ0ZWRNaW5ZLCBiYm94V2lkdGgsIGJib3hIZWlnaHRdKTtcbiAgICB0aGlzLiNsYXN0UG9pbnQgPSBsYXN0UG9pbnQ7XG4gIH1cbiAgZ2V0T3V0bGluZXMoKSB7XG4gICAgdGhpcy4jdmVydGljYWxFZGdlcy5zb3J0KChhLCBiKSA9PiBhWzBdIC0gYlswXSB8fCBhWzFdIC0gYlsxXSB8fCBhWzJdIC0gYlsyXSk7XG4gICAgY29uc3Qgb3V0bGluZVZlcnRpY2FsRWRnZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgdGhpcy4jdmVydGljYWxFZGdlcykge1xuICAgICAgaWYgKGVkZ2VbM10pIHtcbiAgICAgICAgb3V0bGluZVZlcnRpY2FsRWRnZXMucHVzaCguLi50aGlzLiNicmVha0VkZ2UoZWRnZSkpO1xuICAgICAgICB0aGlzLiNpbnNlcnQoZWRnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiNyZW1vdmUoZWRnZSk7XG4gICAgICAgIG91dGxpbmVWZXJ0aWNhbEVkZ2VzLnB1c2goLi4udGhpcy4jYnJlYWtFZGdlKGVkZ2UpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2dldE91dGxpbmVzKG91dGxpbmVWZXJ0aWNhbEVkZ2VzKTtcbiAgfVxuICAjZ2V0T3V0bGluZXMob3V0bGluZVZlcnRpY2FsRWRnZXMpIHtcbiAgICBjb25zdCBlZGdlcyA9IFtdO1xuICAgIGNvbnN0IGFsbEVkZ2VzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgZWRnZSBvZiBvdXRsaW5lVmVydGljYWxFZGdlcykge1xuICAgICAgY29uc3QgW3gsIHkxLCB5Ml0gPSBlZGdlO1xuICAgICAgZWRnZXMucHVzaChbeCwgeTEsIGVkZ2VdLCBbeCwgeTIsIGVkZ2VdKTtcbiAgICB9XG4gICAgZWRnZXMuc29ydCgoYSwgYikgPT4gYVsxXSAtIGJbMV0gfHwgYVswXSAtIGJbMF0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGVkZ2VzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IGVkZ2UxID0gZWRnZXNbaV1bMl07XG4gICAgICBjb25zdCBlZGdlMiA9IGVkZ2VzW2kgKyAxXVsyXTtcbiAgICAgIGVkZ2UxLnB1c2goZWRnZTIpO1xuICAgICAgZWRnZTIucHVzaChlZGdlMSk7XG4gICAgICBhbGxFZGdlcy5hZGQoZWRnZTEpO1xuICAgICAgYWxsRWRnZXMuYWRkKGVkZ2UyKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0bGluZXMgPSBbXTtcbiAgICBsZXQgb3V0bGluZTtcbiAgICB3aGlsZSAoYWxsRWRnZXMuc2l6ZSA+IDApIHtcbiAgICAgIGNvbnN0IGVkZ2UgPSBhbGxFZGdlcy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICBsZXQgW3gsIHkxLCB5MiwgZWRnZTEsIGVkZ2UyXSA9IGVkZ2U7XG4gICAgICBhbGxFZGdlcy5kZWxldGUoZWRnZSk7XG4gICAgICBsZXQgbGFzdFBvaW50WCA9IHg7XG4gICAgICBsZXQgbGFzdFBvaW50WSA9IHkxO1xuICAgICAgb3V0bGluZSA9IFt4LCB5Ml07XG4gICAgICBvdXRsaW5lcy5wdXNoKG91dGxpbmUpO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IGU7XG4gICAgICAgIGlmIChhbGxFZGdlcy5oYXMoZWRnZTEpKSB7XG4gICAgICAgICAgZSA9IGVkZ2UxO1xuICAgICAgICB9IGVsc2UgaWYgKGFsbEVkZ2VzLmhhcyhlZGdlMikpIHtcbiAgICAgICAgICBlID0gZWRnZTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYWxsRWRnZXMuZGVsZXRlKGUpO1xuICAgICAgICBbeCwgeTEsIHkyLCBlZGdlMSwgZWRnZTJdID0gZTtcbiAgICAgICAgaWYgKGxhc3RQb2ludFggIT09IHgpIHtcbiAgICAgICAgICBvdXRsaW5lLnB1c2gobGFzdFBvaW50WCwgbGFzdFBvaW50WSwgeCwgbGFzdFBvaW50WSA9PT0geTEgPyB5MSA6IHkyKTtcbiAgICAgICAgICBsYXN0UG9pbnRYID0geDtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UG9pbnRZID0gbGFzdFBvaW50WSA9PT0geTEgPyB5MiA6IHkxO1xuICAgICAgfVxuICAgICAgb3V0bGluZS5wdXNoKGxhc3RQb2ludFgsIGxhc3RQb2ludFkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEhpZ2hsaWdodE91dGxpbmUob3V0bGluZXMsIHRoaXMuI2JveCwgdGhpcy4jbGFzdFBvaW50KTtcbiAgfVxuICAjYmluYXJ5U2VhcmNoKHkpIHtcbiAgICBjb25zdCBhcnJheSA9IHRoaXMuI2ludGVydmFscztcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSBhcnJheS5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICAgIGNvbnN0IG1pZGRsZSA9IHN0YXJ0ICsgZW5kID4+IDE7XG4gICAgICBjb25zdCB5MSA9IGFycmF5W21pZGRsZV1bMF07XG4gICAgICBpZiAoeTEgPT09IHkpIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZTtcbiAgICAgIH1cbiAgICAgIGlmICh5MSA8IHkpIHtcbiAgICAgICAgc3RhcnQgPSBtaWRkbGUgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gbWlkZGxlIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuZCArIDE7XG4gIH1cbiAgI2luc2VydChbLCB5MSwgeTJdKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLiNiaW5hcnlTZWFyY2goeTEpO1xuICAgIHRoaXMuI2ludGVydmFscy5zcGxpY2UoaW5kZXgsIDAsIFt5MSwgeTJdKTtcbiAgfVxuICAjcmVtb3ZlKFssIHkxLCB5Ml0pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuI2JpbmFyeVNlYXJjaCh5MSk7XG4gICAgZm9yIChsZXQgaSA9IGluZGV4OyBpIDwgdGhpcy4jaW50ZXJ2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSB0aGlzLiNpbnRlcnZhbHNbaV07XG4gICAgICBpZiAoc3RhcnQgIT09IHkxKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ID09PSB5MSAmJiBlbmQgPT09IHkyKSB7XG4gICAgICAgIHRoaXMuI2ludGVydmFscy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IGluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IHRoaXMuI2ludGVydmFsc1tpXTtcbiAgICAgIGlmIChzdGFydCAhPT0geTEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPT09IHkxICYmIGVuZCA9PT0geTIpIHtcbiAgICAgICAgdGhpcy4jaW50ZXJ2YWxzLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjYnJlYWtFZGdlKGVkZ2UpIHtcbiAgICBjb25zdCBbeCwgeTEsIHkyXSA9IGVkZ2U7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtbeCwgeTEsIHkyXV07XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLiNiaW5hcnlTZWFyY2goeTIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gdGhpcy4jaW50ZXJ2YWxzW2ldO1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGpqID0gcmVzdWx0cy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgIGNvbnN0IFssIHkzLCB5NF0gPSByZXN1bHRzW2pdO1xuICAgICAgICBpZiAoZW5kIDw9IHkzIHx8IHk0IDw9IHN0YXJ0KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkzID49IHN0YXJ0KSB7XG4gICAgICAgICAgaWYgKHk0ID4gZW5kKSB7XG4gICAgICAgICAgICByZXN1bHRzW2pdWzFdID0gZW5kO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoamogPT09IDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0cy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgICBqai0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRzW2pdWzJdID0gc3RhcnQ7XG4gICAgICAgIGlmICh5NCA+IGVuZCkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChbeCwgZW5kLCB5NF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG59XG5jbGFzcyBIaWdobGlnaHRPdXRsaW5lIGV4dGVuZHMgT3V0bGluZSB7XG4gICNib3g7XG4gICNvdXRsaW5lcztcbiAgY29uc3RydWN0b3Iob3V0bGluZXMsIGJveCwgbGFzdFBvaW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNvdXRsaW5lcyA9IG91dGxpbmVzO1xuICAgIHRoaXMuI2JveCA9IGJveDtcbiAgICB0aGlzLmxhc3RQb2ludCA9IGxhc3RQb2ludDtcbiAgfVxuICB0b1NWR1BhdGgoKSB7XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgZm9yIChjb25zdCBwb2x5Z29uIG9mIHRoaXMuI291dGxpbmVzKSB7XG4gICAgICBsZXQgW3ByZXZYLCBwcmV2WV0gPSBwb2x5Z29uO1xuICAgICAgYnVmZmVyLnB1c2goYE0ke3ByZXZYfSAke3ByZXZZfWApO1xuICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBwb2x5Z29uLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IHggPSBwb2x5Z29uW2ldO1xuICAgICAgICBjb25zdCB5ID0gcG9seWdvbltpICsgMV07XG4gICAgICAgIGlmICh4ID09PSBwcmV2WCkge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKGBWJHt5fWApO1xuICAgICAgICAgIHByZXZZID0geTtcbiAgICAgICAgfSBlbHNlIGlmICh5ID09PSBwcmV2WSkge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKGBIJHt4fWApO1xuICAgICAgICAgIHByZXZYID0geDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnVmZmVyLnB1c2goXCJaXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCIgXCIpO1xuICB9XG4gIHNlcmlhbGl6ZShbYmxYLCBibFksIHRyWCwgdHJZXSwgX3JvdGF0aW9uKSB7XG4gICAgY29uc3Qgb3V0bGluZXMgPSBbXTtcbiAgICBjb25zdCB3aWR0aCA9IHRyWCAtIGJsWDtcbiAgICBjb25zdCBoZWlnaHQgPSB0clkgLSBibFk7XG4gICAgZm9yIChjb25zdCBvdXRsaW5lIG9mIHRoaXMuI291dGxpbmVzKSB7XG4gICAgICBjb25zdCBwb2ludHMgPSBuZXcgQXJyYXkob3V0bGluZS5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRsaW5lLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHBvaW50c1tpXSA9IGJsWCArIG91dGxpbmVbaV0gKiB3aWR0aDtcbiAgICAgICAgcG9pbnRzW2kgKyAxXSA9IHRyWSAtIG91dGxpbmVbaSArIDFdICogaGVpZ2h0O1xuICAgICAgfVxuICAgICAgb3V0bGluZXMucHVzaChwb2ludHMpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0bGluZXM7XG4gIH1cbiAgZ2V0IGJveCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYm94O1xuICB9XG4gIGdldCBjbGFzc05hbWVzRm9yT3V0bGluaW5nKCkge1xuICAgIHJldHVybiBbXCJoaWdobGlnaHRPdXRsaW5lXCJdO1xuICB9XG59XG5jbGFzcyBGcmVlSGlnaGxpZ2h0T3V0bGluZXIgZXh0ZW5kcyBGcmVlRHJhd091dGxpbmVyIHtcbiAgbmV3RnJlZURyYXdPdXRsaW5lKG91dGxpbmUsIHBvaW50cywgYm94LCBzY2FsZUZhY3RvciwgaW5uZXJNYXJnaW4sIGlzTFRSKSB7XG4gICAgcmV0dXJuIG5ldyBGcmVlSGlnaGxpZ2h0T3V0bGluZShvdXRsaW5lLCBwb2ludHMsIGJveCwgc2NhbGVGYWN0b3IsIGlubmVyTWFyZ2luLCBpc0xUUik7XG4gIH1cbn1cbmNsYXNzIEZyZWVIaWdobGlnaHRPdXRsaW5lIGV4dGVuZHMgRnJlZURyYXdPdXRsaW5lIHtcbiAgbmV3T3V0bGluZXIocG9pbnQsIGJveCwgc2NhbGVGYWN0b3IsIHRoaWNrbmVzcywgaXNMVFIsIGlubmVyTWFyZ2luID0gMCkge1xuICAgIHJldHVybiBuZXcgRnJlZUhpZ2hsaWdodE91dGxpbmVyKHBvaW50LCBib3gsIHNjYWxlRmFjdG9yLCB0aGlja25lc3MsIGlzTFRSLCBpbm5lck1hcmdpbik7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2NvbG9yX3BpY2tlci5qc1xuXG5cblxuY2xhc3MgQ29sb3JQaWNrZXIge1xuICAjYnV0dG9uID0gbnVsbDtcbiAgI2J1dHRvblN3YXRjaCA9IG51bGw7XG4gICNkZWZhdWx0Q29sb3I7XG4gICNkcm9wZG93biA9IG51bGw7XG4gICNkcm9wZG93bldhc0Zyb21LZXlib2FyZCA9IGZhbHNlO1xuICAjaXNNYWluQ29sb3JQaWNrZXIgPSBmYWxzZTtcbiAgI2VkaXRvciA9IG51bGw7XG4gICNldmVudEJ1cztcbiAgI29wZW5Ecm9wZG93bkFDID0gbnVsbDtcbiAgI3VpTWFuYWdlciA9IG51bGw7XG4gICN0eXBlO1xuICBzdGF0aWMgI2wxMG5Db2xvciA9IG51bGw7XG4gIHN0YXRpYyBnZXQgX2tleWJvYXJkTWFuYWdlcigpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2tleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiRXNjYXBlXCIsIFwibWFjK0VzY2FwZVwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9oaWRlRHJvcGRvd25Gcm9tS2V5Ym9hcmRdLCBbW1wiIFwiLCBcIm1hYysgXCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX2NvbG9yU2VsZWN0RnJvbUtleWJvYXJkXSwgW1tcIkFycm93RG93blwiLCBcIkFycm93UmlnaHRcIiwgXCJtYWMrQXJyb3dEb3duXCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIENvbG9yUGlja2VyLnByb3RvdHlwZS5fbW92ZVRvTmV4dF0sIFtbXCJBcnJvd1VwXCIsIFwiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93VXBcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX21vdmVUb1ByZXZpb3VzXSwgW1tcIkhvbWVcIiwgXCJtYWMrSG9tZVwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9tb3ZlVG9CZWdpbm5pbmddLCBbW1wiRW5kXCIsIFwibWFjK0VuZFwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9tb3ZlVG9FbmRdXSkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBlZGl0b3IgPSBudWxsLFxuICAgIHVpTWFuYWdlciA9IG51bGxcbiAgfSkge1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuI2lzTWFpbkNvbG9yUGlja2VyID0gZmFsc2U7XG4gICAgICB0aGlzLiN0eXBlID0gQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0NPTE9SO1xuICAgICAgdGhpcy4jZWRpdG9yID0gZWRpdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNpc01haW5Db2xvclBpY2tlciA9IHRydWU7XG4gICAgICB0aGlzLiN0eXBlID0gQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0RFRkFVTFRfQ09MT1I7XG4gICAgfVxuICAgIHRoaXMuI3VpTWFuYWdlciA9IGVkaXRvcj8uX3VpTWFuYWdlciB8fCB1aU1hbmFnZXI7XG4gICAgdGhpcy4jZXZlbnRCdXMgPSB0aGlzLiN1aU1hbmFnZXIuX2V2ZW50QnVzO1xuICAgIHRoaXMuI2RlZmF1bHRDb2xvciA9IGVkaXRvcj8uY29sb3IgfHwgdGhpcy4jdWlNYW5hZ2VyPy5oaWdobGlnaHRDb2xvcnMudmFsdWVzKCkubmV4dCgpLnZhbHVlIHx8IFwiI0ZGRkY5OFwiO1xuICAgIENvbG9yUGlja2VyLiNsMTBuQ29sb3IgfHw9IE9iamVjdC5mcmVlemUoe1xuICAgICAgYmx1ZTogXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItYmx1ZVwiLFxuICAgICAgZ3JlZW46IFwicGRmanMtZWRpdG9yLWNvbG9ycGlja2VyLWdyZWVuXCIsXG4gICAgICBwaW5rOiBcInBkZmpzLWVkaXRvci1jb2xvcnBpY2tlci1waW5rXCIsXG4gICAgICByZWQ6IFwicGRmanMtZWRpdG9yLWNvbG9ycGlja2VyLXJlZFwiLFxuICAgICAgeWVsbG93OiBcInBkZmpzLWVkaXRvci1jb2xvcnBpY2tlci15ZWxsb3dcIlxuICAgIH0pO1xuICB9XG4gIHJlbmRlckJ1dHRvbigpIHtcbiAgICBjb25zdCBidXR0b24gPSB0aGlzLiNidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBcImNvbG9yUGlja2VyXCI7XG4gICAgYnV0dG9uLnRhYkluZGV4ID0gXCIwXCI7XG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWVkaXRvci1jb2xvcnBpY2tlci1idXR0b25cIik7XG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtaGFzcG9wdXBcIiwgdHJ1ZSk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNvcGVuRHJvcGRvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2tleURvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3Qgc3dhdGNoID0gdGhpcy4jYnV0dG9uU3dhdGNoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgc3dhdGNoLmNsYXNzTmFtZSA9IFwic3dhdGNoXCI7XG4gICAgc3dhdGNoLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIHRydWUpO1xuICAgIHN3YXRjaC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLiNkZWZhdWx0Q29sb3I7XG4gICAgYnV0dG9uLmFwcGVuZChzd2F0Y2gpO1xuICAgIHJldHVybiBidXR0b247XG4gIH1cbiAgcmVuZGVyTWFpbkRyb3Bkb3duKCkge1xuICAgIGNvbnN0IGRyb3Bkb3duID0gdGhpcy4jZHJvcGRvd24gPSB0aGlzLiNnZXREcm9wZG93blJvb3QoKTtcbiAgICBkcm9wZG93bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLW9yaWVudGF0aW9uXCIsIFwiaG9yaXpvbnRhbFwiKTtcbiAgICBkcm9wZG93bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsbGVkYnlcIiwgXCJoaWdobGlnaHRDb2xvclBpY2tlckxhYmVsXCIpO1xuICAgIHJldHVybiBkcm9wZG93bjtcbiAgfVxuICAjZ2V0RHJvcGRvd25Sb290KCkge1xuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBkaXYuY2xhc3NOYW1lID0gXCJkcm9wZG93blwiO1xuICAgIGRpdi5yb2xlID0gXCJsaXN0Ym94XCI7XG4gICAgZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbXVsdGlzZWxlY3RhYmxlXCIsIGZhbHNlKTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1vcmllbnRhdGlvblwiLCBcInZlcnRpY2FsXCIpO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItZHJvcGRvd25cIik7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgY29sb3JdIG9mIHRoaXMuI3VpTWFuYWdlci5oaWdobGlnaHRDb2xvcnMpIHtcbiAgICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICBidXR0b24udGFiSW5kZXggPSBcIjBcIjtcbiAgICAgIGJ1dHRvbi5yb2xlID0gXCJvcHRpb25cIjtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbG9yXCIsIGNvbG9yKTtcbiAgICAgIGJ1dHRvbi50aXRsZSA9IG5hbWU7XG4gICAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIENvbG9yUGlja2VyLiNsMTBuQ29sb3JbbmFtZV0pO1xuICAgICAgY29uc3Qgc3dhdGNoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBidXR0b24uYXBwZW5kKHN3YXRjaCk7XG4gICAgICBzd2F0Y2guY2xhc3NOYW1lID0gXCJzd2F0Y2hcIjtcbiAgICAgIHN3YXRjaC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIGNvbG9yID09PSB0aGlzLiNkZWZhdWx0Q29sb3IpO1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNjb2xvclNlbGVjdC5iaW5kKHRoaXMsIGNvbG9yKSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgZGl2LmFwcGVuZChidXR0b24pO1xuICAgIH1cbiAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4ja2V5RG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICByZXR1cm4gZGl2O1xuICB9XG4gICNjb2xvclNlbGVjdChjb2xvciwgZXZlbnQpIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB0aGlzLiNldmVudEJ1cy5kaXNwYXRjaChcInN3aXRjaGFubm90YXRpb25lZGl0b3JwYXJhbXNcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgdHlwZTogdGhpcy4jdHlwZSxcbiAgICAgIHZhbHVlOiBjb2xvclxuICAgIH0pO1xuICB9XG4gIF9jb2xvclNlbGVjdEZyb21LZXlib2FyZChldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuI2J1dHRvbikge1xuICAgICAgdGhpcy4jb3BlbkRyb3Bkb3duKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29sb3IgPSBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb2xvclwiKTtcbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbG9yU2VsZWN0KGNvbG9yLCBldmVudCk7XG4gIH1cbiAgX21vdmVUb05leHQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLiNidXR0b24pIHtcbiAgICAgIHRoaXMuI2Ryb3Bkb3duLmZpcnN0Q2hpbGQ/LmZvY3VzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnRhcmdldC5uZXh0U2libGluZz8uZm9jdXMoKTtcbiAgfVxuICBfbW92ZVRvUHJldmlvdXMoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLiNkcm9wZG93bj8uZmlyc3RDaGlsZCB8fCBldmVudC50YXJnZXQgPT09IHRoaXMuI2J1dHRvbikge1xuICAgICAgaWYgKHRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuX2hpZGVEcm9wZG93bkZyb21LZXlib2FyZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgIH1cbiAgICBldmVudC50YXJnZXQucHJldmlvdXNTaWJsaW5nPy5mb2N1cygpO1xuICB9XG4gIF9tb3ZlVG9CZWdpbm5pbmcoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNkcm9wZG93bi5maXJzdENoaWxkPy5mb2N1cygpO1xuICB9XG4gIF9tb3ZlVG9FbmQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNkcm9wZG93bi5sYXN0Q2hpbGQ/LmZvY3VzKCk7XG4gIH1cbiAgI2tleURvd24oZXZlbnQpIHtcbiAgICBDb2xvclBpY2tlci5fa2V5Ym9hcmRNYW5hZ2VyLmV4ZWModGhpcywgZXZlbnQpO1xuICB9XG4gICNvcGVuRHJvcGRvd24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy4jaXNEcm9wZG93blZpc2libGUpIHtcbiAgICAgIHRoaXMuaGlkZURyb3Bkb3duKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2Ryb3Bkb3duV2FzRnJvbUtleWJvYXJkID0gZXZlbnQuZGV0YWlsID09PSAwO1xuICAgIGlmICghdGhpcy4jb3BlbkRyb3Bkb3duQUMpIHtcbiAgICAgIHRoaXMuI29wZW5Ecm9wZG93bkFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiNwb2ludGVyRG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICAgIHNpZ25hbDogdGhpcy4jdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI29wZW5Ecm9wZG93bkFDKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNkcm9wZG93bikge1xuICAgICAgdGhpcy4jZHJvcGRvd24uY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuI2Ryb3Bkb3duID0gdGhpcy4jZ2V0RHJvcGRvd25Sb290KCk7XG4gICAgdGhpcy4jYnV0dG9uLmFwcGVuZChyb290KTtcbiAgfVxuICAjcG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy4jZHJvcGRvd24/LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5oaWRlRHJvcGRvd24oKTtcbiAgfVxuICBoaWRlRHJvcGRvd24oKSB7XG4gICAgdGhpcy4jZHJvcGRvd24/LmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gICAgdGhpcy4jb3BlbkRyb3Bkb3duQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jb3BlbkRyb3Bkb3duQUMgPSBudWxsO1xuICB9XG4gIGdldCAjaXNEcm9wZG93blZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Ryb3Bkb3duICYmICF0aGlzLiNkcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoXCJoaWRkZW5cIik7XG4gIH1cbiAgX2hpZGVEcm9wZG93bkZyb21LZXlib2FyZCgpIHtcbiAgICBpZiAodGhpcy4jaXNNYWluQ29sb3JQaWNrZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgdGhpcy4jZWRpdG9yPy51bnNlbGVjdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmhpZGVEcm9wZG93bigpO1xuICAgIHRoaXMuI2J1dHRvbi5mb2N1cyh7XG4gICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlLFxuICAgICAgZm9jdXNWaXNpYmxlOiB0aGlzLiNkcm9wZG93bldhc0Zyb21LZXlib2FyZFxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUNvbG9yKGNvbG9yKSB7XG4gICAgaWYgKHRoaXMuI2J1dHRvblN3YXRjaCkge1xuICAgICAgdGhpcy4jYnV0dG9uU3dhdGNoLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2Ryb3Bkb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGkgPSB0aGlzLiN1aU1hbmFnZXIuaGlnaGxpZ2h0Q29sb3JzLnZhbHVlcygpO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy4jZHJvcGRvd24uY2hpbGRyZW4pIHtcbiAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgaS5uZXh0KCkudmFsdWUgPT09IGNvbG9yKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNidXR0b24/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2J1dHRvbiA9IG51bGw7XG4gICAgdGhpcy4jYnV0dG9uU3dhdGNoID0gbnVsbDtcbiAgICB0aGlzLiNkcm9wZG93bj8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jZHJvcGRvd24gPSBudWxsO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9oaWdobGlnaHQuanNcblxuXG5cblxuXG5cblxuY2xhc3MgSGlnaGxpZ2h0RWRpdG9yIGV4dGVuZHMgQW5ub3RhdGlvbkVkaXRvciB7XG4gICNhbmNob3JOb2RlID0gbnVsbDtcbiAgI2FuY2hvck9mZnNldCA9IDA7XG4gICNib3hlcztcbiAgI2NsaXBQYXRoSWQgPSBudWxsO1xuICAjY29sb3JQaWNrZXIgPSBudWxsO1xuICAjZm9jdXNPdXRsaW5lcyA9IG51bGw7XG4gICNmb2N1c05vZGUgPSBudWxsO1xuICAjZm9jdXNPZmZzZXQgPSAwO1xuICAjaGlnaGxpZ2h0RGl2ID0gbnVsbDtcbiAgI2hpZ2hsaWdodE91dGxpbmVzID0gbnVsbDtcbiAgI2lkID0gbnVsbDtcbiAgI2lzRnJlZUhpZ2hsaWdodCA9IGZhbHNlO1xuICAjbGFzdFBvaW50ID0gbnVsbDtcbiAgI29wYWNpdHk7XG4gICNvdXRsaW5lSWQgPSBudWxsO1xuICAjdGV4dCA9IFwiXCI7XG4gICN0aGlja25lc3M7XG4gICNtZXRob2RPZkNyZWF0aW9uID0gXCJcIjtcbiAgc3RhdGljIF9kZWZhdWx0Q29sb3IgPSBudWxsO1xuICBzdGF0aWMgX2RlZmF1bHRPcGFjaXR5ID0gMTtcbiAgc3RhdGljIF9kZWZhdWx0VGhpY2tuZXNzID0gMTI7XG4gIHN0YXRpYyBfdHlwZSA9IFwiaGlnaGxpZ2h0XCI7XG4gIHN0YXRpYyBfZWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVDtcbiAgc3RhdGljIF9mcmVlSGlnaGxpZ2h0SWQgPSAtMTtcbiAgc3RhdGljIF9mcmVlSGlnaGxpZ2h0ID0gbnVsbDtcbiAgc3RhdGljIF9mcmVlSGlnaGxpZ2h0Q2xpcElkID0gXCJcIjtcbiAgc3RhdGljIGdldCBfa2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHByb3RvID0gSGlnaGxpZ2h0RWRpdG9yLnByb3RvdHlwZTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2tleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93TGVmdFwiXSwgcHJvdG8uX21vdmVDYXJldCwge1xuICAgICAgYXJnczogWzBdXG4gICAgfV0sIFtbXCJBcnJvd1JpZ2h0XCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIHByb3RvLl9tb3ZlQ2FyZXQsIHtcbiAgICAgIGFyZ3M6IFsxXVxuICAgIH1dLCBbW1wiQXJyb3dVcFwiLCBcIm1hYytBcnJvd1VwXCJdLCBwcm90by5fbW92ZUNhcmV0LCB7XG4gICAgICBhcmdzOiBbMl1cbiAgICB9XSwgW1tcIkFycm93RG93blwiLCBcIm1hYytBcnJvd0Rvd25cIl0sIHByb3RvLl9tb3ZlQ2FyZXQsIHtcbiAgICAgIGFyZ3M6IFszXVxuICAgIH1dXSkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG5hbWU6IFwiaGlnaGxpZ2h0RWRpdG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLmNvbG9yID0gcGFyYW1zLmNvbG9yIHx8IEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdENvbG9yO1xuICAgIHRoaXMuI3RoaWNrbmVzcyA9IHBhcmFtcy50aGlja25lc3MgfHwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzO1xuICAgIHRoaXMuI29wYWNpdHkgPSBwYXJhbXMub3BhY2l0eSB8fCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRPcGFjaXR5O1xuICAgIHRoaXMuI2JveGVzID0gcGFyYW1zLmJveGVzIHx8IG51bGw7XG4gICAgdGhpcy4jbWV0aG9kT2ZDcmVhdGlvbiA9IHBhcmFtcy5tZXRob2RPZkNyZWF0aW9uIHx8IFwiXCI7XG4gICAgdGhpcy4jdGV4dCA9IHBhcmFtcy50ZXh0IHx8IFwiXCI7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICBpZiAocGFyYW1zLmhpZ2hsaWdodElkID4gLTEpIHtcbiAgICAgIHRoaXMuI2lzRnJlZUhpZ2hsaWdodCA9IHRydWU7XG4gICAgICB0aGlzLiNjcmVhdGVGcmVlT3V0bGluZXMocGFyYW1zKTtcbiAgICAgIHRoaXMuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNib3hlcykge1xuICAgICAgdGhpcy4jYW5jaG9yTm9kZSA9IHBhcmFtcy5hbmNob3JOb2RlO1xuICAgICAgdGhpcy4jYW5jaG9yT2Zmc2V0ID0gcGFyYW1zLmFuY2hvck9mZnNldDtcbiAgICAgIHRoaXMuI2ZvY3VzTm9kZSA9IHBhcmFtcy5mb2N1c05vZGU7XG4gICAgICB0aGlzLiNmb2N1c09mZnNldCA9IHBhcmFtcy5mb2N1c09mZnNldDtcbiAgICAgIHRoaXMuI2NyZWF0ZU91dGxpbmVzKCk7XG4gICAgICB0aGlzLiNhZGRUb0RyYXdMYXllcigpO1xuICAgICAgdGhpcy5yb3RhdGUodGhpcy5yb3RhdGlvbik7XG4gICAgfVxuICB9XG4gIGdldCB0ZWxlbWV0cnlJbml0aWFsRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWN0aW9uOiBcImFkZGVkXCIsXG4gICAgICB0eXBlOiB0aGlzLiNpc0ZyZWVIaWdobGlnaHQgPyBcImZyZWVfaGlnaGxpZ2h0XCIgOiBcImhpZ2hsaWdodFwiLFxuICAgICAgY29sb3I6IHRoaXMuX3VpTWFuYWdlci5oaWdobGlnaHRDb2xvck5hbWVzLmdldCh0aGlzLmNvbG9yKSxcbiAgICAgIHRoaWNrbmVzczogdGhpcy4jdGhpY2tuZXNzLFxuICAgICAgbWV0aG9kT2ZDcmVhdGlvbjogdGhpcy4jbWV0aG9kT2ZDcmVhdGlvblxuICAgIH07XG4gIH1cbiAgZ2V0IHRlbGVtZXRyeUZpbmFsRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJoaWdobGlnaHRcIixcbiAgICAgIGNvbG9yOiB0aGlzLl91aU1hbmFnZXIuaGlnaGxpZ2h0Q29sb3JOYW1lcy5nZXQodGhpcy5jb2xvcilcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBjb21wdXRlVGVsZW1ldHJ5RmluYWxEYXRhKGRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbnVtYmVyT2ZDb2xvcnM6IGRhdGEuZ2V0KFwiY29sb3JcIikuc2l6ZVxuICAgIH07XG4gIH1cbiAgI2NyZWF0ZU91dGxpbmVzKCkge1xuICAgIGNvbnN0IG91dGxpbmVyID0gbmV3IEhpZ2hsaWdodE91dGxpbmVyKHRoaXMuI2JveGVzLCAwLjAwMSk7XG4gICAgdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMgPSBvdXRsaW5lci5nZXRPdXRsaW5lcygpO1xuICAgIFt0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdID0gdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMuYm94O1xuICAgIGNvbnN0IG91dGxpbmVyRm9yT3V0bGluZSA9IG5ldyBIaWdobGlnaHRPdXRsaW5lcih0aGlzLiNib3hlcywgMC4wMDI1LCAwLjAwMSwgdGhpcy5fdWlNYW5hZ2VyLmRpcmVjdGlvbiA9PT0gXCJsdHJcIik7XG4gICAgdGhpcy4jZm9jdXNPdXRsaW5lcyA9IG91dGxpbmVyRm9yT3V0bGluZS5nZXRPdXRsaW5lcygpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhc3RQb2ludFxuICAgIH0gPSB0aGlzLiNmb2N1c091dGxpbmVzO1xuICAgIHRoaXMuI2xhc3RQb2ludCA9IFsobGFzdFBvaW50WzBdIC0gdGhpcy54KSAvIHRoaXMud2lkdGgsIChsYXN0UG9pbnRbMV0gLSB0aGlzLnkpIC8gdGhpcy5oZWlnaHRdO1xuICB9XG4gICNjcmVhdGVGcmVlT3V0bGluZXMoe1xuICAgIGhpZ2hsaWdodE91dGxpbmVzLFxuICAgIGhpZ2hsaWdodElkLFxuICAgIGNsaXBQYXRoSWRcbiAgfSkge1xuICAgIHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzID0gaGlnaGxpZ2h0T3V0bGluZXM7XG4gICAgY29uc3QgZXh0cmFUaGlja25lc3MgPSAxLjU7XG4gICAgdGhpcy4jZm9jdXNPdXRsaW5lcyA9IGhpZ2hsaWdodE91dGxpbmVzLmdldE5ld091dGxpbmUodGhpcy4jdGhpY2tuZXNzIC8gMiArIGV4dHJhVGhpY2tuZXNzLCAwLjAwMjUpO1xuICAgIGlmIChoaWdobGlnaHRJZCA+PSAwKSB7XG4gICAgICB0aGlzLiNpZCA9IGhpZ2hsaWdodElkO1xuICAgICAgdGhpcy4jY2xpcFBhdGhJZCA9IGNsaXBQYXRoSWQ7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIuZmluYWxpemVEcmF3KGhpZ2hsaWdodElkLCB7XG4gICAgICAgIGJib3g6IGhpZ2hsaWdodE91dGxpbmVzLmJveCxcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IGhpZ2hsaWdodE91dGxpbmVzLnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy4jb3V0bGluZUlkID0gdGhpcy5wYXJlbnQuZHJhd0xheWVyLmRyYXdPdXRsaW5lKHtcbiAgICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgICAgaGlnaGxpZ2h0T3V0bGluZTogdHJ1ZSxcbiAgICAgICAgICBmcmVlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGJib3g6IHRoaXMuI2ZvY3VzT3V0bGluZXMuYm94LFxuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZDogdGhpcy4jZm9jdXNPdXRsaW5lcy50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9LCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICBjb25zdCBhbmdsZSA9IHRoaXMucGFyZW50LnZpZXdwb3J0LnJvdGF0aW9uO1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jaWQsIHtcbiAgICAgICAgYmJveDogSGlnaGxpZ2h0RWRpdG9yLiNyb3RhdGVCYm94KHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLmJveCwgKGFuZ2xlIC0gdGhpcy5yb3RhdGlvbiArIDM2MCkgJSAzNjApLFxuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZDogaGlnaGxpZ2h0T3V0bGluZXMudG9TVkdQYXRoKClcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNvdXRsaW5lSWQsIHtcbiAgICAgICAgYmJveDogSGlnaGxpZ2h0RWRpdG9yLiNyb3RhdGVCYm94KHRoaXMuI2ZvY3VzT3V0bGluZXMuYm94LCBhbmdsZSksXG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBkOiB0aGlzLiNmb2N1c091dGxpbmVzLnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSBoaWdobGlnaHRPdXRsaW5lcy5ib3g7XG4gICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgICAgIHRoaXMueCA9IHk7XG4gICAgICAgICAgdGhpcy55ID0gMSAtIHg7XG4gICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoICogcGFnZUhlaWdodCAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIHBhZ2VXaWR0aCAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICB0aGlzLnggPSAxIC0geDtcbiAgICAgICAgdGhpcy55ID0gMSAtIHk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgICAgICB0aGlzLnggPSAxIC0geTtcbiAgICAgICAgICB0aGlzLnkgPSB4O1xuICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHBhZ2VIZWlnaHQgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiBwYWdlV2lkdGggLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGxhc3RQb2ludFxuICAgIH0gPSB0aGlzLiNmb2N1c091dGxpbmVzO1xuICAgIHRoaXMuI2xhc3RQb2ludCA9IFsobGFzdFBvaW50WzBdIC0geCkgLyB3aWR0aCwgKGxhc3RQb2ludFsxXSAtIHkpIC8gaGVpZ2h0XTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKTtcbiAgICBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRDb2xvciB8fD0gdWlNYW5hZ2VyLmhpZ2hsaWdodENvbG9ycz8udmFsdWVzKCkubmV4dCgpLnZhbHVlIHx8IFwiI2ZmZjA2NlwiO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9ERUZBVUxUX0NPTE9SOlxuICAgICAgICBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRDb2xvciA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX1RISUNLTkVTUzpcbiAgICAgICAgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0cmFuc2xhdGVJblBhZ2UoeCwgeSkge31cbiAgZ2V0IHRvb2xiYXJQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jbGFzdFBvaW50O1xuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfQ09MT1I6XG4gICAgICAgIHRoaXMuI3VwZGF0ZUNvbG9yKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9USElDS05FU1M6XG4gICAgICAgIHRoaXMuI3VwZGF0ZVRoaWNrbmVzcyh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0RFRkFVTFRfQ09MT1IsIEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdENvbG9yXSwgW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9USElDS05FU1MsIEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdFRoaWNrbmVzc11dO1xuICB9XG4gIGdldCBwcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0NPTE9SLCB0aGlzLmNvbG9yIHx8IEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdENvbG9yXSwgW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9USElDS05FU1MsIHRoaXMuI3RoaWNrbmVzcyB8fCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRUaGlja25lc3NdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0ZSRUUsIHRoaXMuI2lzRnJlZUhpZ2hsaWdodF1dO1xuICB9XG4gICN1cGRhdGVDb2xvcihjb2xvcikge1xuICAgIGNvbnN0IHNldENvbG9yQW5kT3BhY2l0eSA9IChjb2wsIG9wYSkgPT4ge1xuICAgICAgdGhpcy5jb2xvciA9IGNvbDtcbiAgICAgIHRoaXMuI29wYWNpdHkgPSBvcGE7XG4gICAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jaWQsIHtcbiAgICAgICAgcm9vdDoge1xuICAgICAgICAgIGZpbGw6IGNvbCxcbiAgICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiBvcGFcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLiNjb2xvclBpY2tlcj8udXBkYXRlQ29sb3IoY29sKTtcbiAgICB9O1xuICAgIGNvbnN0IHNhdmVkQ29sb3IgPSB0aGlzLmNvbG9yO1xuICAgIGNvbnN0IHNhdmVkT3BhY2l0eSA9IHRoaXMuI29wYWNpdHk7XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6IHNldENvbG9yQW5kT3BhY2l0eS5iaW5kKHRoaXMsIGNvbG9yLCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRPcGFjaXR5KSxcbiAgICAgIHVuZG86IHNldENvbG9yQW5kT3BhY2l0eS5iaW5kKHRoaXMsIHNhdmVkQ29sb3IsIHNhdmVkT3BhY2l0eSksXG4gICAgICBwb3N0OiB0aGlzLl91aU1hbmFnZXIudXBkYXRlVUkuYmluZCh0aGlzLl91aU1hbmFnZXIsIHRoaXMpLFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfQ09MT1IsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgYWN0aW9uOiBcImNvbG9yX2NoYW5nZWRcIixcbiAgICAgIGNvbG9yOiB0aGlzLl91aU1hbmFnZXIuaGlnaGxpZ2h0Q29sb3JOYW1lcy5nZXQoY29sb3IpXG4gICAgfSwgdHJ1ZSk7XG4gIH1cbiAgI3VwZGF0ZVRoaWNrbmVzcyh0aGlja25lc3MpIHtcbiAgICBjb25zdCBzYXZlZFRoaWNrbmVzcyA9IHRoaXMuI3RoaWNrbmVzcztcbiAgICBjb25zdCBzZXRUaGlja25lc3MgPSB0aCA9PiB7XG4gICAgICB0aGlzLiN0aGlja25lc3MgPSB0aDtcbiAgICAgIHRoaXMuI2NoYW5nZVRoaWNrbmVzcyh0aCk7XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogc2V0VGhpY2tuZXNzLmJpbmQodGhpcywgdGhpY2tuZXNzKSxcbiAgICAgIHVuZG86IHNldFRoaWNrbmVzcy5iaW5kKHRoaXMsIHNhdmVkVGhpY2tuZXNzKSxcbiAgICAgIHBvc3Q6IHRoaXMuX3VpTWFuYWdlci51cGRhdGVVSS5iaW5kKHRoaXMuX3VpTWFuYWdlciwgdGhpcyksXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19USElDS05FU1MsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgYWN0aW9uOiBcInRoaWNrbmVzc19jaGFuZ2VkXCIsXG4gICAgICB0aGlja25lc3NcbiAgICB9LCB0cnVlKTtcbiAgfVxuICBhc3luYyBhZGRFZGl0VG9vbGJhcigpIHtcbiAgICBjb25zdCB0b29sYmFyID0gYXdhaXQgc3VwZXIuYWRkRWRpdFRvb2xiYXIoKTtcbiAgICBpZiAoIXRvb2xiYXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5fdWlNYW5hZ2VyLmhpZ2hsaWdodENvbG9ycykge1xuICAgICAgdGhpcy4jY29sb3JQaWNrZXIgPSBuZXcgQ29sb3JQaWNrZXIoe1xuICAgICAgICBlZGl0b3I6IHRoaXNcbiAgICAgIH0pO1xuICAgICAgdG9vbGJhci5hZGRDb2xvclBpY2tlcih0aGlzLiNjb2xvclBpY2tlcik7XG4gICAgfVxuICAgIHJldHVybiB0b29sYmFyO1xuICB9XG4gIGRpc2FibGVFZGl0aW5nKCkge1xuICAgIHN1cGVyLmRpc2FibGVFZGl0aW5nKCk7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsIHRydWUpO1xuICB9XG4gIGVuYWJsZUVkaXRpbmcoKSB7XG4gICAgc3VwZXIuZW5hYmxlRWRpdGluZygpO1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJkaXNhYmxlZFwiLCBmYWxzZSk7XG4gIH1cbiAgZml4QW5kU2V0UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHN1cGVyLmZpeEFuZFNldFBvc2l0aW9uKHRoaXMuI2dldFJvdGF0aW9uKCkpO1xuICB9XG4gIGdldEJhc2VUcmFuc2xhdGlvbigpIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG4gIGdldFJlY3QodHgsIHR5KSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldFJlY3QodHgsIHR5LCB0aGlzLiNnZXRSb3RhdGlvbigpKTtcbiAgfVxuICBvbmNlQWRkZWQoZm9jdXMpIHtcbiAgICBpZiAoIXRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkVW5kb2FibGVFZGl0b3IodGhpcyk7XG4gICAgfVxuICAgIGlmIChmb2N1cykge1xuICAgICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuI2NsZWFuRHJhd0xheWVyKCk7XG4gICAgdGhpcy5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgIGFjdGlvbjogXCJkZWxldGVkXCJcbiAgICB9KTtcbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucmVidWlsZCgpO1xuICAgIGlmICh0aGlzLmRpdiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhZGRUb0RyYXdMYXllcigpO1xuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgc2V0UGFyZW50KHBhcmVudCkge1xuICAgIGxldCBtdXN0QmVTZWxlY3RlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnBhcmVudCAmJiAhcGFyZW50KSB7XG4gICAgICB0aGlzLiNjbGVhbkRyYXdMYXllcigpO1xuICAgIH0gZWxzZSBpZiAocGFyZW50KSB7XG4gICAgICB0aGlzLiNhZGRUb0RyYXdMYXllcihwYXJlbnQpO1xuICAgICAgbXVzdEJlU2VsZWN0ZWQgPSAhdGhpcy5wYXJlbnQgJiYgdGhpcy5kaXY/LmNsYXNzTGlzdC5jb250YWlucyhcInNlbGVjdGVkRWRpdG9yXCIpO1xuICAgIH1cbiAgICBzdXBlci5zZXRQYXJlbnQocGFyZW50KTtcbiAgICB0aGlzLnNob3codGhpcy5faXNWaXNpYmxlKTtcbiAgICBpZiAobXVzdEJlU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuc2VsZWN0KCk7XG4gICAgfVxuICB9XG4gICNjaGFuZ2VUaGlja25lc3ModGhpY2tuZXNzKSB7XG4gICAgaWYgKCF0aGlzLiNpc0ZyZWVIaWdobGlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY3JlYXRlRnJlZU91dGxpbmVzKHtcbiAgICAgIGhpZ2hsaWdodE91dGxpbmVzOiB0aGlzLiNoaWdobGlnaHRPdXRsaW5lcy5nZXROZXdPdXRsaW5lKHRoaWNrbmVzcyAvIDIpXG4gICAgfSk7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLnNldERpbXModGhpcy53aWR0aCAqIHBhcmVudFdpZHRoLCB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gIH1cbiAgI2NsZWFuRHJhd0xheWVyKCkge1xuICAgIGlmICh0aGlzLiNpZCA9PT0gbnVsbCB8fCAhdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnJlbW92ZSh0aGlzLiNpZCk7XG4gICAgdGhpcy4jaWQgPSBudWxsO1xuICAgIHRoaXMucGFyZW50LmRyYXdMYXllci5yZW1vdmUodGhpcy4jb3V0bGluZUlkKTtcbiAgICB0aGlzLiNvdXRsaW5lSWQgPSBudWxsO1xuICB9XG4gICNhZGRUb0RyYXdMYXllcihwYXJlbnQgPSB0aGlzLnBhcmVudCkge1xuICAgIGlmICh0aGlzLiNpZCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAoe1xuICAgICAgaWQ6IHRoaXMuI2lkLFxuICAgICAgY2xpcFBhdGhJZDogdGhpcy4jY2xpcFBhdGhJZFxuICAgIH0gPSBwYXJlbnQuZHJhd0xheWVyLmRyYXcoe1xuICAgICAgYmJveDogdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMuYm94LFxuICAgICAgcm9vdDoge1xuICAgICAgICB2aWV3Qm94OiBcIjAgMCAxIDFcIixcbiAgICAgICAgZmlsbDogdGhpcy5jb2xvcixcbiAgICAgICAgXCJmaWxsLW9wYWNpdHlcIjogdGhpcy4jb3BhY2l0eVxuICAgICAgfSxcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBoaWdobGlnaHQ6IHRydWUsXG4gICAgICAgIGZyZWU6IHRoaXMuI2lzRnJlZUhpZ2hsaWdodFxuICAgICAgfSxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMudG9TVkdQYXRoKClcbiAgICAgIH1cbiAgICB9LCBmYWxzZSwgdHJ1ZSkpO1xuICAgIHRoaXMuI291dGxpbmVJZCA9IHBhcmVudC5kcmF3TGF5ZXIuZHJhd091dGxpbmUoe1xuICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgIGhpZ2hsaWdodE91dGxpbmU6IHRydWUsXG4gICAgICAgIGZyZWU6IHRoaXMuI2lzRnJlZUhpZ2hsaWdodFxuICAgICAgfSxcbiAgICAgIGJib3g6IHRoaXMuI2ZvY3VzT3V0bGluZXMuYm94LFxuICAgICAgcGF0aDoge1xuICAgICAgICBkOiB0aGlzLiNmb2N1c091dGxpbmVzLnRvU1ZHUGF0aCgpXG4gICAgICB9XG4gICAgfSwgdGhpcy4jaXNGcmVlSGlnaGxpZ2h0KTtcbiAgICBpZiAodGhpcy4jaGlnaGxpZ2h0RGl2KSB7XG4gICAgICB0aGlzLiNoaWdobGlnaHREaXYuc3R5bGUuY2xpcFBhdGggPSB0aGlzLiNjbGlwUGF0aElkO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgI3JvdGF0ZUJib3goW3gsIHksIHdpZHRoLCBoZWlnaHRdLCBhbmdsZSkge1xuICAgIHN3aXRjaCAoYW5nbGUpIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbMSAtIHkgLSBoZWlnaHQsIHgsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbMSAtIHggLSB3aWR0aCwgMSAtIHkgLSBoZWlnaHQsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeSwgMSAtIHggLSB3aWR0aCwgaGVpZ2h0LCB3aWR0aF07XG4gICAgfVxuICAgIHJldHVybiBbeCwgeSwgd2lkdGgsIGhlaWdodF07XG4gIH1cbiAgcm90YXRlKGFuZ2xlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZHJhd0xheWVyXG4gICAgfSA9IHRoaXMucGFyZW50O1xuICAgIGxldCBib3g7XG4gICAgaWYgKHRoaXMuI2lzRnJlZUhpZ2hsaWdodCkge1xuICAgICAgYW5nbGUgPSAoYW5nbGUgLSB0aGlzLnJvdGF0aW9uICsgMzYwKSAlIDM2MDtcbiAgICAgIGJveCA9IEhpZ2hsaWdodEVkaXRvci4jcm90YXRlQmJveCh0aGlzLiNoaWdobGlnaHRPdXRsaW5lcy5ib3gsIGFuZ2xlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm94ID0gSGlnaGxpZ2h0RWRpdG9yLiNyb3RhdGVCYm94KFt0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdLCBhbmdsZSk7XG4gICAgfVxuICAgIGRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI2lkLCB7XG4gICAgICBiYm94OiBib3gsXG4gICAgICByb290OiB7XG4gICAgICAgIFwiZGF0YS1tYWluLXJvdGF0aW9uXCI6IGFuZ2xlXG4gICAgICB9XG4gICAgfSk7XG4gICAgZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jb3V0bGluZUlkLCB7XG4gICAgICBiYm94OiBIaWdobGlnaHRFZGl0b3IuI3JvdGF0ZUJib3godGhpcy4jZm9jdXNPdXRsaW5lcy5ib3gsIGFuZ2xlKSxcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgXCJkYXRhLW1haW4tcm90YXRpb25cIjogYW5nbGVcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgfVxuICAgIGNvbnN0IGRpdiA9IHN1cGVyLnJlbmRlcigpO1xuICAgIGlmICh0aGlzLiN0ZXh0KSB7XG4gICAgICBkaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0aGlzLiN0ZXh0KTtcbiAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwibWFya1wiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2lzRnJlZUhpZ2hsaWdodCkge1xuICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoXCJmcmVlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNrZXlkb3duLmJpbmQodGhpcyksIHtcbiAgICAgICAgc2lnbmFsOiB0aGlzLl91aU1hbmFnZXIuX3NpZ25hbFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGhpZ2hsaWdodERpdiA9IHRoaXMuI2hpZ2hsaWdodERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LmFwcGVuZChoaWdobGlnaHREaXYpO1xuICAgIGhpZ2hsaWdodERpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgaGlnaGxpZ2h0RGl2LmNsYXNzTmFtZSA9IFwiaW50ZXJuYWxcIjtcbiAgICBoaWdobGlnaHREaXYuc3R5bGUuY2xpcFBhdGggPSB0aGlzLiNjbGlwUGF0aElkO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLnNldERpbXModGhpcy53aWR0aCAqIHBhcmVudFdpZHRoLCB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gICAgYmluZEV2ZW50cyh0aGlzLCB0aGlzLiNoaWdobGlnaHREaXYsIFtcInBvaW50ZXJvdmVyXCIsIFwicG9pbnRlcmxlYXZlXCJdKTtcbiAgICB0aGlzLmVuYWJsZUVkaXRpbmcoKTtcbiAgICByZXR1cm4gZGl2O1xuICB9XG4gIHBvaW50ZXJvdmVyKCkge1xuICAgIGlmICghdGhpcy5pc1NlbGVjdGVkKSB7XG4gICAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jb3V0bGluZUlkLCB7XG4gICAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICAgIGhvdmVyZWQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHBvaW50ZXJsZWF2ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNTZWxlY3RlZCkge1xuICAgICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI291dGxpbmVJZCwge1xuICAgICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgICBob3ZlcmVkOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgI2tleWRvd24oZXZlbnQpIHtcbiAgICBIaWdobGlnaHRFZGl0b3IuX2tleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgfVxuICBfbW92ZUNhcmV0KGRpcmVjdGlvbikge1xuICAgIHRoaXMucGFyZW50LnVuc2VsZWN0KHRoaXMpO1xuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHRoaXMuI3NldENhcmV0KHRydWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgdGhpcy4jc2V0Q2FyZXQoZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgI3NldENhcmV0KHN0YXJ0KSB7XG4gICAgaWYgKCF0aGlzLiNhbmNob3JOb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHNlbGVjdGlvbi5zZXRQb3NpdGlvbih0aGlzLiNhbmNob3JOb2RlLCB0aGlzLiNhbmNob3JPZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3Rpb24uc2V0UG9zaXRpb24odGhpcy4jZm9jdXNOb2RlLCB0aGlzLiNmb2N1c09mZnNldCk7XG4gICAgfVxuICB9XG4gIHNlbGVjdCgpIHtcbiAgICBzdXBlci5zZWxlY3QoKTtcbiAgICBpZiAoIXRoaXMuI291dGxpbmVJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jb3V0bGluZUlkLCB7XG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgaG92ZXJlZDogZmFsc2UsXG4gICAgICAgIHNlbGVjdGVkOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdW5zZWxlY3QoKSB7XG4gICAgc3VwZXIudW5zZWxlY3QoKTtcbiAgICBpZiAoIXRoaXMuI291dGxpbmVJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jb3V0bGluZUlkLCB7XG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCF0aGlzLiNpc0ZyZWVIaWdobGlnaHQpIHtcbiAgICAgIHRoaXMuI3NldENhcmV0KGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgZ2V0IF9tdXN0Rml4UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLiNpc0ZyZWVIaWdobGlnaHQ7XG4gIH1cbiAgc2hvdyh2aXNpYmxlID0gdGhpcy5faXNWaXNpYmxlKSB7XG4gICAgc3VwZXIuc2hvdyh2aXNpYmxlKTtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI2lkLCB7XG4gICAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICAgIGhpZGRlbjogIXZpc2libGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNvdXRsaW5lSWQsIHtcbiAgICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgICAgaGlkZGVuOiAhdmlzaWJsZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgI2dldFJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNpc0ZyZWVIaWdobGlnaHQgPyB0aGlzLnJvdGF0aW9uIDogMDtcbiAgfVxuICAjc2VyaWFsaXplQm94ZXMoKSB7XG4gICAgaWYgKHRoaXMuI2lzRnJlZUhpZ2hsaWdodCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgIGNvbnN0IGJveGVzID0gdGhpcy4jYm94ZXM7XG4gICAgY29uc3QgcXVhZFBvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoYm94ZXMubGVuZ3RoICogOCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gb2YgYm94ZXMpIHtcbiAgICAgIGNvbnN0IHN4ID0geCAqIHBhZ2VXaWR0aCArIHBhZ2VYO1xuICAgICAgY29uc3Qgc3kgPSAoMSAtIHkpICogcGFnZUhlaWdodCArIHBhZ2VZO1xuICAgICAgcXVhZFBvaW50c1tpXSA9IHF1YWRQb2ludHNbaSArIDRdID0gc3g7XG4gICAgICBxdWFkUG9pbnRzW2kgKyAxXSA9IHF1YWRQb2ludHNbaSArIDNdID0gc3k7XG4gICAgICBxdWFkUG9pbnRzW2kgKyAyXSA9IHF1YWRQb2ludHNbaSArIDZdID0gc3ggKyB3aWR0aCAqIHBhZ2VXaWR0aDtcbiAgICAgIHF1YWRQb2ludHNbaSArIDVdID0gcXVhZFBvaW50c1tpICsgN10gPSBzeSAtIGhlaWdodCAqIHBhZ2VIZWlnaHQ7XG4gICAgICBpICs9IDg7XG4gICAgfVxuICAgIHJldHVybiBxdWFkUG9pbnRzO1xuICB9XG4gICNzZXJpYWxpemVPdXRsaW5lcyhyZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLnNlcmlhbGl6ZShyZWN0LCB0aGlzLiNnZXRSb3RhdGlvbigpKTtcbiAgfVxuICBzdGF0aWMgc3RhcnRIaWdobGlnaHRpbmcocGFyZW50LCBpc0xUUiwge1xuICAgIHRhcmdldDogdGV4dExheWVyLFxuICAgIHgsXG4gICAgeVxuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgeDogbGF5ZXJYLFxuICAgICAgeTogbGF5ZXJZLFxuICAgICAgd2lkdGg6IHBhcmVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiBwYXJlbnRIZWlnaHRcbiAgICB9ID0gdGV4dExheWVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHBhcmVudC5jb21iaW5lZFNpZ25hbChhYyk7XG4gICAgY29uc3QgcG9pbnRlclVwQ2FsbGJhY2sgPSBlID0+IHtcbiAgICAgIGFjLmFib3J0KCk7XG4gICAgICB0aGlzLiNlbmRIaWdobGlnaHQocGFyZW50LCBlKTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVyVXBDYWxsYmFjaywge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlclVwQ2FsbGJhY2ssIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgc3RvcEV2ZW50LCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRleHRMYXllci5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgdGhpcy4jaGlnaGxpZ2h0TW92ZS5iaW5kKHRoaXMsIHBhcmVudCksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuX2ZyZWVIaWdobGlnaHQgPSBuZXcgRnJlZUhpZ2hsaWdodE91dGxpbmVyKHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSwgW2xheWVyWCwgbGF5ZXJZLCBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSwgcGFyZW50LnNjYWxlLCB0aGlzLl9kZWZhdWx0VGhpY2tuZXNzIC8gMiwgaXNMVFIsIDAuMDAxKTtcbiAgICAoe1xuICAgICAgaWQ6IHRoaXMuX2ZyZWVIaWdobGlnaHRJZCxcbiAgICAgIGNsaXBQYXRoSWQ6IHRoaXMuX2ZyZWVIaWdobGlnaHRDbGlwSWRcbiAgICB9ID0gcGFyZW50LmRyYXdMYXllci5kcmF3KHtcbiAgICAgIGJib3g6IFswLCAwLCAxLCAxXSxcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgdmlld0JveDogXCIwIDAgMSAxXCIsXG4gICAgICAgIGZpbGw6IHRoaXMuX2RlZmF1bHRDb2xvcixcbiAgICAgICAgXCJmaWxsLW9wYWNpdHlcIjogdGhpcy5fZGVmYXVsdE9wYWNpdHlcbiAgICAgIH0sXG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgaGlnaGxpZ2h0OiB0cnVlLFxuICAgICAgICBmcmVlOiB0cnVlXG4gICAgICB9LFxuICAgICAgcGF0aDoge1xuICAgICAgICBkOiB0aGlzLl9mcmVlSGlnaGxpZ2h0LnRvU1ZHUGF0aCgpXG4gICAgICB9XG4gICAgfSwgdHJ1ZSwgdHJ1ZSkpO1xuICB9XG4gIHN0YXRpYyAjaGlnaGxpZ2h0TW92ZShwYXJlbnQsIGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX2ZyZWVIaWdobGlnaHQuYWRkKGV2ZW50KSkge1xuICAgICAgcGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2ZyZWVIaWdobGlnaHRJZCwge1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZDogdGhpcy5fZnJlZUhpZ2hsaWdodC50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgc3RhdGljICNlbmRIaWdobGlnaHQocGFyZW50LCBldmVudCkge1xuICAgIGlmICghdGhpcy5fZnJlZUhpZ2hsaWdodC5pc0VtcHR5KCkpIHtcbiAgICAgIHBhcmVudC5jcmVhdGVBbmRBZGROZXdFZGl0b3IoZXZlbnQsIGZhbHNlLCB7XG4gICAgICAgIGhpZ2hsaWdodElkOiB0aGlzLl9mcmVlSGlnaGxpZ2h0SWQsXG4gICAgICAgIGhpZ2hsaWdodE91dGxpbmVzOiB0aGlzLl9mcmVlSGlnaGxpZ2h0LmdldE91dGxpbmVzKCksXG4gICAgICAgIGNsaXBQYXRoSWQ6IHRoaXMuX2ZyZWVIaWdobGlnaHRDbGlwSWQsXG4gICAgICAgIG1ldGhvZE9mQ3JlYXRpb246IFwibWFpbl90b29sYmFyXCJcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnQuZHJhd0xheWVyLnJlbW92ZSh0aGlzLl9mcmVlSGlnaGxpZ2h0SWQpO1xuICAgIH1cbiAgICB0aGlzLl9mcmVlSGlnaGxpZ2h0SWQgPSAtMTtcbiAgICB0aGlzLl9mcmVlSGlnaGxpZ2h0ID0gbnVsbDtcbiAgICB0aGlzLl9mcmVlSGlnaGxpZ2h0Q2xpcElkID0gXCJcIjtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBsZXQgaW5pdGlhbERhdGEgPSBudWxsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHF1YWRQb2ludHMsXG4gICAgICAgICAgcmVjdCxcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBjb2xvcixcbiAgICAgICAgICBvcGFjaXR5LFxuICAgICAgICAgIHBvcHVwUmVmXG4gICAgICAgIH0sXG4gICAgICAgIHBhcmVudDoge1xuICAgICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICAgIHBhZ2VOdW1iZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gPSBkYXRhO1xuICAgICAgaW5pdGlhbERhdGEgPSBkYXRhID0ge1xuICAgICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hULFxuICAgICAgICBjb2xvcjogQXJyYXkuZnJvbShjb2xvciksXG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIHF1YWRQb2ludHMsXG4gICAgICAgIGJveGVzOiBudWxsLFxuICAgICAgICBwYWdlSW5kZXg6IHBhZ2VOdW1iZXIgLSAxLFxuICAgICAgICByZWN0OiByZWN0LnNsaWNlKDApLFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgaWQsXG4gICAgICAgIGRlbGV0ZWQ6IGZhbHNlLFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBJbmtBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaW5rTGlzdHMsXG4gICAgICAgICAgcmVjdCxcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBjb2xvcixcbiAgICAgICAgICBib3JkZXJTdHlsZToge1xuICAgICAgICAgICAgcmF3V2lkdGg6IHRoaWNrbmVzc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcG9wdXBSZWZcbiAgICAgICAgfSxcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgcGFnZU51bWJlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBpbml0aWFsRGF0YSA9IGRhdGEgPSB7XG4gICAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQsXG4gICAgICAgIGNvbG9yOiBBcnJheS5mcm9tKGNvbG9yKSxcbiAgICAgICAgdGhpY2tuZXNzLFxuICAgICAgICBpbmtMaXN0cyxcbiAgICAgICAgYm94ZXM6IG51bGwsXG4gICAgICAgIHBhZ2VJbmRleDogcGFnZU51bWJlciAtIDEsXG4gICAgICAgIHJlY3Q6IHJlY3Quc2xpY2UoMCksXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBpZCxcbiAgICAgICAgZGVsZXRlZDogZmFsc2UsXG4gICAgICAgIHBvcHVwUmVmXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjb2xvcixcbiAgICAgIHF1YWRQb2ludHMsXG4gICAgICBpbmtMaXN0cyxcbiAgICAgIG9wYWNpdHlcbiAgICB9ID0gZGF0YTtcbiAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgZWRpdG9yLmNvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoLi4uY29sb3IpO1xuICAgIGVkaXRvci4jb3BhY2l0eSA9IG9wYWNpdHkgfHwgMTtcbiAgICBpZiAoaW5rTGlzdHMpIHtcbiAgICAgIGVkaXRvci4jdGhpY2tuZXNzID0gZGF0YS50aGlja25lc3M7XG4gICAgfVxuICAgIGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkID0gZGF0YS5pZCB8fCBudWxsO1xuICAgIGVkaXRvci5faW5pdGlhbERhdGEgPSBpbml0aWFsRGF0YTtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IGVkaXRvci5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IGVkaXRvci5wYWdlVHJhbnNsYXRpb247XG4gICAgaWYgKHF1YWRQb2ludHMpIHtcbiAgICAgIGNvbnN0IGJveGVzID0gZWRpdG9yLiNib3hlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWFkUG9pbnRzLmxlbmd0aDsgaSArPSA4KSB7XG4gICAgICAgIGJveGVzLnB1c2goe1xuICAgICAgICAgIHg6IChxdWFkUG9pbnRzW2ldIC0gcGFnZVgpIC8gcGFnZVdpZHRoLFxuICAgICAgICAgIHk6IDEgLSAocXVhZFBvaW50c1tpICsgMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiAocXVhZFBvaW50c1tpICsgMl0gLSBxdWFkUG9pbnRzW2ldKSAvIHBhZ2VXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IChxdWFkUG9pbnRzW2kgKyAxXSAtIHF1YWRQb2ludHNbaSArIDVdKSAvIHBhZ2VIZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlZGl0b3IuI2NyZWF0ZU91dGxpbmVzKCk7XG4gICAgICBlZGl0b3IuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgICBlZGl0b3Iucm90YXRlKGVkaXRvci5yb3RhdGlvbik7XG4gICAgfSBlbHNlIGlmIChpbmtMaXN0cykge1xuICAgICAgZWRpdG9yLiNpc0ZyZWVIaWdobGlnaHQgPSB0cnVlO1xuICAgICAgY29uc3QgcG9pbnRzID0gaW5rTGlzdHNbMF07XG4gICAgICBjb25zdCBwb2ludCA9IHtcbiAgICAgICAgeDogcG9pbnRzWzBdIC0gcGFnZVgsXG4gICAgICAgIHk6IHBhZ2VIZWlnaHQgLSAocG9pbnRzWzFdIC0gcGFnZVkpXG4gICAgICB9O1xuICAgICAgY29uc3Qgb3V0bGluZXIgPSBuZXcgRnJlZUhpZ2hsaWdodE91dGxpbmVyKHBvaW50LCBbMCwgMCwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSwgMSwgZWRpdG9yLiN0aGlja25lc3MgLyAyLCB0cnVlLCAwLjAwMSk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgICBwb2ludC54ID0gcG9pbnRzW2ldIC0gcGFnZVg7XG4gICAgICAgIHBvaW50LnkgPSBwYWdlSGVpZ2h0IC0gKHBvaW50c1tpICsgMV0gLSBwYWdlWSk7XG4gICAgICAgIG91dGxpbmVyLmFkZChwb2ludCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlkLFxuICAgICAgICBjbGlwUGF0aElkXG4gICAgICB9ID0gcGFyZW50LmRyYXdMYXllci5kcmF3KHtcbiAgICAgICAgYmJveDogWzAsIDAsIDEsIDFdLFxuICAgICAgICByb290OiB7XG4gICAgICAgICAgdmlld0JveDogXCIwIDAgMSAxXCIsXG4gICAgICAgICAgZmlsbDogZWRpdG9yLmNvbG9yLFxuICAgICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IGVkaXRvci5fZGVmYXVsdE9wYWNpdHlcbiAgICAgICAgfSxcbiAgICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgICAgaGlnaGxpZ2h0OiB0cnVlLFxuICAgICAgICAgIGZyZWU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IG91dGxpbmVyLnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH0sIHRydWUsIHRydWUpO1xuICAgICAgZWRpdG9yLiNjcmVhdGVGcmVlT3V0bGluZXMoe1xuICAgICAgICBoaWdobGlnaHRPdXRsaW5lczogb3V0bGluZXIuZ2V0T3V0bGluZXMoKSxcbiAgICAgICAgaGlnaGxpZ2h0SWQ6IGlkLFxuICAgICAgICBjbGlwUGF0aElkXG4gICAgICB9KTtcbiAgICAgIGVkaXRvci4jYWRkVG9EcmF3TGF5ZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkgfHwgaXNGb3JDb3B5aW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplRGVsZXRlZCgpO1xuICAgIH1cbiAgICBjb25zdCByZWN0ID0gdGhpcy5nZXRSZWN0KDAsIDApO1xuICAgIGNvbnN0IGNvbG9yID0gQW5ub3RhdGlvbkVkaXRvci5fY29sb3JNYW5hZ2VyLmNvbnZlcnQodGhpcy5jb2xvcik7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHtcbiAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQsXG4gICAgICBjb2xvcixcbiAgICAgIG9wYWNpdHk6IHRoaXMuI29wYWNpdHksXG4gICAgICB0aGlja25lc3M6IHRoaXMuI3RoaWNrbmVzcyxcbiAgICAgIHF1YWRQb2ludHM6IHRoaXMuI3NlcmlhbGl6ZUJveGVzKCksXG4gICAgICBvdXRsaW5lczogdGhpcy4jc2VyaWFsaXplT3V0bGluZXMocmVjdCksXG4gICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4LFxuICAgICAgcmVjdCxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLiNnZXRSb3RhdGlvbigpLFxuICAgICAgc3RydWN0VHJlZVBhcmVudElkOiB0aGlzLl9zdHJ1Y3RUcmVlUGFyZW50SWRcbiAgICB9O1xuICAgIGlmICh0aGlzLmFubm90YXRpb25FbGVtZW50SWQgJiYgIXRoaXMuI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc2VyaWFsaXplZC5pZCA9IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgfVxuICAjaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbG9yXG4gICAgfSA9IHRoaXMuX2luaXRpYWxEYXRhO1xuICAgIHJldHVybiBzZXJpYWxpemVkLmNvbG9yLnNvbWUoKGMsIGkpID0+IGMgIT09IGNvbG9yW2ldKTtcbiAgfVxuICByZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgYW5ub3RhdGlvbi51cGRhdGVFZGl0ZWQoe1xuICAgICAgcmVjdDogdGhpcy5nZXRSZWN0KDAsIDApXG4gICAgfSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc3RhdGljIGNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvZHJhdy5qc1xuXG5cblxuY2xhc3MgRHJhd2luZ09wdGlvbnMge1xuICAjc3ZnUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHVwZGF0ZVByb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpc1tuYW1lXSA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlU1ZHUHJvcGVydHkobmFtZSwgdmFsdWUpO1xuICB9XG4gIHVwZGF0ZVByb3BlcnRpZXMocHJvcGVydGllcykge1xuICAgIGlmICghcHJvcGVydGllcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcGVydGllcykpIHtcbiAgICAgIHRoaXMudXBkYXRlUHJvcGVydHkobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVTVkdQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuI3N2Z1Byb3BlcnRpZXNbbmFtZV0gPSB2YWx1ZTtcbiAgfVxuICB0b1NWR1Byb3BlcnRpZXMoKSB7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuI3N2Z1Byb3BlcnRpZXM7XG4gICAgdGhpcy4jc3ZnUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3RcbiAgICB9O1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuI3N2Z1Byb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIHVwZGF0ZUFsbChvcHRpb25zID0gdGhpcykge1xuICAgIHRoaXMudXBkYXRlUHJvcGVydGllcyhvcHRpb25zKTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICB1bnJlYWNoYWJsZShcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxufVxuY2xhc3MgRHJhd2luZ0VkaXRvciBleHRlbmRzIEFubm90YXRpb25FZGl0b3Ige1xuICAjZHJhd091dGxpbmVzID0gbnVsbDtcbiAgI211c3RCZUNvbW1pdHRlZDtcbiAgX2RyYXdJZCA9IG51bGw7XG4gIHN0YXRpYyBfY3VycmVudERyYXdJZCA9IC0xO1xuICBzdGF0aWMgX2N1cnJlbnRQYXJlbnQgPSBudWxsO1xuICBzdGF0aWMgI2N1cnJlbnREcmF3ID0gbnVsbDtcbiAgc3RhdGljICNjdXJyZW50RHJhd2luZ0FDID0gbnVsbDtcbiAgc3RhdGljICNjdXJyZW50RHJhd2luZ09wdGlvbnMgPSBudWxsO1xuICBzdGF0aWMgI2N1cnJlbnRQb2ludGVySWQgPSBOYU47XG4gIHN0YXRpYyAjY3VycmVudFBvaW50ZXJUeXBlID0gbnVsbDtcbiAgc3RhdGljICNjdXJyZW50UG9pbnRlcklkcyA9IG51bGw7XG4gIHN0YXRpYyAjY3VycmVudE1vdmVUaW1lc3RhbXAgPSBOYU47XG4gIHN0YXRpYyBfSU5ORVJfTUFSR0lOID0gMztcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIocGFyYW1zKTtcbiAgICB0aGlzLiNtdXN0QmVDb21taXR0ZWQgPSBwYXJhbXMubXVzdEJlQ29tbWl0dGVkIHx8IGZhbHNlO1xuICAgIGlmIChwYXJhbXMuZHJhd091dGxpbmVzKSB7XG4gICAgICB0aGlzLiNjcmVhdGVEcmF3T3V0bGluZXMocGFyYW1zKTtcbiAgICAgIHRoaXMuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgfVxuICB9XG4gICNjcmVhdGVEcmF3T3V0bGluZXMoe1xuICAgIGRyYXdPdXRsaW5lcyxcbiAgICBkcmF3SWQsXG4gICAgZHJhd2luZ09wdGlvbnNcbiAgfSkge1xuICAgIHRoaXMuI2RyYXdPdXRsaW5lcyA9IGRyYXdPdXRsaW5lcztcbiAgICB0aGlzLl9kcmF3aW5nT3B0aW9ucyB8fD0gZHJhd2luZ09wdGlvbnM7XG4gICAgaWYgKGRyYXdJZCA+PSAwKSB7XG4gICAgICB0aGlzLl9kcmF3SWQgPSBkcmF3SWQ7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIuZmluYWxpemVEcmF3KGRyYXdJZCwgZHJhd091dGxpbmVzLmRlZmF1bHRQcm9wZXJ0aWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZHJhd0lkID0gdGhpcy4jY3JlYXRlRHJhd2luZyhkcmF3T3V0bGluZXMsIHRoaXMucGFyZW50KTtcbiAgICB9XG4gICAgdGhpcy4jdXBkYXRlQmJveChkcmF3T3V0bGluZXMuYm94KTtcbiAgfVxuICAjY3JlYXRlRHJhd2luZyhkcmF3T3V0bGluZXMsIHBhcmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkXG4gICAgfSA9IHBhcmVudC5kcmF3TGF5ZXIuZHJhdyhEcmF3aW5nRWRpdG9yLl9tZXJnZVNWR1Byb3BlcnRpZXModGhpcy5fZHJhd2luZ09wdGlvbnMudG9TVkdQcm9wZXJ0aWVzKCksIGRyYXdPdXRsaW5lcy5kZWZhdWx0U1ZHUHJvcGVydGllcyksIGZhbHNlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIHN0YXRpYyBfbWVyZ2VTVkdQcm9wZXJ0aWVzKHAxLCBwMikge1xuICAgIGNvbnN0IHAxS2V5cyA9IG5ldyBTZXQoT2JqZWN0LmtleXMocDEpKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwMikpIHtcbiAgICAgIGlmIChwMUtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihwMVtrZXldLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwMVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwMTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVmYXVsdERyYXdpbmdPcHRpb25zKF9vcHRpb25zKSB7XG4gICAgdW5yZWFjaGFibGUoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlc01hcCgpIHtcbiAgICB1bnJlYWNoYWJsZShcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzRHJhd2VyKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN0YXRpYyBnZXQgc3VwcG9ydE11bHRpcGxlRHJhd2luZ3MoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgY29uc3QgcHJvcGVydHlOYW1lID0gdGhpcy50eXBlc01hcC5nZXQodHlwZSk7XG4gICAgaWYgKHByb3BlcnR5TmFtZSkge1xuICAgICAgdGhpcy5fZGVmYXVsdERyYXdpbmdPcHRpb25zLnVwZGF0ZVByb3BlcnR5KHByb3BlcnR5TmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY3VycmVudFBhcmVudCkge1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcudXBkYXRlUHJvcGVydHkocHJvcGVydHlOYW1lLCB2YWx1ZSk7XG4gICAgICB0aGlzLl9jdXJyZW50UGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2N1cnJlbnREcmF3SWQsIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucy50b1NWR1Byb3BlcnRpZXMoKSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IHRoaXMuY29uc3RydWN0b3IudHlwZXNNYXAuZ2V0KHR5cGUpO1xuICAgIGlmIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVByb3BlcnR5KHR5cGUsIHByb3BlcnR5TmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IFtdO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnM7XG4gICAgZm9yIChjb25zdCBbdHlwZSwgbmFtZV0gb2YgdGhpcy50eXBlc01hcCkge1xuICAgICAgcHJvcGVydGllcy5wdXNoKFt0eXBlLCBvcHRpb25zW25hbWVdXSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICB9XG4gIGdldCBwcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IFtdO1xuICAgIGNvbnN0IHtcbiAgICAgIF9kcmF3aW5nT3B0aW9uc1xuICAgIH0gPSB0aGlzO1xuICAgIGZvciAoY29uc3QgW3R5cGUsIG5hbWVdIG9mIHRoaXMuY29uc3RydWN0b3IudHlwZXNNYXApIHtcbiAgICAgIHByb3BlcnRpZXMucHVzaChbdHlwZSwgX2RyYXdpbmdPcHRpb25zW25hbWVdXSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICB9XG4gIF91cGRhdGVQcm9wZXJ0eSh0eXBlLCBuYW1lLCB2YWx1ZSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9kcmF3aW5nT3B0aW9ucztcbiAgICBjb25zdCBzYXZlZFZhbHVlID0gb3B0aW9uc1tuYW1lXTtcbiAgICBjb25zdCBzZXR0ZXIgPSB2YWwgPT4ge1xuICAgICAgb3B0aW9ucy51cGRhdGVQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICAgICAgY29uc3QgYmJveCA9IHRoaXMuI2RyYXdPdXRsaW5lcy51cGRhdGVQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICAgICAgaWYgKGJib3gpIHtcbiAgICAgICAgdGhpcy4jdXBkYXRlQmJveChiYm94KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIG9wdGlvbnMudG9TVkdQcm9wZXJ0aWVzKCkpO1xuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6IHNldHRlci5iaW5kKHRoaXMsIHZhbHVlKSxcbiAgICAgIHVuZG86IHNldHRlci5iaW5kKHRoaXMsIHNhdmVkVmFsdWUpLFxuICAgICAgcG9zdDogdGhpcy5fdWlNYW5hZ2VyLnVwZGF0ZVVJLmJpbmQodGhpcy5fdWlNYW5hZ2VyLCB0aGlzKSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZSxcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIF9vblJlc2l6aW5nKCkge1xuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIERyYXdpbmdFZGl0b3IuX21lcmdlU1ZHUHJvcGVydGllcyh0aGlzLiNkcmF3T3V0bGluZXMuZ2V0UGF0aFJlc2l6aW5nU1ZHUHJvcGVydGllcyh0aGlzLiNjb252ZXJ0VG9EcmF3U3BhY2UoKSksIHtcbiAgICAgIGJib3g6IHRoaXMuI3JvdGF0ZUJveCgpXG4gICAgfSkpO1xuICB9XG4gIF9vblJlc2l6ZWQoKSB7XG4gICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2RyYXdJZCwgRHJhd2luZ0VkaXRvci5fbWVyZ2VTVkdQcm9wZXJ0aWVzKHRoaXMuI2RyYXdPdXRsaW5lcy5nZXRQYXRoUmVzaXplZFNWR1Byb3BlcnRpZXModGhpcy4jY29udmVydFRvRHJhd1NwYWNlKCkpLCB7XG4gICAgICBiYm94OiB0aGlzLiNyb3RhdGVCb3goKVxuICAgIH0pKTtcbiAgfVxuICBfb25UcmFuc2xhdGluZyh4LCB5KSB7XG4gICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2RyYXdJZCwge1xuICAgICAgYmJveDogdGhpcy4jcm90YXRlQm94KHgsIHkpXG4gICAgfSk7XG4gIH1cbiAgX29uVHJhbnNsYXRlZCgpIHtcbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZHJhd0lkLCBEcmF3aW5nRWRpdG9yLl9tZXJnZVNWR1Byb3BlcnRpZXModGhpcy4jZHJhd091dGxpbmVzLmdldFBhdGhUcmFuc2xhdGVkU1ZHUHJvcGVydGllcyh0aGlzLiNjb252ZXJ0VG9EcmF3U3BhY2UoKSwgdGhpcy5wYXJlbnREaW1lbnNpb25zKSwge1xuICAgICAgYmJveDogdGhpcy4jcm90YXRlQm94KClcbiAgICB9KSk7XG4gIH1cbiAgX29uU3RhcnREcmFnZ2luZygpIHtcbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZHJhd0lkLCB7XG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgbW92aW5nOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX29uU3RvcERyYWdnaW5nKCkge1xuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIHtcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBtb3Zpbmc6IGZhbHNlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY29tbWl0KCkge1xuICAgIHN1cGVyLmNvbW1pdCgpO1xuICAgIHRoaXMuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5kaXNhYmxlRWRpdGluZygpO1xuICB9XG4gIGRpc2FibGVFZGl0aW5nKCkge1xuICAgIHN1cGVyLmRpc2FibGVFZGl0aW5nKCk7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsIHRydWUpO1xuICB9XG4gIGVuYWJsZUVkaXRpbmcoKSB7XG4gICAgc3VwZXIuZW5hYmxlRWRpdGluZygpO1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJkaXNhYmxlZFwiLCBmYWxzZSk7XG4gIH1cbiAgZ2V0QmFzZVRyYW5zbGF0aW9uKCkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbiAgZ2V0IGlzUmVzaXphYmxlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIG9uY2VBZGRlZChmb2N1cykge1xuICAgIGlmICghdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGRVbmRvYWJsZUVkaXRvcih0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgIGlmICh0aGlzLiNtdXN0QmVDb21taXR0ZWQpIHtcbiAgICAgIHRoaXMuI211c3RCZUNvbW1pdHRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5jb21taXQoKTtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgICAgaWYgKGZvY3VzICYmIHRoaXMuaXNPblNjcmVlbikge1xuICAgICAgICB0aGlzLmRpdi5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy4jY2xlYW5EcmF3TGF5ZXIoKTtcbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucmVidWlsZCgpO1xuICAgIGlmICh0aGlzLmRpdiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhZGRUb0RyYXdMYXllcigpO1xuICAgIHRoaXMuI3VwZGF0ZUJib3godGhpcy4jZHJhd091dGxpbmVzLmJveCk7XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkKHRoaXMpO1xuICAgIH1cbiAgfVxuICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgbGV0IG11c3RCZVNlbGVjdGVkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMucGFyZW50ICYmICFwYXJlbnQpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5yZW1vdmVTaG91bGRSZXNjYWxlKHRoaXMpO1xuICAgICAgdGhpcy4jY2xlYW5EcmF3TGF5ZXIoKTtcbiAgICB9IGVsc2UgaWYgKHBhcmVudCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmFkZFNob3VsZFJlc2NhbGUodGhpcyk7XG4gICAgICB0aGlzLiNhZGRUb0RyYXdMYXllcihwYXJlbnQpO1xuICAgICAgbXVzdEJlU2VsZWN0ZWQgPSAhdGhpcy5wYXJlbnQgJiYgdGhpcy5kaXY/LmNsYXNzTGlzdC5jb250YWlucyhcInNlbGVjdGVkRWRpdG9yXCIpO1xuICAgIH1cbiAgICBzdXBlci5zZXRQYXJlbnQocGFyZW50KTtcbiAgICBpZiAobXVzdEJlU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuc2VsZWN0KCk7XG4gICAgfVxuICB9XG4gICNjbGVhbkRyYXdMYXllcigpIHtcbiAgICBpZiAodGhpcy5fZHJhd0lkID09PSBudWxsIHx8ICF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIucmVtb3ZlKHRoaXMuX2RyYXdJZCk7XG4gICAgdGhpcy5fZHJhd0lkID0gbnVsbDtcbiAgICB0aGlzLl9kcmF3aW5nT3B0aW9ucy5yZXNldCgpO1xuICB9XG4gICNhZGRUb0RyYXdMYXllcihwYXJlbnQgPSB0aGlzLnBhcmVudCkge1xuICAgIGlmICh0aGlzLl9kcmF3SWQgIT09IG51bGwgJiYgdGhpcy5wYXJlbnQgPT09IHBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZHJhd0lkICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUGFyZW50KHRoaXMuX2RyYXdJZCwgcGFyZW50LmRyYXdMYXllcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RyYXdpbmdPcHRpb25zLnVwZGF0ZUFsbCgpO1xuICAgIHRoaXMuX2RyYXdJZCA9IHRoaXMuI2NyZWF0ZURyYXdpbmcodGhpcy4jZHJhd091dGxpbmVzLCBwYXJlbnQpO1xuICB9XG4gICNjb252ZXJ0VG9QYXJlbnRTcGFjZShbeCwgeSwgd2lkdGgsIGhlaWdodF0pIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXJlbnREaW1lbnNpb25zOiBbcFcsIHBIXSxcbiAgICAgIHJvdGF0aW9uXG4gICAgfSA9IHRoaXM7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFt5LCAxIC0geCwgd2lkdGggKiAocEggLyBwVyksIGhlaWdodCAqIChwVyAvIHBIKV07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geCwgMSAtIHksIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbMSAtIHksIHgsIHdpZHRoICogKHBIIC8gcFcpLCBoZWlnaHQgKiAocFcgLyBwSCldO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt4LCB5LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICB9XG4gIH1cbiAgI2NvbnZlcnRUb0RyYXdTcGFjZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcGFyZW50RGltZW5zaW9uczogW3BXLCBwSF0sXG4gICAgICByb3RhdGlvblxuICAgIH0gPSB0aGlzO1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbMSAtIHksIHgsIHdpZHRoICogKHBXIC8gcEgpLCBoZWlnaHQgKiAocEggLyBwVyldO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbMSAtIHgsIDEgLSB5LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3ksIDEgLSB4LCB3aWR0aCAqIChwVyAvIHBIKSwgaGVpZ2h0ICogKHBIIC8gcFcpXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbeCwgeSwgd2lkdGgsIGhlaWdodF07XG4gICAgfVxuICB9XG4gICN1cGRhdGVCYm94KGJib3gpIHtcbiAgICBbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XSA9IHRoaXMuI2NvbnZlcnRUb1BhcmVudFNwYWNlKGJib3gpO1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgdGhpcy5zZXREaW1zKHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgIH1cbiAgICB0aGlzLl9vblJlc2l6ZWQoKTtcbiAgfVxuICAjcm90YXRlQm94KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICByb3RhdGlvbixcbiAgICAgIHBhcmVudFJvdGF0aW9uLFxuICAgICAgcGFyZW50RGltZW5zaW9uczogW3BXLCBwSF1cbiAgICB9ID0gdGhpcztcbiAgICBzd2l0Y2ggKChyb3RhdGlvbiAqIDQgKyBwYXJlbnRSb3RhdGlvbikgLyA5MCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gWzEgLSB5IC0gaGVpZ2h0LCB4LCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIFsxIC0geCAtIHdpZHRoLCAxIC0geSAtIGhlaWdodCwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBbeSwgMSAtIHggLSB3aWR0aCwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiBbeCwgeSAtIHdpZHRoICogKHBXIC8gcEgpLCBoZWlnaHQgKiAocEggLyBwVyksIHdpZHRoICogKHBXIC8gcEgpXTtcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmV0dXJuIFsxIC0geSwgeCwgd2lkdGggKiAocFcgLyBwSCksIGhlaWdodCAqIChwSCAvIHBXKV07XG4gICAgICBjYXNlIDY6XG4gICAgICAgIHJldHVybiBbMSAtIHggLSBoZWlnaHQgKiAocEggLyBwVyksIDEgLSB5LCBoZWlnaHQgKiAocEggLyBwVyksIHdpZHRoICogKHBXIC8gcEgpXTtcbiAgICAgIGNhc2UgNzpcbiAgICAgICAgcmV0dXJuIFt5IC0gd2lkdGggKiAocFcgLyBwSCksIDEgLSB4IC0gaGVpZ2h0ICogKHBIIC8gcFcpLCB3aWR0aCAqIChwVyAvIHBIKSwgaGVpZ2h0ICogKHBIIC8gcFcpXTtcbiAgICAgIGNhc2UgODpcbiAgICAgICAgcmV0dXJuIFt4IC0gd2lkdGgsIHkgLSBoZWlnaHQsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSA5OlxuICAgICAgICByZXR1cm4gWzEgLSB5LCB4IC0gd2lkdGgsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgY2FzZSAxMDpcbiAgICAgICAgcmV0dXJuIFsxIC0geCwgMSAtIHksIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAxMTpcbiAgICAgICAgcmV0dXJuIFt5IC0gaGVpZ2h0LCAxIC0geCwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBjYXNlIDEyOlxuICAgICAgICByZXR1cm4gW3ggLSBoZWlnaHQgKiAocEggLyBwVyksIHksIGhlaWdodCAqIChwSCAvIHBXKSwgd2lkdGggKiAocFcgLyBwSCldO1xuICAgICAgY2FzZSAxMzpcbiAgICAgICAgcmV0dXJuIFsxIC0geSAtIHdpZHRoICogKHBXIC8gcEgpLCB4IC0gaGVpZ2h0ICogKHBIIC8gcFcpLCB3aWR0aCAqIChwVyAvIHBIKSwgaGVpZ2h0ICogKHBIIC8gcFcpXTtcbiAgICAgIGNhc2UgMTQ6XG4gICAgICAgIHJldHVybiBbMSAtIHgsIDEgLSB5IC0gd2lkdGggKiAocFcgLyBwSCksIGhlaWdodCAqIChwSCAvIHBXKSwgd2lkdGggKiAocFcgLyBwSCldO1xuICAgICAgY2FzZSAxNTpcbiAgICAgICAgcmV0dXJuIFt5LCAxIC0geCwgd2lkdGggKiAocFcgLyBwSCksIGhlaWdodCAqIChwSCAvIHBXKV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW3gsIHksIHdpZHRoLCBoZWlnaHRdO1xuICAgIH1cbiAgfVxuICByb3RhdGUoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIERyYXdpbmdFZGl0b3IuX21lcmdlU1ZHUHJvcGVydGllcyh7XG4gICAgICBiYm94OiB0aGlzLiNyb3RhdGVCb3goKVxuICAgIH0sIHRoaXMuI2RyYXdPdXRsaW5lcy51cGRhdGVSb3RhdGlvbigodGhpcy5wYXJlbnRSb3RhdGlvbiAtIHRoaXMucm90YXRpb24gKyAzNjApICUgMzYwKSkpO1xuICB9XG4gIG9uU2NhbGVDaGFuZ2luZygpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3VwZGF0ZUJib3godGhpcy4jZHJhd091dGxpbmVzLnVwZGF0ZVBhcmVudERpbWVuc2lvbnModGhpcy5wYXJlbnREaW1lbnNpb25zLCB0aGlzLnBhcmVudC5zY2FsZSkpO1xuICB9XG4gIHN0YXRpYyBvblNjYWxlQ2hhbmdpbmdXaGVuRHJhd2luZygpIHt9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdjtcbiAgICB9XG4gICAgY29uc3QgZGl2ID0gc3VwZXIucmVuZGVyKCk7XG4gICAgZGl2LmNsYXNzTGlzdC5hZGQoXCJkcmF3XCIpO1xuICAgIGNvbnN0IGRyYXdEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5hcHBlbmQoZHJhd0Rpdik7XG4gICAgZHJhd0Rpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgZHJhd0Rpdi5jbGFzc05hbWUgPSBcImludGVybmFsXCI7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMuc2V0RGltcyh0aGlzLndpZHRoICogcGFyZW50V2lkdGgsIHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgICB0aGlzLl91aU1hbmFnZXIuYWRkU2hvdWxkUmVzY2FsZSh0aGlzKTtcbiAgICB0aGlzLmRpc2FibGVFZGl0aW5nKCk7XG4gICAgcmV0dXJuIGRpdjtcbiAgfVxuICBzdGF0aWMgY3JlYXRlRHJhd2VySW5zdGFuY2UoX3gsIF95LCBfcGFyZW50V2lkdGgsIF9wYXJlbnRIZWlnaHQsIF9yb3RhdGlvbikge1xuICAgIHVucmVhY2hhYmxlKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHN0YXRpYyBzdGFydERyYXdpbmcocGFyZW50LCB1aU1hbmFnZXIsIF9pc0xUUiwgZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICB0YXJnZXQsXG4gICAgICBvZmZzZXRYOiB4LFxuICAgICAgb2Zmc2V0WTogeSxcbiAgICAgIHBvaW50ZXJJZCxcbiAgICAgIHBvaW50ZXJUeXBlXG4gICAgfSA9IGV2ZW50O1xuICAgIGlmIChEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlclR5cGUgJiYgRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJUeXBlICE9PSBwb2ludGVyVHlwZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICByb3RhdGlvblxuICAgICAgfVxuICAgIH0gPSBwYXJlbnQ7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGg6IHBhcmVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiBwYXJlbnRIZWlnaHRcbiAgICB9ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGFjID0gRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXdpbmdBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSBwYXJlbnQuY29tYmluZWRTaWduYWwoYWMpO1xuICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVySWQgfHw9IHBvaW50ZXJJZDtcbiAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlclR5cGUgPz89IHBvaW50ZXJUeXBlO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIGUgPT4ge1xuICAgICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVySWQgPT09IGUucG9pbnRlcklkKSB7XG4gICAgICAgIHRoaXMuX2VuZERyYXcoZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlcklkcz8uZGVsZXRlKGUucG9pbnRlcklkKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJjYW5jZWxcIiwgZSA9PiB7XG4gICAgICBpZiAoRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudFBhcmVudC5lbmREcmF3aW5nU2Vzc2lvbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZHM/LmRlbGV0ZShlLnBvaW50ZXJJZCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBlID0+IHtcbiAgICAgIGlmIChEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlclR5cGUgIT09IGUucG9pbnRlclR5cGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVySWRzIHx8PSBuZXcgU2V0KCkpLmFkZChlLnBvaW50ZXJJZCk7XG4gICAgICBpZiAoRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcuaXNDYW5jZWxsYWJsZSgpKSB7XG4gICAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LnJlbW92ZUxhc3RFbGVtZW50KCk7XG4gICAgICAgIGlmIChEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50UGFyZW50LmVuZERyYXdpbmdTZXNzaW9uKHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2VuZERyYXcobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgdGhpcy5fZHJhd01vdmUuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgZSA9PiB7XG4gICAgICBpZiAoZS50aW1lU3RhbXAgPT09IERyYXdpbmdFZGl0b3IuI2N1cnJlbnRNb3ZlVGltZXN0YW1wKSB7XG4gICAgICAgIHN0b3BFdmVudChlKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBwYXJlbnQudG9nZ2xlRHJhd2luZygpO1xuICAgIHVpTWFuYWdlci5fZWRpdG9yVW5kb0Jhcj8uaGlkZSgpO1xuICAgIGlmIChEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdykge1xuICAgICAgcGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2N1cnJlbnREcmF3SWQsIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LnN0YXJ0TmV3KHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHVpTWFuYWdlci51cGRhdGVVSUZvckRlZmF1bHRQcm9wZXJ0aWVzKHRoaXMpO1xuICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3ID0gdGhpcy5jcmVhdGVEcmF3ZXJJbnN0YW5jZSh4LCB5LCBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCByb3RhdGlvbik7XG4gICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXdpbmdPcHRpb25zID0gdGhpcy5nZXREZWZhdWx0RHJhd2luZ09wdGlvbnMoKTtcbiAgICB0aGlzLl9jdXJyZW50UGFyZW50ID0gcGFyZW50O1xuICAgICh7XG4gICAgICBpZDogdGhpcy5fY3VycmVudERyYXdJZFxuICAgIH0gPSBwYXJlbnQuZHJhd0xheWVyLmRyYXcodGhpcy5fbWVyZ2VTVkdQcm9wZXJ0aWVzKERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3aW5nT3B0aW9ucy50b1NWR1Byb3BlcnRpZXMoKSwgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcuZGVmYXVsdFNWR1Byb3BlcnRpZXMpLCB0cnVlLCBmYWxzZSkpO1xuICB9XG4gIHN0YXRpYyBfZHJhd01vdmUoZXZlbnQpIHtcbiAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50TW92ZVRpbWVzdGFtcCA9IC0xO1xuICAgIGlmICghRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFksXG4gICAgICBwb2ludGVySWRcbiAgICB9ID0gZXZlbnQ7XG4gICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVySWQgIT09IHBvaW50ZXJJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZHM/LnNpemUgPj0gMSkge1xuICAgICAgdGhpcy5fZW5kRHJhdyhldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2N1cnJlbnRQYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fY3VycmVudERyYXdJZCwgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcuYWRkKG9mZnNldFgsIG9mZnNldFkpKTtcbiAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50TW92ZVRpbWVzdGFtcCA9IGV2ZW50LnRpbWVTdGFtcDtcbiAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICB9XG4gIHN0YXRpYyBfY2xlYW51cChhbGwpIHtcbiAgICBpZiAoYWxsKSB7XG4gICAgICB0aGlzLl9jdXJyZW50RHJhd0lkID0gLTE7XG4gICAgICB0aGlzLl9jdXJyZW50UGFyZW50ID0gbnVsbDtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3ID0gbnVsbDtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3aW5nT3B0aW9ucyA9IG51bGw7XG4gICAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlclR5cGUgPSBudWxsO1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudE1vdmVUaW1lc3RhbXAgPSBOYU47XG4gICAgfVxuICAgIGlmIChEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhd2luZ0FDKSB7XG4gICAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhd2luZ0FDLmFib3J0KCk7XG4gICAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhd2luZ0FDID0gbnVsbDtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVySWQgPSBOYU47XG4gICAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlcklkcyA9IG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBfZW5kRHJhdyhldmVudCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX2N1cnJlbnRQYXJlbnQ7XG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGFyZW50LnRvZ2dsZURyYXdpbmcodHJ1ZSk7XG4gICAgdGhpcy5fY2xlYW51cChmYWxzZSk7XG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fY3VycmVudERyYXdJZCwgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcuZW5kKGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3VwcG9ydE11bHRpcGxlRHJhd2luZ3MpIHtcbiAgICAgIGNvbnN0IGRyYXcgPSBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdztcbiAgICAgIGNvbnN0IGRyYXdJZCA9IHRoaXMuX2N1cnJlbnREcmF3SWQ7XG4gICAgICBjb25zdCBsYXN0RWxlbWVudCA9IGRyYXcuZ2V0TGFzdEVsZW1lbnQoKTtcbiAgICAgIHBhcmVudC5hZGRDb21tYW5kcyh7XG4gICAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICAgIHBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyhkcmF3SWQsIGRyYXcuc2V0TGFzdEVsZW1lbnQobGFzdEVsZW1lbnQpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICAgIHBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyhkcmF3SWQsIGRyYXcucmVtb3ZlTGFzdEVsZW1lbnQoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG11c3RFeGVjOiBmYWxzZSxcbiAgICAgICAgdHlwZTogQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRFJBV19TVEVQXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbmREcmF3aW5nKGZhbHNlKTtcbiAgfVxuICBzdGF0aWMgZW5kRHJhd2luZyhpc0Fib3J0ZWQpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9jdXJyZW50UGFyZW50O1xuICAgIGlmICghcGFyZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcGFyZW50LnRvZ2dsZURyYXdpbmcodHJ1ZSk7XG4gICAgcGFyZW50LmNsZWFuVW5kb1N0YWNrKEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkRSQVdfU1RFUCk7XG4gICAgaWYgKCFEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdy5pc0VtcHR5KCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFnZURpbWVuc2lvbnM6IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdLFxuICAgICAgICBzY2FsZVxuICAgICAgfSA9IHBhcmVudDtcbiAgICAgIGNvbnN0IGVkaXRvciA9IHBhcmVudC5jcmVhdGVBbmRBZGROZXdFZGl0b3Ioe1xuICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICBvZmZzZXRZOiAwXG4gICAgICB9LCBmYWxzZSwge1xuICAgICAgICBkcmF3SWQ6IHRoaXMuX2N1cnJlbnREcmF3SWQsXG4gICAgICAgIGRyYXdPdXRsaW5lczogRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcuZ2V0T3V0bGluZXMocGFnZVdpZHRoICogc2NhbGUsIHBhZ2VIZWlnaHQgKiBzY2FsZSwgc2NhbGUsIHRoaXMuX0lOTkVSX01BUkdJTiksXG4gICAgICAgIGRyYXdpbmdPcHRpb25zOiBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhd2luZ09wdGlvbnMsXG4gICAgICAgIG11c3RCZUNvbW1pdHRlZDogIWlzQWJvcnRlZFxuICAgICAgfSk7XG4gICAgICB0aGlzLl9jbGVhbnVwKHRydWUpO1xuICAgICAgcmV0dXJuIGVkaXRvcjtcbiAgICB9XG4gICAgcGFyZW50LmRyYXdMYXllci5yZW1vdmUodGhpcy5fY3VycmVudERyYXdJZCk7XG4gICAgdGhpcy5fY2xlYW51cCh0cnVlKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjcmVhdGVEcmF3aW5nT3B0aW9ucyhfZGF0YSkge31cbiAgc3RhdGljIGRlc2VyaWFsaXplRHJhdyhfcGFnZVgsIF9wYWdlWSwgX3BhZ2VXaWR0aCwgX3BhZ2VIZWlnaHQsIF9pbm5lcldpZHRoLCBfZGF0YSkge1xuICAgIHVucmVhY2hhYmxlKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICBwYWdlSGVpZ2h0LFxuICAgICAgICBwYWdlWCxcbiAgICAgICAgcGFnZVlcbiAgICAgIH1cbiAgICB9ID0gcGFyZW50LnZpZXdwb3J0O1xuICAgIGNvbnN0IGRyYXdPdXRsaW5lcyA9IHRoaXMuZGVzZXJpYWxpemVEcmF3KHBhZ2VYLCBwYWdlWSwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCB0aGlzLl9JTk5FUl9NQVJHSU4sIGRhdGEpO1xuICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKTtcbiAgICBlZGl0b3IuY3JlYXRlRHJhd2luZ09wdGlvbnMoZGF0YSk7XG4gICAgZWRpdG9yLiNjcmVhdGVEcmF3T3V0bGluZXMoe1xuICAgICAgZHJhd091dGxpbmVzXG4gICAgfSk7XG4gICAgZWRpdG9yLiNhZGRUb0RyYXdMYXllcigpO1xuICAgIGVkaXRvci5vblNjYWxlQ2hhbmdpbmcoKTtcbiAgICBlZGl0b3Iucm90YXRlKCk7XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBzZXJpYWxpemVEcmF3KGlzRm9yQ29weWluZykge1xuICAgIGNvbnN0IFtwYWdlWCwgcGFnZVldID0gdGhpcy5wYWdlVHJhbnNsYXRpb247XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIHJldHVybiB0aGlzLiNkcmF3T3V0bGluZXMuc2VyaWFsaXplKFtwYWdlWCwgcGFnZVksIHBhZ2VXaWR0aCwgcGFnZUhlaWdodF0sIGlzRm9yQ29weWluZyk7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGFubm90YXRpb24udXBkYXRlRWRpdGVkKHtcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UmVjdCgwLCAwKVxuICAgIH0pO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN0YXRpYyBjYW5DcmVhdGVOZXdFbXB0eUVkaXRvcigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2RyYXdlcnMvaW5rZHJhdy5qc1xuXG5cbmNsYXNzIElua0RyYXdPdXRsaW5lciB7XG4gICNsYXN0ID0gbmV3IEZsb2F0NjRBcnJheSg2KTtcbiAgI2xpbmU7XG4gICNsaW5lcztcbiAgI3JvdGF0aW9uO1xuICAjdGhpY2tuZXNzO1xuICAjcG9pbnRzO1xuICAjbGFzdFNWR1BhdGggPSBcIlwiO1xuICAjbGFzdEluZGV4ID0gMDtcbiAgI291dGxpbmVzID0gbmV3IElua0RyYXdPdXRsaW5lKCk7XG4gICNwYXJlbnRXaWR0aDtcbiAgI3BhcmVudEhlaWdodDtcbiAgY29uc3RydWN0b3IoeCwgeSwgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgcm90YXRpb24sIHRoaWNrbmVzcykge1xuICAgIHRoaXMuI3BhcmVudFdpZHRoID0gcGFyZW50V2lkdGg7XG4gICAgdGhpcy4jcGFyZW50SGVpZ2h0ID0gcGFyZW50SGVpZ2h0O1xuICAgIHRoaXMuI3JvdGF0aW9uID0gcm90YXRpb247XG4gICAgdGhpcy4jdGhpY2tuZXNzID0gdGhpY2tuZXNzO1xuICAgIFt4LCB5XSA9IHRoaXMuI25vcm1hbGl6ZVBvaW50KHgsIHkpO1xuICAgIGNvbnN0IGxpbmUgPSB0aGlzLiNsaW5lID0gW05hTiwgTmFOLCBOYU4sIE5hTiwgeCwgeV07XG4gICAgdGhpcy4jcG9pbnRzID0gW3gsIHldO1xuICAgIHRoaXMuI2xpbmVzID0gW3tcbiAgICAgIGxpbmUsXG4gICAgICBwb2ludHM6IHRoaXMuI3BvaW50c1xuICAgIH1dO1xuICAgIHRoaXMuI2xhc3Quc2V0KGxpbmUsIDApO1xuICB9XG4gIHVwZGF0ZVByb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKG5hbWUgPT09IFwic3Ryb2tlLXdpZHRoXCIpIHtcbiAgICAgIHRoaXMuI3RoaWNrbmVzcyA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICAjbm9ybWFsaXplUG9pbnQoeCwgeSkge1xuICAgIHJldHVybiBPdXRsaW5lLl9ub3JtYWxpemVQb2ludCh4LCB5LCB0aGlzLiNwYXJlbnRXaWR0aCwgdGhpcy4jcGFyZW50SGVpZ2h0LCB0aGlzLiNyb3RhdGlvbik7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gIXRoaXMuI2xpbmVzIHx8IHRoaXMuI2xpbmVzLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBpc0NhbmNlbGxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLiNwb2ludHMubGVuZ3RoIDw9IDEwO1xuICB9XG4gIGFkZCh4LCB5KSB7XG4gICAgW3gsIHldID0gdGhpcy4jbm9ybWFsaXplUG9pbnQoeCwgeSk7XG4gICAgY29uc3QgW3gxLCB5MSwgeDIsIHkyXSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMiwgNik7XG4gICAgY29uc3QgZGlmZlggPSB4IC0geDI7XG4gICAgY29uc3QgZGlmZlkgPSB5IC0geTI7XG4gICAgY29uc3QgZCA9IE1hdGguaHlwb3QodGhpcy4jcGFyZW50V2lkdGggKiBkaWZmWCwgdGhpcy4jcGFyZW50SGVpZ2h0ICogZGlmZlkpO1xuICAgIGlmIChkIDw9IDIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNwb2ludHMucHVzaCh4LCB5KTtcbiAgICBpZiAoaXNOYU4oeDEpKSB7XG4gICAgICB0aGlzLiNsYXN0LnNldChbeDIsIHkyLCB4LCB5XSwgMik7XG4gICAgICB0aGlzLiNsaW5lLnB1c2goTmFOLCBOYU4sIE5hTiwgTmFOLCB4LCB5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBkOiB0aGlzLnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpc05hTih0aGlzLiNsYXN0WzBdKSkge1xuICAgICAgdGhpcy4jbGluZS5zcGxpY2UoNiwgNik7XG4gICAgfVxuICAgIHRoaXMuI2xhc3Quc2V0KFt4MSwgeTEsIHgyLCB5MiwgeCwgeV0sIDApO1xuICAgIHRoaXMuI2xpbmUucHVzaCguLi5PdXRsaW5lLmNyZWF0ZUJlemllclBvaW50cyh4MSwgeTEsIHgyLCB5MiwgeCwgeSkpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGVuZCh4LCB5KSB7XG4gICAgY29uc3QgY2hhbmdlID0gdGhpcy5hZGQoeCwgeSk7XG4gICAgaWYgKGNoYW5nZSkge1xuICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3BvaW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBkOiB0aGlzLnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN0YXJ0TmV3KHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uKSB7XG4gICAgdGhpcy4jcGFyZW50V2lkdGggPSBwYXJlbnRXaWR0aDtcbiAgICB0aGlzLiNwYXJlbnRIZWlnaHQgPSBwYXJlbnRIZWlnaHQ7XG4gICAgdGhpcy4jcm90YXRpb24gPSByb3RhdGlvbjtcbiAgICBbeCwgeV0gPSB0aGlzLiNub3JtYWxpemVQb2ludCh4LCB5KTtcbiAgICBjb25zdCBsaW5lID0gdGhpcy4jbGluZSA9IFtOYU4sIE5hTiwgTmFOLCBOYU4sIHgsIHldO1xuICAgIHRoaXMuI3BvaW50cyA9IFt4LCB5XTtcbiAgICBjb25zdCBsYXN0ID0gdGhpcy4jbGluZXMuYXQoLTEpO1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0LmxpbmUgPSBuZXcgRmxvYXQzMkFycmF5KGxhc3QubGluZSk7XG4gICAgICBsYXN0LnBvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkobGFzdC5wb2ludHMpO1xuICAgIH1cbiAgICB0aGlzLiNsaW5lcy5wdXNoKHtcbiAgICAgIGxpbmUsXG4gICAgICBwb2ludHM6IHRoaXMuI3BvaW50c1xuICAgIH0pO1xuICAgIHRoaXMuI2xhc3Quc2V0KGxpbmUsIDApO1xuICAgIHRoaXMuI2xhc3RJbmRleCA9IDA7XG4gICAgdGhpcy50b1NWR1BhdGgoKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXRMYXN0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy4jbGluZXMuYXQoLTEpO1xuICB9XG4gIHNldExhc3RFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBpZiAoIXRoaXMuI2xpbmVzKSB7XG4gICAgICByZXR1cm4gdGhpcy4jb3V0bGluZXMuc2V0TGFzdEVsZW1lbnQoZWxlbWVudCk7XG4gICAgfVxuICAgIHRoaXMuI2xpbmVzLnB1c2goZWxlbWVudCk7XG4gICAgdGhpcy4jbGluZSA9IGVsZW1lbnQubGluZTtcbiAgICB0aGlzLiNwb2ludHMgPSBlbGVtZW50LnBvaW50cztcbiAgICB0aGlzLiNsYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJlbW92ZUxhc3RFbGVtZW50KCkge1xuICAgIGlmICghdGhpcy4jbGluZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLiNvdXRsaW5lcy5yZW1vdmVMYXN0RWxlbWVudCgpO1xuICAgIH1cbiAgICB0aGlzLiNsaW5lcy5wb3AoKTtcbiAgICB0aGlzLiNsYXN0U1ZHUGF0aCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdGhpcy4jbGluZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsaW5lLFxuICAgICAgICBwb2ludHNcbiAgICAgIH0gPSB0aGlzLiNsaW5lc1tpXTtcbiAgICAgIHRoaXMuI2xpbmUgPSBsaW5lO1xuICAgICAgdGhpcy4jcG9pbnRzID0gcG9pbnRzO1xuICAgICAgdGhpcy4jbGFzdEluZGV4ID0gMDtcbiAgICAgIHRoaXMudG9TVkdQYXRoKCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMuI2xhc3RTVkdQYXRoXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0b1NWR1BhdGgoKSB7XG4gICAgY29uc3QgZmlyc3RYID0gT3V0bGluZS5zdmdSb3VuZCh0aGlzLiNsaW5lWzRdKTtcbiAgICBjb25zdCBmaXJzdFkgPSBPdXRsaW5lLnN2Z1JvdW5kKHRoaXMuI2xpbmVbNV0pO1xuICAgIGlmICh0aGlzLiNwb2ludHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB0aGlzLiNsYXN0U1ZHUGF0aCA9IGAke3RoaXMuI2xhc3RTVkdQYXRofSBNICR7Zmlyc3RYfSAke2ZpcnN0WX0gWmA7XG4gICAgICByZXR1cm4gdGhpcy4jbGFzdFNWR1BhdGg7XG4gICAgfVxuICAgIGlmICh0aGlzLiNwb2ludHMubGVuZ3RoIDw9IDYpIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLiNsYXN0U1ZHUGF0aC5sYXN0SW5kZXhPZihcIk1cIik7XG4gICAgICB0aGlzLiNsYXN0U1ZHUGF0aCA9IGAke3RoaXMuI2xhc3RTVkdQYXRoLnNsaWNlKDAsIGkpfSBNICR7Zmlyc3RYfSAke2ZpcnN0WX1gO1xuICAgICAgdGhpcy4jbGFzdEluZGV4ID0gNjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3BvaW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgIGNvbnN0IHNlY29uZFggPSBPdXRsaW5lLnN2Z1JvdW5kKHRoaXMuI2xpbmVbMTBdKTtcbiAgICAgIGNvbnN0IHNlY29uZFkgPSBPdXRsaW5lLnN2Z1JvdW5kKHRoaXMuI2xpbmVbMTFdKTtcbiAgICAgIHRoaXMuI2xhc3RTVkdQYXRoID0gYCR7dGhpcy4jbGFzdFNWR1BhdGh9IEwgJHtzZWNvbmRYfSAke3NlY29uZFl9YDtcbiAgICAgIHRoaXMuI2xhc3RJbmRleCA9IDEyO1xuICAgICAgcmV0dXJuIHRoaXMuI2xhc3RTVkdQYXRoO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICBpZiAodGhpcy4jbGFzdEluZGV4ID09PSAwKSB7XG4gICAgICBidWZmZXIucHVzaChgTSAke2ZpcnN0WH0gJHtmaXJzdFl9YCk7XG4gICAgICB0aGlzLiNsYXN0SW5kZXggPSA2O1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gdGhpcy4jbGFzdEluZGV4LCBpaSA9IHRoaXMuI2xpbmUubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNikge1xuICAgICAgY29uc3QgW2MxeCwgYzF5LCBjMngsIGMyeSwgeCwgeV0gPSB0aGlzLiNsaW5lLnNsaWNlKGksIGkgKyA2KS5tYXAoT3V0bGluZS5zdmdSb3VuZCk7XG4gICAgICBidWZmZXIucHVzaChgQyR7YzF4fSAke2MxeX0gJHtjMnh9ICR7YzJ5fSAke3h9ICR7eX1gKTtcbiAgICB9XG4gICAgdGhpcy4jbGFzdFNWR1BhdGggKz0gYnVmZmVyLmpvaW4oXCIgXCIpO1xuICAgIHRoaXMuI2xhc3RJbmRleCA9IHRoaXMuI2xpbmUubGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLiNsYXN0U1ZHUGF0aDtcbiAgfVxuICBnZXRPdXRsaW5lcyhwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCBzY2FsZSwgaW5uZXJNYXJnaW4pIHtcbiAgICBjb25zdCBsYXN0ID0gdGhpcy4jbGluZXMuYXQoLTEpO1xuICAgIGxhc3QubGluZSA9IG5ldyBGbG9hdDMyQXJyYXkobGFzdC5saW5lKTtcbiAgICBsYXN0LnBvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkobGFzdC5wb2ludHMpO1xuICAgIHRoaXMuI291dGxpbmVzLmJ1aWxkKHRoaXMuI2xpbmVzLCBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCBzY2FsZSwgdGhpcy4jcm90YXRpb24sIHRoaXMuI3RoaWNrbmVzcywgaW5uZXJNYXJnaW4pO1xuICAgIHRoaXMuI2xhc3QgPSBudWxsO1xuICAgIHRoaXMuI2xpbmUgPSBudWxsO1xuICAgIHRoaXMuI2xpbmVzID0gbnVsbDtcbiAgICB0aGlzLiNsYXN0U1ZHUGF0aCA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXMuI291dGxpbmVzO1xuICB9XG4gIGdldCBkZWZhdWx0U1ZHUHJvcGVydGllcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vdDoge1xuICAgICAgICB2aWV3Qm94OiBcIjAgMCAxMDAwMCAxMDAwMFwiXG4gICAgICB9LFxuICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgIGRyYXc6IHRydWVcbiAgICAgIH0sXG4gICAgICBiYm94OiBbMCwgMCwgMSwgMV1cbiAgICB9O1xuICB9XG59XG5jbGFzcyBJbmtEcmF3T3V0bGluZSBleHRlbmRzIE91dGxpbmUge1xuICAjYmJveDtcbiAgI2N1cnJlbnRSb3RhdGlvbiA9IDA7XG4gICNpbm5lck1hcmdpbjtcbiAgI2xpbmVzO1xuICAjcGFyZW50V2lkdGg7XG4gICNwYXJlbnRIZWlnaHQ7XG4gICNwYXJlbnRTY2FsZTtcbiAgI3JvdGF0aW9uO1xuICAjdGhpY2tuZXNzO1xuICBidWlsZChsaW5lcywgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgcGFyZW50U2NhbGUsIHJvdGF0aW9uLCB0aGlja25lc3MsIGlubmVyTWFyZ2luKSB7XG4gICAgdGhpcy4jcGFyZW50V2lkdGggPSBwYXJlbnRXaWR0aDtcbiAgICB0aGlzLiNwYXJlbnRIZWlnaHQgPSBwYXJlbnRIZWlnaHQ7XG4gICAgdGhpcy4jcGFyZW50U2NhbGUgPSBwYXJlbnRTY2FsZTtcbiAgICB0aGlzLiNyb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMuI3RoaWNrbmVzcyA9IHRoaWNrbmVzcztcbiAgICB0aGlzLiNpbm5lck1hcmdpbiA9IGlubmVyTWFyZ2luID8/IDA7XG4gICAgdGhpcy4jbGluZXMgPSBsaW5lcztcbiAgICB0aGlzLiNjb21wdXRlQmJveCgpO1xuICB9XG4gIHNldExhc3RFbGVtZW50KGVsZW1lbnQpIHtcbiAgICB0aGlzLiNsaW5lcy5wdXNoKGVsZW1lbnQpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJlbW92ZUxhc3RFbGVtZW50KCkge1xuICAgIHRoaXMuI2xpbmVzLnBvcCgpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIGxpbmVcbiAgICB9IG9mIHRoaXMuI2xpbmVzKSB7XG4gICAgICBidWZmZXIucHVzaChgTSR7T3V0bGluZS5zdmdSb3VuZChsaW5lWzRdKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKGxpbmVbNV0pfWApO1xuICAgICAgaWYgKGxpbmUubGVuZ3RoID09PSA2KSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKFwiWlwiKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobGluZS5sZW5ndGggPT09IDEyKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBMJHtPdXRsaW5lLnN2Z1JvdW5kKGxpbmVbMTBdKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKGxpbmVbMTFdKX1gKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gNiwgaWkgPSBsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDYpIHtcbiAgICAgICAgY29uc3QgW2MxeCwgYzF5LCBjMngsIGMyeSwgeCwgeV0gPSBsaW5lLnN1YmFycmF5KGksIGkgKyA2KS5tYXAoT3V0bGluZS5zdmdSb3VuZCk7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBDJHtjMXh9ICR7YzF5fSAke2MyeH0gJHtjMnl9ICR7eH0gJHt5fWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCJcIik7XG4gIH1cbiAgc2VyaWFsaXplKFtwYWdlWCwgcGFnZVksIHBhZ2VXaWR0aCwgcGFnZUhlaWdodF0sIGlzRm9yQ29weWluZykge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRMaW5lcyA9IFtdO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRQb2ludHMgPSBbXTtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNnZXRCQm94V2l0aE5vTWFyZ2luKCk7XG4gICAgbGV0IHR4LCB0eSwgc3gsIHN5LCB4MSwgeTEsIHgyLCB5MiwgcmVzY2FsZUZuO1xuICAgIHN3aXRjaCAodGhpcy4jcm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmVzY2FsZUZuID0gT3V0bGluZS5fcmVzY2FsZTtcbiAgICAgICAgdHggPSBwYWdlWDtcbiAgICAgICAgdHkgPSBwYWdlWSArIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHN4ID0gcGFnZVdpZHRoO1xuICAgICAgICBzeSA9IC1wYWdlSGVpZ2h0O1xuICAgICAgICB4MSA9IHBhZ2VYICsgeCAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTEgPSBwYWdlWSArICgxIC0geSAtIGhlaWdodCkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICB4MiA9IHBhZ2VYICsgKHggKyB3aWR0aCkgKiBwYWdlV2lkdGg7XG4gICAgICAgIHkyID0gcGFnZVkgKyAoMSAtIHkpICogcGFnZUhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcDtcbiAgICAgICAgdHggPSBwYWdlWDtcbiAgICAgICAgdHkgPSBwYWdlWTtcbiAgICAgICAgc3ggPSBwYWdlV2lkdGg7XG4gICAgICAgIHN5ID0gcGFnZUhlaWdodDtcbiAgICAgICAgeDEgPSBwYWdlWCArIHkgKiBwYWdlV2lkdGg7XG4gICAgICAgIHkxID0gcGFnZVkgKyB4ICogcGFnZUhlaWdodDtcbiAgICAgICAgeDIgPSBwYWdlWCArICh5ICsgaGVpZ2h0KSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTIgPSBwYWdlWSArICh4ICsgd2lkdGgpICogcGFnZUhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmVzY2FsZUZuID0gT3V0bGluZS5fcmVzY2FsZTtcbiAgICAgICAgdHggPSBwYWdlWCArIHBhZ2VXaWR0aDtcbiAgICAgICAgdHkgPSBwYWdlWTtcbiAgICAgICAgc3ggPSAtcGFnZVdpZHRoO1xuICAgICAgICBzeSA9IHBhZ2VIZWlnaHQ7XG4gICAgICAgIHgxID0gcGFnZVggKyAoMSAtIHggLSB3aWR0aCkgKiBwYWdlV2lkdGg7XG4gICAgICAgIHkxID0gcGFnZVkgKyB5ICogcGFnZUhlaWdodDtcbiAgICAgICAgeDIgPSBwYWdlWCArICgxIC0geCkgKiBwYWdlV2lkdGg7XG4gICAgICAgIHkyID0gcGFnZVkgKyAoeSArIGhlaWdodCkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcDtcbiAgICAgICAgdHggPSBwYWdlWCArIHBhZ2VXaWR0aDtcbiAgICAgICAgdHkgPSBwYWdlWSArIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHN4ID0gLXBhZ2VXaWR0aDtcbiAgICAgICAgc3kgPSAtcGFnZUhlaWdodDtcbiAgICAgICAgeDEgPSBwYWdlWCArICgxIC0geSAtIGhlaWdodCkgKiBwYWdlV2lkdGg7XG4gICAgICAgIHkxID0gcGFnZVkgKyAoMSAtIHggLSB3aWR0aCkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICB4MiA9IHBhZ2VYICsgKDEgLSB5KSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTIgPSBwYWdlWSArICgxIC0geCkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBsaW5lLFxuICAgICAgcG9pbnRzXG4gICAgfSBvZiB0aGlzLiNsaW5lcykge1xuICAgICAgc2VyaWFsaXplZExpbmVzLnB1c2gocmVzY2FsZUZuKGxpbmUsIHR4LCB0eSwgc3gsIHN5LCBpc0ZvckNvcHlpbmcgPyBuZXcgQXJyYXkobGluZS5sZW5ndGgpIDogbnVsbCkpO1xuICAgICAgc2VyaWFsaXplZFBvaW50cy5wdXNoKHJlc2NhbGVGbihwb2ludHMsIHR4LCB0eSwgc3gsIHN5LCBpc0ZvckNvcHlpbmcgPyBuZXcgQXJyYXkocG9pbnRzLmxlbmd0aCkgOiBudWxsKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBsaW5lczogc2VyaWFsaXplZExpbmVzLFxuICAgICAgcG9pbnRzOiBzZXJpYWxpemVkUG9pbnRzLFxuICAgICAgcmVjdDogW3gxLCB5MSwgeDIsIHkyXVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplKHBhZ2VYLCBwYWdlWSwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCBpbm5lck1hcmdpbiwge1xuICAgIHBhdGhzOiB7XG4gICAgICBsaW5lcyxcbiAgICAgIHBvaW50c1xuICAgIH0sXG4gICAgcm90YXRpb24sXG4gICAgdGhpY2tuZXNzXG4gIH0pIHtcbiAgICBjb25zdCBuZXdMaW5lcyA9IFtdO1xuICAgIGxldCB0eCwgdHksIHN4LCBzeSwgcmVzY2FsZUZuO1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmVzY2FsZUZuID0gT3V0bGluZS5fcmVzY2FsZTtcbiAgICAgICAgdHggPSAtcGFnZVggLyBwYWdlV2lkdGg7XG4gICAgICAgIHR5ID0gcGFnZVkgLyBwYWdlSGVpZ2h0ICsgMTtcbiAgICAgICAgc3ggPSAxIC8gcGFnZVdpZHRoO1xuICAgICAgICBzeSA9IC0xIC8gcGFnZUhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcDtcbiAgICAgICAgdHggPSAtcGFnZVkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICB0eSA9IC1wYWdlWCAvIHBhZ2VXaWR0aDtcbiAgICAgICAgc3ggPSAxIC8gcGFnZUhlaWdodDtcbiAgICAgICAgc3kgPSAxIC8gcGFnZVdpZHRoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlO1xuICAgICAgICB0eCA9IHBhZ2VYIC8gcGFnZVdpZHRoICsgMTtcbiAgICAgICAgdHkgPSAtcGFnZVkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICBzeCA9IC0xIC8gcGFnZVdpZHRoO1xuICAgICAgICBzeSA9IDEgLyBwYWdlSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcDtcbiAgICAgICAgdHggPSBwYWdlWSAvIHBhZ2VIZWlnaHQgKyAxO1xuICAgICAgICB0eSA9IHBhZ2VYIC8gcGFnZVdpZHRoICsgMTtcbiAgICAgICAgc3ggPSAtMSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHN5ID0gLTEgLyBwYWdlV2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoIWxpbmVzKSB7XG4gICAgICBsaW5lcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBwb2ludHMpIHtcbiAgICAgICAgY29uc3QgbGVuID0gcG9pbnQubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID09PSAyKSB7XG4gICAgICAgICAgbGluZXMucHVzaChuZXcgRmxvYXQzMkFycmF5KFtOYU4sIE5hTiwgTmFOLCBOYU4sIHBvaW50WzBdLCBwb2ludFsxXV0pKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuID09PSA0KSB7XG4gICAgICAgICAgbGluZXMucHVzaChuZXcgRmxvYXQzMkFycmF5KFtOYU4sIE5hTiwgTmFOLCBOYU4sIHBvaW50WzBdLCBwb2ludFsxXSwgTmFOLCBOYU4sIE5hTiwgTmFOLCBwb2ludFsyXSwgcG9pbnRbM11dKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGluZSA9IG5ldyBGbG9hdDMyQXJyYXkoMyAqIChsZW4gLSAyKSk7XG4gICAgICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIGxldCBbeDEsIHkxLCB4MiwgeTJdID0gcG9pbnQuc3ViYXJyYXkoMCwgNCk7XG4gICAgICAgIGxpbmUuc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIHgxLCB5MV0sIDApO1xuICAgICAgICBmb3IgKGxldCBpID0gNDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3QgeCA9IHBvaW50W2ldO1xuICAgICAgICAgIGNvbnN0IHkgPSBwb2ludFtpICsgMV07XG4gICAgICAgICAgbGluZS5zZXQoT3V0bGluZS5jcmVhdGVCZXppZXJQb2ludHMoeDEsIHkxLCB4MiwgeTIsIHgsIHkpLCAoaSAtIDIpICogMyk7XG4gICAgICAgICAgW3gxLCB5MSwgeDIsIHkyXSA9IFt4MiwgeTIsIHgsIHldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGxpbmVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIG5ld0xpbmVzLnB1c2goe1xuICAgICAgICBsaW5lOiByZXNjYWxlRm4obGluZXNbaV0ubWFwKHggPT4geCA/PyBOYU4pLCB0eCwgdHksIHN4LCBzeSksXG4gICAgICAgIHBvaW50czogcmVzY2FsZUZuKHBvaW50c1tpXS5tYXAoeCA9PiB4ID8/IE5hTiksIHR4LCB0eSwgc3gsIHN5KVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG91dGxpbmVzID0gbmV3IElua0RyYXdPdXRsaW5lKCk7XG4gICAgb3V0bGluZXMuYnVpbGQobmV3TGluZXMsIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgMSwgcm90YXRpb24sIHRoaWNrbmVzcywgaW5uZXJNYXJnaW4pO1xuICAgIHJldHVybiBvdXRsaW5lcztcbiAgfVxuICAjZ2V0TWFyZ2luQ29tcG9uZW50cyh0aGlja25lc3MgPSB0aGlzLiN0aGlja25lc3MpIHtcbiAgICBjb25zdCBtYXJnaW4gPSB0aGlzLiNpbm5lck1hcmdpbiArIHRoaWNrbmVzcyAvIDIgKiB0aGlzLiNwYXJlbnRTY2FsZTtcbiAgICByZXR1cm4gdGhpcy4jcm90YXRpb24gJSAxODAgPT09IDAgPyBbbWFyZ2luIC8gdGhpcy4jcGFyZW50V2lkdGgsIG1hcmdpbiAvIHRoaXMuI3BhcmVudEhlaWdodF0gOiBbbWFyZ2luIC8gdGhpcy4jcGFyZW50SGVpZ2h0LCBtYXJnaW4gLyB0aGlzLiNwYXJlbnRXaWR0aF07XG4gIH1cbiAgI2dldEJCb3hXaXRoTm9NYXJnaW4oKSB7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYmJveDtcbiAgICBjb25zdCBbbWFyZ2luWCwgbWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKDApO1xuICAgIHJldHVybiBbeCArIG1hcmdpblgsIHkgKyBtYXJnaW5ZLCB3aWR0aCAtIDIgKiBtYXJnaW5YLCBoZWlnaHQgLSAyICogbWFyZ2luWV07XG4gIH1cbiAgI2NvbXB1dGVCYm94KCkge1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLiNiYm94ID0gbmV3IEZsb2F0MzJBcnJheShbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV0pO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgbGluZVxuICAgIH0gb2YgdGhpcy4jbGluZXMpIHtcbiAgICAgIGlmIChsaW5lLmxlbmd0aCA8PSAxMikge1xuICAgICAgICBmb3IgKGxldCBpID0gNCwgaWkgPSBsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDYpIHtcbiAgICAgICAgICBjb25zdCBbeCwgeV0gPSBsaW5lLnN1YmFycmF5KGksIGkgKyAyKTtcbiAgICAgICAgICBiYm94WzBdID0gTWF0aC5taW4oYmJveFswXSwgeCk7XG4gICAgICAgICAgYmJveFsxXSA9IE1hdGgubWluKGJib3hbMV0sIHkpO1xuICAgICAgICAgIGJib3hbMl0gPSBNYXRoLm1heChiYm94WzJdLCB4KTtcbiAgICAgICAgICBiYm94WzNdID0gTWF0aC5tYXgoYmJveFszXSwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgbGFzdFggPSBsaW5lWzRdLFxuICAgICAgICBsYXN0WSA9IGxpbmVbNV07XG4gICAgICBmb3IgKGxldCBpID0gNiwgaWkgPSBsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDYpIHtcbiAgICAgICAgY29uc3QgW2MxeCwgYzF5LCBjMngsIGMyeSwgeCwgeV0gPSBsaW5lLnN1YmFycmF5KGksIGkgKyA2KTtcbiAgICAgICAgVXRpbC5iZXppZXJCb3VuZGluZ0JveChsYXN0WCwgbGFzdFksIGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSwgYmJveCk7XG4gICAgICAgIGxhc3RYID0geDtcbiAgICAgICAgbGFzdFkgPSB5O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBbbWFyZ2luWCwgbWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKCk7XG4gICAgYmJveFswXSA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGJib3hbMF0gLSBtYXJnaW5YKSk7XG4gICAgYmJveFsxXSA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGJib3hbMV0gLSBtYXJnaW5ZKSk7XG4gICAgYmJveFsyXSA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGJib3hbMl0gKyBtYXJnaW5YKSk7XG4gICAgYmJveFszXSA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGJib3hbM10gKyBtYXJnaW5ZKSk7XG4gICAgYmJveFsyXSAtPSBiYm94WzBdO1xuICAgIGJib3hbM10gLT0gYmJveFsxXTtcbiAgfVxuICBnZXQgYm94KCkge1xuICAgIHJldHVybiB0aGlzLiNiYm94O1xuICB9XG4gIHVwZGF0ZVByb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKG5hbWUgPT09IFwic3Ryb2tlLXdpZHRoXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLiN1cGRhdGVUaGlja25lc3ModmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAjdXBkYXRlVGhpY2tuZXNzKHRoaWNrbmVzcykge1xuICAgIGNvbnN0IFtvbGRNYXJnaW5YLCBvbGRNYXJnaW5ZXSA9IHRoaXMuI2dldE1hcmdpbkNvbXBvbmVudHMoKTtcbiAgICB0aGlzLiN0aGlja25lc3MgPSB0aGlja25lc3M7XG4gICAgY29uc3QgW25ld01hcmdpblgsIG5ld01hcmdpblldID0gdGhpcy4jZ2V0TWFyZ2luQ29tcG9uZW50cygpO1xuICAgIGNvbnN0IFtkaWZmTWFyZ2luWCwgZGlmZk1hcmdpblldID0gW25ld01hcmdpblggLSBvbGRNYXJnaW5YLCBuZXdNYXJnaW5ZIC0gb2xkTWFyZ2luWV07XG4gICAgY29uc3QgYmJveCA9IHRoaXMuI2Jib3g7XG4gICAgYmJveFswXSAtPSBkaWZmTWFyZ2luWDtcbiAgICBiYm94WzFdIC09IGRpZmZNYXJnaW5ZO1xuICAgIGJib3hbMl0gKz0gMiAqIGRpZmZNYXJnaW5YO1xuICAgIGJib3hbM10gKz0gMiAqIGRpZmZNYXJnaW5ZO1xuICAgIHJldHVybiBiYm94O1xuICB9XG4gIHVwZGF0ZVBhcmVudERpbWVuc2lvbnMoW3dpZHRoLCBoZWlnaHRdLCBzY2FsZSkge1xuICAgIGNvbnN0IFtvbGRNYXJnaW5YLCBvbGRNYXJnaW5ZXSA9IHRoaXMuI2dldE1hcmdpbkNvbXBvbmVudHMoKTtcbiAgICB0aGlzLiNwYXJlbnRXaWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuI3BhcmVudEhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLiNwYXJlbnRTY2FsZSA9IHNjYWxlO1xuICAgIGNvbnN0IFtuZXdNYXJnaW5YLCBuZXdNYXJnaW5ZXSA9IHRoaXMuI2dldE1hcmdpbkNvbXBvbmVudHMoKTtcbiAgICBjb25zdCBkaWZmTWFyZ2luWCA9IG5ld01hcmdpblggLSBvbGRNYXJnaW5YO1xuICAgIGNvbnN0IGRpZmZNYXJnaW5ZID0gbmV3TWFyZ2luWSAtIG9sZE1hcmdpblk7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuI2Jib3g7XG4gICAgYmJveFswXSAtPSBkaWZmTWFyZ2luWDtcbiAgICBiYm94WzFdIC09IGRpZmZNYXJnaW5ZO1xuICAgIGJib3hbMl0gKz0gMiAqIGRpZmZNYXJnaW5YO1xuICAgIGJib3hbM10gKz0gMiAqIGRpZmZNYXJnaW5ZO1xuICAgIHJldHVybiBiYm94O1xuICB9XG4gIHVwZGF0ZVJvdGF0aW9uKHJvdGF0aW9uKSB7XG4gICAgdGhpcy4jY3VycmVudFJvdGF0aW9uID0gcm90YXRpb247XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgdHJhbnNmb3JtOiB0aGlzLnJvdGF0aW9uVHJhbnNmb3JtXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBnZXQgdmlld0JveCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYmJveC5tYXAoT3V0bGluZS5zdmdSb3VuZCkuam9pbihcIiBcIik7XG4gIH1cbiAgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzKCkge1xuICAgIGNvbnN0IFt4LCB5XSA9IHRoaXMuI2Jib3g7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgdmlld0JveDogdGhpcy52aWV3Qm94XG4gICAgICB9LFxuICAgICAgcGF0aDoge1xuICAgICAgICBcInRyYW5zZm9ybS1vcmlnaW5cIjogYCR7T3V0bGluZS5zdmdSb3VuZCh4KX0gJHtPdXRsaW5lLnN2Z1JvdW5kKHkpfWBcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGdldCByb3RhdGlvblRyYW5zZm9ybSgpIHtcbiAgICBjb25zdCBbLCwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNiYm94O1xuICAgIGxldCBhID0gMCxcbiAgICAgIGIgPSAwLFxuICAgICAgYyA9IDAsXG4gICAgICBkID0gMCxcbiAgICAgIGUgPSAwLFxuICAgICAgZiA9IDA7XG4gICAgc3dpdGNoICh0aGlzLiNjdXJyZW50Um90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIGIgPSBoZWlnaHQgLyB3aWR0aDtcbiAgICAgICAgYyA9IC13aWR0aCAvIGhlaWdodDtcbiAgICAgICAgZSA9IHdpZHRoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICBhID0gLTE7XG4gICAgICAgIGQgPSAtMTtcbiAgICAgICAgZSA9IHdpZHRoO1xuICAgICAgICBmID0gaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICBiID0gLWhlaWdodCAvIHdpZHRoO1xuICAgICAgICBjID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgICAgIGYgPSBoZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBgbWF0cml4KCR7YX0gJHtifSAke2N9ICR7ZH0gJHtPdXRsaW5lLnN2Z1JvdW5kKGUpfSAke091dGxpbmUuc3ZnUm91bmQoZil9KWA7XG4gIH1cbiAgZ2V0UGF0aFJlc2l6aW5nU1ZHUHJvcGVydGllcyhbbmV3WCwgbmV3WSwgbmV3V2lkdGgsIG5ld0hlaWdodF0pIHtcbiAgICBjb25zdCBbbWFyZ2luWCwgbWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKCk7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYmJveDtcbiAgICBpZiAoTWF0aC5hYnMod2lkdGggLSBtYXJnaW5YKSA8PSBPdXRsaW5lLlBSRUNJU0lPTiB8fCBNYXRoLmFicyhoZWlnaHQgLSBtYXJnaW5ZKSA8PSBPdXRsaW5lLlBSRUNJU0lPTikge1xuICAgICAgY29uc3QgdHggPSBuZXdYICsgbmV3V2lkdGggLyAyIC0gKHggKyB3aWR0aCAvIDIpO1xuICAgICAgY29uc3QgdHkgPSBuZXdZICsgbmV3SGVpZ2h0IC8gMiAtICh5ICsgaGVpZ2h0IC8gMik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IGAke091dGxpbmUuc3ZnUm91bmQobmV3WCl9ICR7T3V0bGluZS5zdmdSb3VuZChuZXdZKX1gLFxuICAgICAgICAgIHRyYW5zZm9ybTogYCR7dGhpcy5yb3RhdGlvblRyYW5zZm9ybX0gdHJhbnNsYXRlKCR7dHh9ICR7dHl9KWBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgczF4ID0gKG5ld1dpZHRoIC0gMiAqIG1hcmdpblgpIC8gKHdpZHRoIC0gMiAqIG1hcmdpblgpO1xuICAgIGNvbnN0IHMxeSA9IChuZXdIZWlnaHQgLSAyICogbWFyZ2luWSkgLyAoaGVpZ2h0IC0gMiAqIG1hcmdpblkpO1xuICAgIGNvbnN0IHMyeCA9IHdpZHRoIC8gbmV3V2lkdGg7XG4gICAgY29uc3QgczJ5ID0gaGVpZ2h0IC8gbmV3SGVpZ2h0O1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB7XG4gICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBgJHtPdXRsaW5lLnN2Z1JvdW5kKHgpfSAke091dGxpbmUuc3ZnUm91bmQoeSl9YCxcbiAgICAgICAgdHJhbnNmb3JtOiBgJHt0aGlzLnJvdGF0aW9uVHJhbnNmb3JtfSBzY2FsZSgke3MyeH0gJHtzMnl9KSBgICsgYHRyYW5zbGF0ZSgke091dGxpbmUuc3ZnUm91bmQobWFyZ2luWCl9ICR7T3V0bGluZS5zdmdSb3VuZChtYXJnaW5ZKX0pIHNjYWxlKCR7czF4fSAke3MxeX0pIGAgKyBgdHJhbnNsYXRlKCR7T3V0bGluZS5zdmdSb3VuZCgtbWFyZ2luWCl9ICR7T3V0bGluZS5zdmdSb3VuZCgtbWFyZ2luWSl9KWBcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGdldFBhdGhSZXNpemVkU1ZHUHJvcGVydGllcyhbbmV3WCwgbmV3WSwgbmV3V2lkdGgsIG5ld0hlaWdodF0pIHtcbiAgICBjb25zdCBbbWFyZ2luWCwgbWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKCk7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuI2Jib3g7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gYmJveDtcbiAgICBiYm94WzBdID0gbmV3WDtcbiAgICBiYm94WzFdID0gbmV3WTtcbiAgICBiYm94WzJdID0gbmV3V2lkdGg7XG4gICAgYmJveFszXSA9IG5ld0hlaWdodDtcbiAgICBpZiAoTWF0aC5hYnMod2lkdGggLSBtYXJnaW5YKSA8PSBPdXRsaW5lLlBSRUNJU0lPTiB8fCBNYXRoLmFicyhoZWlnaHQgLSBtYXJnaW5ZKSA8PSBPdXRsaW5lLlBSRUNJU0lPTikge1xuICAgICAgY29uc3QgdHggPSBuZXdYICsgbmV3V2lkdGggLyAyIC0gKHggKyB3aWR0aCAvIDIpO1xuICAgICAgY29uc3QgdHkgPSBuZXdZICsgbmV3SGVpZ2h0IC8gMiAtICh5ICsgaGVpZ2h0IC8gMik7XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgcG9pbnRzXG4gICAgICB9IG9mIHRoaXMuI2xpbmVzKSB7XG4gICAgICAgIE91dGxpbmUuX3RyYW5zbGF0ZShsaW5lLCB0eCwgdHksIGxpbmUpO1xuICAgICAgICBPdXRsaW5lLl90cmFuc2xhdGUocG9pbnRzLCB0eCwgdHksIHBvaW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb290OiB7XG4gICAgICAgICAgdmlld0JveDogdGhpcy52aWV3Qm94XG4gICAgICAgIH0sXG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBcInRyYW5zZm9ybS1vcmlnaW5cIjogYCR7T3V0bGluZS5zdmdSb3VuZChuZXdYKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKG5ld1kpfWAsXG4gICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLnJvdGF0aW9uVHJhbnNmb3JtIHx8IG51bGwsXG4gICAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzMXggPSAobmV3V2lkdGggLSAyICogbWFyZ2luWCkgLyAod2lkdGggLSAyICogbWFyZ2luWCk7XG4gICAgY29uc3QgczF5ID0gKG5ld0hlaWdodCAtIDIgKiBtYXJnaW5ZKSAvIChoZWlnaHQgLSAyICogbWFyZ2luWSk7XG4gICAgY29uc3QgdHggPSAtczF4ICogKHggKyBtYXJnaW5YKSArIG5ld1ggKyBtYXJnaW5YO1xuICAgIGNvbnN0IHR5ID0gLXMxeSAqICh5ICsgbWFyZ2luWSkgKyBuZXdZICsgbWFyZ2luWTtcbiAgICBpZiAoczF4ICE9PSAxIHx8IHMxeSAhPT0gMSB8fCB0eCAhPT0gMCB8fCB0eSAhPT0gMCkge1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIHBvaW50c1xuICAgICAgfSBvZiB0aGlzLiNsaW5lcykge1xuICAgICAgICBPdXRsaW5lLl9yZXNjYWxlKGxpbmUsIHR4LCB0eSwgczF4LCBzMXksIGxpbmUpO1xuICAgICAgICBPdXRsaW5lLl9yZXNjYWxlKHBvaW50cywgdHgsIHR5LCBzMXgsIHMxeSwgcG9pbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgdmlld0JveDogdGhpcy52aWV3Qm94XG4gICAgICB9LFxuICAgICAgcGF0aDoge1xuICAgICAgICBcInRyYW5zZm9ybS1vcmlnaW5cIjogYCR7T3V0bGluZS5zdmdSb3VuZChuZXdYKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKG5ld1kpfWAsXG4gICAgICAgIHRyYW5zZm9ybTogdGhpcy5yb3RhdGlvblRyYW5zZm9ybSB8fCBudWxsLFxuICAgICAgICBkOiB0aGlzLnRvU1ZHUGF0aCgpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBnZXRQYXRoVHJhbnNsYXRlZFNWR1Byb3BlcnRpZXMoW25ld1gsIG5ld1ldLCBwYXJlbnREaW1lbnNpb25zKSB7XG4gICAgY29uc3QgW25ld1BhcmVudFdpZHRoLCBuZXdQYXJlbnRIZWlnaHRdID0gcGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCBiYm94ID0gdGhpcy4jYmJveDtcbiAgICBjb25zdCB0eCA9IG5ld1ggLSBiYm94WzBdO1xuICAgIGNvbnN0IHR5ID0gbmV3WSAtIGJib3hbMV07XG4gICAgaWYgKHRoaXMuI3BhcmVudFdpZHRoID09PSBuZXdQYXJlbnRXaWR0aCAmJiB0aGlzLiNwYXJlbnRIZWlnaHQgPT09IG5ld1BhcmVudEhlaWdodCkge1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIHBvaW50c1xuICAgICAgfSBvZiB0aGlzLiNsaW5lcykge1xuICAgICAgICBPdXRsaW5lLl90cmFuc2xhdGUobGluZSwgdHgsIHR5LCBsaW5lKTtcbiAgICAgICAgT3V0bGluZS5fdHJhbnNsYXRlKHBvaW50cywgdHgsIHR5LCBwb2ludHMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzeCA9IHRoaXMuI3BhcmVudFdpZHRoIC8gbmV3UGFyZW50V2lkdGg7XG4gICAgICBjb25zdCBzeSA9IHRoaXMuI3BhcmVudEhlaWdodCAvIG5ld1BhcmVudEhlaWdodDtcbiAgICAgIHRoaXMuI3BhcmVudFdpZHRoID0gbmV3UGFyZW50V2lkdGg7XG4gICAgICB0aGlzLiNwYXJlbnRIZWlnaHQgPSBuZXdQYXJlbnRIZWlnaHQ7XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgcG9pbnRzXG4gICAgICB9IG9mIHRoaXMuI2xpbmVzKSB7XG4gICAgICAgIE91dGxpbmUuX3Jlc2NhbGUobGluZSwgdHgsIHR5LCBzeCwgc3ksIGxpbmUpO1xuICAgICAgICBPdXRsaW5lLl9yZXNjYWxlKHBvaW50cywgdHgsIHR5LCBzeCwgc3ksIHBvaW50cyk7XG4gICAgICB9XG4gICAgICBiYm94WzJdICo9IHN4O1xuICAgICAgYmJveFszXSAqPSBzeTtcbiAgICB9XG4gICAgYmJveFswXSA9IG5ld1g7XG4gICAgYmJveFsxXSA9IG5ld1k7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgdmlld0JveDogdGhpcy52aWV3Qm94XG4gICAgICB9LFxuICAgICAgcGF0aDoge1xuICAgICAgICBkOiB0aGlzLnRvU1ZHUGF0aCgpLFxuICAgICAgICBcInRyYW5zZm9ybS1vcmlnaW5cIjogYCR7T3V0bGluZS5zdmdSb3VuZChuZXdYKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKG5ld1kpfWBcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGdldCBkZWZhdWx0U1ZHUHJvcGVydGllcygpIHtcbiAgICBjb25zdCBiYm94ID0gdGhpcy4jYmJveDtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vdDoge1xuICAgICAgICB2aWV3Qm94OiB0aGlzLnZpZXdCb3hcbiAgICAgIH0sXG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgZHJhdzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKSxcbiAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IGAke091dGxpbmUuc3ZnUm91bmQoYmJveFswXSl9ICR7T3V0bGluZS5zdmdSb3VuZChiYm94WzFdKX1gLFxuICAgICAgICB0cmFuc2Zvcm06IHRoaXMucm90YXRpb25UcmFuc2Zvcm0gfHwgbnVsbFxuICAgICAgfSxcbiAgICAgIGJib3hcbiAgICB9O1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9pbmsuanNcblxuXG5cblxuXG5jbGFzcyBJbmtEcmF3aW5nT3B0aW9ucyBleHRlbmRzIERyYXdpbmdPcHRpb25zIHtcbiAgI3ZpZXdQYXJhbWV0ZXJzO1xuICBjb25zdHJ1Y3Rvcih2aWV3ZXJQYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiN2aWV3UGFyYW1ldGVycyA9IHZpZXdlclBhcmFtZXRlcnM7XG4gICAgc3VwZXIudXBkYXRlUHJvcGVydGllcyh7XG4gICAgICBmaWxsOiBcIm5vbmVcIixcbiAgICAgIHN0cm9rZTogQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcixcbiAgICAgIFwic3Ryb2tlLW9wYWNpdHlcIjogMSxcbiAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IDEsXG4gICAgICBcInN0cm9rZS1saW5lY2FwXCI6IFwicm91bmRcIixcbiAgICAgIFwic3Ryb2tlLWxpbmVqb2luXCI6IFwicm91bmRcIixcbiAgICAgIFwic3Ryb2tlLW1pdGVybGltaXRcIjogMTBcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVTVkdQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChuYW1lID09PSBcInN0cm9rZS13aWR0aFwiKSB7XG4gICAgICB2YWx1ZSA/Pz0gdGhpc1tcInN0cm9rZS13aWR0aFwiXTtcbiAgICAgIHZhbHVlICo9IHRoaXMuI3ZpZXdQYXJhbWV0ZXJzLnJlYWxTY2FsZTtcbiAgICB9XG4gICAgc3VwZXIudXBkYXRlU1ZHUHJvcGVydHkobmFtZSwgdmFsdWUpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IElua0RyYXdpbmdPcHRpb25zKHRoaXMuI3ZpZXdQYXJhbWV0ZXJzKTtcbiAgICBjbG9uZS51cGRhdGVBbGwodGhpcyk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG5jbGFzcyBJbmtFZGl0b3IgZXh0ZW5kcyBEcmF3aW5nRWRpdG9yIHtcbiAgc3RhdGljIF90eXBlID0gXCJpbmtcIjtcbiAgc3RhdGljIF9lZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LO1xuICBzdGF0aWMgX2RlZmF1bHREcmF3aW5nT3B0aW9ucyA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG5hbWU6IFwiaW5rRWRpdG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLl93aWxsS2VlcEFzcGVjdFJhdGlvID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKTtcbiAgICB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnMgPSBuZXcgSW5rRHJhd2luZ09wdGlvbnModWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzKTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVmYXVsdERyYXdpbmdPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBjbG9uZSA9IHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucy5jbG9uZSgpO1xuICAgIGNsb25lLnVwZGF0ZVByb3BlcnRpZXMob3B0aW9ucyk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIHN0YXRpYyBnZXQgc3VwcG9ydE11bHRpcGxlRHJhd2luZ3MoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlc01hcCgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwidHlwZXNNYXBcIiwgbmV3IE1hcChbW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19USElDS05FU1MsIFwic3Ryb2tlLXdpZHRoXCJdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX0NPTE9SLCBcInN0cm9rZVwiXSwgW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19PUEFDSVRZLCBcInN0cm9rZS1vcGFjaXR5XCJdXSkpO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVEcmF3ZXJJbnN0YW5jZSh4LCB5LCBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCByb3RhdGlvbikge1xuICAgIHJldHVybiBuZXcgSW5rRHJhd091dGxpbmVyKHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uLCB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnNbXCJzdHJva2Utd2lkdGhcIl0pO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZURyYXcocGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIGlubmVyTWFyZ2luLCBkYXRhKSB7XG4gICAgcmV0dXJuIElua0RyYXdPdXRsaW5lLmRlc2VyaWFsaXplKHBhZ2VYLCBwYWdlWSwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCBpbm5lck1hcmdpbiwgZGF0YSk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgbGV0IGluaXRpYWxEYXRhID0gbnVsbDtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIElua0Fubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpbmtMaXN0cyxcbiAgICAgICAgICByZWN0LFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgIG9wYWNpdHksXG4gICAgICAgICAgYm9yZGVyU3R5bGU6IHtcbiAgICAgICAgICAgIHJhd1dpZHRoOiB0aGlja25lc3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBvcHVwUmVmXG4gICAgICAgIH0sXG4gICAgICAgIHBhcmVudDoge1xuICAgICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICAgIHBhZ2VOdW1iZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gPSBkYXRhO1xuICAgICAgaW5pdGlhbERhdGEgPSBkYXRhID0ge1xuICAgICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LLFxuICAgICAgICBjb2xvcjogQXJyYXkuZnJvbShjb2xvciksXG4gICAgICAgIHRoaWNrbmVzcyxcbiAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgcGF0aHM6IHtcbiAgICAgICAgICBwb2ludHM6IGlua0xpc3RzXG4gICAgICAgIH0sXG4gICAgICAgIGJveGVzOiBudWxsLFxuICAgICAgICBwYWdlSW5kZXg6IHBhZ2VOdW1iZXIgLSAxLFxuICAgICAgICByZWN0OiByZWN0LnNsaWNlKDApLFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgaWQsXG4gICAgICAgIGRlbGV0ZWQ6IGZhbHNlLFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkID0gZGF0YS5pZCB8fCBudWxsO1xuICAgIGVkaXRvci5faW5pdGlhbERhdGEgPSBpbml0aWFsRGF0YTtcbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIG9uU2NhbGVDaGFuZ2luZygpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLm9uU2NhbGVDaGFuZ2luZygpO1xuICAgIGNvbnN0IHtcbiAgICAgIF9kcmF3SWQsXG4gICAgICBfZHJhd2luZ09wdGlvbnMsXG4gICAgICBwYXJlbnRcbiAgICB9ID0gdGhpcztcbiAgICBfZHJhd2luZ09wdGlvbnMudXBkYXRlU1ZHUHJvcGVydHkoXCJzdHJva2Utd2lkdGhcIik7XG4gICAgcGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKF9kcmF3SWQsIF9kcmF3aW5nT3B0aW9ucy50b1NWR1Byb3BlcnRpZXMoKSk7XG4gIH1cbiAgc3RhdGljIG9uU2NhbGVDaGFuZ2luZ1doZW5EcmF3aW5nKCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX2N1cnJlbnRQYXJlbnQ7XG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIub25TY2FsZUNoYW5naW5nV2hlbkRyYXdpbmcoKTtcbiAgICB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnMudXBkYXRlU1ZHUHJvcGVydHkoXCJzdHJva2Utd2lkdGhcIik7XG4gICAgcGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2N1cnJlbnREcmF3SWQsIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucy50b1NWR1Byb3BlcnRpZXMoKSk7XG4gIH1cbiAgY3JlYXRlRHJhd2luZ09wdGlvbnMoe1xuICAgIGNvbG9yLFxuICAgIHRoaWNrbmVzcyxcbiAgICBvcGFjaXR5XG4gIH0pIHtcbiAgICB0aGlzLl9kcmF3aW5nT3B0aW9ucyA9IElua0VkaXRvci5nZXREZWZhdWx0RHJhd2luZ09wdGlvbnMoe1xuICAgICAgc3Ryb2tlOiBVdGlsLm1ha2VIZXhDb2xvciguLi5jb2xvciksXG4gICAgICBcInN0cm9rZS13aWR0aFwiOiB0aGlja25lc3MsXG4gICAgICBcInN0cm9rZS1vcGFjaXR5XCI6IG9wYWNpdHlcbiAgICB9KTtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWxldGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVEZWxldGVkKCk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGxpbmVzLFxuICAgICAgcG9pbnRzLFxuICAgICAgcmVjdFxuICAgIH0gPSB0aGlzLnNlcmlhbGl6ZURyYXcoaXNGb3JDb3B5aW5nKTtcbiAgICBjb25zdCB7XG4gICAgICBfZHJhd2luZ09wdGlvbnM6IHtcbiAgICAgICAgc3Ryb2tlLFxuICAgICAgICBcInN0cm9rZS1vcGFjaXR5XCI6IG9wYWNpdHksXG4gICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHRoaWNrbmVzc1xuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LLFxuICAgICAgY29sb3I6IEFubm90YXRpb25FZGl0b3IuX2NvbG9yTWFuYWdlci5jb252ZXJ0KHN0cm9rZSksXG4gICAgICBvcGFjaXR5LFxuICAgICAgdGhpY2tuZXNzLFxuICAgICAgcGF0aHM6IHtcbiAgICAgICAgbGluZXMsXG4gICAgICAgIHBvaW50c1xuICAgICAgfSxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5wYWdlSW5kZXgsXG4gICAgICByZWN0LFxuICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24sXG4gICAgICBzdHJ1Y3RUcmVlUGFyZW50SWQ6IHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZFxuICAgIH07XG4gICAgaWYgKGlzRm9yQ29weWluZykge1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmFubm90YXRpb25FbGVtZW50SWQgJiYgIXRoaXMuI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc2VyaWFsaXplZC5pZCA9IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgfVxuICAjaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbG9yLFxuICAgICAgdGhpY2tuZXNzLFxuICAgICAgb3BhY2l0eSxcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0gPSB0aGlzLl9pbml0aWFsRGF0YTtcbiAgICByZXR1cm4gdGhpcy5faGFzQmVlbk1vdmVkIHx8IHRoaXMuX2hhc0JlZW5SZXNpemVkIHx8IHNlcmlhbGl6ZWQuY29sb3Iuc29tZSgoYywgaSkgPT4gYyAhPT0gY29sb3JbaV0pIHx8IHNlcmlhbGl6ZWQudGhpY2tuZXNzICE9PSB0aGlja25lc3MgfHwgc2VyaWFsaXplZC5vcGFjaXR5ICE9PSBvcGFjaXR5IHx8IHNlcmlhbGl6ZWQucGFnZUluZGV4ICE9PSBwYWdlSW5kZXg7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHBvaW50cyxcbiAgICAgIHJlY3RcbiAgICB9ID0gdGhpcy5zZXJpYWxpemVEcmF3KGZhbHNlKTtcbiAgICBhbm5vdGF0aW9uLnVwZGF0ZUVkaXRlZCh7XG4gICAgICByZWN0LFxuICAgICAgdGhpY2tuZXNzOiB0aGlzLl9kcmF3aW5nT3B0aW9uc1tcInN0cm9rZS13aWR0aFwiXSxcbiAgICAgIHBvaW50c1xuICAgIH0pO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9zdGFtcC5qc1xuXG5cblxuXG5jbGFzcyBTdGFtcEVkaXRvciBleHRlbmRzIEFubm90YXRpb25FZGl0b3Ige1xuICAjYml0bWFwID0gbnVsbDtcbiAgI2JpdG1hcElkID0gbnVsbDtcbiAgI2JpdG1hcFByb21pc2UgPSBudWxsO1xuICAjYml0bWFwVXJsID0gbnVsbDtcbiAgI2JpdG1hcEZpbGUgPSBudWxsO1xuICAjYml0bWFwRmlsZU5hbWUgPSBcIlwiO1xuICAjY2FudmFzID0gbnVsbDtcbiAgI3Jlc2l6ZVRpbWVvdXRJZCA9IG51bGw7XG4gICNpc1N2ZyA9IGZhbHNlO1xuICAjaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2sgPSBmYWxzZTtcbiAgc3RhdGljIF90eXBlID0gXCJzdGFtcFwiO1xuICBzdGF0aWMgX2VkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUDtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbmFtZTogXCJzdGFtcEVkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy4jYml0bWFwVXJsID0gcGFyYW1zLmJpdG1hcFVybDtcbiAgICB0aGlzLiNiaXRtYXBGaWxlID0gcGFyYW1zLmJpdG1hcEZpbGU7XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5pbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcik7XG4gIH1cbiAgc3RhdGljIGdldCBzdXBwb3J0ZWRUeXBlcygpIHtcbiAgICBjb25zdCB0eXBlcyA9IFtcImFwbmdcIiwgXCJhdmlmXCIsIFwiYm1wXCIsIFwiZ2lmXCIsIFwianBlZ1wiLCBcInBuZ1wiLCBcInN2Zyt4bWxcIiwgXCJ3ZWJwXCIsIFwieC1pY29uXCJdO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJzdXBwb3J0ZWRUeXBlc1wiLCB0eXBlcy5tYXAodHlwZSA9PiBgaW1hZ2UvJHt0eXBlfWApKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHN1cHBvcnRlZFR5cGVzU3RyKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJzdXBwb3J0ZWRUeXBlc1N0clwiLCB0aGlzLnN1cHBvcnRlZFR5cGVzLmpvaW4oXCIsXCIpKTtcbiAgfVxuICBzdGF0aWMgaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nKG1pbWUpIHtcbiAgICByZXR1cm4gdGhpcy5zdXBwb3J0ZWRUeXBlcy5pbmNsdWRlcyhtaW1lKTtcbiAgfVxuICBzdGF0aWMgcGFzdGUoaXRlbSwgcGFyZW50KSB7XG4gICAgcGFyZW50LnBhc3RlRWRpdG9yKEFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QLCB7XG4gICAgICBiaXRtYXBGaWxlOiBpdGVtLmdldEFzRmlsZSgpXG4gICAgfSk7XG4gIH1cbiAgYWx0VGV4dEZpbmlzaCgpIHtcbiAgICBpZiAodGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRGbG93KSB7XG4gICAgICB0aGlzLmRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gICAgc3VwZXIuYWx0VGV4dEZpbmlzaCgpO1xuICB9XG4gIGdldCB0ZWxlbWV0cnlGaW5hbERhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic3RhbXBcIixcbiAgICAgIGhhc0FsdFRleHQ6ICEhdGhpcy5hbHRUZXh0RGF0YT8uYWx0VGV4dFxuICAgIH07XG4gIH1cbiAgc3RhdGljIGNvbXB1dGVUZWxlbWV0cnlGaW5hbERhdGEoZGF0YSkge1xuICAgIGNvbnN0IGhhc0FsdFRleHRTdGF0cyA9IGRhdGEuZ2V0KFwiaGFzQWx0VGV4dFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgaGFzQWx0VGV4dDogaGFzQWx0VGV4dFN0YXRzLmdldCh0cnVlKSA/PyAwLFxuICAgICAgaGFzTm9BbHRUZXh0OiBoYXNBbHRUZXh0U3RhdHMuZ2V0KGZhbHNlKSA/PyAwXG4gICAgfTtcbiAgfVxuICAjZ2V0Qml0bWFwRmV0Y2hlZChkYXRhLCBmcm9tSWQgPSBmYWxzZSkge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYml0bWFwID0gZGF0YS5iaXRtYXA7XG4gICAgaWYgKCFmcm9tSWQpIHtcbiAgICAgIHRoaXMuI2JpdG1hcElkID0gZGF0YS5pZDtcbiAgICAgIHRoaXMuI2lzU3ZnID0gZGF0YS5pc1N2ZztcbiAgICB9XG4gICAgaWYgKGRhdGEuZmlsZSkge1xuICAgICAgdGhpcy4jYml0bWFwRmlsZU5hbWUgPSBkYXRhLmZpbGUubmFtZTtcbiAgICB9XG4gICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gIH1cbiAgI2dldEJpdG1hcERvbmUoKSB7XG4gICAgdGhpcy4jYml0bWFwUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcoZmFsc2UpO1xuICAgIGlmICghdGhpcy4jY2FudmFzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSAmJiB0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dEZsb3cgJiYgdGhpcy4jYml0bWFwKSB7XG4gICAgICB0aGlzLl9lZGl0VG9vbGJhci5oaWRlKCk7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuZWRpdEFsdFRleHQodGhpcywgdHJ1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UgJiYgdGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRGbG93ICYmIHRoaXMuI2JpdG1hcCkge1xuICAgICAgdGhpcy5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgICAgYWN0aW9uOiBcInBkZmpzLmltYWdlLmltYWdlX2FkZGVkXCIsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBhbHRfdGV4dF9tb2RhbDogZmFsc2UsXG4gICAgICAgICAgYWx0X3RleHRfdHlwZTogXCJlbXB0eVwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5tbEd1ZXNzQWx0VGV4dCgpO1xuICAgICAgfSBjYXRjaCB7fVxuICAgIH1cbiAgICB0aGlzLmRpdi5mb2N1cygpO1xuICB9XG4gIGFzeW5jIG1sR3Vlc3NBbHRUZXh0KGltYWdlRGF0YSA9IG51bGwsIHVwZGF0ZUFsdFRleHREYXRhID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLmhhc0FsdFRleHREYXRhKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBtbE1hbmFnZXJcbiAgICB9ID0gdGhpcy5fdWlNYW5hZ2VyO1xuICAgIGlmICghbWxNYW5hZ2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBNTC5cIik7XG4gICAgfVxuICAgIGlmICghKGF3YWl0IG1sTWFuYWdlci5pc0VuYWJsZWRGb3IoXCJhbHRUZXh0XCIpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTUwgaXNuJ3QgZW5hYmxlZCBmb3IgYWx0IHRleHQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gaW1hZ2VEYXRhIHx8IHRoaXMuY29weUNhbnZhcyhudWxsLCBudWxsLCB0cnVlKS5pbWFnZURhdGE7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtbE1hbmFnZXIuZ3Vlc3Moe1xuICAgICAgbmFtZTogXCJhbHRUZXh0XCIsXG4gICAgICByZXF1ZXN0OiB7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGNoYW5uZWxzOiBkYXRhLmxlbmd0aCAvICh3aWR0aCAqIGhlaWdodClcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZXNwb25zZSBmcm9tIHRoZSBBSSBzZXJ2aWNlLlwiKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBmcm9tIHRoZSBBSSBzZXJ2aWNlLlwiKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLmNhbmNlbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2Uub3V0cHV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB2YWxpZCByZXNwb25zZSBmcm9tIHRoZSBBSSBzZXJ2aWNlLlwiKTtcbiAgICB9XG4gICAgY29uc3QgYWx0VGV4dCA9IHJlc3BvbnNlLm91dHB1dDtcbiAgICBhd2FpdCB0aGlzLnNldEd1ZXNzZWRBbHRUZXh0KGFsdFRleHQpO1xuICAgIGlmICh1cGRhdGVBbHRUZXh0RGF0YSAmJiAhdGhpcy5oYXNBbHRUZXh0RGF0YSgpKSB7XG4gICAgICB0aGlzLmFsdFRleHREYXRhID0ge1xuICAgICAgICBhbHQ6IGFsdFRleHQsXG4gICAgICAgIGRlY29yYXRpdmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYWx0VGV4dDtcbiAgfVxuICAjZ2V0Qml0bWFwKCkge1xuICAgIGlmICh0aGlzLiNiaXRtYXBJZCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcodHJ1ZSk7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21JZCh0aGlzLiNiaXRtYXBJZCkudGhlbihkYXRhID0+IHRoaXMuI2dldEJpdG1hcEZldGNoZWQoZGF0YSwgdHJ1ZSkpLmZpbmFsbHkoKCkgPT4gdGhpcy4jZ2V0Qml0bWFwRG9uZSgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2JpdG1hcFVybCkge1xuICAgICAgY29uc3QgdXJsID0gdGhpcy4jYml0bWFwVXJsO1xuICAgICAgdGhpcy4jYml0bWFwVXJsID0gbnVsbDtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKHRydWUpO1xuICAgICAgdGhpcy4jYml0bWFwUHJvbWlzZSA9IHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0RnJvbVVybCh1cmwpLnRoZW4oZGF0YSA9PiB0aGlzLiNnZXRCaXRtYXBGZXRjaGVkKGRhdGEpKS5maW5hbGx5KCgpID0+IHRoaXMuI2dldEJpdG1hcERvbmUoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNiaXRtYXBGaWxlKSB7XG4gICAgICBjb25zdCBmaWxlID0gdGhpcy4jYml0bWFwRmlsZTtcbiAgICAgIHRoaXMuI2JpdG1hcEZpbGUgPSBudWxsO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcodHJ1ZSk7XG4gICAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tRmlsZShmaWxlKS50aGVuKGRhdGEgPT4gdGhpcy4jZ2V0Qml0bWFwRmV0Y2hlZChkYXRhKSkuZmluYWxseSgoKSA9PiB0aGlzLiNnZXRCaXRtYXBEb25lKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBpbnB1dC50eXBlID0gXCJmaWxlXCI7XG4gICAgaW5wdXQuYWNjZXB0ID0gU3RhbXBFZGl0b3Iuc3VwcG9ydGVkVHlwZXNTdHI7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgdGhpcy4jYml0bWFwUHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICghaW5wdXQuZmlsZXMgfHwgaW5wdXQuZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyh0cnVlKTtcbiAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tRmlsZShpbnB1dC5maWxlc1swXSk7XG4gICAgICAgICAgdGhpcy5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgICAgICAgIGFjdGlvbjogXCJwZGZqcy5pbWFnZS5pbWFnZV9zZWxlY3RlZFwiLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBhbHRfdGV4dF9tb2RhbDogdGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRGbG93XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy4jZ2V0Qml0bWFwRmV0Y2hlZChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2FuY2VsXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgIH0pLmZpbmFsbHkoKCkgPT4gdGhpcy4jZ2V0Qml0bWFwRG9uZSgpKTtcbiAgICBpbnB1dC5jbGljaygpO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy4jYml0bWFwSWQpIHtcbiAgICAgIHRoaXMuI2JpdG1hcCA9IG51bGw7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmRlbGV0ZUlkKHRoaXMuI2JpdG1hcElkKTtcbiAgICAgIHRoaXMuI2NhbnZhcz8ucmVtb3ZlKCk7XG4gICAgICB0aGlzLiNjYW52YXMgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy4jcmVzaXplVGltZW91dElkKTtcbiAgICAgICAgdGhpcy4jcmVzaXplVGltZW91dElkID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIucmVtb3ZlKCk7XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICBpZiAodGhpcy4jYml0bWFwSWQpIHtcbiAgICAgICAgdGhpcy4jZ2V0Qml0bWFwKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnJlYnVpbGQoKTtcbiAgICBpZiAodGhpcy5kaXYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2JpdG1hcElkICYmIHRoaXMuI2NhbnZhcyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy4jZ2V0Qml0bWFwKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgb25jZUFkZGVkKGZvY3VzKSB7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgIGlmIChmb2N1cykge1xuICAgICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gISh0aGlzLiNiaXRtYXBQcm9taXNlIHx8IHRoaXMuI2JpdG1hcCB8fCB0aGlzLiNiaXRtYXBVcmwgfHwgdGhpcy4jYml0bWFwRmlsZSB8fCB0aGlzLiNiaXRtYXBJZCk7XG4gIH1cbiAgZ2V0IGlzUmVzaXphYmxlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdjtcbiAgICB9XG4gICAgbGV0IGJhc2VYLCBiYXNlWTtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgYmFzZVggPSB0aGlzLng7XG4gICAgICBiYXNlWSA9IHRoaXMueTtcbiAgICB9XG4gICAgc3VwZXIucmVuZGVyKCk7XG4gICAgdGhpcy5kaXYuaGlkZGVuID0gdHJ1ZTtcbiAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiZmlndXJlXCIpO1xuICAgIHRoaXMuYWRkQWx0VGV4dEJ1dHRvbigpO1xuICAgIGlmICh0aGlzLiNiaXRtYXApIHtcbiAgICAgIHRoaXMuI2NyZWF0ZUNhbnZhcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNnZXRCaXRtYXAoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMud2lkdGggJiYgIXRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgdGhpcy5zZXRBdChiYXNlWCAqIHBhcmVudFdpZHRoLCBiYXNlWSAqIHBhcmVudEhlaWdodCwgdGhpcy53aWR0aCAqIHBhcmVudFdpZHRoLCB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gICAgfVxuICAgIHRoaXMuX3VpTWFuYWdlci5hZGRTaG91bGRSZXNjYWxlKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICBfb25SZXNpemVkKCkge1xuICAgIHRoaXMub25TY2FsZUNoYW5naW5nKCk7XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCk7XG4gICAgfVxuICAgIGNvbnN0IFRJTUVfVE9fV0FJVCA9IDIwMDtcbiAgICB0aGlzLiNyZXNpemVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB0aGlzLiNkcmF3Qml0bWFwKCk7XG4gICAgfSwgVElNRV9UT19XQUlUKTtcbiAgfVxuICAjY3JlYXRlQ2FudmFzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpdlxuICAgIH0gPSB0aGlzO1xuICAgIGxldCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzLiNiaXRtYXA7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IE1BWF9SQVRJTyA9IDAuNzU7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIHdpZHRoID0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aDtcbiAgICAgIGhlaWdodCA9IHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodDtcbiAgICB9IGVsc2UgaWYgKHdpZHRoID4gTUFYX1JBVElPICogcGFnZVdpZHRoIHx8IGhlaWdodCA+IE1BWF9SQVRJTyAqIHBhZ2VIZWlnaHQpIHtcbiAgICAgIGNvbnN0IGZhY3RvciA9IE1hdGgubWluKE1BWF9SQVRJTyAqIHBhZ2VXaWR0aCAvIHdpZHRoLCBNQVhfUkFUSU8gKiBwYWdlSGVpZ2h0IC8gaGVpZ2h0KTtcbiAgICAgIHdpZHRoICo9IGZhY3RvcjtcbiAgICAgIGhlaWdodCAqPSBmYWN0b3I7XG4gICAgfVxuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLnNldERpbXMod2lkdGggKiBwYXJlbnRXaWR0aCAvIHBhZ2VXaWR0aCwgaGVpZ2h0ICogcGFyZW50SGVpZ2h0IC8gcGFnZUhlaWdodCk7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcoZmFsc2UpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuI2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJpbWdcIik7XG4gICAgdGhpcy5hZGRDb250YWluZXIoY2FudmFzKTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGggLyBwYWdlV2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgLyBwYWdlSGVpZ2h0O1xuICAgIGlmICh0aGlzLl9pbml0aWFsT3B0aW9ucz8uaXNDZW50ZXJlZCkge1xuICAgICAgdGhpcy5jZW50ZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgIH1cbiAgICB0aGlzLl9pbml0aWFsT3B0aW9ucyA9IG51bGw7XG4gICAgaWYgKCF0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSB8fCAhdGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRGbG93IHx8IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgZGl2LmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLiNkcmF3Qml0bWFwKCk7XG4gICAgaWYgKCF0aGlzLiNoYXNCZWVuQWRkZWRJblVuZG9TdGFjaykge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkVW5kb2FibGVFZGl0b3IodGhpcyk7XG4gICAgICB0aGlzLiNoYXNCZWVuQWRkZWRJblVuZG9TdGFjayA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwiaW5zZXJ0ZWRfaW1hZ2VcIlxuICAgIH0pO1xuICAgIGlmICh0aGlzLiNiaXRtYXBGaWxlTmFtZSkge1xuICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy4jYml0bWFwRmlsZU5hbWUpO1xuICAgIH1cbiAgfVxuICBjb3B5Q2FudmFzKG1heERhdGFEaW1lbnNpb24sIG1heFByZXZpZXdEaW1lbnNpb24sIGNyZWF0ZUltYWdlRGF0YSA9IGZhbHNlKSB7XG4gICAgaWYgKCFtYXhEYXRhRGltZW5zaW9uKSB7XG4gICAgICBtYXhEYXRhRGltZW5zaW9uID0gMjI0O1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB3aWR0aDogYml0bWFwV2lkdGgsXG4gICAgICBoZWlnaHQ6IGJpdG1hcEhlaWdodFxuICAgIH0gPSB0aGlzLiNiaXRtYXA7XG4gICAgY29uc3Qgb3V0cHV0U2NhbGUgPSBuZXcgT3V0cHV0U2NhbGUoKTtcbiAgICBsZXQgYml0bWFwID0gdGhpcy4jYml0bWFwO1xuICAgIGxldCB3aWR0aCA9IGJpdG1hcFdpZHRoLFxuICAgICAgaGVpZ2h0ID0gYml0bWFwSGVpZ2h0O1xuICAgIGxldCBjYW52YXMgPSBudWxsO1xuICAgIGlmIChtYXhQcmV2aWV3RGltZW5zaW9uKSB7XG4gICAgICBpZiAoYml0bWFwV2lkdGggPiBtYXhQcmV2aWV3RGltZW5zaW9uIHx8IGJpdG1hcEhlaWdodCA+IG1heFByZXZpZXdEaW1lbnNpb24pIHtcbiAgICAgICAgY29uc3QgcmF0aW8gPSBNYXRoLm1pbihtYXhQcmV2aWV3RGltZW5zaW9uIC8gYml0bWFwV2lkdGgsIG1heFByZXZpZXdEaW1lbnNpb24gLyBiaXRtYXBIZWlnaHQpO1xuICAgICAgICB3aWR0aCA9IE1hdGguZmxvb3IoYml0bWFwV2lkdGggKiByYXRpbyk7XG4gICAgICAgIGhlaWdodCA9IE1hdGguZmxvb3IoYml0bWFwSGVpZ2h0ICogcmF0aW8pO1xuICAgICAgfVxuICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgIGNvbnN0IHNjYWxlZFdpZHRoID0gY2FudmFzLndpZHRoID0gTWF0aC5jZWlsKHdpZHRoICogb3V0cHV0U2NhbGUuc3gpO1xuICAgICAgY29uc3Qgc2NhbGVkSGVpZ2h0ID0gY2FudmFzLmhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgKiBvdXRwdXRTY2FsZS5zeSk7XG4gICAgICBpZiAoIXRoaXMuI2lzU3ZnKSB7XG4gICAgICAgIGJpdG1hcCA9IHRoaXMuI3NjYWxlQml0bWFwKHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuICAgICAgfVxuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGN0eC5maWx0ZXIgPSB0aGlzLl91aU1hbmFnZXIuaGNtRmlsdGVyO1xuICAgICAgbGV0IHdoaXRlID0gXCJ3aGl0ZVwiLFxuICAgICAgICBibGFjayA9IFwiI2NmY2ZkOFwiO1xuICAgICAgaWYgKHRoaXMuX3VpTWFuYWdlci5oY21GaWx0ZXIgIT09IFwibm9uZVwiKSB7XG4gICAgICAgIGJsYWNrID0gXCJibGFja1wiO1xuICAgICAgfSBlbHNlIGlmICh3aW5kb3cubWF0Y2hNZWRpYT8uKFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiKS5tYXRjaGVzKSB7XG4gICAgICAgIHdoaXRlID0gXCIjOGY4ZjlkXCI7XG4gICAgICAgIGJsYWNrID0gXCIjNDI0MTRkXCI7XG4gICAgICB9XG4gICAgICBjb25zdCBib3hEaW0gPSAxNTtcbiAgICAgIGNvbnN0IGJveERpbVdpZHRoID0gYm94RGltICogb3V0cHV0U2NhbGUuc3g7XG4gICAgICBjb25zdCBib3hEaW1IZWlnaHQgPSBib3hEaW0gKiBvdXRwdXRTY2FsZS5zeTtcbiAgICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKGJveERpbVdpZHRoICogMiwgYm94RGltSGVpZ2h0ICogMik7XG4gICAgICBjb25zdCBwYXR0ZXJuQ3R4ID0gcGF0dGVybi5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBwYXR0ZXJuQ3R4LmZpbGxTdHlsZSA9IHdoaXRlO1xuICAgICAgcGF0dGVybkN0eC5maWxsUmVjdCgwLCAwLCBib3hEaW1XaWR0aCAqIDIsIGJveERpbUhlaWdodCAqIDIpO1xuICAgICAgcGF0dGVybkN0eC5maWxsU3R5bGUgPSBibGFjaztcbiAgICAgIHBhdHRlcm5DdHguZmlsbFJlY3QoMCwgMCwgYm94RGltV2lkdGgsIGJveERpbUhlaWdodCk7XG4gICAgICBwYXR0ZXJuQ3R4LmZpbGxSZWN0KGJveERpbVdpZHRoLCBib3hEaW1IZWlnaHQsIGJveERpbVdpZHRoLCBib3hEaW1IZWlnaHQpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGN0eC5jcmVhdGVQYXR0ZXJuKHBhdHRlcm4sIFwicmVwZWF0XCIpO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDAsIGJpdG1hcC53aWR0aCwgYml0bWFwLmhlaWdodCwgMCwgMCwgc2NhbGVkV2lkdGgsIHNjYWxlZEhlaWdodCk7XG4gICAgfVxuICAgIGxldCBpbWFnZURhdGEgPSBudWxsO1xuICAgIGlmIChjcmVhdGVJbWFnZURhdGEpIHtcbiAgICAgIGxldCBkYXRhV2lkdGgsIGRhdGFIZWlnaHQ7XG4gICAgICBpZiAob3V0cHV0U2NhbGUuc3ltbWV0cmljICYmIGJpdG1hcC53aWR0aCA8IG1heERhdGFEaW1lbnNpb24gJiYgYml0bWFwLmhlaWdodCA8IG1heERhdGFEaW1lbnNpb24pIHtcbiAgICAgICAgZGF0YVdpZHRoID0gYml0bWFwLndpZHRoO1xuICAgICAgICBkYXRhSGVpZ2h0ID0gYml0bWFwLmhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJpdG1hcCA9IHRoaXMuI2JpdG1hcDtcbiAgICAgICAgaWYgKGJpdG1hcFdpZHRoID4gbWF4RGF0YURpbWVuc2lvbiB8fCBiaXRtYXBIZWlnaHQgPiBtYXhEYXRhRGltZW5zaW9uKSB7XG4gICAgICAgICAgY29uc3QgcmF0aW8gPSBNYXRoLm1pbihtYXhEYXRhRGltZW5zaW9uIC8gYml0bWFwV2lkdGgsIG1heERhdGFEaW1lbnNpb24gLyBiaXRtYXBIZWlnaHQpO1xuICAgICAgICAgIGRhdGFXaWR0aCA9IE1hdGguZmxvb3IoYml0bWFwV2lkdGggKiByYXRpbyk7XG4gICAgICAgICAgZGF0YUhlaWdodCA9IE1hdGguZmxvb3IoYml0bWFwSGVpZ2h0ICogcmF0aW8pO1xuICAgICAgICAgIGlmICghdGhpcy4jaXNTdmcpIHtcbiAgICAgICAgICAgIGJpdG1hcCA9IHRoaXMuI3NjYWxlQml0bWFwKGRhdGFXaWR0aCwgZGF0YUhlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKGRhdGFXaWR0aCwgZGF0YUhlaWdodCk7XG4gICAgICBjb25zdCBvZmZzY3JlZW5DdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIG9mZnNjcmVlbkN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBiaXRtYXAud2lkdGgsIGJpdG1hcC5oZWlnaHQsIDAsIDAsIGRhdGFXaWR0aCwgZGF0YUhlaWdodCk7XG4gICAgICBpbWFnZURhdGEgPSB7XG4gICAgICAgIHdpZHRoOiBkYXRhV2lkdGgsXG4gICAgICAgIGhlaWdodDogZGF0YUhlaWdodCxcbiAgICAgICAgZGF0YTogb2Zmc2NyZWVuQ3R4LmdldEltYWdlRGF0YSgwLCAwLCBkYXRhV2lkdGgsIGRhdGFIZWlnaHQpLmRhdGFcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjYW52YXMsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGltYWdlRGF0YVxuICAgIH07XG4gIH1cbiAgI3NjYWxlQml0bWFwKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aDogYml0bWFwV2lkdGgsXG4gICAgICBoZWlnaHQ6IGJpdG1hcEhlaWdodFxuICAgIH0gPSB0aGlzLiNiaXRtYXA7XG4gICAgbGV0IG5ld1dpZHRoID0gYml0bWFwV2lkdGg7XG4gICAgbGV0IG5ld0hlaWdodCA9IGJpdG1hcEhlaWdodDtcbiAgICBsZXQgYml0bWFwID0gdGhpcy4jYml0bWFwO1xuICAgIHdoaWxlIChuZXdXaWR0aCA+IDIgKiB3aWR0aCB8fCBuZXdIZWlnaHQgPiAyICogaGVpZ2h0KSB7XG4gICAgICBjb25zdCBwcmV2V2lkdGggPSBuZXdXaWR0aDtcbiAgICAgIGNvbnN0IHByZXZIZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICBpZiAobmV3V2lkdGggPiAyICogd2lkdGgpIHtcbiAgICAgICAgbmV3V2lkdGggPSBuZXdXaWR0aCA+PSAxNjM4NCA/IE1hdGguZmxvb3IobmV3V2lkdGggLyAyKSAtIDEgOiBNYXRoLmNlaWwobmV3V2lkdGggLyAyKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdIZWlnaHQgPiAyICogaGVpZ2h0KSB7XG4gICAgICAgIG5ld0hlaWdodCA9IG5ld0hlaWdodCA+PSAxNjM4NCA/IE1hdGguZmxvb3IobmV3SGVpZ2h0IC8gMikgLSAxIDogTWF0aC5jZWlsKG5ld0hlaWdodCAvIDIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgIGNvbnN0IGN0eCA9IG9mZnNjcmVlbi5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCwgcHJldldpZHRoLCBwcmV2SGVpZ2h0LCAwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgIGJpdG1hcCA9IG9mZnNjcmVlbi50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIGJpdG1hcDtcbiAgfVxuICAjZHJhd0JpdG1hcCgpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBvdXRwdXRTY2FsZSA9IG5ldyBPdXRwdXRTY2FsZSgpO1xuICAgIGNvbnN0IHNjYWxlZFdpZHRoID0gTWF0aC5jZWlsKHdpZHRoICogcGFyZW50V2lkdGggKiBvdXRwdXRTY2FsZS5zeCk7XG4gICAgY29uc3Qgc2NhbGVkSGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCAqIHBhcmVudEhlaWdodCAqIG91dHB1dFNjYWxlLnN5KTtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLiNjYW52YXM7XG4gICAgaWYgKCFjYW52YXMgfHwgY2FudmFzLndpZHRoID09PSBzY2FsZWRXaWR0aCAmJiBjYW52YXMuaGVpZ2h0ID09PSBzY2FsZWRIZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FudmFzLndpZHRoID0gc2NhbGVkV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHNjYWxlZEhlaWdodDtcbiAgICBjb25zdCBiaXRtYXAgPSB0aGlzLiNpc1N2ZyA/IHRoaXMuI2JpdG1hcCA6IHRoaXMuI3NjYWxlQml0bWFwKHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgY3R4LmZpbHRlciA9IHRoaXMuX3VpTWFuYWdlci5oY21GaWx0ZXI7XG4gICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDAsIGJpdG1hcC53aWR0aCwgYml0bWFwLmhlaWdodCwgMCwgMCwgc2NhbGVkV2lkdGgsIHNjYWxlZEhlaWdodCk7XG4gIH1cbiAgZ2V0SW1hZ2VGb3JBbHRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiNjYW52YXM7XG4gIH1cbiAgI3NlcmlhbGl6ZUJpdG1hcCh0b1VybCkge1xuICAgIGlmICh0b1VybCkge1xuICAgICAgaWYgKHRoaXMuI2lzU3ZnKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0U3ZnVXJsKHRoaXMuI2JpdG1hcElkKTtcbiAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAoe1xuICAgICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHRcbiAgICAgIH0gPSB0aGlzLiNiaXRtYXApO1xuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy4jYml0bWFwLCAwLCAwKTtcbiAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNpc1N2Zykge1xuICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLnJvdW5kKHRoaXMud2lkdGggKiBwYWdlV2lkdGggKiBQaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFMpO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQgKiBQaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFMpO1xuICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnN0IGN0eCA9IG9mZnNjcmVlbi5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHguZHJhd0ltYWdlKHRoaXMuI2JpdG1hcCwgMCwgMCwgdGhpcy4jYml0bWFwLndpZHRoLCB0aGlzLiNiaXRtYXAuaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHJldHVybiBvZmZzY3JlZW4udHJhbnNmZXJUb0ltYWdlQml0bWFwKCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUodGhpcy4jYml0bWFwKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBsZXQgaW5pdGlhbERhdGEgPSBudWxsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgU3RhbXBBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcmVjdCxcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBzdHJ1Y3RQYXJlbnQsXG4gICAgICAgICAgcG9wdXBSZWZcbiAgICAgICAgfSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgICBwYWdlTnVtYmVyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiY2FudmFzXCIpO1xuICAgICAgY29uc3QgaW1hZ2VEYXRhID0gdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tQ2FudmFzKGNvbnRhaW5lci5pZCwgY2FudmFzKTtcbiAgICAgIGNhbnZhcy5yZW1vdmUoKTtcbiAgICAgIGNvbnN0IGFsdFRleHQgPSAoYXdhaXQgcGFyZW50Ll9zdHJ1Y3RUcmVlLmdldEFyaWFBdHRyaWJ1dGVzKGAke0Fubm90YXRpb25QcmVmaXh9JHtpZH1gKSk/LmdldChcImFyaWEtbGFiZWxcIikgfHwgXCJcIjtcbiAgICAgIGluaXRpYWxEYXRhID0gZGF0YSA9IHtcbiAgICAgICAgYW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QLFxuICAgICAgICBiaXRtYXBJZDogaW1hZ2VEYXRhLmlkLFxuICAgICAgICBiaXRtYXA6IGltYWdlRGF0YS5iaXRtYXAsXG4gICAgICAgIHBhZ2VJbmRleDogcGFnZU51bWJlciAtIDEsXG4gICAgICAgIHJlY3Q6IHJlY3Quc2xpY2UoMCksXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBpZCxcbiAgICAgICAgZGVsZXRlZDogZmFsc2UsXG4gICAgICAgIGFjY2Vzc2liaWxpdHlEYXRhOiB7XG4gICAgICAgICAgZGVjb3JhdGl2ZTogZmFsc2UsXG4gICAgICAgICAgYWx0VGV4dFxuICAgICAgICB9LFxuICAgICAgICBpc1N2ZzogZmFsc2UsXG4gICAgICAgIHN0cnVjdFBhcmVudCxcbiAgICAgICAgcG9wdXBSZWZcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKTtcbiAgICBjb25zdCB7XG4gICAgICByZWN0LFxuICAgICAgYml0bWFwLFxuICAgICAgYml0bWFwVXJsLFxuICAgICAgYml0bWFwSWQsXG4gICAgICBpc1N2ZyxcbiAgICAgIGFjY2Vzc2liaWxpdHlEYXRhXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGJpdG1hcElkICYmIHVpTWFuYWdlci5pbWFnZU1hbmFnZXIuaXNWYWxpZElkKGJpdG1hcElkKSkge1xuICAgICAgZWRpdG9yLiNiaXRtYXBJZCA9IGJpdG1hcElkO1xuICAgICAgaWYgKGJpdG1hcCkge1xuICAgICAgICBlZGl0b3IuI2JpdG1hcCA9IGJpdG1hcDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWRpdG9yLiNiaXRtYXBVcmwgPSBiaXRtYXBVcmw7XG4gICAgfVxuICAgIGVkaXRvci4jaXNTdmcgPSBpc1N2ZztcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSBlZGl0b3IucGFnZURpbWVuc2lvbnM7XG4gICAgZWRpdG9yLndpZHRoID0gKHJlY3RbMl0gLSByZWN0WzBdKSAvIHBhcmVudFdpZHRoO1xuICAgIGVkaXRvci5oZWlnaHQgPSAocmVjdFszXSAtIHJlY3RbMV0pIC8gcGFyZW50SGVpZ2h0O1xuICAgIGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkID0gZGF0YS5pZCB8fCBudWxsO1xuICAgIGlmIChhY2Nlc3NpYmlsaXR5RGF0YSkge1xuICAgICAgZWRpdG9yLmFsdFRleHREYXRhID0gYWNjZXNzaWJpbGl0eURhdGE7XG4gICAgfVxuICAgIGVkaXRvci5faW5pdGlhbERhdGEgPSBpbml0aWFsRGF0YTtcbiAgICBlZGl0b3IuI2hhc0JlZW5BZGRlZEluVW5kb1N0YWNrID0gISFpbml0aWFsRGF0YTtcbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIHNlcmlhbGl6ZShpc0ZvckNvcHlpbmcgPSBmYWxzZSwgY29udGV4dCA9IG51bGwpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWxldGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVEZWxldGVkKCk7XG4gICAgfVxuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVAsXG4gICAgICBiaXRtYXBJZDogdGhpcy4jYml0bWFwSWQsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4LFxuICAgICAgcmVjdDogdGhpcy5nZXRSZWN0KDAsIDApLFxuICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24sXG4gICAgICBpc1N2ZzogdGhpcy4jaXNTdmcsXG4gICAgICBzdHJ1Y3RUcmVlUGFyZW50SWQ6IHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZFxuICAgIH07XG4gICAgaWYgKGlzRm9yQ29weWluZykge1xuICAgICAgc2VyaWFsaXplZC5iaXRtYXBVcmwgPSB0aGlzLiNzZXJpYWxpemVCaXRtYXAodHJ1ZSk7XG4gICAgICBzZXJpYWxpemVkLmFjY2Vzc2liaWxpdHlEYXRhID0gdGhpcy5zZXJpYWxpemVBbHRUZXh0KHRydWUpO1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGRlY29yYXRpdmUsXG4gICAgICBhbHRUZXh0XG4gICAgfSA9IHRoaXMuc2VyaWFsaXplQWx0VGV4dChmYWxzZSk7XG4gICAgaWYgKCFkZWNvcmF0aXZlICYmIGFsdFRleHQpIHtcbiAgICAgIHNlcmlhbGl6ZWQuYWNjZXNzaWJpbGl0eURhdGEgPSB7XG4gICAgICAgIHR5cGU6IFwiRmlndXJlXCIsXG4gICAgICAgIGFsdDogYWx0VGV4dFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpO1xuICAgICAgaWYgKGNoYW5nZXMuaXNTYW1lKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGNoYW5nZXMuaXNTYW1lQWx0VGV4dCkge1xuICAgICAgICBkZWxldGUgc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcmlhbGl6ZWQuYWNjZXNzaWJpbGl0eURhdGEuc3RydWN0UGFyZW50ID0gdGhpcy5faW5pdGlhbERhdGEuc3RydWN0UGFyZW50ID8/IC0xO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXJpYWxpemVkLmlkID0gdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgY29udGV4dC5zdGFtcHMgfHw9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBhcmVhID0gdGhpcy4jaXNTdmcgPyAoc2VyaWFsaXplZC5yZWN0WzJdIC0gc2VyaWFsaXplZC5yZWN0WzBdKSAqIChzZXJpYWxpemVkLnJlY3RbM10gLSBzZXJpYWxpemVkLnJlY3RbMV0pIDogbnVsbDtcbiAgICBpZiAoIWNvbnRleHQuc3RhbXBzLmhhcyh0aGlzLiNiaXRtYXBJZCkpIHtcbiAgICAgIGNvbnRleHQuc3RhbXBzLnNldCh0aGlzLiNiaXRtYXBJZCwge1xuICAgICAgICBhcmVhLFxuICAgICAgICBzZXJpYWxpemVkXG4gICAgICB9KTtcbiAgICAgIHNlcmlhbGl6ZWQuYml0bWFwID0gdGhpcy4jc2VyaWFsaXplQml0bWFwKGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI2lzU3ZnKSB7XG4gICAgICBjb25zdCBwcmV2RGF0YSA9IGNvbnRleHQuc3RhbXBzLmdldCh0aGlzLiNiaXRtYXBJZCk7XG4gICAgICBpZiAoYXJlYSA+IHByZXZEYXRhLmFyZWEpIHtcbiAgICAgICAgcHJldkRhdGEuYXJlYSA9IGFyZWE7XG4gICAgICAgIHByZXZEYXRhLnNlcmlhbGl6ZWQuYml0bWFwLmNsb3NlKCk7XG4gICAgICAgIHByZXZEYXRhLnNlcmlhbGl6ZWQuYml0bWFwID0gdGhpcy4jc2VyaWFsaXplQml0bWFwKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cbiAgI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlSW5kZXgsXG4gICAgICBhY2Nlc3NpYmlsaXR5RGF0YToge1xuICAgICAgICBhbHRUZXh0XG4gICAgICB9XG4gICAgfSA9IHRoaXMuX2luaXRpYWxEYXRhO1xuICAgIGNvbnN0IGlzU2FtZVBhZ2VJbmRleCA9IHNlcmlhbGl6ZWQucGFnZUluZGV4ID09PSBwYWdlSW5kZXg7XG4gICAgY29uc3QgaXNTYW1lQWx0VGV4dCA9IChzZXJpYWxpemVkLmFjY2Vzc2liaWxpdHlEYXRhPy5hbHQgfHwgXCJcIikgPT09IGFsdFRleHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzU2FtZTogIXRoaXMuX2hhc0JlZW5Nb3ZlZCAmJiAhdGhpcy5faGFzQmVlblJlc2l6ZWQgJiYgaXNTYW1lUGFnZUluZGV4ICYmIGlzU2FtZUFsdFRleHQsXG4gICAgICBpc1NhbWVBbHRUZXh0XG4gICAgfTtcbiAgfVxuICByZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgYW5ub3RhdGlvbi51cGRhdGVFZGl0ZWQoe1xuICAgICAgcmVjdDogdGhpcy5nZXRSZWN0KDAsIDApXG4gICAgfSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2Fubm90YXRpb25fZWRpdG9yX2xheWVyLmpzXG5cblxuXG5cblxuXG5cbmNsYXNzIEFubm90YXRpb25FZGl0b3JMYXllciB7XG4gICNhY2Nlc3NpYmlsaXR5TWFuYWdlcjtcbiAgI2FsbG93Q2xpY2sgPSBmYWxzZTtcbiAgI2Fubm90YXRpb25MYXllciA9IG51bGw7XG4gICNjbGlja0FDID0gbnVsbDtcbiAgI2VkaXRvckZvY3VzVGltZW91dElkID0gbnVsbDtcbiAgI2VkaXRvcnMgPSBuZXcgTWFwKCk7XG4gICNoYWRQb2ludGVyRG93biA9IGZhbHNlO1xuICAjaXNEaXNhYmxpbmcgPSBmYWxzZTtcbiAgI2lzRW5hYmxpbmcgPSBmYWxzZTtcbiAgI2RyYXdpbmdBQyA9IG51bGw7XG4gICNmb2N1c2VkRWxlbWVudCA9IG51bGw7XG4gICN0ZXh0TGF5ZXIgPSBudWxsO1xuICAjdGV4dFNlbGVjdGlvbkFDID0gbnVsbDtcbiAgI3VpTWFuYWdlcjtcbiAgc3RhdGljIF9pbml0aWFsaXplZCA9IGZhbHNlO1xuICBzdGF0aWMgI2VkaXRvclR5cGVzID0gbmV3IE1hcChbRnJlZVRleHRFZGl0b3IsIElua0VkaXRvciwgU3RhbXBFZGl0b3IsIEhpZ2hsaWdodEVkaXRvcl0ubWFwKHR5cGUgPT4gW3R5cGUuX2VkaXRvclR5cGUsIHR5cGVdKSk7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1aU1hbmFnZXIsXG4gICAgcGFnZUluZGV4LFxuICAgIGRpdixcbiAgICBzdHJ1Y3RUcmVlTGF5ZXIsXG4gICAgYWNjZXNzaWJpbGl0eU1hbmFnZXIsXG4gICAgYW5ub3RhdGlvbkxheWVyLFxuICAgIGRyYXdMYXllcixcbiAgICB0ZXh0TGF5ZXIsXG4gICAgdmlld3BvcnQsXG4gICAgbDEwblxuICB9KSB7XG4gICAgY29uc3QgZWRpdG9yVHlwZXMgPSBbLi4uQW5ub3RhdGlvbkVkaXRvckxheWVyLiNlZGl0b3JUeXBlcy52YWx1ZXMoKV07XG4gICAgaWYgKCFBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuX2luaXRpYWxpemVkKSB7XG4gICAgICBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiBlZGl0b3JUeXBlcykge1xuICAgICAgICBlZGl0b3JUeXBlLmluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdWlNYW5hZ2VyLnJlZ2lzdGVyRWRpdG9yVHlwZXMoZWRpdG9yVHlwZXMpO1xuICAgIHRoaXMuI3VpTWFuYWdlciA9IHVpTWFuYWdlcjtcbiAgICB0aGlzLnBhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICB0aGlzLmRpdiA9IGRpdjtcbiAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlciA9IGFjY2Vzc2liaWxpdHlNYW5hZ2VyO1xuICAgIHRoaXMuI2Fubm90YXRpb25MYXllciA9IGFubm90YXRpb25MYXllcjtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgdGhpcy4jdGV4dExheWVyID0gdGV4dExheWVyO1xuICAgIHRoaXMuZHJhd0xheWVyID0gZHJhd0xheWVyO1xuICAgIHRoaXMuX3N0cnVjdFRyZWUgPSBzdHJ1Y3RUcmVlTGF5ZXI7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZExheWVyKHRoaXMpO1xuICB9XG4gIGdldCBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLiNlZGl0b3JzLnNpemUgPT09IDA7XG4gIH1cbiAgZ2V0IGlzSW52aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmlzRW1wdHkgJiYgdGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORTtcbiAgfVxuICB1cGRhdGVUb29sYmFyKG1vZGUpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudXBkYXRlVG9vbGJhcihtb2RlKTtcbiAgfVxuICB1cGRhdGVNb2RlKG1vZGUgPSB0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpKSB7XG4gICAgdGhpcy4jY2xlYW51cCgpO1xuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FOlxuICAgICAgICB0aGlzLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyhmYWxzZSk7XG4gICAgICAgIHRoaXMudG9nZ2xlQW5ub3RhdGlvbkxheWVyUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlQ2xpY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5JTks6XG4gICAgICAgIHRoaXMuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy50b2dnbGVQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgICAgICB0aGlzLmVuYWJsZUNsaWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQ6XG4gICAgICAgIHRoaXMuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnRvZ2dsZVBvaW50ZXJFdmVudHMoZmFsc2UpO1xuICAgICAgICB0aGlzLmRpc2FibGVDbGljaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy50b2dnbGVQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgICAgICB0aGlzLmVuYWJsZUNsaWNrKCk7XG4gICAgfVxuICAgIHRoaXMudG9nZ2xlQW5ub3RhdGlvbkxheWVyUG9pbnRlckV2ZW50cyhmYWxzZSk7XG4gICAgY29uc3Qge1xuICAgICAgY2xhc3NMaXN0XG4gICAgfSA9IHRoaXMuZGl2O1xuICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuI2VkaXRvclR5cGVzLnZhbHVlcygpKSB7XG4gICAgICBjbGFzc0xpc3QudG9nZ2xlKGAke2VkaXRvclR5cGUuX3R5cGV9RWRpdGluZ2AsIG1vZGUgPT09IGVkaXRvclR5cGUuX2VkaXRvclR5cGUpO1xuICAgIH1cbiAgICB0aGlzLmRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgfVxuICBoYXNUZXh0TGF5ZXIodGV4dExheWVyKSB7XG4gICAgcmV0dXJuIHRleHRMYXllciA9PT0gdGhpcy4jdGV4dExheWVyPy5kaXY7XG4gIH1cbiAgc2V0RWRpdGluZ1N0YXRlKGlzRWRpdGluZykge1xuICAgIHRoaXMuI3VpTWFuYWdlci5zZXRFZGl0aW5nU3RhdGUoaXNFZGl0aW5nKTtcbiAgfVxuICBhZGRDb21tYW5kcyhwYXJhbXMpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuYWRkQ29tbWFuZHMocGFyYW1zKTtcbiAgfVxuICBjbGVhblVuZG9TdGFjayh0eXBlKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmNsZWFuVW5kb1N0YWNrKHR5cGUpO1xuICB9XG4gIHRvZ2dsZURyYXdpbmcoZW5hYmxlZCA9IGZhbHNlKSB7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRyYXdpbmdcIiwgIWVuYWJsZWQpO1xuICB9XG4gIHRvZ2dsZVBvaW50ZXJFdmVudHMoZW5hYmxlZCA9IGZhbHNlKSB7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsICFlbmFibGVkKTtcbiAgfVxuICB0b2dnbGVBbm5vdGF0aW9uTGF5ZXJQb2ludGVyRXZlbnRzKGVuYWJsZWQgPSBmYWxzZSkge1xuICAgIHRoaXMuI2Fubm90YXRpb25MYXllcj8uZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJkaXNhYmxlZFwiLCAhZW5hYmxlZCk7XG4gIH1cbiAgYXN5bmMgZW5hYmxlKCkge1xuICAgIHRoaXMuI2lzRW5hYmxpbmcgPSB0cnVlO1xuICAgIHRoaXMuZGl2LnRhYkluZGV4ID0gMDtcbiAgICB0aGlzLnRvZ2dsZVBvaW50ZXJFdmVudHModHJ1ZSk7XG4gICAgY29uc3QgYW5ub3RhdGlvbkVsZW1lbnRJZHMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgZWRpdG9yLmVuYWJsZUVkaXRpbmcoKTtcbiAgICAgIGVkaXRvci5zaG93KHRydWUpO1xuICAgICAgaWYgKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICAgIHRoaXMuI3VpTWFuYWdlci5yZW1vdmVDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKGVkaXRvcik7XG4gICAgICAgIGFubm90YXRpb25FbGVtZW50SWRzLmFkZChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy4jYW5ub3RhdGlvbkxheWVyKSB7XG4gICAgICB0aGlzLiNpc0VuYWJsaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRhYmxlcyA9IHRoaXMuI2Fubm90YXRpb25MYXllci5nZXRFZGl0YWJsZUFubm90YXRpb25zKCk7XG4gICAgZm9yIChjb25zdCBlZGl0YWJsZSBvZiBlZGl0YWJsZXMpIHtcbiAgICAgIGVkaXRhYmxlLmhpZGUoKTtcbiAgICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdGFibGUuZGF0YS5pZCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoYW5ub3RhdGlvbkVsZW1lbnRJZHMuaGFzKGVkaXRhYmxlLmRhdGEuaWQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZWRpdG9yID0gYXdhaXQgdGhpcy5kZXNlcmlhbGl6ZShlZGl0YWJsZSk7XG4gICAgICBpZiAoIWVkaXRvcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkT3JSZWJ1aWxkKGVkaXRvcik7XG4gICAgICBlZGl0b3IuZW5hYmxlRWRpdGluZygpO1xuICAgIH1cbiAgICB0aGlzLiNpc0VuYWJsaW5nID0gZmFsc2U7XG4gIH1cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLiNpc0Rpc2FibGluZyA9IHRydWU7XG4gICAgdGhpcy5kaXYudGFiSW5kZXggPSAtMTtcbiAgICB0aGlzLnRvZ2dsZVBvaW50ZXJFdmVudHMoZmFsc2UpO1xuICAgIGNvbnN0IGNoYW5nZWRBbm5vdGF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCByZXNldEFubm90YXRpb25zID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGVkaXRvci5kaXNhYmxlRWRpdGluZygpO1xuICAgICAgaWYgKCFlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlZGl0b3Iuc2VyaWFsaXplKCkgIT09IG51bGwpIHtcbiAgICAgICAgY2hhbmdlZEFubm90YXRpb25zLnNldChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCwgZWRpdG9yKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNldEFubm90YXRpb25zLnNldChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCwgZWRpdG9yKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2V0RWRpdGFibGVBbm5vdGF0aW9uKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKT8uc2hvdygpO1xuICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYW5ub3RhdGlvbkxheWVyKSB7XG4gICAgICBjb25zdCBlZGl0YWJsZXMgPSB0aGlzLiNhbm5vdGF0aW9uTGF5ZXIuZ2V0RWRpdGFibGVBbm5vdGF0aW9ucygpO1xuICAgICAgZm9yIChjb25zdCBlZGl0YWJsZSBvZiBlZGl0YWJsZXMpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGlkXG4gICAgICAgIH0gPSBlZGl0YWJsZS5kYXRhO1xuICAgICAgICBpZiAodGhpcy4jdWlNYW5hZ2VyLmlzRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGlkKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlZGl0b3IgPSByZXNldEFubm90YXRpb25zLmdldChpZCk7XG4gICAgICAgIGlmIChlZGl0b3IpIHtcbiAgICAgICAgICBlZGl0b3IucmVzZXRBbm5vdGF0aW9uRWxlbWVudChlZGl0YWJsZSk7XG4gICAgICAgICAgZWRpdG9yLnNob3coZmFsc2UpO1xuICAgICAgICAgIGVkaXRhYmxlLnNob3coKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3IgPSBjaGFuZ2VkQW5ub3RhdGlvbnMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGVkaXRvcikge1xuICAgICAgICAgIHRoaXMuI3VpTWFuYWdlci5hZGRDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKGVkaXRvcik7XG4gICAgICAgICAgaWYgKGVkaXRvci5yZW5kZXJBbm5vdGF0aW9uRWxlbWVudChlZGl0YWJsZSkpIHtcbiAgICAgICAgICAgIGVkaXRvci5zaG93KGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWRpdGFibGUuc2hvdygpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNjbGVhbnVwKCk7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSkge1xuICAgICAgdGhpcy5kaXYuaGlkZGVuID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY2xhc3NMaXN0XG4gICAgfSA9IHRoaXMuZGl2O1xuICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuI2VkaXRvclR5cGVzLnZhbHVlcygpKSB7XG4gICAgICBjbGFzc0xpc3QucmVtb3ZlKGAke2VkaXRvclR5cGUuX3R5cGV9RWRpdGluZ2ApO1xuICAgIH1cbiAgICB0aGlzLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgdGhpcy50b2dnbGVBbm5vdGF0aW9uTGF5ZXJQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgIHRoaXMuI2lzRGlzYWJsaW5nID0gZmFsc2U7XG4gIH1cbiAgZ2V0RWRpdGFibGVBbm5vdGF0aW9uKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Fubm90YXRpb25MYXllcj8uZ2V0RWRpdGFibGVBbm5vdGF0aW9uKGlkKSB8fCBudWxsO1xuICB9XG4gIHNldEFjdGl2ZUVkaXRvcihlZGl0b3IpIHtcbiAgICBjb25zdCBjdXJyZW50QWN0aXZlID0gdGhpcy4jdWlNYW5hZ2VyLmdldEFjdGl2ZSgpO1xuICAgIGlmIChjdXJyZW50QWN0aXZlID09PSBlZGl0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnNldEFjdGl2ZUVkaXRvcihlZGl0b3IpO1xuICB9XG4gIGVuYWJsZVRleHRTZWxlY3Rpb24oKSB7XG4gICAgdGhpcy5kaXYudGFiSW5kZXggPSAtMTtcbiAgICBpZiAodGhpcy4jdGV4dExheWVyPy5kaXYgJiYgIXRoaXMuI3RleHRTZWxlY3Rpb25BQykge1xuICAgICAgdGhpcy4jdGV4dFNlbGVjdGlvbkFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI3RleHRTZWxlY3Rpb25BQyk7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiN0ZXh0TGF5ZXJQb2ludGVyRG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRpbmdcIik7XG4gICAgfVxuICB9XG4gIGRpc2FibGVUZXh0U2VsZWN0aW9uKCkge1xuICAgIHRoaXMuZGl2LnRhYkluZGV4ID0gMDtcbiAgICBpZiAodGhpcy4jdGV4dExheWVyPy5kaXYgJiYgdGhpcy4jdGV4dFNlbGVjdGlvbkFDKSB7XG4gICAgICB0aGlzLiN0ZXh0U2VsZWN0aW9uQUMuYWJvcnQoKTtcbiAgICAgIHRoaXMuI3RleHRTZWxlY3Rpb25BQyA9IG51bGw7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJoaWdobGlnaHRpbmdcIik7XG4gICAgfVxuICB9XG4gICN0ZXh0TGF5ZXJQb2ludGVyRG93bihldmVudCkge1xuICAgIHRoaXMuI3VpTWFuYWdlci51bnNlbGVjdEFsbCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldFxuICAgIH0gPSBldmVudDtcbiAgICBpZiAodGFyZ2V0ID09PSB0aGlzLiN0ZXh0TGF5ZXIuZGl2IHx8ICh0YXJnZXQuZ2V0QXR0cmlidXRlKFwicm9sZVwiKSA9PT0gXCJpbWdcIiB8fCB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZW5kT2ZDb250ZW50XCIpKSAmJiB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaXNNYWNcbiAgICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3VpTWFuYWdlci5zaG93QWxsRWRpdG9ycyhcImhpZ2hsaWdodFwiLCB0cnVlLCB0cnVlKTtcbiAgICAgIHRoaXMuI3RleHRMYXllci5kaXYuY2xhc3NMaXN0LmFkZChcImZyZWVcIik7XG4gICAgICB0aGlzLnRvZ2dsZURyYXdpbmcoKTtcbiAgICAgIEhpZ2hsaWdodEVkaXRvci5zdGFydEhpZ2hsaWdodGluZyh0aGlzLCB0aGlzLiN1aU1hbmFnZXIuZGlyZWN0aW9uID09PSBcImx0clwiLCB7XG4gICAgICAgIHRhcmdldDogdGhpcy4jdGV4dExheWVyLmRpdixcbiAgICAgICAgeDogZXZlbnQueCxcbiAgICAgICAgeTogZXZlbnQueVxuICAgICAgfSk7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJmcmVlXCIpO1xuICAgICAgICB0aGlzLnRvZ2dsZURyYXdpbmcodHJ1ZSk7XG4gICAgICB9LCB7XG4gICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgIHNpZ25hbDogdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWxcbiAgICAgIH0pO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgZW5hYmxlQ2xpY2soKSB7XG4gICAgaWYgKHRoaXMuI2NsaWNrQUMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY2xpY2tBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiN1aU1hbmFnZXIuY29tYmluZWRTaWduYWwodGhpcy4jY2xpY2tBQyk7XG4gICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMucG9pbnRlcmRvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3QgcG9pbnRlcnVwID0gdGhpcy5wb2ludGVydXAuYmluZCh0aGlzKTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJ1cCwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJjYW5jZWxcIiwgcG9pbnRlcnVwLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICBkaXNhYmxlQ2xpY2soKSB7XG4gICAgdGhpcy4jY2xpY2tBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNjbGlja0FDID0gbnVsbDtcbiAgfVxuICBhdHRhY2goZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9ycy5zZXQoZWRpdG9yLmlkLCBlZGl0b3IpO1xuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25FbGVtZW50SWRcbiAgICB9ID0gZWRpdG9yO1xuICAgIGlmIChhbm5vdGF0aW9uRWxlbWVudElkICYmIHRoaXMuI3VpTWFuYWdlci5pc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uRWxlbWVudElkKSkge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLnJlbW92ZURlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBkZXRhY2goZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9ycy5kZWxldGUoZWRpdG9yLmlkKTtcbiAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlcj8ucmVtb3ZlUG9pbnRlckluVGV4dExheWVyKGVkaXRvci5jb250ZW50RGl2KTtcbiAgICBpZiAoIXRoaXMuI2lzRGlzYWJsaW5nICYmIGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuYWRkRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvcik7XG4gICAgfVxuICB9XG4gIHJlbW92ZShlZGl0b3IpIHtcbiAgICB0aGlzLmRldGFjaChlZGl0b3IpO1xuICAgIHRoaXMuI3VpTWFuYWdlci5yZW1vdmVFZGl0b3IoZWRpdG9yKTtcbiAgICBlZGl0b3IuZGl2LnJlbW92ZSgpO1xuICAgIGVkaXRvci5pc0F0dGFjaGVkVG9ET00gPSBmYWxzZTtcbiAgfVxuICBjaGFuZ2VQYXJlbnQoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5wYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVkaXRvci5wYXJlbnQgJiYgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5hZGREZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgICAgQW5ub3RhdGlvbkVkaXRvci5kZWxldGVBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpO1xuICAgICAgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmF0dGFjaChlZGl0b3IpO1xuICAgIGVkaXRvci5wYXJlbnQ/LmRldGFjaChlZGl0b3IpO1xuICAgIGVkaXRvci5zZXRQYXJlbnQodGhpcyk7XG4gICAgaWYgKGVkaXRvci5kaXYgJiYgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgZWRpdG9yLmRpdi5yZW1vdmUoKTtcbiAgICAgIHRoaXMuZGl2LmFwcGVuZChlZGl0b3IuZGl2KTtcbiAgICB9XG4gIH1cbiAgYWRkKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IucGFyZW50ID09PSB0aGlzICYmIGVkaXRvci5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VQYXJlbnQoZWRpdG9yKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIuYWRkRWRpdG9yKGVkaXRvcik7XG4gICAgdGhpcy5hdHRhY2goZWRpdG9yKTtcbiAgICBpZiAoIWVkaXRvci5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIGNvbnN0IGRpdiA9IGVkaXRvci5yZW5kZXIoKTtcbiAgICAgIHRoaXMuZGl2LmFwcGVuZChkaXYpO1xuICAgICAgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSA9IHRydWU7XG4gICAgfVxuICAgIGVkaXRvci5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgIGVkaXRvci5vbmNlQWRkZWQoIXRoaXMuI2lzRW5hYmxpbmcpO1xuICAgIHRoaXMuI3VpTWFuYWdlci5hZGRUb0Fubm90YXRpb25TdG9yYWdlKGVkaXRvcik7XG4gICAgZWRpdG9yLl9yZXBvcnRUZWxlbWV0cnkoZWRpdG9yLnRlbGVtZXRyeUluaXRpYWxEYXRhKTtcbiAgfVxuICBtb3ZlRWRpdG9ySW5ET00oZWRpdG9yKSB7XG4gICAgaWYgKCFlZGl0b3IuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFjdGl2ZUVsZW1lbnRcbiAgICB9ID0gZG9jdW1lbnQ7XG4gICAgaWYgKGVkaXRvci5kaXYuY29udGFpbnMoYWN0aXZlRWxlbWVudCkgJiYgIXRoaXMuI2VkaXRvckZvY3VzVGltZW91dElkKSB7XG4gICAgICBlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgdGhpcy4jZWRpdG9yRm9jdXNUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy4jZWRpdG9yRm9jdXNUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICBpZiAoIWVkaXRvci5kaXYuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICBlZGl0b3IuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsICgpID0+IHtcbiAgICAgICAgICAgIGVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgICAgc2lnbmFsOiB0aGlzLiN1aU1hbmFnZXIuX3NpZ25hbFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH1cbiAgICBlZGl0b3IuX3N0cnVjdFRyZWVQYXJlbnRJZCA9IHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5tb3ZlRWxlbWVudEluRE9NKHRoaXMuZGl2LCBlZGl0b3IuZGl2LCBlZGl0b3IuY29udGVudERpdiwgdHJ1ZSk7XG4gIH1cbiAgYWRkT3JSZWJ1aWxkKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IubmVlZHNUb0JlUmVidWlsdCgpKSB7XG4gICAgICBlZGl0b3IucGFyZW50IHx8PSB0aGlzO1xuICAgICAgZWRpdG9yLnJlYnVpbGQoKTtcbiAgICAgIGVkaXRvci5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkKGVkaXRvcik7XG4gICAgfVxuICB9XG4gIGFkZFVuZG9hYmxlRWRpdG9yKGVkaXRvcikge1xuICAgIGNvbnN0IGNtZCA9ICgpID0+IGVkaXRvci5fdWlNYW5hZ2VyLnJlYnVpbGQoZWRpdG9yKTtcbiAgICBjb25zdCB1bmRvID0gKCkgPT4ge1xuICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQsXG4gICAgICB1bmRvLFxuICAgICAgbXVzdEV4ZWM6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgZ2V0TmV4dElkKCkge1xuICAgIHJldHVybiB0aGlzLiN1aU1hbmFnZXIuZ2V0SWQoKTtcbiAgfVxuICBnZXQgI2N1cnJlbnRFZGl0b3JUeXBlKCkge1xuICAgIHJldHVybiBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuI2VkaXRvclR5cGVzLmdldCh0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpKTtcbiAgfVxuICBjb21iaW5lZFNpZ25hbChhYykge1xuICAgIHJldHVybiB0aGlzLiN1aU1hbmFnZXIuY29tYmluZWRTaWduYWwoYWMpO1xuICB9XG4gICNjcmVhdGVOZXdFZGl0b3IocGFyYW1zKSB7XG4gICAgY29uc3QgZWRpdG9yVHlwZSA9IHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlO1xuICAgIHJldHVybiBlZGl0b3JUeXBlID8gbmV3IGVkaXRvclR5cGUucHJvdG90eXBlLmNvbnN0cnVjdG9yKHBhcmFtcykgOiBudWxsO1xuICB9XG4gIGNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yKCkge1xuICAgIHJldHVybiB0aGlzLiNjdXJyZW50RWRpdG9yVHlwZT8uY2FuQ3JlYXRlTmV3RW1wdHlFZGl0b3IoKTtcbiAgfVxuICBwYXN0ZUVkaXRvcihtb2RlLCBwYXJhbXMpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudXBkYXRlVG9vbGJhcihtb2RlKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIudXBkYXRlTW9kZShtb2RlKTtcbiAgICBjb25zdCB7XG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WVxuICAgIH0gPSB0aGlzLiNnZXRDZW50ZXJQb2ludCgpO1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXROZXh0SWQoKTtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiNjcmVhdGVOZXdFZGl0b3Ioe1xuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgaWQsXG4gICAgICB4OiBvZmZzZXRYLFxuICAgICAgeTogb2Zmc2V0WSxcbiAgICAgIHVpTWFuYWdlcjogdGhpcy4jdWlNYW5hZ2VyLFxuICAgICAgaXNDZW50ZXJlZDogdHJ1ZSxcbiAgICAgIC4uLnBhcmFtc1xuICAgIH0pO1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuYWRkKGVkaXRvcik7XG4gICAgfVxuICB9XG4gIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEpIHtcbiAgICByZXR1cm4gKGF3YWl0IEFubm90YXRpb25FZGl0b3JMYXllci4jZWRpdG9yVHlwZXMuZ2V0KGRhdGEuYW5ub3RhdGlvblR5cGUgPz8gZGF0YS5hbm5vdGF0aW9uRWRpdG9yVHlwZSk/LmRlc2VyaWFsaXplKGRhdGEsIHRoaXMsIHRoaXMuI3VpTWFuYWdlcikpIHx8IG51bGw7XG4gIH1cbiAgY3JlYXRlQW5kQWRkTmV3RWRpdG9yKGV2ZW50LCBpc0NlbnRlcmVkLCBkYXRhID0ge30pIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuZ2V0TmV4dElkKCk7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jY3JlYXRlTmV3RWRpdG9yKHtcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIGlkLFxuICAgICAgeDogZXZlbnQub2Zmc2V0WCxcbiAgICAgIHk6IGV2ZW50Lm9mZnNldFksXG4gICAgICB1aU1hbmFnZXI6IHRoaXMuI3VpTWFuYWdlcixcbiAgICAgIGlzQ2VudGVyZWQsXG4gICAgICAuLi5kYXRhXG4gICAgfSk7XG4gICAgaWYgKGVkaXRvcikge1xuICAgICAgdGhpcy5hZGQoZWRpdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICAjZ2V0Q2VudGVyUG9pbnQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB0bFggPSBNYXRoLm1heCgwLCB4KTtcbiAgICBjb25zdCB0bFkgPSBNYXRoLm1heCgwLCB5KTtcbiAgICBjb25zdCBiclggPSBNYXRoLm1pbih3aW5kb3cuaW5uZXJXaWR0aCwgeCArIHdpZHRoKTtcbiAgICBjb25zdCBiclkgPSBNYXRoLm1pbih3aW5kb3cuaW5uZXJIZWlnaHQsIHkgKyBoZWlnaHQpO1xuICAgIGNvbnN0IGNlbnRlclggPSAodGxYICsgYnJYKSAvIDIgLSB4O1xuICAgIGNvbnN0IGNlbnRlclkgPSAodGxZICsgYnJZKSAvIDIgLSB5O1xuICAgIGNvbnN0IFtvZmZzZXRYLCBvZmZzZXRZXSA9IHRoaXMudmlld3BvcnQucm90YXRpb24gJSAxODAgPT09IDAgPyBbY2VudGVyWCwgY2VudGVyWV0gOiBbY2VudGVyWSwgY2VudGVyWF07XG4gICAgcmV0dXJuIHtcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZXG4gICAgfTtcbiAgfVxuICBhZGROZXdFZGl0b3IoKSB7XG4gICAgdGhpcy5jcmVhdGVBbmRBZGROZXdFZGl0b3IodGhpcy4jZ2V0Q2VudGVyUG9pbnQoKSwgdHJ1ZSk7XG4gIH1cbiAgc2V0U2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnNldFNlbGVjdGVkKGVkaXRvcik7XG4gIH1cbiAgdG9nZ2xlU2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnRvZ2dsZVNlbGVjdGVkKGVkaXRvcik7XG4gIH1cbiAgdW5zZWxlY3QoZWRpdG9yKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnVuc2VsZWN0KGVkaXRvcik7XG4gIH1cbiAgcG9pbnRlcnVwKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5kaXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNoYWRQb2ludGVyRG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNoYWRQb2ludGVyRG93biA9IGZhbHNlO1xuICAgIGlmICh0aGlzLiNjdXJyZW50RWRpdG9yVHlwZT8uaXNEcmF3ZXIgJiYgdGhpcy4jY3VycmVudEVkaXRvclR5cGUuc3VwcG9ydE11bHRpcGxlRHJhd2luZ3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNhbGxvd0NsaWNrKSB7XG4gICAgICB0aGlzLiNhbGxvd0NsaWNrID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jcmVhdGVBbmRBZGROZXdFZGl0b3IoZXZlbnQsIGZhbHNlKTtcbiAgfVxuICBwb2ludGVyZG93bihldmVudCkge1xuICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQpIHtcbiAgICAgIHRoaXMuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jaGFkUG9pbnRlckRvd24pIHtcbiAgICAgIHRoaXMuI2hhZFBvaW50ZXJEb3duID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2hhZFBvaW50ZXJEb3duID0gdHJ1ZTtcbiAgICBpZiAodGhpcy4jY3VycmVudEVkaXRvclR5cGU/LmlzRHJhd2VyKSB7XG4gICAgICB0aGlzLnN0YXJ0RHJhd2luZ1Nlc3Npb24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiN1aU1hbmFnZXIuZ2V0QWN0aXZlKCk7XG4gICAgdGhpcy4jYWxsb3dDbGljayA9ICFlZGl0b3IgfHwgZWRpdG9yLmlzRW1wdHkoKTtcbiAgfVxuICBzdGFydERyYXdpbmdTZXNzaW9uKGV2ZW50KSB7XG4gICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgICBpZiAodGhpcy4jZHJhd2luZ0FDKSB7XG4gICAgICB0aGlzLiNjdXJyZW50RWRpdG9yVHlwZS5zdGFydERyYXdpbmcodGhpcywgdGhpcy4jdWlNYW5hZ2VyLCBmYWxzZSwgZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0Q3VycmVudERyYXdpbmdTZXNzaW9uKHRoaXMpO1xuICAgIHRoaXMuI2RyYXdpbmdBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiN1aU1hbmFnZXIuY29tYmluZWRTaWduYWwodGhpcy4jZHJhd2luZ0FDKTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCAoe1xuICAgICAgcmVsYXRlZFRhcmdldFxuICAgIH0pID0+IHtcbiAgICAgIGlmIChyZWxhdGVkVGFyZ2V0ICYmICF0aGlzLmRpdi5jb250YWlucyhyZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICB0aGlzLiNmb2N1c2VkRWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLiNjdXJyZW50RWRpdG9yVHlwZS5zdGFydERyYXdpbmcodGhpcywgdGhpcy4jdWlNYW5hZ2VyLCBmYWxzZSwgZXZlbnQpO1xuICB9XG4gIHBhdXNlKG9uKSB7XG4gICAgaWYgKG9uKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnRcbiAgICAgIH0gPSBkb2N1bWVudDtcbiAgICAgIGlmICh0aGlzLmRpdi5jb250YWlucyhhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICB0aGlzLiNmb2N1c2VkRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNmb2N1c2VkRWxlbWVudCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuI2ZvY3VzZWRFbGVtZW50Py5mb2N1cygpO1xuICAgICAgICB0aGlzLiNmb2N1c2VkRWxlbWVudCA9IG51bGw7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH1cbiAgZW5kRHJhd2luZ1Nlc3Npb24oaXNBYm9ydGVkID0gZmFsc2UpIHtcbiAgICBpZiAoIXRoaXMuI2RyYXdpbmdBQykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRoaXMuI3VpTWFuYWdlci5zZXRDdXJyZW50RHJhd2luZ1Nlc3Npb24obnVsbCk7XG4gICAgdGhpcy4jZHJhd2luZ0FDLmFib3J0KCk7XG4gICAgdGhpcy4jZHJhd2luZ0FDID0gbnVsbDtcbiAgICB0aGlzLiNmb2N1c2VkRWxlbWVudCA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlLmVuZERyYXdpbmcoaXNBYm9ydGVkKTtcbiAgfVxuICBmaW5kTmV3UGFyZW50KGVkaXRvciwgeCwgeSkge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy4jdWlNYW5hZ2VyLmZpbmRQYXJlbnQoeCwgeSk7XG4gICAgaWYgKGxheWVyID09PSBudWxsIHx8IGxheWVyID09PSB0aGlzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxheWVyLmNoYW5nZVBhcmVudChlZGl0b3IpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbW1pdE9yUmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLiNkcmF3aW5nQUMpIHtcbiAgICAgIHRoaXMuZW5kRHJhd2luZ1Nlc3Npb24oKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKCkge1xuICAgIGlmICghdGhpcy4jZHJhd2luZ0FDKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlLm9uU2NhbGVDaGFuZ2luZ1doZW5EcmF3aW5nKHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuZ2V0QWN0aXZlKCk/LnBhcmVudCA9PT0gdGhpcykge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuc2V0QWN0aXZlRWRpdG9yKG51bGwpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jZWRpdG9yRm9jdXNUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCk7XG4gICAgICB0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5yZW1vdmVQb2ludGVySW5UZXh0TGF5ZXIoZWRpdG9yLmNvbnRlbnREaXYpO1xuICAgICAgZWRpdG9yLnNldFBhcmVudChudWxsKTtcbiAgICAgIGVkaXRvci5pc0F0dGFjaGVkVG9ET00gPSBmYWxzZTtcbiAgICAgIGVkaXRvci5kaXYucmVtb3ZlKCk7XG4gICAgfVxuICAgIHRoaXMuZGl2ID0gbnVsbDtcbiAgICB0aGlzLiNlZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnJlbW92ZUxheWVyKHRoaXMpO1xuICB9XG4gICNjbGVhbnVwKCkge1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlZGl0b3IuaXNFbXB0eSgpKSB7XG4gICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVuZGVyKHtcbiAgICB2aWV3cG9ydFxuICB9KSB7XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIHNldExheWVyRGltZW5zaW9ucyh0aGlzLmRpdiwgdmlld3BvcnQpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3VpTWFuYWdlci5nZXRFZGl0b3JzKHRoaXMucGFnZUluZGV4KSkge1xuICAgICAgdGhpcy5hZGQoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5yZWJ1aWxkKCk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlTW9kZSgpO1xuICB9XG4gIHVwZGF0ZSh7XG4gICAgdmlld3BvcnRcbiAgfSkge1xuICAgIHRoaXMuI3VpTWFuYWdlci5jb21taXRPclJlbW92ZSgpO1xuICAgIHRoaXMuI2NsZWFudXAoKTtcbiAgICBjb25zdCBvbGRSb3RhdGlvbiA9IHRoaXMudmlld3BvcnQucm90YXRpb247XG4gICAgY29uc3Qgcm90YXRpb24gPSB2aWV3cG9ydC5yb3RhdGlvbjtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgc2V0TGF5ZXJEaW1lbnNpb25zKHRoaXMuZGl2LCB7XG4gICAgICByb3RhdGlvblxuICAgIH0pO1xuICAgIGlmIChvbGRSb3RhdGlvbiAhPT0gcm90YXRpb24pIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgZWRpdG9yLnJvdGF0ZShyb3RhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBwYWdlRGltZW5zaW9ucygpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0XG4gICAgfSA9IHRoaXMudmlld3BvcnQucmF3RGltcztcbiAgICByZXR1cm4gW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF07XG4gIH1cbiAgZ2V0IHNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLiN1aU1hbmFnZXIudmlld1BhcmFtZXRlcnMucmVhbFNjYWxlO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2RyYXdfbGF5ZXIuanNcblxuXG5jbGFzcyBEcmF3TGF5ZXIge1xuICAjcGFyZW50ID0gbnVsbDtcbiAgI2lkID0gMDtcbiAgI21hcHBpbmcgPSBuZXcgTWFwKCk7XG4gICN0b1VwZGF0ZSA9IG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHBhZ2VJbmRleFxuICB9KSB7XG4gICAgdGhpcy5wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gIH1cbiAgc2V0UGFyZW50KHBhcmVudCkge1xuICAgIGlmICghdGhpcy4jcGFyZW50KSB7XG4gICAgICB0aGlzLiNwYXJlbnQgPSBwYXJlbnQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNwYXJlbnQgIT09IHBhcmVudCkge1xuICAgICAgaWYgKHRoaXMuI21hcHBpbmcuc2l6ZSA+IDApIHtcbiAgICAgICAgZm9yIChjb25zdCByb290IG9mIHRoaXMuI21hcHBpbmcudmFsdWVzKCkpIHtcbiAgICAgICAgICByb290LnJlbW92ZSgpO1xuICAgICAgICAgIHBhcmVudC5hcHBlbmQocm9vdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuI3BhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBfc3ZnRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX3N2Z0ZhY3RvcnlcIiwgbmV3IERPTVNWR0ZhY3RvcnkoKSk7XG4gIH1cbiAgc3RhdGljICNzZXRCb3goZWxlbWVudCwgW3gsIHksIHdpZHRoLCBoZWlnaHRdKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gZWxlbWVudDtcbiAgICBzdHlsZS50b3AgPSBgJHsxMDAgKiB5fSVgO1xuICAgIHN0eWxlLmxlZnQgPSBgJHsxMDAgKiB4fSVgO1xuICAgIHN0eWxlLndpZHRoID0gYCR7MTAwICogd2lkdGh9JWA7XG4gICAgc3R5bGUuaGVpZ2h0ID0gYCR7MTAwICogaGVpZ2h0fSVgO1xuICB9XG4gICNjcmVhdGVTVkcoKSB7XG4gICAgY29uc3Qgc3ZnID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZSgxLCAxLCB0cnVlKTtcbiAgICB0aGlzLiNwYXJlbnQuYXBwZW5kKHN2Zyk7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIHRydWUpO1xuICAgIHJldHVybiBzdmc7XG4gIH1cbiAgI2NyZWF0ZUNsaXBQYXRoKGRlZnMsIHBhdGhJZCkge1xuICAgIGNvbnN0IGNsaXBQYXRoID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJjbGlwUGF0aFwiKTtcbiAgICBkZWZzLmFwcGVuZChjbGlwUGF0aCk7XG4gICAgY29uc3QgY2xpcFBhdGhJZCA9IGBjbGlwXyR7cGF0aElkfWA7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlKFwiaWRcIiwgY2xpcFBhdGhJZCk7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlKFwiY2xpcFBhdGhVbml0c1wiLCBcIm9iamVjdEJvdW5kaW5nQm94XCIpO1xuICAgIGNvbnN0IGNsaXBQYXRoVXNlID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJ1c2VcIik7XG4gICAgY2xpcFBhdGguYXBwZW5kKGNsaXBQYXRoVXNlKTtcbiAgICBjbGlwUGF0aFVzZS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGAjJHtwYXRoSWR9YCk7XG4gICAgY2xpcFBhdGhVc2UuY2xhc3NMaXN0LmFkZChcImNsaXBcIik7XG4gICAgcmV0dXJuIGNsaXBQYXRoSWQ7XG4gIH1cbiAgI3VwZGF0ZVByb3BlcnRpZXMoZWxlbWVudCwgcHJvcGVydGllcykge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BlcnRpZXMpKSB7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkcmF3KHByb3BlcnRpZXMsIGlzUGF0aFVwZGF0YWJsZSA9IGZhbHNlLCBoYXNDbGlwID0gZmFsc2UpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuI2lkKys7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuI2NyZWF0ZVNWRygpO1xuICAgIGNvbnN0IGRlZnMgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImRlZnNcIik7XG4gICAgcm9vdC5hcHBlbmQoZGVmcyk7XG4gICAgY29uc3QgcGF0aCA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwicGF0aFwiKTtcbiAgICBkZWZzLmFwcGVuZChwYXRoKTtcbiAgICBjb25zdCBwYXRoSWQgPSBgcGF0aF9wJHt0aGlzLnBhZ2VJbmRleH1fJHtpZH1gO1xuICAgIHBhdGguc2V0QXR0cmlidXRlKFwiaWRcIiwgcGF0aElkKTtcbiAgICBwYXRoLnNldEF0dHJpYnV0ZShcInZlY3Rvci1lZmZlY3RcIiwgXCJub24tc2NhbGluZy1zdHJva2VcIik7XG4gICAgaWYgKGlzUGF0aFVwZGF0YWJsZSkge1xuICAgICAgdGhpcy4jdG9VcGRhdGUuc2V0KGlkLCBwYXRoKTtcbiAgICB9XG4gICAgY29uc3QgY2xpcFBhdGhJZCA9IGhhc0NsaXAgPyB0aGlzLiNjcmVhdGVDbGlwUGF0aChkZWZzLCBwYXRoSWQpIDogbnVsbDtcbiAgICBjb25zdCB1c2UgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInVzZVwiKTtcbiAgICByb290LmFwcGVuZCh1c2UpO1xuICAgIHVzZS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGAjJHtwYXRoSWR9YCk7XG4gICAgdGhpcy51cGRhdGVQcm9wZXJ0aWVzKHJvb3QsIHByb3BlcnRpZXMpO1xuICAgIHRoaXMuI21hcHBpbmcuc2V0KGlkLCByb290KTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQsXG4gICAgICBjbGlwUGF0aElkOiBgdXJsKCMke2NsaXBQYXRoSWR9KWBcbiAgICB9O1xuICB9XG4gIGRyYXdPdXRsaW5lKHByb3BlcnRpZXMsIG11c3RSZW1vdmVTZWxmSW50ZXJzZWN0aW9ucykge1xuICAgIGNvbnN0IGlkID0gdGhpcy4jaWQrKztcbiAgICBjb25zdCByb290ID0gdGhpcy4jY3JlYXRlU1ZHKCk7XG4gICAgY29uc3QgZGVmcyA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiKTtcbiAgICByb290LmFwcGVuZChkZWZzKTtcbiAgICBjb25zdCBwYXRoID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIpO1xuICAgIGRlZnMuYXBwZW5kKHBhdGgpO1xuICAgIGNvbnN0IHBhdGhJZCA9IGBwYXRoX3Ake3RoaXMucGFnZUluZGV4fV8ke2lkfWA7XG4gICAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBwYXRoSWQpO1xuICAgIHBhdGguc2V0QXR0cmlidXRlKFwidmVjdG9yLWVmZmVjdFwiLCBcIm5vbi1zY2FsaW5nLXN0cm9rZVwiKTtcbiAgICBsZXQgbWFza0lkO1xuICAgIGlmIChtdXN0UmVtb3ZlU2VsZkludGVyc2VjdGlvbnMpIHtcbiAgICAgIGNvbnN0IG1hc2sgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcIm1hc2tcIik7XG4gICAgICBkZWZzLmFwcGVuZChtYXNrKTtcbiAgICAgIG1hc2tJZCA9IGBtYXNrX3Ake3RoaXMucGFnZUluZGV4fV8ke2lkfWA7XG4gICAgICBtYXNrLnNldEF0dHJpYnV0ZShcImlkXCIsIG1hc2tJZCk7XG4gICAgICBtYXNrLnNldEF0dHJpYnV0ZShcIm1hc2tVbml0c1wiLCBcIm9iamVjdEJvdW5kaW5nQm94XCIpO1xuICAgICAgY29uc3QgcmVjdCA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwicmVjdFwiKTtcbiAgICAgIG1hc2suYXBwZW5kKHJlY3QpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjFcIik7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjFcIik7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ3aGl0ZVwiKTtcbiAgICAgIGNvbnN0IHVzZSA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwidXNlXCIpO1xuICAgICAgbWFzay5hcHBlbmQodXNlKTtcbiAgICAgIHVzZS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGAjJHtwYXRoSWR9YCk7XG4gICAgICB1c2Uuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwibm9uZVwiKTtcbiAgICAgIHVzZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwiYmxhY2tcIik7XG4gICAgICB1c2Uuc2V0QXR0cmlidXRlKFwiZmlsbC1ydWxlXCIsIFwibm9uemVyb1wiKTtcbiAgICAgIHVzZS5jbGFzc0xpc3QuYWRkKFwibWFza1wiKTtcbiAgICB9XG4gICAgY29uc3QgdXNlMSA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwidXNlXCIpO1xuICAgIHJvb3QuYXBwZW5kKHVzZTEpO1xuICAgIHVzZTEuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBgIyR7cGF0aElkfWApO1xuICAgIGlmIChtYXNrSWQpIHtcbiAgICAgIHVzZTEuc2V0QXR0cmlidXRlKFwibWFza1wiLCBgdXJsKCMke21hc2tJZH0pYCk7XG4gICAgfVxuICAgIGNvbnN0IHVzZTIgPSB1c2UxLmNsb25lTm9kZSgpO1xuICAgIHJvb3QuYXBwZW5kKHVzZTIpO1xuICAgIHVzZTEuY2xhc3NMaXN0LmFkZChcIm1haW5PdXRsaW5lXCIpO1xuICAgIHVzZTIuY2xhc3NMaXN0LmFkZChcInNlY29uZGFyeU91dGxpbmVcIik7XG4gICAgdGhpcy51cGRhdGVQcm9wZXJ0aWVzKHJvb3QsIHByb3BlcnRpZXMpO1xuICAgIHRoaXMuI21hcHBpbmcuc2V0KGlkLCByb290KTtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgZmluYWxpemVEcmF3KGlkLCBwcm9wZXJ0aWVzKSB7XG4gICAgdGhpcy4jdG9VcGRhdGUuZGVsZXRlKGlkKTtcbiAgICB0aGlzLnVwZGF0ZVByb3BlcnRpZXMoaWQsIHByb3BlcnRpZXMpO1xuICB9XG4gIHVwZGF0ZVByb3BlcnRpZXMoZWxlbWVudE9ySWQsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIXByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcm9vdCxcbiAgICAgIGJib3gsXG4gICAgICByb290Q2xhc3MsXG4gICAgICBwYXRoXG4gICAgfSA9IHByb3BlcnRpZXM7XG4gICAgY29uc3QgZWxlbWVudCA9IHR5cGVvZiBlbGVtZW50T3JJZCA9PT0gXCJudW1iZXJcIiA/IHRoaXMuI21hcHBpbmcuZ2V0KGVsZW1lbnRPcklkKSA6IGVsZW1lbnRPcklkO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocm9vdCkge1xuICAgICAgdGhpcy4jdXBkYXRlUHJvcGVydGllcyhlbGVtZW50LCByb290KTtcbiAgICB9XG4gICAgaWYgKGJib3gpIHtcbiAgICAgIERyYXdMYXllci4jc2V0Qm94KGVsZW1lbnQsIGJib3gpO1xuICAgIH1cbiAgICBpZiAocm9vdENsYXNzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNsYXNzTGlzdFxuICAgICAgfSA9IGVsZW1lbnQ7XG4gICAgICBmb3IgKGNvbnN0IFtjbGFzc05hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyb290Q2xhc3MpKSB7XG4gICAgICAgIGNsYXNzTGlzdC50b2dnbGUoY2xhc3NOYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXRoKSB7XG4gICAgICBjb25zdCBkZWZzID0gZWxlbWVudC5maXJzdENoaWxkO1xuICAgICAgY29uc3QgcGF0aEVsZW1lbnQgPSBkZWZzLmZpcnN0Q2hpbGQ7XG4gICAgICB0aGlzLiN1cGRhdGVQcm9wZXJ0aWVzKHBhdGhFbGVtZW50LCBwYXRoKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlUGFyZW50KGlkLCBsYXllcikge1xuICAgIGlmIChsYXllciA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByb290ID0gdGhpcy4jbWFwcGluZy5nZXQoaWQpO1xuICAgIGlmICghcm9vdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsYXllci4jcGFyZW50LmFwcGVuZChyb290KTtcbiAgICB0aGlzLiNtYXBwaW5nLmRlbGV0ZShpZCk7XG4gICAgbGF5ZXIuI21hcHBpbmcuc2V0KGlkLCByb290KTtcbiAgfVxuICByZW1vdmUoaWQpIHtcbiAgICB0aGlzLiN0b1VwZGF0ZS5kZWxldGUoaWQpO1xuICAgIGlmICh0aGlzLiNwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jbWFwcGluZy5nZXQoaWQpLnJlbW92ZSgpO1xuICAgIHRoaXMuI21hcHBpbmcuZGVsZXRlKGlkKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI3BhcmVudCA9IG51bGw7XG4gICAgZm9yIChjb25zdCByb290IG9mIHRoaXMuI21hcHBpbmcudmFsdWVzKCkpIHtcbiAgICAgIHJvb3QucmVtb3ZlKCk7XG4gICAgfVxuICAgIHRoaXMuI21hcHBpbmcuY2xlYXIoKTtcbiAgICB0aGlzLiN0b1VwZGF0ZS5jbGVhcigpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9wZGYuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5jb25zdCBwZGZqc1ZlcnNpb24gPSBcIjQuMTAuMzhcIjtcbmNvbnN0IHBkZmpzQnVpbGQgPSBcImY5YmVhMzk3ZlwiO1xue1xuICBnbG9iYWxUaGlzLnBkZmpzVGVzdGluZ1V0aWxzID0ge1xuICAgIEhpZ2hsaWdodE91dGxpbmVyOiBIaWdobGlnaHRPdXRsaW5lclxuICB9O1xufVxuXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0Fib3J0RXhjZXB0aW9uID0gX193ZWJwYWNrX2V4cG9ydHNfXy5BYm9ydEV4Y2VwdGlvbjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbkVkaXRvckxheWVyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5Bbm5vdGF0aW9uRWRpdG9yTGF5ZXI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbkVkaXRvclR5cGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkFubm90YXRpb25FZGl0b3JUeXBlO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Bbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5Bbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Bbm5vdGF0aW9uTGF5ZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkFubm90YXRpb25MYXllcjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbk1vZGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkFubm90YXRpb25Nb2RlO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db2xvclBpY2tlciA9IF9fd2VicGFja19leHBvcnRzX18uQ29sb3JQaWNrZXI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0RPTVNWR0ZhY3RvcnkgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkRPTVNWR0ZhY3Rvcnk7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0RyYXdMYXllciA9IF9fd2VicGFja19leHBvcnRzX18uRHJhd0xheWVyO1xudmFyIF9fd2VicGFja19leHBvcnRzX19GZWF0dXJlVGVzdCA9IF9fd2VicGFja19leHBvcnRzX18uRmVhdHVyZVRlc3Q7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0dsb2JhbFdvcmtlck9wdGlvbnMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkdsb2JhbFdvcmtlck9wdGlvbnM7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0ltYWdlS2luZCA9IF9fd2VicGFja19leHBvcnRzX18uSW1hZ2VLaW5kO1xudmFyIF9fd2VicGFja19leHBvcnRzX19JbnZhbGlkUERGRXhjZXB0aW9uID0gX193ZWJwYWNrX2V4cG9ydHNfXy5JbnZhbGlkUERGRXhjZXB0aW9uO1xudmFyIF9fd2VicGFja19leHBvcnRzX19NaXNzaW5nUERGRXhjZXB0aW9uID0gX193ZWJwYWNrX2V4cG9ydHNfXy5NaXNzaW5nUERGRXhjZXB0aW9uO1xudmFyIF9fd2VicGFja19leHBvcnRzX19PUFMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLk9QUztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fT3V0cHV0U2NhbGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLk91dHB1dFNjYWxlO1xudmFyIF9fd2VicGFja19leHBvcnRzX19QREZEYXRhUmFuZ2VUcmFuc3BvcnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlBERkRhdGFSYW5nZVRyYW5zcG9ydDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUERGRGF0ZVN0cmluZyA9IF9fd2VicGFja19leHBvcnRzX18uUERGRGF0ZVN0cmluZztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUERGV29ya2VyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5QREZXb3JrZXI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1Bhc3N3b3JkUmVzcG9uc2VzID0gX193ZWJwYWNrX2V4cG9ydHNfXy5QYXNzd29yZFJlc3BvbnNlcztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUGVybWlzc2lvbkZsYWcgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlBlcm1pc3Npb25GbGFnO1xudmFyIF9fd2VicGFja19leHBvcnRzX19QaXhlbHNQZXJJbmNoID0gX193ZWJwYWNrX2V4cG9ydHNfXy5QaXhlbHNQZXJJbmNoO1xudmFyIF9fd2VicGFja19leHBvcnRzX19SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24gPSBfX3dlYnBhY2tfZXhwb3J0c19fLlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fVGV4dExheWVyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5UZXh0TGF5ZXI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1RvdWNoTWFuYWdlciA9IF9fd2VicGFja19leHBvcnRzX18uVG91Y2hNYW5hZ2VyO1xudmFyIF9fd2VicGFja19leHBvcnRzX19VbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24gPSBfX3dlYnBhY2tfZXhwb3J0c19fLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fVXRpbCA9IF9fd2VicGFja19leHBvcnRzX18uVXRpbDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fVmVyYm9zaXR5TGV2ZWwgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlZlcmJvc2l0eUxldmVsO1xudmFyIF9fd2VicGFja19leHBvcnRzX19YZmFMYXllciA9IF9fd2VicGFja19leHBvcnRzX18uWGZhTGF5ZXI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2J1aWxkID0gX193ZWJwYWNrX2V4cG9ydHNfXy5idWlsZDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCA9IF9fd2VicGFja19leHBvcnRzX18uY3JlYXRlVmFsaWRBYnNvbHV0ZVVybDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fZmV0Y2hEYXRhID0gX193ZWJwYWNrX2V4cG9ydHNfXy5mZXRjaERhdGE7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2dldERvY3VtZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5nZXREb2N1bWVudDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fZ2V0RmlsZW5hbWVGcm9tVXJsID0gX193ZWJwYWNrX2V4cG9ydHNfXy5nZXRGaWxlbmFtZUZyb21Vcmw7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2dldFBkZkZpbGVuYW1lRnJvbVVybCA9IF9fd2VicGFja19leHBvcnRzX18uZ2V0UGRmRmlsZW5hbWVGcm9tVXJsO1xudmFyIF9fd2VicGFja19leHBvcnRzX19nZXRYZmFQYWdlVmlld3BvcnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmdldFhmYVBhZ2VWaWV3cG9ydDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19faXNEYXRhU2NoZW1lID0gX193ZWJwYWNrX2V4cG9ydHNfXy5pc0RhdGFTY2hlbWU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2lzUGRmRmlsZSA9IF9fd2VicGFja19leHBvcnRzX18uaXNQZGZGaWxlO1xudmFyIF9fd2VicGFja19leHBvcnRzX19ub0NvbnRleHRNZW51ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5ub0NvbnRleHRNZW51O1xudmFyIF9fd2VicGFja19leHBvcnRzX19ub3JtYWxpemVVbmljb2RlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5ub3JtYWxpemVVbmljb2RlO1xudmFyIF9fd2VicGFja19leHBvcnRzX19zZXRMYXllckRpbWVuc2lvbnMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnNldExheWVyRGltZW5zaW9ucztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fc2hhZG93ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5zaGFkb3c7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX3N0b3BFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uc3RvcEV2ZW50O1xudmFyIF9fd2VicGFja19leHBvcnRzX192ZXJzaW9uID0gX193ZWJwYWNrX2V4cG9ydHNfXy52ZXJzaW9uO1xuZXhwb3J0IHsgX193ZWJwYWNrX2V4cG9ydHNfX0Fib3J0RXhjZXB0aW9uIGFzIEFib3J0RXhjZXB0aW9uLCBfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbkVkaXRvckxheWVyIGFzIEFubm90YXRpb25FZGl0b3JMYXllciwgX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlIGFzIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLCBfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbkVkaXRvclR5cGUgYXMgQW5ub3RhdGlvbkVkaXRvclR5cGUsIF9fd2VicGFja19leHBvcnRzX19Bbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyIGFzIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIsIF9fd2VicGFja19leHBvcnRzX19Bbm5vdGF0aW9uTGF5ZXIgYXMgQW5ub3RhdGlvbkxheWVyLCBfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbk1vZGUgYXMgQW5ub3RhdGlvbk1vZGUsIF9fd2VicGFja19leHBvcnRzX19Db2xvclBpY2tlciBhcyBDb2xvclBpY2tlciwgX193ZWJwYWNrX2V4cG9ydHNfX0RPTVNWR0ZhY3RvcnkgYXMgRE9NU1ZHRmFjdG9yeSwgX193ZWJwYWNrX2V4cG9ydHNfX0RyYXdMYXllciBhcyBEcmF3TGF5ZXIsIF9fd2VicGFja19leHBvcnRzX19GZWF0dXJlVGVzdCBhcyBGZWF0dXJlVGVzdCwgX193ZWJwYWNrX2V4cG9ydHNfX0dsb2JhbFdvcmtlck9wdGlvbnMgYXMgR2xvYmFsV29ya2VyT3B0aW9ucywgX193ZWJwYWNrX2V4cG9ydHNfX0ltYWdlS2luZCBhcyBJbWFnZUtpbmQsIF9fd2VicGFja19leHBvcnRzX19JbnZhbGlkUERGRXhjZXB0aW9uIGFzIEludmFsaWRQREZFeGNlcHRpb24sIF9fd2VicGFja19leHBvcnRzX19NaXNzaW5nUERGRXhjZXB0aW9uIGFzIE1pc3NpbmdQREZFeGNlcHRpb24sIF9fd2VicGFja19leHBvcnRzX19PUFMgYXMgT1BTLCBfX3dlYnBhY2tfZXhwb3J0c19fT3V0cHV0U2NhbGUgYXMgT3V0cHV0U2NhbGUsIF9fd2VicGFja19leHBvcnRzX19QREZEYXRhUmFuZ2VUcmFuc3BvcnQgYXMgUERGRGF0YVJhbmdlVHJhbnNwb3J0LCBfX3dlYnBhY2tfZXhwb3J0c19fUERGRGF0ZVN0cmluZyBhcyBQREZEYXRlU3RyaW5nLCBfX3dlYnBhY2tfZXhwb3J0c19fUERGV29ya2VyIGFzIFBERldvcmtlciwgX193ZWJwYWNrX2V4cG9ydHNfX1Bhc3N3b3JkUmVzcG9uc2VzIGFzIFBhc3N3b3JkUmVzcG9uc2VzLCBfX3dlYnBhY2tfZXhwb3J0c19fUGVybWlzc2lvbkZsYWcgYXMgUGVybWlzc2lvbkZsYWcsIF9fd2VicGFja19leHBvcnRzX19QaXhlbHNQZXJJbmNoIGFzIFBpeGVsc1BlckluY2gsIF9fd2VicGFja19leHBvcnRzX19SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24gYXMgUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uLCBfX3dlYnBhY2tfZXhwb3J0c19fVGV4dExheWVyIGFzIFRleHRMYXllciwgX193ZWJwYWNrX2V4cG9ydHNfX1RvdWNoTWFuYWdlciBhcyBUb3VjaE1hbmFnZXIsIF9fd2VicGFja19leHBvcnRzX19VbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24gYXMgVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uLCBfX3dlYnBhY2tfZXhwb3J0c19fVXRpbCBhcyBVdGlsLCBfX3dlYnBhY2tfZXhwb3J0c19fVmVyYm9zaXR5TGV2ZWwgYXMgVmVyYm9zaXR5TGV2ZWwsIF9fd2VicGFja19leHBvcnRzX19YZmFMYXllciBhcyBYZmFMYXllciwgX193ZWJwYWNrX2V4cG9ydHNfX2J1aWxkIGFzIGJ1aWxkLCBfX3dlYnBhY2tfZXhwb3J0c19fY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCBhcyBjcmVhdGVWYWxpZEFic29sdXRlVXJsLCBfX3dlYnBhY2tfZXhwb3J0c19fZmV0Y2hEYXRhIGFzIGZldGNoRGF0YSwgX193ZWJwYWNrX2V4cG9ydHNfX2dldERvY3VtZW50IGFzIGdldERvY3VtZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fZ2V0RmlsZW5hbWVGcm9tVXJsIGFzIGdldEZpbGVuYW1lRnJvbVVybCwgX193ZWJwYWNrX2V4cG9ydHNfX2dldFBkZkZpbGVuYW1lRnJvbVVybCBhcyBnZXRQZGZGaWxlbmFtZUZyb21VcmwsIF9fd2VicGFja19leHBvcnRzX19nZXRYZmFQYWdlVmlld3BvcnQgYXMgZ2V0WGZhUGFnZVZpZXdwb3J0LCBfX3dlYnBhY2tfZXhwb3J0c19faXNEYXRhU2NoZW1lIGFzIGlzRGF0YVNjaGVtZSwgX193ZWJwYWNrX2V4cG9ydHNfX2lzUGRmRmlsZSBhcyBpc1BkZkZpbGUsIF9fd2VicGFja19leHBvcnRzX19ub0NvbnRleHRNZW51IGFzIG5vQ29udGV4dE1lbnUsIF9fd2VicGFja19leHBvcnRzX19ub3JtYWxpemVVbmljb2RlIGFzIG5vcm1hbGl6ZVVuaWNvZGUsIF9fd2VicGFja19leHBvcnRzX19zZXRMYXllckRpbWVuc2lvbnMgYXMgc2V0TGF5ZXJEaW1lbnNpb25zLCBfX3dlYnBhY2tfZXhwb3J0c19fc2hhZG93IGFzIHNoYWRvdywgX193ZWJwYWNrX2V4cG9ydHNfX3N0b3BFdmVudCBhcyBzdG9wRXZlbnQsIF9fd2VicGFja19leHBvcnRzX192ZXJzaW9uIGFzIHZlcnNpb24gfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGRmLm1qcy5tYXAiXSwibmFtZXMiOlsiX193ZWJwYWNrX3JlcXVpcmVfXyIsImQiLCJleHBvcnRzIiwiZGVmaW5pdGlvbiIsImtleSIsIm8iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJvYmoiLCJwcm9wIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX193ZWJwYWNrX2V4cG9ydHNfXyIsImdsb2JhbFRoaXMiLCJwZGZqc0xpYiIsIkFib3J0RXhjZXB0aW9uIiwiQW5ub3RhdGlvbkVkaXRvckxheWVyIiwiQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUiLCJBbm5vdGF0aW9uRWRpdG9yVHlwZSIsIkFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIiLCJBbm5vdGF0aW9uTGF5ZXIiLCJBbm5vdGF0aW9uTW9kZSIsIkNvbG9yUGlja2VyIiwiRE9NU1ZHRmFjdG9yeSIsIkRyYXdMYXllciIsIkZlYXR1cmVUZXN0IiwidXRpbF9GZWF0dXJlVGVzdCIsIkdsb2JhbFdvcmtlck9wdGlvbnMiLCJJbWFnZUtpbmQiLCJ1dGlsX0ltYWdlS2luZCIsIkludmFsaWRQREZFeGNlcHRpb24iLCJNaXNzaW5nUERGRXhjZXB0aW9uIiwiT1BTIiwiT3V0cHV0U2NhbGUiLCJQREZEYXRhUmFuZ2VUcmFuc3BvcnQiLCJQREZEYXRlU3RyaW5nIiwiUERGV29ya2VyIiwiUGFzc3dvcmRSZXNwb25zZXMiLCJQZXJtaXNzaW9uRmxhZyIsIlBpeGVsc1BlckluY2giLCJSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24iLCJUZXh0TGF5ZXIiLCJUb3VjaE1hbmFnZXIiLCJVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24iLCJVdGlsIiwiVmVyYm9zaXR5TGV2ZWwiLCJYZmFMYXllciIsImJ1aWxkIiwiY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCIsImZldGNoRGF0YSIsImdldERvY3VtZW50IiwiZ2V0RmlsZW5hbWVGcm9tVXJsIiwiZ2V0UGRmRmlsZW5hbWVGcm9tVXJsIiwiZ2V0WGZhUGFnZVZpZXdwb3J0IiwiaXNEYXRhU2NoZW1lIiwiaXNQZGZGaWxlIiwibm9Db250ZXh0TWVudSIsIm5vcm1hbGl6ZVVuaWNvZGUiLCJzZXRMYXllckRpbWVuc2lvbnMiLCJzaGFkb3ciLCJzdG9wRXZlbnQiLCJ2ZXJzaW9uIiwiaXNOb2RlSlMiLCJwcm9jZXNzIiwidmVyc2lvbnMiLCJudyIsImVsZWN0cm9uIiwidHlwZSIsIklERU5USVRZX01BVFJJWCIsIkZPTlRfSURFTlRJVFlfTUFUUklYIiwiTUFYX0lNQUdFX1NJWkVfVE9fQ0FDSEUiLCJMSU5FX0ZBQ1RPUiIsIkxJTkVfREVTQ0VOVF9GQUNUT1IiLCJCQVNFTElORV9GQUNUT1IiLCJSZW5kZXJpbmdJbnRlbnRGbGFnIiwiQU5ZIiwiRElTUExBWSIsIlBSSU5UIiwiU0FWRSIsIkFOTk9UQVRJT05TX0ZPUk1TIiwiQU5OT1RBVElPTlNfU1RPUkFHRSIsIkFOTk9UQVRJT05TX0RJU0FCTEUiLCJJU19FRElUSU5HIiwiT1BMSVNUIiwiRElTQUJMRSIsIkVOQUJMRSIsIkVOQUJMRV9GT1JNUyIsIkVOQUJMRV9TVE9SQUdFIiwiQW5ub3RhdGlvbkVkaXRvclByZWZpeCIsIk5PTkUiLCJGUkVFVEVYVCIsIkhJR0hMSUdIVCIsIlNUQU1QIiwiSU5LIiwiUkVTSVpFIiwiQ1JFQVRFIiwiRlJFRVRFWFRfU0laRSIsIkZSRUVURVhUX0NPTE9SIiwiRlJFRVRFWFRfT1BBQ0lUWSIsIklOS19DT0xPUiIsIklOS19USElDS05FU1MiLCJJTktfT1BBQ0lUWSIsIkhJR0hMSUdIVF9DT0xPUiIsIkhJR0hMSUdIVF9ERUZBVUxUX0NPTE9SIiwiSElHSExJR0hUX1RISUNLTkVTUyIsIkhJR0hMSUdIVF9GUkVFIiwiSElHSExJR0hUX1NIT1dfQUxMIiwiRFJBV19TVEVQIiwiTU9ESUZZX0NPTlRFTlRTIiwiQ09QWSIsIk1PRElGWV9BTk5PVEFUSU9OUyIsIkZJTExfSU5URVJBQ1RJVkVfRk9STVMiLCJDT1BZX0ZPUl9BQ0NFU1NJQklMSVRZIiwiQVNTRU1CTEUiLCJQUklOVF9ISUdIX1FVQUxJVFkiLCJUZXh0UmVuZGVyaW5nTW9kZSIsIkZJTEwiLCJTVFJPS0UiLCJGSUxMX1NUUk9LRSIsIklOVklTSUJMRSIsIkZJTExfQUREX1RPX1BBVEgiLCJTVFJPS0VfQUREX1RPX1BBVEgiLCJGSUxMX1NUUk9LRV9BRERfVE9fUEFUSCIsIkFERF9UT19QQVRIIiwiRklMTF9TVFJPS0VfTUFTSyIsIkFERF9UT19QQVRIX0ZMQUciLCJHUkFZU0NBTEVfMUJQUCIsIlJHQl8yNEJQUCIsIlJHQkFfMzJCUFAiLCJBbm5vdGF0aW9uVHlwZSIsIlRFWFQiLCJMSU5LIiwiTElORSIsIlNRVUFSRSIsIkNJUkNMRSIsIlBPTFlHT04iLCJQT0xZTElORSIsIlVOREVSTElORSIsIlNRVUlHR0xZIiwiU1RSSUtFT1VUIiwiQ0FSRVQiLCJQT1BVUCIsIkZJTEVBVFRBQ0hNRU5UIiwiU09VTkQiLCJNT1ZJRSIsIldJREdFVCIsIlNDUkVFTiIsIlBSSU5URVJNQVJLIiwiVFJBUE5FVCIsIldBVEVSTUFSSyIsIlRIUkVFRCIsIlJFREFDVCIsIkFubm90YXRpb25SZXBseVR5cGUiLCJHUk9VUCIsIlJFUExZIiwiQW5ub3RhdGlvbkZsYWciLCJISURERU4iLCJOT1pPT00iLCJOT1JPVEFURSIsIk5PVklFVyIsIlJFQURPTkxZIiwiTE9DS0VEIiwiVE9HR0xFTk9WSUVXIiwiTE9DS0VEQ09OVEVOVFMiLCJBbm5vdGF0aW9uRmllbGRGbGFnIiwiUkVRVUlSRUQiLCJOT0VYUE9SVCIsIk1VTFRJTElORSIsIlBBU1NXT1JEIiwiTk9UT0dHTEVUT09GRiIsIlJBRElPIiwiUFVTSEJVVFRPTiIsIkNPTUJPIiwiRURJVCIsIlNPUlQiLCJGSUxFU0VMRUNUIiwiTVVMVElTRUxFQ1QiLCJET05PVFNQRUxMQ0hFQ0siLCJET05PVFNDUk9MTCIsIkNPTUIiLCJSSUNIVEVYVCIsIlJBRElPU0lOVU5JU09OIiwiQ09NTUlUT05TRUxDSEFOR0UiLCJBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlIiwiU09MSUQiLCJEQVNIRUQiLCJCRVZFTEVEIiwiSU5TRVQiLCJBbm5vdGF0aW9uQWN0aW9uRXZlbnRUeXBlIiwiRSIsIlgiLCJEIiwiVSIsIkZvIiwiQmwiLCJQTyIsIlBDIiwiUFYiLCJQSSIsIksiLCJGIiwiViIsIkMiLCJEb2N1bWVudEFjdGlvbkV2ZW50VHlwZSIsIldDIiwiV1MiLCJEUyIsIldQIiwiRFAiLCJQYWdlQWN0aW9uRXZlbnRUeXBlIiwiTyIsIkVSUk9SUyIsIldBUk5JTkdTIiwiSU5GT1MiLCJkZXBlbmRlbmN5Iiwic2V0TGluZVdpZHRoIiwic2V0TGluZUNhcCIsInNldExpbmVKb2luIiwic2V0TWl0ZXJMaW1pdCIsInNldERhc2giLCJzZXRSZW5kZXJpbmdJbnRlbnQiLCJzZXRGbGF0bmVzcyIsInNldEdTdGF0ZSIsInNhdmUiLCJyZXN0b3JlIiwidHJhbnNmb3JtIiwibW92ZVRvIiwibGluZVRvIiwiY3VydmVUbyIsImN1cnZlVG8yIiwiY3VydmVUbzMiLCJjbG9zZVBhdGgiLCJyZWN0YW5nbGUiLCJzdHJva2UiLCJjbG9zZVN0cm9rZSIsImZpbGwiLCJlb0ZpbGwiLCJmaWxsU3Ryb2tlIiwiZW9GaWxsU3Ryb2tlIiwiY2xvc2VGaWxsU3Ryb2tlIiwiY2xvc2VFT0ZpbGxTdHJva2UiLCJlbmRQYXRoIiwiY2xpcCIsImVvQ2xpcCIsImJlZ2luVGV4dCIsImVuZFRleHQiLCJzZXRDaGFyU3BhY2luZyIsInNldFdvcmRTcGFjaW5nIiwic2V0SFNjYWxlIiwic2V0TGVhZGluZyIsInNldEZvbnQiLCJzZXRUZXh0UmVuZGVyaW5nTW9kZSIsInNldFRleHRSaXNlIiwibW92ZVRleHQiLCJzZXRMZWFkaW5nTW92ZVRleHQiLCJzZXRUZXh0TWF0cml4IiwibmV4dExpbmUiLCJzaG93VGV4dCIsInNob3dTcGFjZWRUZXh0IiwibmV4dExpbmVTaG93VGV4dCIsIm5leHRMaW5lU2V0U3BhY2luZ1Nob3dUZXh0Iiwic2V0Q2hhcldpZHRoIiwic2V0Q2hhcldpZHRoQW5kQm91bmRzIiwic2V0U3Ryb2tlQ29sb3JTcGFjZSIsInNldEZpbGxDb2xvclNwYWNlIiwic2V0U3Ryb2tlQ29sb3IiLCJzZXRTdHJva2VDb2xvck4iLCJzZXRGaWxsQ29sb3IiLCJzZXRGaWxsQ29sb3JOIiwic2V0U3Ryb2tlR3JheSIsInNldEZpbGxHcmF5Iiwic2V0U3Ryb2tlUkdCQ29sb3IiLCJzZXRGaWxsUkdCQ29sb3IiLCJzZXRTdHJva2VDTVlLQ29sb3IiLCJzZXRGaWxsQ01ZS0NvbG9yIiwic2hhZGluZ0ZpbGwiLCJiZWdpbklubGluZUltYWdlIiwiYmVnaW5JbWFnZURhdGEiLCJlbmRJbmxpbmVJbWFnZSIsInBhaW50WE9iamVjdCIsIm1hcmtQb2ludCIsIm1hcmtQb2ludFByb3BzIiwiYmVnaW5NYXJrZWRDb250ZW50IiwiYmVnaW5NYXJrZWRDb250ZW50UHJvcHMiLCJlbmRNYXJrZWRDb250ZW50IiwiYmVnaW5Db21wYXQiLCJlbmRDb21wYXQiLCJwYWludEZvcm1YT2JqZWN0QmVnaW4iLCJwYWludEZvcm1YT2JqZWN0RW5kIiwiYmVnaW5Hcm91cCIsImVuZEdyb3VwIiwiYmVnaW5Bbm5vdGF0aW9uIiwiZW5kQW5ub3RhdGlvbiIsInBhaW50SW1hZ2VNYXNrWE9iamVjdCIsInBhaW50SW1hZ2VNYXNrWE9iamVjdEdyb3VwIiwicGFpbnRJbWFnZVhPYmplY3QiLCJwYWludElubGluZUltYWdlWE9iamVjdCIsInBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXAiLCJwYWludEltYWdlWE9iamVjdFJlcGVhdCIsInBhaW50SW1hZ2VNYXNrWE9iamVjdFJlcGVhdCIsInBhaW50U29saWRDb2xvckltYWdlTWFzayIsImNvbnN0cnVjdFBhdGgiLCJzZXRTdHJva2VUcmFuc3BhcmVudCIsInNldEZpbGxUcmFuc3BhcmVudCIsIk5FRURfUEFTU1dPUkQiLCJJTkNPUlJFQ1RfUEFTU1dPUkQiLCJ2ZXJib3NpdHkiLCJzZXRWZXJib3NpdHlMZXZlbCIsImxldmVsIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiZ2V0VmVyYm9zaXR5TGV2ZWwiLCJpbmZvIiwibXNnIiwiY29uc29sZSIsImxvZyIsIndhcm4iLCJ1bnJlYWNoYWJsZSIsIkVycm9yIiwiYXNzZXJ0IiwiY29uZCIsIl9pc1ZhbGlkUHJvdG9jb2wiLCJ1cmwiLCJwcm90b2NvbCIsImJhc2VVcmwiLCJvcHRpb25zIiwiYWRkRGVmYXVsdFByb3RvY29sIiwic3RhcnRzV2l0aCIsImRvdHMiLCJtYXRjaCIsImxlbmd0aCIsInRyeUNvbnZlcnRFbmNvZGluZyIsInN0cmluZ1RvVVRGOFN0cmluZyIsImFic29sdXRlVXJsIiwiVVJMIiwidmFsdWUiLCJub25TZXJpYWxpemFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIkJhc2VFeGNlcHRpb24iLCJCYXNlRXhjZXB0aW9uQ2xvc3VyZSIsIm1lc3NhZ2UiLCJuYW1lIiwiY29uc3RydWN0b3IiLCJQYXNzd29yZEV4Y2VwdGlvbiIsImNvZGUiLCJVbmtub3duRXJyb3JFeGNlcHRpb24iLCJkZXRhaWxzIiwic3RhdHVzIiwiRm9ybWF0RXJyb3IiLCJieXRlc1RvU3RyaW5nIiwiYnl0ZXMiLCJ1bmRlZmluZWQiLCJNQVhfQVJHVU1FTlRfQ09VTlQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJhcHBseSIsInN0ckJ1ZiIsImkiLCJjaHVua0VuZCIsIk1hdGgiLCJtaW4iLCJjaHVuayIsInN1YmFycmF5IiwicHVzaCIsImpvaW4iLCJzdHJpbmdUb0J5dGVzIiwic3RyIiwiVWludDhBcnJheSIsImNoYXJDb2RlQXQiLCJzdHJpbmczMiIsIm9iamVjdFNpemUiLCJrZXlzIiwib2JqZWN0RnJvbU1hcCIsIm1hcCIsImNyZWF0ZSIsImlzTGl0dGxlRW5kaWFuIiwiYnVmZmVyOCIsInZpZXczMiIsIlVpbnQzMkFycmF5IiwiYnVmZmVyIiwiaXNFdmFsU3VwcG9ydGVkIiwiRnVuY3Rpb24iLCJpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCIsIk9mZnNjcmVlbkNhbnZhcyIsImlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkIiwiSW1hZ2VEZWNvZGVyIiwicGxhdGZvcm0iLCJuYXZpZ2F0b3IiLCJpc01hYyIsImluY2x1ZGVzIiwiaXNXaW5kb3dzIiwiaXNGaXJlZm94IiwidXNlckFnZW50IiwiaXNDU1NSb3VuZFN1cHBvcnRlZCIsIkNTUyIsInN1cHBvcnRzIiwiaGV4TnVtYmVycyIsIkFycmF5IiwiZnJvbSIsIm4iLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwibWFrZUhleENvbG9yIiwiciIsImciLCJiIiwic2NhbGVNaW5NYXgiLCJtaW5NYXgiLCJ0ZW1wIiwibTEiLCJtMiIsImFwcGx5VHJhbnNmb3JtIiwicCIsIm0iLCJ4dCIsInl0IiwiYXBwbHlJbnZlcnNlVHJhbnNmb3JtIiwiZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3giLCJwMSIsInAyIiwic2xpY2UiLCJwMyIsInA0IiwibWF4IiwiaW52ZXJzZVRyYW5zZm9ybSIsInNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlIiwidHJhbnNwb3NlIiwiYSIsImMiLCJmaXJzdCIsInNlY29uZCIsInNxcnQiLCJzeCIsInN5Iiwibm9ybWFsaXplUmVjdCIsInJlY3QiLCJpbnRlcnNlY3QiLCJyZWN0MSIsInJlY3QyIiwieExvdyIsInhIaWdoIiwieUxvdyIsInlIaWdoIiwiZ2V0RXh0cmVtdW1PbkN1cnZlIiwieDAiLCJ4MSIsIngyIiwieDMiLCJ5MCIsInkxIiwieTIiLCJ5MyIsInQiLCJtdCIsInR0IiwidHR0IiwieCIsInkiLCJnZXRFeHRyZW11bSIsImFicyIsImRlbHRhIiwic3FydERlbHRhIiwiYTIiLCJiZXppZXJCb3VuZGluZ0JveCIsIlBERlN0cmluZ1RyYW5zbGF0ZVRhYmxlIiwic3RyaW5nVG9QREZTdHJpbmciLCJlbmNvZGluZyIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImZhdGFsIiwiZGVjb2RlZCIsImRlY29kZSIsInJlcGxhY2VBbGwiLCJleCIsImlpIiwiY2hhckNvZGUiLCJjaGFyQXQiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlc2NhcGUiLCJ1dGY4U3RyaW5nVG9TdHJpbmciLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsImlzQXJyYXlFcXVhbCIsImFycjEiLCJhcnIyIiwiZ2V0TW9kaWZpY2F0aW9uRGF0ZSIsImRhdGUiLCJEYXRlIiwiZ2V0VVRDRnVsbFllYXIiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJnZXRVVENIb3VycyIsImdldFVUQ01pbnV0ZXMiLCJnZXRVVENTZWNvbmRzIiwiTm9ybWFsaXplUmVnZXgiLCJOb3JtYWxpemF0aW9uTWFwIiwiTWFwIiwiXyIsIm5vcm1hbGl6ZSIsImdldFV1aWQiLCJjcnlwdG8iLCJyYW5kb21VVUlEIiwiYnVmIiwiZ2V0UmFuZG9tVmFsdWVzIiwiQW5ub3RhdGlvblByZWZpeCIsInRvSGV4VXRpbCIsImFyciIsInRvSGV4IiwibnVtIiwidG9CYXNlNjRVdGlsIiwidG9CYXNlNjQiLCJidG9hIiwiZnJvbUJhc2U2NFV0aWwiLCJmcm9tQmFzZTY0IiwiYXRvYiIsIlByb21pc2UiLCJ0cnkiLCJmbiIsImFyZ3MiLCJyZXNvbHZlIiwiU1ZHX05TIiwiUERGIiwiUERGX1RPX0NTU19VTklUUyIsImlzVmFsaWRGZXRjaFVybCIsImRvY3VtZW50IiwiYmFzZVVSSSIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsInN0YXR1c1RleHQiLCJhcnJheUJ1ZmZlciIsImJsb2IiLCJqc29uIiwidGV4dCIsInJlamVjdCIsInJlcXVlc3QiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJyZXNwb25zZVR5cGUiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwiRE9ORSIsInJlc3BvbnNlVGV4dCIsInNlbmQiLCJQYWdlVmlld3BvcnQiLCJ2aWV3Qm94IiwidXNlclVuaXQiLCJzY2FsZSIsInJvdGF0aW9uIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJkb250RmxpcCIsImNlbnRlclgiLCJjZW50ZXJZIiwicm90YXRlQSIsInJvdGF0ZUIiLCJyb3RhdGVDIiwicm90YXRlRCIsIm9mZnNldENhbnZhc1giLCJvZmZzZXRDYW52YXNZIiwid2lkdGgiLCJoZWlnaHQiLCJyYXdEaW1zIiwiZGltcyIsInBhZ2VXaWR0aCIsInBhZ2VIZWlnaHQiLCJwYWdlWCIsInBhZ2VZIiwiY2xvbmUiLCJjb252ZXJ0VG9WaWV3cG9ydFBvaW50IiwiY29udmVydFRvVmlld3BvcnRSZWN0YW5nbGUiLCJ0b3BMZWZ0IiwiYm90dG9tUmlnaHQiLCJjb252ZXJ0VG9QZGZQb2ludCIsImV4dHJhRGVsYXkiLCJ0cmltIiwic3Vic3RyaW5nIiwidG9Mb3dlckNhc2UiLCJmaWxlbmFtZSIsInRlc3QiLCJzcGxpdCIsImxhc3RJbmRleE9mIiwiZGVmYXVsdEZpbGVuYW1lIiwicmVVUkkiLCJyZUZpbGVuYW1lIiwic3BsaXRVUkkiLCJleGVjIiwic3VnZ2VzdGVkRmlsZW5hbWUiLCJTdGF0VGltZXIiLCJ0aW1lIiwic3RhcnRlZCIsIm5vdyIsInRpbWVFbmQiLCJ0aW1lcyIsInN0YXJ0IiwiZW5kIiwib3V0QnVmIiwibG9uZ2VzdCIsInBhZEVuZCIsImUiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsImRlcHJlY2F0ZWQiLCJyZWdleCIsInRvRGF0ZU9iamVjdCIsImlucHV0IiwiUmVnRXhwIiwibWF0Y2hlcyIsInllYXIiLCJwYXJzZUludCIsIm1vbnRoIiwiZGF5IiwiaG91ciIsIm1pbnV0ZSIsInVuaXZlcnNhbFRpbWVSZWxhdGlvbiIsIm9mZnNldEhvdXIiLCJvZmZzZXRNaW51dGUiLCJVVEMiLCJ4ZmFQYWdlIiwiYXR0cmlidXRlcyIsInN0eWxlIiwiZ2V0UkdCIiwiY29sb3IiLCJjb2xvclJHQiIsImdldENvbG9yVmFsdWVzIiwiY29sb3JzIiwic3BhbiIsImNyZWF0ZUVsZW1lbnQiLCJ2aXNpYmlsaXR5IiwiYm9keSIsImFwcGVuZCIsImNvbXB1dGVkQ29sb3IiLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwic2V0IiwicmVtb3ZlIiwiZ2V0Q3VycmVudFRyYW5zZm9ybSIsImN0eCIsImYiLCJnZXRUcmFuc2Zvcm0iLCJnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSIsImludmVydFNlbGYiLCJkaXYiLCJ2aWV3cG9ydCIsIm11c3RGbGlwIiwibXVzdFJvdGF0ZSIsInVzZVJvdW5kIiwidyIsImgiLCJ3aWR0aFN0ciIsImhlaWdodFN0ciIsInNldEF0dHJpYnV0ZSIsInBpeGVsUmF0aW8iLCJkZXZpY2VQaXhlbFJhdGlvIiwic2NhbGVkIiwic3ltbWV0cmljIiwiRWRpdG9yVG9vbGJhciIsInRvb2xiYXIiLCJjb2xvclBpY2tlciIsImVkaXRvciIsImJ1dHRvbnMiLCJhbHRUZXh0IiwibDEwblJlbW92ZSIsImZyZWV6ZSIsImZyZWV0ZXh0IiwiaGlnaGxpZ2h0IiwiaW5rIiwic3RhbXAiLCJyZW5kZXIiLCJlZGl0VG9vbGJhciIsImNsYXNzTGlzdCIsImFkZCIsInNpZ25hbCIsIl91aU1hbmFnZXIiLCJfc2lnbmFsIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBvaW50ZXJEb3duIiwiY2xhc3NOYW1lIiwicG9zaXRpb24iLCJ0b29sYmFyUG9zaXRpb24iLCJkaXJlY3Rpb24iLCJpbnNldElubGluZUVuZCIsInRvcCIsImFkZERlbGV0ZUJ1dHRvbiIsImZvY3VzSW4iLCJfZm9jdXNFdmVudHNBbGxvd2VkIiwiZm9jdXNPdXQiLCJhZGRMaXN0ZW5lcnNUb0VsZW1lbnQiLCJlbGVtZW50IiwiYmluZCIsImNhcHR1cmUiLCJoaWRlIiwiaGlkZURyb3Bkb3duIiwic2hvdyIsInNob3duIiwiZWRpdG9yVHlwZSIsImJ1dHRvbiIsInRhYkluZGV4IiwiZGVsZXRlIiwiZGl2aWRlciIsImFkZEFsdFRleHQiLCJwcmVwZW5kIiwiYWRkQ29sb3JQaWNrZXIiLCJyZW5kZXJCdXR0b24iLCJkZXN0cm95IiwiSGlnaGxpZ2h0VG9vbGJhciIsInVpTWFuYWdlciIsImFkZEhpZ2hsaWdodEJ1dHRvbiIsImdldExhc3RQb2ludCIsImJveGVzIiwiaXNMVFIiLCJsYXN0WSIsImxhc3RYIiwiYm94IiwicGFyZW50IiwiaGlnaGxpZ2h0U2VsZWN0aW9uIiwiYmluZEV2ZW50cyIsIm5hbWVzIiwib3BhY2l0eVRvSGV4Iiwib3BhY2l0eSIsInJvdW5kIiwiSWRNYW5hZ2VyIiwiaWQiLCJJbWFnZU1hbmFnZXIiLCJiYXNlSWQiLCJjYWNoZSIsIl9pc1NWR0ZpdHRpbmdDYW52YXMiLCJzdmciLCJjYW52YXMiLCJnZXRDb250ZXh0Iiwid2lsbFJlYWRGcmVxdWVudGx5IiwiaW1hZ2UiLCJJbWFnZSIsInNyYyIsInByb21pc2UiLCJ0aGVuIiwiZHJhd0ltYWdlIiwiZ2V0SW1hZ2VEYXRhIiwiZGF0YSIsInJhd0RhdGEiLCJiaXRtYXAiLCJyZWZDb3VudGVyIiwiaXNTdmciLCJGaWxlIiwiZmlsZSIsIkJsb2IiLCJtdXN0UmVtb3ZlQXNwZWN0UmF0aW9Qcm9taXNlIiwiZmlsZVJlYWRlciIsIkZpbGVSZWFkZXIiLCJpbWFnZUVsZW1lbnQiLCJpbWFnZVByb21pc2UiLCJvbmxvYWQiLCJzdmdVcmwiLCJyZXN1bHQiLCJvbmVycm9yIiwicmVhZEFzRGF0YVVSTCIsImNyZWF0ZUltYWdlQml0bWFwIiwiZ2V0RnJvbUZpbGUiLCJsYXN0TW9kaWZpZWQiLCJzaXplIiwiZ2V0RnJvbVVybCIsImdldEZyb21CbG9iIiwiYmxvYlByb21pc2UiLCJnZXRGcm9tSWQiLCJnZXRGcm9tQ2FudmFzIiwib2Zmc2NyZWVuIiwidHJhbnNmZXJUb0ltYWdlQml0bWFwIiwiZ2V0U3ZnVXJsIiwiZGVsZXRlSWQiLCJ0cmFuc2ZlckZyb21JbWFnZUJpdG1hcCIsImNvbnZlcnRUb0Jsb2IiLCJjbG9zZSIsImlzVmFsaWRJZCIsIkNvbW1hbmRNYW5hZ2VyIiwiY29tbWFuZHMiLCJsb2NrZWQiLCJtYXhTaXplIiwiY21kIiwidW5kbyIsInBvc3QiLCJtdXN0RXhlYyIsIk5hTiIsIm92ZXJ3cml0ZUlmU2FtZVR5cGUiLCJrZWVwVW5kbyIsIm5leHQiLCJzcGxpY2UiLCJyZWRvIiwiaGFzU29tZXRoaW5nVG9VbmRvIiwiaGFzU29tZXRoaW5nVG9SZWRvIiwiY2xlYW5UeXBlIiwiS2V5Ym9hcmRNYW5hZ2VyIiwiY2FsbGJhY2tzIiwiYWxsS2V5cyIsIlNldCIsImNhbGxiYWNrIiwiaXNNYWNLZXkiLCJhdCIsInNlcmlhbGl6ZSIsImV2ZW50IiwiYWx0S2V5IiwiY3RybEtleSIsIm1ldGFLZXkiLCJzaGlmdEtleSIsInNlbGYiLCJoYXMiLCJidWJibGVzIiwiY2hlY2tlciIsIkNvbG9yTWFuYWdlciIsIl9jb2xvcnNNYXBwaW5nIiwiX2NvbG9ycyIsImNvbnZlcnQiLCJyZ2IiLCJtYXRjaE1lZGlhIiwiUkdCIiwiZXZlcnkiLCJnZXRIZXhDb2RlIiwiYWJvcnRDb250cm9sbGVyIiwiYWN0aXZlRWRpdG9yIiwiYWxsRWRpdG9ycyIsImFsbExheWVycyIsImFsdFRleHRNYW5hZ2VyIiwiYW5ub3RhdGlvblN0b3JhZ2UiLCJjaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9ucyIsImNvbW1hbmRNYW5hZ2VyIiwiY29weVBhc3RlQUMiLCJjdXJyZW50RHJhd2luZ1Nlc3Npb24iLCJjdXJyZW50UGFnZUluZGV4IiwiZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcyIsImRyYWdnaW5nRWRpdG9ycyIsImVkaXRvclR5cGVzIiwiZWRpdG9yc1RvUmVzY2FsZSIsImVuYWJsZUhpZ2hsaWdodEZsb2F0aW5nQnV0dG9uIiwiZW5hYmxlVXBkYXRlZEFkZEltYWdlIiwiZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSIsImZpbHRlckZhY3RvcnkiLCJmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQiLCJmb2N1c01hbmFnZXJBQyIsImhpZ2hsaWdodENvbG9ycyIsImhpZ2hsaWdodFdoZW5TaGlmdFVwIiwiaGlnaGxpZ2h0VG9vbGJhciIsImlkTWFuYWdlciIsImlzRW5hYmxlZCIsImlzV2FpdGluZyIsImtleWJvYXJkTWFuYWdlckFDIiwibGFzdEFjdGl2ZUVsZW1lbnQiLCJtYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXIiLCJtbE1hbmFnZXIiLCJtb2RlIiwic2VsZWN0ZWRFZGl0b3JzIiwic2VsZWN0ZWRUZXh0Tm9kZSIsInBhZ2VDb2xvcnMiLCJzaG93QWxsU3RhdGVzIiwicHJldmlvdXNTdGF0ZXMiLCJ0cmFuc2xhdGlvbiIsInRyYW5zbGF0aW9uVGltZW91dElkIiwiY29udGFpbmVyIiwidmlld2VyIiwidXBkYXRlTW9kZUNhcGFiaWxpdHkiLCJUUkFOU0xBVEVfU01BTEwiLCJUUkFOU0xBVEVfQklHIiwiX2tleWJvYXJkTWFuYWdlciIsInByb3RvIiwiYXJyb3dDaGVja2VyIiwiY29udGFpbnMiLCJhY3RpdmVFbGVtZW50IiwidGFnTmFtZSIsImhhc1NvbWV0aGluZ1RvQ29udHJvbCIsInRleHRJbnB1dENoZWNrZXIiLCJfc2VsZiIsInRhcmdldCIsImVsIiwiSFRNTElucHV0RWxlbWVudCIsInNtYWxsIiwiYmlnIiwic2VsZWN0QWxsIiwiYWRkTmV3RWRpdG9yRnJvbUtleWJvYXJkIiwiSFRNTEJ1dHRvbkVsZW1lbnQiLCJpc0VudGVySGFuZGxlZCIsInVuc2VsZWN0QWxsIiwidHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzIiwiZXZlbnRCdXMiLCJwZGZEb2N1bWVudCIsImVkaXRvclVuZG9CYXIiLCJzdXBwb3J0c1BpbmNoVG9ab29tIiwiQWJvcnRDb250cm9sbGVyIiwiX2VkaXRvclVuZG9CYXIiLCJpc0VkaXRpbmciLCJpc0VtcHR5IiwiaGFzU2VsZWN0ZWRFZGl0b3IiLCJoYXNTZWxlY3RlZFRleHQiLCJfZXZlbnRCdXMiLCJfb24iLCJvbkVkaXRpbmdBY3Rpb24iLCJvblBhZ2VDaGFuZ2luZyIsIm9uU2NhbGVDaGFuZ2luZyIsIm9uUm90YXRpb25DaGFuZ2luZyIsIm9uU2V0UHJlZmVyZW5jZSIsImV2dCIsInVwZGF0ZVBhcmFtcyIsImFkZFNlbGVjdGlvbkxpc3RlbmVyIiwiYWRkRHJhZ0FuZERyb3BMaXN0ZW5lcnMiLCJhZGRLZXlib2FyZE1hbmFnZXIiLCJ2aWV3UGFyYW1ldGVycyIsInJlYWxTY2FsZSIsImlzU2hpZnRLZXlEb3duIiwiX3N1cHBvcnRzUGluY2hUb1pvb20iLCJhYm9ydCIsImxheWVyIiwidmFsdWVzIiwiY2xlYXIiLCJjbGVhclRpbWVvdXQiLCJjb21iaW5lZFNpZ25hbCIsImFjIiwiQWJvcnRTaWduYWwiLCJhbnkiLCJ1c2VOZXdBbHRUZXh0RmxvdyIsInVzZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UiLCJoY21GaWx0ZXIiLCJhZGRIQ01GaWx0ZXIiLCJmb3JlZ3JvdW5kIiwiYmFja2dyb3VuZCIsInBhaXIiLCJoaWdobGlnaHRDb2xvck5hbWVzIiwicmV2ZXJzZSIsInNldEN1cnJlbnREcmF3aW5nU2Vzc2lvbiIsImRpc2FibGVVc2VyU2VsZWN0Iiwic2V0TWFpbkhpZ2hsaWdodENvbG9yUGlja2VyIiwiZWRpdEFsdFRleHQiLCJmaXJzdFRpbWUiLCJzd2l0Y2hUb01vZGUiLCJvbiIsIm9uY2UiLCJkaXNwYXRjaCIsInNvdXJjZSIsInNldFByZWZlcmVuY2UiLCJwYWdlTnVtYmVyIiwiZm9jdXNNYWluQ29udGFpbmVyIiwiZm9jdXMiLCJmaW5kUGFyZW50IiwibGF5ZXJYIiwibGF5ZXJZIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidG9nZ2xlIiwiYWRkU2hvdWxkUmVzY2FsZSIsInJlbW92ZVNob3VsZFJlc2NhbGUiLCJjb21taXRPclJlbW92ZSIsInBhZ2VzUm90YXRpb24iLCJnZXRBbmNob3JFbGVtZW50Rm9yU2VsZWN0aW9uIiwiYW5jaG9yTm9kZSIsIm5vZGVUeXBlIiwiTm9kZSIsIlRFWFRfTk9ERSIsInBhcmVudEVsZW1lbnQiLCJnZXRMYXllckZvclRleHRMYXllciIsInRleHRMYXllciIsImN1cnJlbnRMYXllciIsImhhc1RleHRMYXllciIsIm1ldGhvZE9mQ3JlYXRpb24iLCJzZWxlY3Rpb24iLCJnZXRTZWxlY3Rpb24iLCJpc0NvbGxhcHNlZCIsImFuY2hvck9mZnNldCIsImZvY3VzTm9kZSIsImZvY3VzT2Zmc2V0IiwiYW5jaG9yRWxlbWVudCIsImNsb3Nlc3QiLCJnZXRTZWxlY3Rpb25Cb3hlcyIsImVtcHR5IiwiaXNOb25lTW9kZSIsImNyZWF0ZUFuZEFkZE5ld0VkaXRvciIsInNob3dBbGxFZGl0b3JzIiwiZGlzcGxheUhpZ2hsaWdodFRvb2xiYXIiLCJhZGRUb0Fubm90YXRpb25TdG9yYWdlIiwic2V0VmFsdWUiLCJzZWxlY3Rpb25DaGFuZ2UiLCJkaXNwYXRjaFVwZGF0ZVN0YXRlcyIsImFjdGl2ZUxheWVyIiwidG9nZ2xlRHJhd2luZyIsInBvaW50ZXJ1cCIsIm9uU2VsZWN0RW5kIiwiYWRkRm9jdXNNYW5hZ2VyIiwiYmx1ciIsInJlbW92ZUZvY3VzTWFuYWdlciIsImhhc1NlbGVjdGlvbiIsImxhc3RFZGl0b3IiLCJrZXlkb3duIiwia2V5dXAiLCJyZW1vdmVLZXlib2FyZE1hbmFnZXIiLCJhZGRDb3B5UGFzdGVMaXN0ZW5lcnMiLCJjb3B5IiwiY3V0IiwicGFzdGUiLCJyZW1vdmVDb3B5UGFzdGVMaXN0ZW5lcnMiLCJkcmFnT3ZlciIsImRyb3AiLCJhZGRFZGl0TGlzdGVuZXJzIiwicmVtb3ZlRWRpdExpc3RlbmVycyIsImRhdGFUcmFuc2ZlciIsIml0ZW1zIiwiaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nIiwiZHJvcEVmZmVjdCIsIml0ZW0iLCJlZGl0b3JzIiwic2VyaWFsaXplZCIsImNsaXBib2FyZERhdGEiLCJzZXREYXRhIiwiSlNPTiIsInN0cmluZ2lmeSIsImdldERhdGEiLCJwYXJzZSIsImlzQXJyYXkiLCJuZXdFZGl0b3JzIiwiZGVzZXJpYWxpemVkRWRpdG9yIiwiZGVzZXJpYWxpemUiLCJhZGRFZGl0b3JUb0xheWVyIiwic2VsZWN0RWRpdG9ycyIsImFkZENvbW1hbmRzIiwiaXNFZGl0b3JIYW5kbGluZ0tleWJvYXJkIiwiaGFzQ2hhbmdlZCIsImVudHJpZXMiLCJzb21lIiwiYXNzaWduIiwiZGlzcGF0Y2hVcGRhdGVVSSIsInNldEVkaXRpbmdTdGF0ZSIsInJlZ2lzdGVyRWRpdG9yVHlwZXMiLCJ0eXBlcyIsImRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUiLCJnZXRJZCIsImdldExheWVyIiwicGFnZUluZGV4IiwiYWRkTGF5ZXIiLCJlbmFibGUiLCJkaXNhYmxlIiwicmVtb3ZlTGF5ZXIiLCJ1cGRhdGVNb2RlIiwiZWRpdElkIiwiaXNGcm9tS2V5Ym9hcmQiLCJ3aXRoUmVzb2x2ZXJzIiwiZGlzYWJsZUFsbCIsImVuYWJsZUFsbCIsImFubm90YXRpb25FbGVtZW50SWQiLCJzZXRTZWxlY3RlZCIsImVudGVySW5FZGl0TW9kZSIsInVuc2VsZWN0IiwiY2FuQ3JlYXRlTmV3RW1wdHlFZGl0b3IiLCJhZGROZXdFZGl0b3IiLCJ1cGRhdGVUb29sYmFyIiwidXBkYXRlQ29sb3IiLCJhY3Rpb24iLCJ1cGRhdGVEZWZhdWx0UGFyYW1zIiwidmlzaWJsZSIsInVwZGF0ZUJ1dHRvbiIsInN0YXRlIiwiZW5hYmxlV2FpdGluZyIsIm11c3RXYWl0IiwiZGlzYWJsZUNsaWNrIiwiZW5hYmxlQ2xpY2siLCJwcm9taXNlcyIsImFsbCIsImdldEVkaXRvcnMiLCJnZXRFZGl0b3IiLCJhZGRFZGl0b3IiLCJyZW1vdmVFZGl0b3IiLCJzZXRUaW1lb3V0IiwiYWRkRGVsZXRlZEFubm90YXRpb25FbGVtZW50IiwiYWRkQ2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbiIsImRlbGV0ZWQiLCJpc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudCIsInJlbW92ZURlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudCIsInJlbW92ZUNoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24iLCJhZGRPclJlYnVpbGQiLCJzZXRBY3RpdmVFZGl0b3IiLCJwcm9wZXJ0aWVzVG9VcGRhdGUiLCJsYXN0U2VsZWN0ZWRFZGl0b3IiLCJlZCIsInVwZGF0ZVVJIiwidXBkYXRlVUlGb3JEZWZhdWx0UHJvcGVydGllcyIsInRvZ2dsZVNlbGVjdGVkIiwic2VsZWN0IiwiaXNTZWxlY3RlZCIsImZpcnN0U2VsZWN0ZWRFZGl0b3IiLCJwYXJhbXMiLCJjbGVhblVuZG9TdGFjayIsImRyYXdpbmdFZGl0b3IiLCJlbmREcmF3aW5nU2Vzc2lvbiIsImNvbW1pdCIsIm5vQ29tbWl0IiwidG90YWxYIiwidG90YWxZIiwiVElNRV9UT19XQUlUIiwidHJhbnNsYXRlSW5QYWdlIiwic2V0VXBEcmFnU2Vzc2lvbiIsInNhdmVkWCIsInNhdmVkWSIsInNhdmVkUGFnZUluZGV4IiwibmV3WCIsIm5ld1kiLCJuZXdQYWdlSW5kZXgiLCJlbmREcmFnU2Vzc2lvbiIsIm11c3RCZUFkZGVkSW5VbmRvU3RhY2siLCJtb3ZlIiwiX3NldFBhcmVudEFuZFBvc2l0aW9uIiwiZHJhZ1NlbGVjdGVkRWRpdG9ycyIsInR4IiwidHkiLCJkcmFnIiwicmVidWlsZCIsImNoYW5nZVBhcmVudCIsImdldEFjdGl2ZSIsInNob3VsZEdldEtleWJvYXJkRXZlbnRzIiwiaXNBY3RpdmUiLCJnZXRNb2RlIiwiaW1hZ2VNYW5hZ2VyIiwicmFuZ2VDb3VudCIsImdldFJhbmdlQXQiLCJjb21tb25BbmNlc3RvckNvbnRhaW5lciIsInBhcmVudFdpZHRoIiwicGFyZW50SGVpZ2h0Iiwicm90YXRvciIsImdldEF0dHJpYnV0ZSIsInJhbmdlIiwiY29sbGFwc2VkIiwiZ2V0Q2xpZW50UmVjdHMiLCJyZW5kZXJBbm5vdGF0aW9uRWxlbWVudCIsImFubm90YXRpb24iLCJlZGl0b3JJZCIsImdldFJhd1ZhbHVlIiwiaGFzQmVlbk1vZGlmaWVkIiwiQWx0VGV4dCIsImFsdFRleHREZWNvcmF0aXZlIiwiYWx0VGV4dEJ1dHRvbiIsImFsdFRleHRCdXR0b25MYWJlbCIsImFsdFRleHRUb29sdGlwIiwiYWx0VGV4dFRvb2x0aXBUaW1lb3V0IiwiYWx0VGV4dFdhc0Zyb21LZXlCb2FyZCIsImJhZGdlIiwiZ3Vlc3NlZFRleHQiLCJ0ZXh0V2l0aERpc2NsYWltZXIiLCJsMTBuTmV3QnV0dG9uIiwiX2wxMG4iLCJhZGRlZCIsIm1pc3NpbmciLCJyZXZpZXciLCJpbml0aWFsaXplIiwibDEwbiIsImxhYmVsIiwib25DbGljayIsIl9yZXBvcnRUZWxlbWV0cnkiLCJzZXRTdGF0ZSIsImZpbmlzaCIsImZvY3VzVmlzaWJsZSIsImhhc0RhdGEiLCJzZXRHdWVzc2VkVGV4dCIsImdlbmVyYXRlZEFsdFRleHQiLCJ0b2dnbGVBbHRUZXh0QmFkZ2UiLCJpc0ZvckNvcHlpbmciLCJkZWNvcmF0aXZlIiwiY2FuY2VsIiwiZW5hYmxlZCIsImRpc2FibGVkIiwidG9vbHRpcCIsIkRFTEFZX1RPX1NIT1dfVE9PTFRJUCIsInJlbW92ZUF0dHJpYnV0ZSIsInRleHRDb250ZW50IiwicGFyZW50Tm9kZSIsImdldEltYWdlRm9yQWx0VGV4dCIsImlzUGluY2hpbmciLCJpc1BpbmNoaW5nU3RvcHBlZCIsImlzUGluY2hpbmdEaXNhYmxlZCIsIm9uUGluY2hTdGFydCIsIm9uUGluY2hpbmciLCJvblBpbmNoRW5kIiwidG91Y2hJbmZvIiwidG91Y2hNYW5hZ2VyQUMiLCJ0b3VjaE1vdmVBQyIsIm9uVG91Y2hTdGFydCIsInBhc3NpdmUiLCJNSU5fVE9VQ0hfRElTVEFOQ0VfVE9fUElOQ0giLCJ0b3VjaGVzIiwib3B0Iiwib25Ub3VjaE1vdmUiLCJvblRvdWNoRW5kIiwidG91Y2gwIiwidG91Y2gxIiwiaWRlbnRpZmllciIsInRvdWNoMFgiLCJzY3JlZW5YIiwidG91Y2gwWSIsInNjcmVlblkiLCJ0b3VjaDFYIiwidG91Y2gxWSIsInNjcmVlbjBYIiwic2NyZWVuMFkiLCJzY3JlZW4xWCIsInNjcmVlbjFZIiwicFRvdWNoMFgiLCJwVG91Y2gwWSIsInBUb3VjaDFYIiwicFRvdWNoMVkiLCJwcmV2R2FwWCIsInByZXZHYXBZIiwiY3VyckdhcFgiLCJjdXJyR2FwWSIsImRpc3RhbmNlIiwiaHlwb3QiLCJwRGlzdGFuY2UiLCJvcmlnaW4iLCJBbm5vdGF0aW9uRWRpdG9yIiwiYWNjZXNzaWJpbGl0eURhdGEiLCJhbGxSZXNpemVyRGl2cyIsImRyYWdQb2ludGVySWQiLCJkcmFnUG9pbnRlclR5cGUiLCJrZWVwQXNwZWN0UmF0aW8iLCJyZXNpemVyc0RpdiIsImxhc3RQb2ludGVyQ29vcmRzIiwic2F2ZWREaW1lbnNpb25zIiwiZm9jdXNBQyIsImZvY3VzZWRSZXNpemVyTmFtZSIsImhhc0JlZW5DbGlja2VkIiwiaW5pdGlhbFJlY3QiLCJpc0luRWRpdE1vZGUiLCJpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQiLCJtb3ZlSW5ET01UaW1lb3V0IiwicHJldkRyYWdYIiwicHJldkRyYWdZIiwidGVsZW1ldHJ5VGltZW91dHMiLCJ0b3VjaE1hbmFnZXIiLCJfbDEwblJlc2l6ZXIiLCJpc0RyYWdnYWJsZSIsInpJbmRleCIsIl9ib3JkZXJMaW5lV2lkdGgiLCJfY29sb3JNYW5hZ2VyIiwiX3pJbmRleCIsIl90ZWxlbWV0cnlUaW1lb3V0IiwiX3Jlc2l6ZXJLZXlib2FyZE1hbmFnZXIiLCJyZXNpemUiLCJfcmVzaXplV2l0aEtleWJvYXJkIiwiX3N0b3BSZXNpemluZ1dpdGhLZXlib2FyZCIsInBhcmFtZXRlcnMiLCJfZWRpdFRvb2xiYXIiLCJfaW5pdGlhbE9wdGlvbnMiLCJfaW5pdGlhbERhdGEiLCJfaXNWaXNpYmxlIiwiX3dpbGxLZWVwQXNwZWN0UmF0aW8iLCJpc0NlbnRlcmVkIiwiX3N0cnVjdFRyZWVQYXJlbnRJZCIsInBhZ2VSb3RhdGlvbiIsInBhZ2VEaW1lbnNpb25zIiwicGFnZVRyYW5zbGF0aW9uIiwicGFyZW50RGltZW5zaW9ucyIsImlzQXR0YWNoZWRUb0RPTSIsImdldFByb3RvdHlwZU9mIiwiX3R5cGUiLCJpc0RyYXdlciIsIl9kZWZhdWx0TGluZUNvbG9yIiwiZGVsZXRlQW5ub3RhdGlvbkVsZW1lbnQiLCJmYWtlRWRpdG9yIiwiRmFrZUVkaXRvciIsImdldE5leHRJZCIsInRvcE1pZGRsZSIsInRvcFJpZ2h0IiwibWlkZGxlUmlnaHQiLCJib3R0b21NaWRkbGUiLCJib3R0b21MZWZ0IiwibWlkZGxlTGVmdCIsImRvY3VtZW50RWxlbWVudCIsInBhcnNlRmxvYXQiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiX3ZhbHVlIiwibWltZSIsIl9pc0RyYWdnYWJsZSIsImNlbnRlciIsInBhcmVudFJvdGF0aW9uIiwiZml4QW5kU2V0UG9zaXRpb24iLCJzZXRJbkJhY2tncm91bmQiLCJzZXRJbkZvcmVncm91bmQiLCJzZXRQYXJlbnQiLCJzdG9wUmVzaXppbmciLCJmb2N1c2luIiwiZm9jdXNvdXQiLCJyZWxhdGVkVGFyZ2V0IiwiaXNNdWx0aXBsZVNlbGVjdGlvbiIsInNldEF0Iiwic2NyZWVuVG9QYWdlVHJhbnNsYXRpb24iLCJ0cmFuc2xhdGUiLCJfb25UcmFuc2xhdGluZyIsInNjcm9sbEludG9WaWV3IiwiYmxvY2siLCJmaW5kTmV3UGFyZW50IiwiZmxvb3IiLCJieCIsImJ5IiwiZ2V0QmFzZVRyYW5zbGF0aW9uIiwibGVmdCIsInRvRml4ZWQiLCJfb25UcmFuc2xhdGVkIiwiX2hhc0JlZW5Nb3ZlZCIsIl9oYXNCZWVuUmVzaXplZCIsIl9tdXN0Rml4UG9zaXRpb24iLCJtb3ZlSW5ET00iLCJyb3RhdGVQb2ludCIsImFuZ2xlIiwicGFnZVRyYW5zbGF0aW9uVG9TY3JlZW4iLCJnZXRSb3RhdGlvbk1hdHJpeCIsInBhcmVudFNjYWxlIiwic2V0RGltcyIsImZpeERpbXMiLCJ3aWR0aFBlcmNlbnQiLCJlbmRzV2l0aCIsImhlaWdodFBlcmNlbnQiLCJnZXRJbml0aWFsVHJhbnNsYXRpb24iLCJjcmVhdGVSZXNpemVycyIsImNsYXNzZXMiLCJyZXNpemVyUG9pbnRlcmRvd24iLCJzYXZlZERyYWdnYWJsZSIsInRvZ2dsZVBvaW50ZXJFdmVudHMiLCJyZXNpemVyUG9pbnRlcm1vdmUiLCJzYXZlZFdpZHRoIiwic2F2ZWRIZWlnaHQiLCJzYXZlZFBhcmVudEN1cnNvciIsImN1cnNvciIsInNhdmVkQ3Vyc29yIiwicG9pbnRlclVwQ2FsbGJhY2siLCJhZGRSZXNpemVUb1VuZG9TdGFjayIsIl9vblJlc2l6ZWQiLCJuZXdXaWR0aCIsIm5ld0hlaWdodCIsIl9yb3VuZCIsIm1pbldpZHRoIiwiTUlOX1NJWkUiLCJtaW5IZWlnaHQiLCJyb3RhdGlvbk1hdHJpeCIsInRyYW5zZiIsImludlJvdGF0aW9uTWF0cml4IiwiaW52VHJhbnNmIiwiZ2V0UG9pbnQiLCJnZXRPcHBvc2l0ZSIsImlzRGlhZ29uYWwiLCJpc0hvcml6b250YWwiLCJwb2ludCIsIm9wcG9zaXRlUG9pbnQiLCJ0cmFuc2ZPcHBvc2l0ZVBvaW50Iiwib3Bwb3NpdGVYIiwib3Bwb3NpdGVZIiwicmF0aW9YIiwicmF0aW9ZIiwiZGVsdGFYIiwiZGVsdGFZIiwiZnJvbUtleWJvYXJkIiwibGFzdFNjcmVlblgiLCJsYXN0U2NyZWVuWSIsIm9sZERpYWciLCJfb25SZXNpemluZyIsImFsdFRleHRGaW5pc2giLCJhZGRFZGl0VG9vbGJhciIsInJlbW92ZUVkaXRUb29sYmFyIiwiYWRkQ29udGFpbmVyIiwiZWRpdFRvb2xiYXJEaXYiLCJiZWZvcmUiLCJnZXRDbGllbnREaW1lbnNpb25zIiwiYWRkQWx0VGV4dEJ1dHRvbiIsImFsdFRleHREYXRhIiwiZ3Vlc3NlZEFsdFRleHQiLCJzZXRHdWVzc2VkQWx0VGV4dCIsInNlcmlhbGl6ZUFsdFRleHQiLCJoYXNBbHRUZXh0IiwiaGFzQWx0VGV4dERhdGEiLCJhZGRGb2N1c0xpc3RlbmVycyIsIm1heFdpZHRoIiwibWF4SGVpZ2h0IiwiaXNSZXNpemFibGUiLCJ0b3VjaFBpbmNoU3RhcnRDYWxsYmFjayIsInRvdWNoUGluY2hDYWxsYmFjayIsInRvdWNoUGluY2hFbmRDYWxsYmFjayIsIl9vcmlnaW4iLCJwcmV2RGlzdGFuY2UiLCJzbG93RG93bkZhY3RvciIsImZhY3RvciIsInRyYW5zZkNlbnRlclBvaW50IiwibmV3VHJhbnNmQ2VudGVyUG9pbnQiLCJwb2ludGVyZG93biIsInNlbGVjdE9uUG9pbnRlckV2ZW50IiwiaGFzRHJhZ2dpbmdTdGFydGVkIiwib3B0cyIsImNhbmNlbERyYWciLCJfb25TdG9wRHJhZ2dpbmciLCJjbGllbnRYIiwiY2xpZW50WSIsInBvaW50ZXJJZCIsInBvaW50ZXJUeXBlIiwiX29uU3RhcnREcmFnZ2luZyIsImlzUHJpbWFyeSIsIm1vdmVFZGl0b3JJbkRPTSIsImdldFJlY3QiLCJzaGlmdFgiLCJzaGlmdFkiLCJnZXRSZWN0SW5DdXJyZW50Q29vcmRzIiwib25jZUFkZGVkIiwiZW5hYmxlRWRpdE1vZGUiLCJkaXNhYmxlRWRpdE1vZGUiLCJuZWVkc1RvQmVSZWJ1aWx0IiwiaXNPblNjcmVlbiIsImJvdHRvbSIsInJpZ2h0IiwiaW5uZXJIZWlnaHQiLCJpbm5lcldpZHRoIiwicm90YXRlIiwiX2FuZ2xlIiwic2VyaWFsaXplRGVsZXRlZCIsInBvcHVwUmVmIiwiY29udGV4dCIsInRpbWVvdXQiLCJtYWtlUmVzaXphYmxlIiwiY2hpbGRyZW4iLCJib3VuZFJlc2l6ZXJLZXlkb3duIiwicmVzaXplcktleWRvd24iLCJib3VuZFJlc2l6ZXJCbHVyIiwicmVzaXplckJsdXIiLCJyZXNpemVyRm9jdXMiLCJmaXJzdFBvc2l0aW9uIiwibmV4dEZpcnN0UG9zaXRpb24iLCJmaXJzdENoaWxkIiwibGFzdENoaWxkIiwiY2hpbGQiLCJzZXRSZXNpemVyVGFiSW5kZXgiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJwcmV2ZW50U2Nyb2xsIiwiZGlzYWJsZUVkaXRpbmciLCJlbmFibGVFZGl0aW5nIiwiY29udGVudERpdiIsInNldEFzcGVjdFJhdGlvIiwiYXNwZWN0UmF0aW8iLCJ0ZWxlbWV0cnlJbml0aWFsRGF0YSIsInRlbGVtZXRyeUZpbmFsRGF0YSIsImNvbnRlbnQiLCJxdWVyeVNlbGVjdG9yIiwibm9kZU5hbWUiLCJyZXNldEFubm90YXRpb25FbGVtZW50IiwiU0VFRCIsIk1BU0tfSElHSCIsIk1BU0tfTE9XIiwiTXVybXVySGFzaDNfNjQiLCJzZWVkIiwiaDEiLCJoMiIsInVwZGF0ZSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYnl0ZUxlbmd0aCIsImJsb2NrQ291bnRzIiwidGFpbExlbmd0aCIsImRhdGFVaW50MzIiLCJrMSIsImsyIiwiQzEiLCJDMiIsIkMxX0xPVyIsIkMyX0xPVyIsImhleGRpZ2VzdCIsIlNlcmlhbGl6YWJsZUVtcHR5IiwiaGFzaCIsInRyYW5zZmVyIiwiQW5ub3RhdGlvblN0b3JhZ2UiLCJtb2RpZmllZCIsIm1vZGlmaWVkSWRzIiwic3RvcmFnZSIsIm9uU2V0TW9kaWZpZWQiLCJvblJlc2V0TW9kaWZpZWQiLCJvbkFubm90YXRpb25FZGl0b3IiLCJnZXRWYWx1ZSIsImRlZmF1bHRWYWx1ZSIsInJlc2V0TW9kaWZpZWQiLCJlbnRyeSIsInZhbCIsInNldE1vZGlmaWVkIiwiZ2V0QWxsIiwic2V0QWxsIiwicHJpbnQiLCJQcmludEFubm90YXRpb25TdG9yYWdlIiwic2VyaWFsaXphYmxlIiwiaGFzQml0bWFwIiwiZWRpdG9yU3RhdHMiLCJzdGF0cyIsInR5cGVUb0VkaXRvciIsImNvdW50ZXJzIiwiY291bnQiLCJjb21wdXRlVGVsZW1ldHJ5RmluYWxEYXRhIiwicmVzZXRNb2RpZmllZElkcyIsImlkcyIsInN0cnVjdHVyZWRDbG9uZSIsIkZvbnRMb2FkZXIiLCJzeXN0ZW1Gb250cyIsIm93bmVyRG9jdW1lbnQiLCJzdHlsZUVsZW1lbnQiLCJfZG9jdW1lbnQiLCJuYXRpdmVGb250RmFjZXMiLCJsb2FkaW5nUmVxdWVzdHMiLCJsb2FkVGVzdEZvbnRJZCIsImFkZE5hdGl2ZUZvbnRGYWNlIiwibmF0aXZlRm9udEZhY2UiLCJmb250cyIsInJlbW92ZU5hdGl2ZUZvbnRGYWNlIiwiaW5zZXJ0UnVsZSIsInJ1bGUiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInN0eWxlU2hlZXQiLCJzaGVldCIsImNzc1J1bGVzIiwibG9hZFN5c3RlbUZvbnQiLCJzeXN0ZW1Gb250SW5mbyIsIl9pbnNwZWN0Rm9udCIsImxvYWRlZE5hbWUiLCJkaXNhYmxlRm9udEZhY2UiLCJpc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkIiwiZm9udEZhY2UiLCJGb250RmFjZSIsImxvYWQiLCJiYXNlRm9udE5hbWUiLCJmb250IiwiYXR0YWNoZWQiLCJtaXNzaW5nRmlsZSIsImNyZWF0ZU5hdGl2ZUZvbnRGYWNlIiwibG9hZGVkIiwiZmFtaWx5IiwiY3JlYXRlRm9udEZhY2VSdWxlIiwiaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWQiLCJfcXVldWVMb2FkaW5nQ2FsbGJhY2siLCJfcHJlcGFyZUZvbnRMb2FkRXZlbnQiLCJoYXNGb250cyIsInN1cHBvcnRlZCIsImNvbXBsZXRlUmVxdWVzdCIsImRvbmUiLCJvdGhlclJlcXVlc3QiLCJzaGlmdCIsImNvbXBsZXRlIiwiX2xvYWRUZXN0Rm9udCIsInRlc3RGb250IiwiaW50MzIiLCJvZmZzZXQiLCJzcGxpY2VTdHJpbmciLCJzIiwiaW5zZXJ0IiwiY2h1bmsxIiwiY2h1bmsyIiwiY2FsbGVkIiwiaXNGb250UmVhZHkiLCJmaWxsVGV4dCIsImltYWdlRGF0YSIsIkNPTU1FTlRfT0ZGU0VUIiwiQ0ZGX0NIRUNLU1VNX09GRlNFVCIsIlhYWFhfVkFMVUUiLCJjaGVja3N1bSIsImZvbnRGYW1pbHkiLCJGb250RmFjZU9iamVjdCIsInRyYW5zbGF0ZWREYXRhIiwiZm9udEV4dHJhUHJvcGVydGllcyIsImluc3BlY3RGb250IiwiY29tcGlsZWRHbHlwaHMiLCJjc3NGb250SW5mbyIsImNzcyIsIndlaWdodCIsImZvbnRXZWlnaHQiLCJpdGFsaWNBbmdsZSIsIm1pbWV0eXBlIiwiZ2V0UGF0aEdlbmVyYXRvciIsIm9ianMiLCJjaGFyYWN0ZXIiLCJvYmpJZCIsImNtZHMiLCJwYXRoIiwiUGF0aDJEIiwiQ2FsbGJhY2tLaW5kIiwiREFUQSIsIkVSUk9SIiwiU3RyZWFtS2luZCIsIkNBTkNFTCIsIkNBTkNFTF9DT01QTEVURSIsIkNMT1NFIiwiRU5RVUVVRSIsIlBVTEwiLCJQVUxMX0NPTVBMRVRFIiwiU1RBUlRfQ09NUExFVEUiLCJvbkZuIiwid3JhcFJlYXNvbiIsIk1lc3NhZ2VIYW5kbGVyIiwibWVzc2FnZUFDIiwic291cmNlTmFtZSIsInRhcmdldE5hbWUiLCJjb21PYmoiLCJjYWxsYmFja0lkIiwic3RyZWFtSWQiLCJzdHJlYW1TaW5rcyIsInN0cmVhbUNvbnRyb2xsZXJzIiwiY2FsbGJhY2tDYXBhYmlsaXRpZXMiLCJhY3Rpb25IYW5kbGVyIiwib25NZXNzYWdlIiwic3RyZWFtIiwicHJvY2Vzc1N0cmVhbU1lc3NhZ2UiLCJjYXBhYmlsaXR5IiwicmVhc29uIiwicG9zdE1lc3NhZ2UiLCJjcmVhdGVTdHJlYW1TaW5rIiwiYWN0aW9uTmFtZSIsImhhbmRsZXIiLCJhaCIsInRyYW5zZmVycyIsInNlbmRXaXRoUHJvbWlzZSIsInNlbmRXaXRoU3RyZWFtIiwicXVldWVpbmdTdHJhdGVneSIsIlJlYWRhYmxlU3RyZWFtIiwiY29udHJvbGxlciIsInN0YXJ0Q2FwYWJpbGl0eSIsInN0YXJ0Q2FsbCIsInB1bGxDYWxsIiwiY2FuY2VsQ2FsbCIsImlzQ2xvc2VkIiwiZGVzaXJlZFNpemUiLCJwdWxsIiwicHVsbENhcGFiaWxpdHkiLCJjYW5jZWxDYXBhYmlsaXR5Iiwic3RyZWFtU2luayIsImVucXVldWUiLCJpc0NhbmNlbGxlZCIsImxhc3REZXNpcmVkU2l6ZSIsInNpbmtDYXBhYmlsaXR5IiwicmVhZHkiLCJlcnJvciIsIm9uUHVsbCIsIm9uQ2FuY2VsIiwic3VjY2VzcyIsInN0cmVhbUNvbnRyb2xsZXIiLCJkZWxldGVTdHJlYW1Db250cm9sbGVyIiwiZGF0YVJlYXNvbiIsImFsbFNldHRsZWQiLCJCYXNlQ2FudmFzRmFjdG9yeSIsImVuYWJsZUhXQSIsIl9jcmVhdGVDYW52YXMiLCJyZXNldCIsImNhbnZhc0FuZENvbnRleHQiLCJET01DYW52YXNGYWN0b3J5IiwiQmFzZUNNYXBSZWFkZXJGYWN0b3J5IiwiaXNDb21wcmVzc2VkIiwiX2ZldGNoIiwiY01hcERhdGEiLCJjYXRjaCIsIkRPTUNNYXBSZWFkZXJGYWN0b3J5IiwiQmFzZUZpbHRlckZhY3RvcnkiLCJhZGRGaWx0ZXIiLCJtYXBzIiwiZmdDb2xvciIsImJnQ29sb3IiLCJhZGRBbHBoYUZpbHRlciIsImFkZEx1bWlub3NpdHlGaWx0ZXIiLCJhZGRIaWdobGlnaHRIQ01GaWx0ZXIiLCJmaWx0ZXJOYW1lIiwibmV3RmdDb2xvciIsIm5ld0JnQ29sb3IiLCJrZWVwSENNIiwiRE9NRmlsdGVyRmFjdG9yeSIsIl9jYWNoZSIsIl9kZWZzIiwiZG9jSWQiLCJfaGNtQ2FjaGUiLCJoY21DYWNoZSIsImRlZnMiLCJjb250YWluIiwiY3JlYXRlRWxlbWVudE5TIiwiY3JlYXRlVGFibGVzIiwibWFwUiIsInRhYmxlIiwibWFwRyIsIm1hcEIiLCJidWZmZXJSIiwiYnVmZmVyRyIsImJ1ZmZlckIiLCJjcmVhdGVVcmwiLCJ0YWJsZVIiLCJ0YWJsZUciLCJ0YWJsZUIiLCJmaWx0ZXIiLCJjcmVhdGVGaWx0ZXIiLCJhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24iLCJmZ1JHQiIsImJnUkdCIiwiYWRkR3JheUNvbnZlcnNpb24iLCJnZXRTdGVwcyIsInRhYmxlQSIsImFkZFRyYW5zZmVyTWFwQWxwaGFDb252ZXJzaW9uIiwiYWRkTHVtaW5vc2l0eUNvbnZlcnNpb24iLCJmZ0dyYXkiLCJiZ0dyYXkiLCJuZXdGZ1JHQiIsIm5ld0JnUkdCIiwiZmciLCJiZyIsInN0ZXAiLCJuZXdTdGFydCIsIm5ld1N0ZXAiLCJwcmV2IiwiayIsImoiLCJmZUNvbG9yTWF0cml4IiwiYXBwZW5kRmVGdW5jIiwiZmVDb21wb25lbnRUcmFuc2ZlciIsImZ1bmMiLCJmZUZ1bmMiLCJyVGFibGUiLCJnVGFibGUiLCJiVGFibGUiLCJhVGFibGUiLCJCYXNlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSIsIm5vZGVfdXRpbHNfZmV0Y2hEYXRhIiwiZnMiLCJnZXRCdWlsdGluTW9kdWxlIiwicmVhZEZpbGUiLCJOb2RlRmlsdGVyRmFjdG9yeSIsIk5vZGVDYW52YXNGYWN0b3J5IiwicmVxdWlyZSIsImNyZWF0ZVJlcXVpcmUiLCJjcmVhdGVDYW52YXMiLCJOb2RlQ01hcFJlYWRlckZhY3RvcnkiLCJOb2RlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJQYXRoVHlwZSIsIlNIQURJTkciLCJhcHBseUJvdW5kaW5nQm94IiwiYmJveCIsInJlZ2lvbiIsIkJhc2VTaGFkaW5nUGF0dGVybiIsImdldFBhdHRlcm4iLCJSYWRpYWxBeGlhbFNoYWRpbmdQYXR0ZXJuIiwiSVIiLCJfYmJveCIsIl9jb2xvclN0b3BzIiwiX3AwIiwiX3AxIiwiX3IwIiwiX3IxIiwibWF0cml4IiwiX2NyZWF0ZUdyYWRpZW50IiwiZ3JhZCIsImNyZWF0ZUxpbmVhckdyYWRpZW50IiwiY3JlYXRlUmFkaWFsR3JhZGllbnQiLCJjb2xvclN0b3AiLCJhZGRDb2xvclN0b3AiLCJvd25lciIsImludmVyc2UiLCJwYXRoVHlwZSIsInBhdHRlcm4iLCJvd25lckJCb3giLCJjdXJyZW50IiwiZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveCIsImNlaWwiLCJ0bXBDYW52YXMiLCJjYWNoZWRDYW52YXNlcyIsImdldENhbnZhcyIsInRtcEN0eCIsImNsZWFyUmVjdCIsImJlZ2luUGF0aCIsImJhc2VUcmFuc2Zvcm0iLCJmaWxsU3R5bGUiLCJjcmVhdGVQYXR0ZXJuIiwiZG9tTWF0cml4IiwiRE9NTWF0cml4Iiwic2V0VHJhbnNmb3JtIiwiZHJhd1RyaWFuZ2xlIiwiYzEiLCJjMiIsImMzIiwiY29vcmRzIiwicm93U2l6ZSIsInRtcCIsInNjYWxlWCIsInNjYWxlWSIsImMxciIsImMxZyIsImMxYiIsImMyciIsImMyZyIsImMyYiIsImMzciIsImMzZyIsImMzYiIsIm1pblkiLCJtYXhZIiwieGEiLCJjYXIiLCJjYWciLCJjYWIiLCJ4YiIsImNiciIsImNiZyIsImNiYiIsIngxXyIsIngyXyIsImRyYXdGaWd1cmUiLCJmaWd1cmUiLCJwcyIsImNzIiwidmVydGljZXNQZXJSb3ciLCJyb3dzIiwiY29scyIsInEiLCJNZXNoU2hhZGluZ1BhdHRlcm4iLCJfY29vcmRzIiwiX2ZpZ3VyZXMiLCJfYm91bmRzIiwiX2JhY2tncm91bmQiLCJfY3JlYXRlTWVzaENhbnZhcyIsImNvbWJpbmVkU2NhbGUiLCJiYWNrZ3JvdW5kQ29sb3IiLCJFWFBFQ1RFRF9TQ0FMRSIsIk1BWF9QQVRURVJOX1NJWkUiLCJCT1JERVJfU0laRSIsImJvdW5kc1dpZHRoIiwiYm91bmRzSGVpZ2h0IiwicGFkZGVkV2lkdGgiLCJwYWRkZWRIZWlnaHQiLCJjcmVhdGVJbWFnZURhdGEiLCJwdXRJbWFnZURhdGEiLCJtYXRyaXhTY2FsZSIsInRlbXBvcmFyeVBhdHRlcm5DYW52YXMiLCJEdW1teVNoYWRpbmdQYXR0ZXJuIiwiZ2V0U2hhZGluZ1BhdHRlcm4iLCJQYWludFR5cGUiLCJDT0xPUkVEIiwiVU5DT0xPUkVEIiwiVGlsaW5nUGF0dGVybiIsImNhbnZhc0dyYXBoaWNzRmFjdG9yeSIsIm9wZXJhdG9yTGlzdCIsInhzdGVwIiwieXN0ZXAiLCJwYWludFR5cGUiLCJ0aWxpbmdUeXBlIiwiY3JlYXRlUGF0dGVybkNhbnZhcyIsImN1ck1hdHJpeFNjYWxlIiwiY29tYmluZWRTY2FsZVgiLCJjb21iaW5lZFNjYWxlWSIsImNhbnZhc1dpZHRoIiwiY2FudmFzSGVpZ2h0IiwicmVkcmF3SG9yaXpvbnRhbGx5IiwicmVkcmF3VmVydGljYWxseSIsInhTY2FsZWRTdGVwIiwieVNjYWxlZFN0ZXAiLCJ4U2NhbGVkV2lkdGgiLCJ5U2NhbGVkSGVpZ2h0IiwiZGlteCIsImdldFNpemVBbmRTY2FsZSIsImRpbXkiLCJncmFwaGljcyIsImNyZWF0ZUNhbnZhc0dyYXBoaWNzIiwiZ3JvdXBMZXZlbCIsInNldEZpbGxBbmRTdHJva2VTdHlsZVRvQ29udGV4dCIsImNsaXBCYm94IiwiZXhlY3V0ZU9wZXJhdG9yTGlzdCIsImVuZERyYXdpbmciLCJkaW14MiIsImRpbXkyIiwieFNpemUiLCJ5U2l6ZSIsInRtcENhbnZhczIiLCJ0bXBDdHgyIiwiamoiLCJyZWFsT3V0cHV0U2l6ZSIsImJib3hXaWR0aCIsImJib3hIZWlnaHQiLCJ1cGRhdGVSZWN0TWluTWF4Iiwic3Ryb2tlU3R5bGUiLCJmaWxsQ29sb3IiLCJzdHJva2VDb2xvciIsImNzc0NvbG9yIiwiY29udmVydFRvUkdCQSIsImtpbmQiLCJjb252ZXJ0QmxhY2tBbmRXaGl0ZVRvUkdCQSIsImNvbnZlcnRSR0JUb1JHQkEiLCJzcmNQb3MiLCJkZXN0Iiwibm9uQmxhY2tDb2xvciIsImludmVyc2VEZWNvZGUiLCJibGFjayIsInplcm9NYXBwaW5nIiwib25lTWFwcGluZyIsIndpZHRoSW5Tb3VyY2UiLCJ3aWR0aFJlbWFpbmRlciIsInNyY0xlbmd0aCIsImRlc3RQb3MiLCJlbGVtIiwibGVuIiwibGVuMzIiLCJzcmMzMiIsInMxIiwiczIiLCJzMyIsImdyYXlUb1JHQkEiLCJNSU5fRk9OVF9TSVpFIiwiTUFYX0ZPTlRfU0laRSIsIkVYRUNVVElPTl9USU1FIiwiRVhFQ1VUSU9OX1NURVBTIiwiTUFYX1NJWkVfVE9fQ09NUElMRSIsIkZVTExfQ0hVTktfSEVJR0hUIiwibWlycm9yQ29udGV4dE9wZXJhdGlvbnMiLCJkZXN0Q3R4IiwiX3JlbW92ZU1pcnJvcmluZyIsIl9fb3JpZ2luYWxTYXZlIiwiX19vcmlnaW5hbFJlc3RvcmUiLCJfX29yaWdpbmFsUm90YXRlIiwiX19vcmlnaW5hbFNjYWxlIiwiX19vcmlnaW5hbFRyYW5zbGF0ZSIsIl9fb3JpZ2luYWxUcmFuc2Zvcm0iLCJfX29yaWdpbmFsU2V0VHJhbnNmb3JtIiwiX19vcmlnaW5hbFJlc2V0VHJhbnNmb3JtIiwicmVzZXRUcmFuc2Zvcm0iLCJfX29yaWdpbmFsQ2xpcCIsIl9fb3JpZ2luYWxNb3ZlVG8iLCJfX29yaWdpbmFsTGluZVRvIiwiX19vcmlnaW5hbEJlemllckN1cnZlVG8iLCJiZXppZXJDdXJ2ZVRvIiwiX19vcmlnaW5hbFJlY3QiLCJfX29yaWdpbmFsQ2xvc2VQYXRoIiwiX19vcmlnaW5hbEJlZ2luUGF0aCIsImN0eFNhdmUiLCJjdHhSZXN0b3JlIiwiY3R4VHJhbnNsYXRlIiwiY3R4U2NhbGUiLCJjdHhUcmFuc2Zvcm0iLCJjdHhTZXRUcmFuc2Zvcm0iLCJjdHhSZXNldFRyYW5zZm9ybSIsImN0eFJvdGF0ZSIsImNwMXgiLCJjcDF5IiwiY3AyeCIsImNwMnkiLCJDYWNoZWRDYW52YXNlcyIsImNhbnZhc0ZhY3RvcnkiLCJjYW52YXNFbnRyeSIsImRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyIsInNyY0ltZyIsInNyY1giLCJzcmNZIiwic3JjVyIsInNyY0giLCJkZXN0WCIsImRlc3RZIiwiZGVzdFciLCJkZXN0SCIsInRsWCIsInJUbFgiLCJ0bFkiLCJyVGxZIiwiYnJYIiwicldpZHRoIiwiYnJZIiwickhlaWdodCIsInNpZ24iLCJjb21waWxlVHlwZTNHbHlwaCIsImltZ0RhdGEiLCJQT0lOVF9UT19QUk9DRVNTX0xJTUlUIiwiUE9JTlRfVFlQRVMiLCJ3aWR0aDEiLCJwb2ludHMiLCJqMCIsImxpbmVTaXplIiwicG9zIiwibWFzayIsInN1bSIsInN0ZXBzIiwiSW50MzJBcnJheSIsInAwIiwicHAiLCJkcmF3T3V0bGluZSIsIkNhbnZhc0V4dHJhU3RhdGUiLCJhbHBoYUlzU2hhcGUiLCJmb250U2l6ZSIsImZvbnRTaXplU2NhbGUiLCJ0ZXh0TWF0cml4IiwidGV4dE1hdHJpeFNjYWxlIiwiZm9udE1hdHJpeCIsImxlYWRpbmciLCJsaW5lWCIsImxpbmVZIiwiY2hhclNwYWNpbmciLCJ3b3JkU3BhY2luZyIsInRleHRIU2NhbGUiLCJ0ZXh0UmVuZGVyaW5nTW9kZSIsInRleHRSaXNlIiwicGF0dGVybkZpbGwiLCJwYXR0ZXJuU3Ryb2tlIiwiZmlsbEFscGhhIiwic3Ryb2tlQWxwaGEiLCJsaW5lV2lkdGgiLCJhY3RpdmVTTWFzayIsInRyYW5zZmVyTWFwcyIsInN0YXJ0TmV3UGF0aEFuZENsaXBCb3giLCJjbGlwQm94Iiwic2V0Q3VycmVudFBvaW50IiwidXBkYXRlUGF0aE1pbk1heCIsIm1pblgiLCJtYXhYIiwidXBkYXRlU2NhbGluZ1BhdGhNaW5NYXgiLCJ1cGRhdGVDdXJ2ZVBhdGhNaW5NYXgiLCJnZXRQYXRoQm91bmRpbmdCb3giLCJ4U3Ryb2tlUGFkIiwieVN0cm9rZVBhZCIsInVwZGF0ZUNsaXBGcm9tUGF0aCIsImlzRW1wdHlDbGlwIiwiSW5maW5pdHkiLCJwdXRCaW5hcnlJbWFnZURhdGEiLCJJbWFnZURhdGEiLCJwYXJ0aWFsQ2h1bmtIZWlnaHQiLCJmdWxsQ2h1bmtzIiwidG90YWxDaHVua3MiLCJjaHVua0ltZ0RhdGEiLCJ0aGlzQ2h1bmtIZWlnaHQiLCJlbGVtc0luVGhpc0NodW5rIiwiZGVzdDMyIiwiZGVzdDMyRGF0YUxlbmd0aCIsImZ1bGxTcmNEaWZmIiwid2hpdGUiLCJzcmNEaWZmIiwia0VuZCIsImtFbmRVbnJvbGxlZCIsInNyY0J5dGUiLCJwdXRCaW5hcnlJbWFnZU1hc2siLCJjb3B5Q3R4U3RhdGUiLCJzb3VyY2VDdHgiLCJwcm9wZXJ0aWVzIiwicHJvcGVydHkiLCJzZXRMaW5lRGFzaCIsImdldExpbmVEYXNoIiwibGluZURhc2hPZmZzZXQiLCJyZXNldEN0eFRvRGVmYXVsdCIsImZpbGxSdWxlIiwiZ2xvYmFsQWxwaGEiLCJsaW5lQ2FwIiwibGluZUpvaW4iLCJtaXRlckxpbWl0IiwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIiwiZ2V0SW1hZ2VTbW9vdGhpbmdFbmFibGVkIiwiaW50ZXJwb2xhdGUiLCJmcm91bmQiLCJhY3R1YWxTY2FsZSIsIkxJTkVfQ0FQX1NUWUxFUyIsIkxJTkVfSk9JTl9TVFlMRVMiLCJOT1JNQUxfQ0xJUCIsIkVPX0NMSVAiLCJDYW52YXNHcmFwaGljcyIsImNhbnZhc0N0eCIsImNvbW1vbk9ianMiLCJvcHRpb25hbENvbnRlbnRDb25maWciLCJtYXJrZWRDb250ZW50U3RhY2siLCJhbm5vdGF0aW9uQ2FudmFzTWFwIiwic3RhdGVTdGFjayIsInBlbmRpbmdDbGlwIiwicGVuZGluZ0VPRmlsbCIsInJlcyIsInhvYmpzIiwiZ3JvdXBTdGFjayIsInByb2Nlc3NpbmdUeXBlMyIsImJhc2VUcmFuc2Zvcm1TdGFjayIsInNtYXNrU3RhY2siLCJzbWFza0NvdW50ZXIiLCJ0ZW1wU01hc2siLCJzdXNwZW5kZWRDdHgiLCJjb250ZW50VmlzaWJsZSIsImNhY2hlZFBhdHRlcm5zIiwidmlld3BvcnRTY2FsZSIsIm91dHB1dFNjYWxlWCIsIm91dHB1dFNjYWxlWSIsIl9jYWNoZWRTY2FsZUZvclN0cm9raW5nIiwiX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGgiLCJfY2FjaGVkQml0bWFwc01hcCIsImdldE9iamVjdCIsImZhbGxiYWNrIiwiYmVnaW5EcmF3aW5nIiwidHJhbnNwYXJlbmN5Iiwic2F2ZWRGaWxsU3R5bGUiLCJmaWxsUmVjdCIsInRyYW5zcGFyZW50Q2FudmFzIiwiY29tcG9zaXRlQ3R4IiwiZXhlY3V0aW9uU3RhcnRJZHgiLCJjb250aW51ZUNhbGxiYWNrIiwic3RlcHBlciIsImFyZ3NBcnJheSIsImZuQXJyYXkiLCJhcmdzQXJyYXlMZW4iLCJjaHVua09wZXJhdGlvbnMiLCJlbmRUaW1lIiwiZm5JZCIsIm5leHRCcmVha1BvaW50IiwiYnJlYWtJdCIsImRlcE9iaklkIiwib2Jqc1Bvb2wiLCJyZXN0b3JlSW5pdGlhbFN0YXRlIiwiaW5TTWFza01vZGUiLCJIVE1MQ2FudmFzRWxlbWVudCIsImRyYXdGaWx0ZXIiLCJoY21GaWx0ZXJJZCIsInNhdmVkRmlsdGVyIiwiX3NjYWxlSW1hZ2UiLCJpbWciLCJkaXNwbGF5V2lkdGgiLCJkaXNwbGF5SGVpZ2h0Iiwid2lkdGhTY2FsZSIsImhlaWdodFNjYWxlIiwicGFpbnRXaWR0aCIsInBhaW50SGVpZ2h0IiwidG1wQ2FudmFzSWQiLCJfY3JlYXRlTWFza0NhbnZhcyIsImlzUGF0dGVybkZpbGwiLCJjdXJyZW50VHJhbnNmb3JtIiwiY2FjaGVLZXkiLCJtYXNrQ2FudmFzIiwibWFpbktleSIsImNhY2hlZEltYWdlIiwibWFza1RvQ2FudmFzIiwiZHJhd25XaWR0aCIsImRyYXduSGVpZ2h0IiwiZmlsbENhbnZhcyIsImZpbGxDdHgiLCJpbWFnZVNtb290aGluZ0VuYWJsZWQiLCJsaW1pdCIsImRhc2hBcnJheSIsImRhc2hQaGFzZSIsImludGVudCIsImZsYXRuZXNzIiwic3RhdGVzIiwiY2hlY2tTTWFza1N0YXRlIiwiYmVnaW5TTWFza01vZGUiLCJlbmRTTWFza01vZGUiLCJjYWNoZUlkIiwic2NyYXRjaENhbnZhcyIsImNvbXBvc2UiLCJkaXJ0eUJveCIsInNtYXNrIiwiY29tcG9zZVNNYXNrIiwibGF5ZXJDdHgiLCJsYXllckJveCIsImxheWVyT2Zmc2V0WCIsImxheWVyT2Zmc2V0WSIsImxheWVyV2lkdGgiLCJsYXllckhlaWdodCIsImdlbmVyaWNDb21wb3NlU01hc2siLCJzdWJ0eXBlIiwiYmFja2Ryb3AiLCJ0cmFuc2Zlck1hcCIsIm1hc2tDdHgiLCJtYXNrT2Zmc2V0WCIsIm1hc2tPZmZzZXRZIiwibWFza1giLCJtYXNrWSIsImJhY2tkcm9wUkdCIiwib2xkIiwicG9wIiwib3BzIiwic3RhcnRYIiwic3RhcnRZIiwiaXNTY2FsaW5nTWF0cml4IiwibWluTWF4Rm9yQmV6aWVyIiwieHciLCJ5aCIsImNvbnN1bWVQYXRoIiwicmVzY2FsZUFuZFN0cm9rZSIsIm5lZWRSZXN0b3JlIiwicGF0aHMiLCJwZW5kaW5nVGV4dFBhdGhzIiwibmV3UGF0aCIsImFkZFBhdGgiLCJwcmVNdWx0aXBseVNlbGYiLCJzcGFjaW5nIiwiZm9udFJlZk5hbWUiLCJmb250T2JqIiwiZm9udERpcmVjdGlvbiIsImlzVHlwZTNGb250IiwidHlwZWZhY2UiLCJmYWxsYmFja05hbWUiLCJib2xkIiwiaXRhbGljIiwiYnJvd3NlckZvbnRTaXplIiwicmlzZSIsImdldFNjYWxlZFBhdGgiLCJtdWx0aXBseVNlbGYiLCJwYWludENoYXIiLCJwYXR0ZXJuRmlsbFRyYW5zZm9ybSIsInBhdHRlcm5TdHJva2VUcmFuc2Zvcm0iLCJmaWxsU3Ryb2tlTW9kZSIsImlzQWRkVG9QYXRoU2V0Iiwic3Ryb2tlVGV4dCIsImlzRm9udFN1YnBpeGVsQUFFbmFibGVkIiwiZ2x5cGhzIiwic2hvd1R5cGUzVGV4dCIsImdseXBoc0xlbmd0aCIsInZlcnRpY2FsIiwic3BhY2luZ0RpciIsImRlZmF1bHRWTWV0cmljcyIsIndpZHRoQWR2YW5jZVNjYWxlIiwic2ltcGxlRmlsbFRleHQiLCJnZXRTaW5nbGVQaXhlbFdpZHRoIiwiaXNJbnZhbGlkUERGanNGb250IiwiY2hhcnMiLCJnbHlwaCIsInVuaWNvZGUiLCJyZXN0b3JlTmVlZGVkIiwiaXNTcGFjZSIsImZvbnRDaGFyIiwiYWNjZW50Iiwic2NhbGVkWCIsInNjYWxlZFkiLCJ2bWV0cmljIiwidngiLCJ2eSIsInJlbWVhc3VyZSIsIm1lYXN1cmVkV2lkdGgiLCJtZWFzdXJlVGV4dCIsImNoYXJhY3RlclNjYWxlWCIsImlzSW5Gb250Iiwic2NhbGVkQWNjZW50WCIsInNjYWxlZEFjY2VudFkiLCJjaGFyV2lkdGgiLCJpc1RleHRJbnZpc2libGUiLCJzcGFjaW5nTGVuZ3RoIiwiY2hhclByb2NPcGVyYXRvckxpc3QiLCJvcGVyYXRvckxpc3RJZCIsInRyYW5zZm9ybWVkIiwieFdpZHRoIiwieVdpZHRoIiwibGx4IiwibGx5IiwidXJ4IiwidXJ5IiwiZ2V0Q29sb3JOX1BhdHRlcm4iLCJfZ2V0UGF0dGVybiIsImFyZ3VtZW50cyIsImludiIsImdyb3VwIiwiY3VycmVudEN0eCIsImlzb2xhdGVkIiwia25vY2tvdXQiLCJib3VuZHMiLCJjYW52YXNCb3VuZHMiLCJncm91cEN0eCIsInN0YXJ0VHJhbnNmb3JtSW52ZXJzZSIsImN1cnJlbnRNdHgiLCJoYXNPd25DYW52YXMiLCJhbm5vdGF0aW9uQ2FudmFzIiwic2F2ZWRDdHgiLCJjb21waWxlZCIsInNrZXdYIiwic2tld1kiLCJwb3NpdGlvbnMiLCJ0cmFucyIsImltYWdlcyIsImFwcGx5VHJhbnNmZXJNYXBzVG9DYW52YXMiLCJhcHBseVRyYW5zZmVyTWFwc1RvQml0bWFwIiwiaW1nVG9QYWludCIsIkhUTUxFbGVtZW50IiwidGFnIiwiaXNWaXNpYmxlIiwiaXNDb250ZW50VmlzaWJsZSIsImFic0RldCIsIm5vcm1YIiwibm9ybVkiLCJnZXRTY2FsZUZvclN0cm9raW5nIiwic2NhbGVkTGluZVdpZHRoIiwic2NhbGVkWExpbmVXaWR0aCIsInNjYWxlZFlMaW5lV2lkdGgiLCJiYXNlQXJlYSIsInNhdmVSZXN0b3JlIiwiZGFzaGVzIiwib3AiLCJwb3J0Iiwid29ya2VyUG9ydCIsIldvcmtlciIsIndvcmtlclNyYyIsIk1ldGFkYXRhIiwibWV0YWRhdGFNYXAiLCJwYXJzZWREYXRhIiwiZ2V0UmF3IiwiSU5URVJOQUwiLCJTeW1ib2wiLCJPcHRpb25hbENvbnRlbnRHcm91cCIsImlzRGlzcGxheSIsImlzUHJpbnQiLCJ1c2VyU2V0IiwicmVuZGVyaW5nSW50ZW50IiwidXNhZ2UiLCJyYkdyb3VwcyIsInZpZXciLCJ2aWV3U3RhdGUiLCJwcmludFN0YXRlIiwiX3NldFZpc2libGUiLCJpbnRlcm5hbCIsIk9wdGlvbmFsQ29udGVudENvbmZpZyIsImNhY2hlZEdldEhhc2giLCJncm91cHMiLCJpbml0aWFsSGFzaCIsIm9yZGVyIiwiY3JlYXRvciIsImJhc2VTdGF0ZSIsIm9mZiIsImdldEhhc2giLCJldmFsdWF0ZVZpc2liaWxpdHlFeHByZXNzaW9uIiwiYXJyYXkiLCJvcGVyYXRvciIsImV4cHJlc3Npb24iLCJwb2xpY3kiLCJzZXRWaXNpYmlsaXR5IiwicHJlc2VydmVSQiIsInJiR3JvdXAiLCJvdGhlcklkIiwic2V0T0NHU3RhdGUiLCJoYXNJbml0aWFsVmlzaWJpbGl0eSIsImdldE9yZGVyIiwiZ2V0R3JvdXBzIiwiZ2V0R3JvdXAiLCJQREZEYXRhVHJhbnNwb3J0U3RyZWFtIiwicGRmRGF0YVJhbmdlVHJhbnNwb3J0IiwiZGlzYWJsZVJhbmdlIiwiZGlzYWJsZVN0cmVhbSIsImluaXRpYWxEYXRhIiwicHJvZ3Jlc3NpdmVEb25lIiwiY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUiLCJfcXVldWVkQ2h1bmtzIiwiX3Byb2dyZXNzaXZlRG9uZSIsIl9jb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSIsIl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQiLCJfaXNTdHJlYW1pbmdTdXBwb3J0ZWQiLCJfaXNSYW5nZVN1cHBvcnRlZCIsIl9jb250ZW50TGVuZ3RoIiwiX2Z1bGxSZXF1ZXN0UmVhZGVyIiwiX3JhbmdlUmVhZGVycyIsImFkZFJhbmdlTGlzdGVuZXIiLCJiZWdpbiIsIl9vblJlY2VpdmVEYXRhIiwiYWRkUHJvZ3Jlc3NMaXN0ZW5lciIsInRvdGFsIiwiX29uUHJvZ3Jlc3MiLCJhZGRQcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lciIsImFkZFByb2dyZXNzaXZlRG9uZUxpc3RlbmVyIiwiX29uUHJvZ3Jlc3NpdmVEb25lIiwidHJhbnNwb3J0UmVhZHkiLCJfZW5xdWV1ZSIsImZvdW5kIiwicmFuZ2VSZWFkZXIiLCJfYmVnaW4iLCJfcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoIiwiX2xvYWRlZCIsIm9uUHJvZ3Jlc3MiLCJfcmVtb3ZlUmFuZ2VSZWFkZXIiLCJyZWFkZXIiLCJpbmRleE9mIiwiZ2V0RnVsbFJlYWRlciIsInF1ZXVlZENodW5rcyIsIlBERkRhdGFUcmFuc3BvcnRTdHJlYW1SZWFkZXIiLCJnZXRSYW5nZVJlYWRlciIsIlBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlciIsInJlcXVlc3REYXRhUmFuZ2UiLCJjYW5jZWxBbGxSZXF1ZXN0cyIsIl9zdHJlYW0iLCJfZG9uZSIsIl9maWxlbmFtZSIsIl9yZXF1ZXN0cyIsIl9oZWFkZXJzUmVhZHkiLCJyZXF1ZXN0Q2FwYWJpbGl0eSIsImhlYWRlcnNSZWFkeSIsImlzUmFuZ2VTdXBwb3J0ZWQiLCJpc1N0cmVhbWluZ1N1cHBvcnRlZCIsImNvbnRlbnRMZW5ndGgiLCJyZWFkIiwiX2VuZCIsIl9xdWV1ZWRDaHVuayIsInJlcXVlc3RzQ2FwYWJpbGl0eSIsImdldEZpbGVuYW1lRnJvbUNvbnRlbnREaXNwb3NpdGlvbkhlYWRlciIsImNvbnRlbnREaXNwb3NpdGlvbiIsIm5lZWRzRW5jb2RpbmdGaXh1cCIsInRvUGFyYW1SZWdFeHAiLCJyZmMyNjE2dW5xdW90ZSIsInJmYzU5ODdkZWNvZGUiLCJyZmMyMDQ3ZGVjb2RlIiwiZml4dXBFbmNvZGluZyIsInJmYzIyMzFnZXRwYXJhbSIsImF0dHJpYnV0ZVBhdHRlcm4iLCJmbGFncyIsInRleHRkZWNvZGUiLCJjb250ZW50RGlzcG9zaXRpb25TdHIiLCJpdGVyIiwicXVvdCIsInBhcnQiLCJwYXJ0cyIsInF1b3RpbmRleCIsImV4dHZhbHVlIiwiZW5jb2RpbmdlbmQiLCJsYW5ndmFsdWUiLCJyZXBsYWNlIiwiY2hhcnNldCIsImhleCIsImNyZWF0ZUhlYWRlcnMiLCJpc0h0dHAiLCJodHRwSGVhZGVycyIsImhlYWRlcnMiLCJIZWFkZXJzIiwiZ2V0UmVzcG9uc2VPcmlnaW4iLCJ2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyIsInJlc3BvbnNlSGVhZGVycyIsInJhbmdlQ2h1bmtTaXplIiwicmV0dXJuVmFsdWVzIiwiYWxsb3dSYW5nZVJlcXVlc3RzIiwic3VnZ2VzdGVkTGVuZ3RoIiwiY29udGVudEVuY29kaW5nIiwiZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlciIsImNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3IiLCJ2YWxpZGF0ZVJlc3BvbnNlU3RhdHVzIiwiY3JlYXRlRmV0Y2hPcHRpb25zIiwid2l0aENyZWRlbnRpYWxzIiwibWV0aG9kIiwiY3JlZGVudGlhbHMiLCJyZWRpcmVjdCIsImdldEFycmF5QnVmZmVyIiwiUERGRmV0Y2hTdHJlYW0iLCJfcmVzcG9uc2VPcmlnaW4iLCJfcmFuZ2VSZXF1ZXN0UmVhZGVycyIsIlBERkZldGNoU3RyZWFtUmVhZGVyIiwiUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlciIsIl9yZWFkZXIiLCJfd2l0aENyZWRlbnRpYWxzIiwiX2hlYWRlcnNDYXBhYmlsaXR5IiwiX2Rpc2FibGVSYW5nZSIsIl9yYW5nZUNodW5rU2l6ZSIsIl9hYm9ydENvbnRyb2xsZXIiLCJnZXRSZWFkZXIiLCJfcmVhZENhcGFiaWxpdHkiLCJyZXNwb25zZU9yaWdpbiIsIk9LX1JFU1BPTlNFIiwiUEFSVElBTF9DT05URU5UX1JFU1BPTlNFIiwibmV0d29ya19nZXRBcnJheUJ1ZmZlciIsInhociIsIk5ldHdvcmtNYW5hZ2VyIiwiY3VyclhocklkIiwicGVuZGluZ1JlcXVlc3RzIiwieGhySWQiLCJwZW5kaW5nUmVxdWVzdCIsInNldFJlcXVlc3RIZWFkZXIiLCJleHBlY3RlZFN0YXR1cyIsIm9uRXJyb3IiLCJvblN0YXRlQ2hhbmdlIiwib25wcm9ncmVzcyIsIm9uSGVhZGVyc1JlY2VpdmVkIiwib25Eb25lIiwieGhyU3RhdHVzIiwib2tfcmVzcG9uc2Vfb25fcmFuZ2VfcmVxdWVzdCIsInJhbmdlSGVhZGVyIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJnZXRSZXF1ZXN0WGhyIiwiaXNQZW5kaW5nUmVxdWVzdCIsImFib3J0UmVxdWVzdCIsIlBERk5ldHdvcmtTdHJlYW0iLCJfc291cmNlIiwiX21hbmFnZXIiLCJfb25SYW5nZVJlcXVlc3RSZWFkZXJDbG9zZWQiLCJQREZOZXR3b3JrU3RyZWFtRnVsbFJlcXVlc3RSZWFkZXIiLCJQREZOZXR3b3JrU3RyZWFtUmFuZ2VSZXF1ZXN0UmVhZGVyIiwib25DbG9zZWQiLCJtYW5hZ2VyIiwiX3VybCIsIl9mdWxsUmVxdWVzdElkIiwiX29uSGVhZGVyc1JlY2VpdmVkIiwiX29uRG9uZSIsIl9vbkVycm9yIiwiX2NhY2hlZENodW5rcyIsIl9zdG9yZWRFcnJvciIsImZ1bGxSZXF1ZXN0WGhySWQiLCJmdWxsUmVxdWVzdFhociIsInJlc3BvbnNlVVJMIiwicmF3UmVzcG9uc2VIZWFkZXJzIiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwidHJpbVN0YXJ0IiwibGVuZ3RoQ29tcHV0YWJsZSIsIl9yZXF1ZXN0SWQiLCJfY2xvc2UiLCJ1cmxSZWdleCIsInBhcnNlVXJsT3JQYXRoIiwic291cmNlVXJsIiwicGF0aFRvRmlsZVVSTCIsIlBERk5vZGVTdHJlYW0iLCJQREZOb2RlU3RyZWFtRnNGdWxsUmVhZGVyIiwiUERGTm9kZVN0cmVhbUZzUmFuZ2VSZWFkZXIiLCJfcmVhZGFibGVTdHJlYW0iLCJsc3RhdCIsInN0YXQiLCJfc2V0UmVhZGFibGVTdHJlYW0iLCJjcmVhdGVSZWFkU3RyZWFtIiwiX2Vycm9yIiwicmVhZGFibGVTdHJlYW0iLCJNQVhfVEVYVF9ESVZTX1RPX1JFTkRFUiIsIkRFRkFVTFRfRk9OVF9TSVpFIiwiREVGQVVMVF9GT05UX0FTQ0VOVCIsImRpc2FibGVQcm9jZXNzSXRlbXMiLCJmb250SW5zcGVjdG9yRW5hYmxlZCIsImxhbmciLCJsYXlvdXRUZXh0UGFyYW1zIiwicm9vdENvbnRhaW5lciIsInN0eWxlQ2FjaGUiLCJ0ZXh0Q29udGVudEl0ZW1zU3RyIiwidGV4dENvbnRlbnRTb3VyY2UiLCJ0ZXh0RGl2cyIsInRleHREaXZQcm9wZXJ0aWVzIiwiYXNjZW50Q2FjaGUiLCJjYW52YXNDb250ZXh0cyIsImNhbnZhc0N0eEZvbnRzIiwiV2Vha01hcCIsIm1pbkZvbnRTaXplIiwicGVuZGluZ1RleHRMYXllcnMiLCJGb250SW5zcGVjdG9yIiwiZW5zdXJlTWluRm9udFNpemVDb21wdXRlZCIsImZpbmFsbHkiLCJmb250RmFtaWx5TWFwIiwicHVtcCIsInN0eWxlcyIsInByb2Nlc3NJdGVtcyIsIm9uQmVmb3JlIiwiZ2V0Q3R4IiwibGF5b3V0IiwiYWJvcnRFeCIsImFwcGVuZFRleHQiLCJnZW9tIiwidGV4dERpdiIsImhhc1RleHQiLCJoYXNFT0wiLCJhdGFuMiIsImZvbnROYW1lIiwiZm9udFN1YnN0aXR1dGlvbiIsImZvbnRIZWlnaHQiLCJmb250QXNjZW50IiwiZ2V0QXNjZW50Iiwic2luIiwiY29zIiwic2NhbGVGYWN0b3JTdHIiLCJkaXZTdHlsZSIsImRpciIsImRhdGFzZXQiLCJmb250U3Vic3RpdHV0aW9uTG9hZGVkTmFtZSIsInNob3VsZFNjYWxlVGV4dCIsImFic1NjYWxlWCIsImFic1NjYWxlWSIsImJyIiwiZW5zdXJlQ3R4Rm9udCIsImNsZWFudXAiLCJhbHBoYSIsImNhY2hlZCIsImxpbmVIZWlnaHQiLCJjYWNoZWRBc2NlbnQiLCJtZXRyaWNzIiwiYXNjZW50IiwiZm9udEJvdW5kaW5nQm94QXNjZW50IiwiZGVzY2VudCIsImZvbnRCb3VuZGluZ0JveERlc2NlbnQiLCJyYXRpbyIsInBpeGVscyIsIlhmYVRleHQiLCJ4ZmEiLCJvdXRwdXQiLCJ3YWxrIiwibm9kZSIsInNob3VsZEJ1aWxkVGV4dCIsIkRFRkFVTFRfUkFOR0VfQ0hVTktfU0laRSIsIlJFTkRFUklOR19DQU5DRUxMRURfVElNRU9VVCIsIkRFTEFZRURfQ0xFQU5VUF9USU1FT1VUIiwiRGVmYXVsdENhbnZhc0ZhY3RvcnkiLCJEZWZhdWx0Q01hcFJlYWRlckZhY3RvcnkiLCJEZWZhdWx0RmlsdGVyRmFjdG9yeSIsIkRlZmF1bHRTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSIsInRhc2siLCJQREZEb2N1bWVudExvYWRpbmdUYXNrIiwiZ2V0VXJsUHJvcCIsImdldERhdGFQcm9wIiwicGFzc3dvcmQiLCJyYW5nZVRyYW5zcG9ydCIsIndvcmtlciIsImRvY0Jhc2VVcmwiLCJjTWFwVXJsIiwiY01hcFBhY2tlZCIsIkNNYXBSZWFkZXJGYWN0b3J5Iiwic3RhbmRhcmRGb250RGF0YVVybCIsIlN0YW5kYXJkRm9udERhdGFGYWN0b3J5IiwiaWdub3JlRXJyb3JzIiwic3RvcEF0RXJyb3JzIiwibWF4SW1hZ2VTaXplIiwiY2hyb21lIiwiY2FudmFzTWF4QXJlYUluQnl0ZXMiLCJlbmFibGVYZmEiLCJkaXNhYmxlQXV0b0ZldGNoIiwicGRmQnVnIiwiQ2FudmFzRmFjdG9yeSIsIkZpbHRlckZhY3RvcnkiLCJ1c2VTeXN0ZW1Gb250cyIsInVzZVdvcmtlckZldGNoIiwidHJhbnNwb3J0RmFjdG9yeSIsImNNYXBSZWFkZXJGYWN0b3J5Iiwic3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJ3b3JrZXJQYXJhbXMiLCJmcm9tUG9ydCIsIl93b3JrZXIiLCJkb2NQYXJhbXMiLCJhcGlWZXJzaW9uIiwiZXZhbHVhdG9yT3B0aW9ucyIsInRyYW5zcG9ydFBhcmFtcyIsImxvYWRpbmdQYXJhbXMiLCJkZXN0cm95ZWQiLCJ3b3JrZXJJZFByb21pc2UiLCJtZXNzYWdlSGFuZGxlciIsIm5ldHdvcmtTdHJlYW0iLCJOZXR3b3JrU3RyZWFtIiwiUmVzcG9uc2UiLCJ3b3JrZXJJZCIsInRyYW5zcG9ydCIsIldvcmtlclRyYW5zcG9ydCIsIl90cmFuc3BvcnQiLCJfY2FwYWJpbGl0eSIsImhyZWYiLCJsb2NhdGlvbiIsIkJ1ZmZlciIsImlzTmFOIiwiaXNSZWZQcm94eSIsInJlZiIsImdlbiIsIm9uUGFzc3dvcmQiLCJfcGVuZGluZ0Rlc3Ryb3kiLCJfcmFuZ2VMaXN0ZW5lcnMiLCJfcHJvZ3Jlc3NMaXN0ZW5lcnMiLCJfcHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzIiwiX3Byb2dyZXNzaXZlRG9uZUxpc3RlbmVycyIsIl9yZWFkeUNhcGFiaWxpdHkiLCJsaXN0ZW5lciIsIm9uRGF0YVJhbmdlIiwib25EYXRhUHJvZ3Jlc3MiLCJvbkRhdGFQcm9ncmVzc2l2ZVJlYWQiLCJvbkRhdGFQcm9ncmVzc2l2ZURvbmUiLCJQREZEb2N1bWVudFByb3h5IiwicGRmSW5mbyIsIl9wZGZJbmZvIiwibnVtUGFnZXMiLCJmaW5nZXJwcmludHMiLCJpc1B1cmVYZmEiLCJfaHRtbEZvclhmYSIsImFsbFhmYUh0bWwiLCJnZXRQYWdlIiwiZ2V0UGFnZUluZGV4IiwiZ2V0RGVzdGluYXRpb25zIiwiZ2V0RGVzdGluYXRpb24iLCJnZXRQYWdlTGFiZWxzIiwiZ2V0UGFnZUxheW91dCIsImdldFBhZ2VNb2RlIiwiZ2V0Vmlld2VyUHJlZmVyZW5jZXMiLCJnZXRPcGVuQWN0aW9uIiwiZ2V0QXR0YWNobWVudHMiLCJnZXRKU0FjdGlvbnMiLCJnZXREb2NKU0FjdGlvbnMiLCJnZXRPdXRsaW5lIiwiZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnIiwiZ2V0UmVuZGVyaW5nSW50ZW50IiwiZ2V0UGVybWlzc2lvbnMiLCJnZXRNZXRhZGF0YSIsImdldE1hcmtJbmZvIiwic2F2ZURvY3VtZW50IiwiZ2V0RG93bmxvYWRJbmZvIiwiZG93bmxvYWRJbmZvQ2FwYWJpbGl0eSIsImtlZXBMb2FkZWRGb250cyIsInN0YXJ0Q2xlYW51cCIsImxvYWRpbmdUYXNrIiwiY2FjaGVkUGFnZU51bWJlciIsImdldEZpZWxkT2JqZWN0cyIsImhhc0pTQWN0aW9ucyIsImdldENhbGN1bGF0aW9uT3JkZXJJZHMiLCJQREZQYWdlUHJveHkiLCJkZWxheWVkQ2xlYW51cFRpbWVvdXQiLCJwZW5kaW5nQ2xlYW51cCIsInBhZ2VJbmZvIiwiX3BhZ2VJbmRleCIsIl9wYWdlSW5mbyIsIl9zdGF0cyIsIl9wZGZCdWciLCJQREZPYmplY3RzIiwiX21heWJlQ2xlYW51cEFmdGVyUmVuZGVyIiwiX2ludGVudFN0YXRlcyIsImdldFZpZXdwb3J0IiwiZ2V0QW5ub3RhdGlvbnMiLCJnZXRQYWdlSlNBY3Rpb25zIiwiZ2V0WGZhIiwiY2FudmFzQ29udGV4dCIsImFubm90YXRpb25Nb2RlIiwib3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZSIsInByaW50QW5ub3RhdGlvblN0b3JhZ2UiLCJpbnRlbnRBcmdzIiwiYWJvcnREZWxheWVkQ2xlYW51cCIsImludGVudFN0YXRlIiwic3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCIsImludGVudFByaW50IiwiZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSIsImxhc3RDaHVuayIsInNlcGFyYXRlQW5ub3RzIiwiX3B1bXBPcGVyYXRvckxpc3QiLCJyZW5kZXJUYXNrcyIsImludGVybmFsUmVuZGVyVGFzayIsInRyeUNsZWFudXAiLCJfYWJvcnRPcGVyYXRvckxpc3QiLCJTdGF0cyIsIkludGVybmFsUmVuZGVyVGFzayIsInVzZVJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJlbmRlclRhc2siLCJpbml0aWFsaXplR3JhcGhpY3MiLCJvcGVyYXRvckxpc3RDaGFuZ2VkIiwiZ2V0T3BlcmF0b3JMaXN0Iiwib3BMaXN0UmVhZENhcGFiaWxpdHkiLCJvcExpc3RUYXNrIiwic3RyZWFtVGV4dENvbnRlbnQiLCJpbmNsdWRlTWFya2VkQ29udGVudCIsImRpc2FibGVOb3JtYWxpemF0aW9uIiwiVEVYVF9DT05URU5UX0NIVU5LX1NJWkUiLCJoaWdoV2F0ZXJNYXJrIiwiZ2V0VGV4dENvbnRlbnQiLCJnZXRTdHJ1Y3RUcmVlIiwiX2Rlc3Ryb3kiLCJ3YWl0T24iLCJmb3JjZSIsImNvbXBsZXRlZCIsInJlc2V0U3RhdHMiLCJkZWxheWVkIiwiX3N0YXJ0UmVuZGVyUGFnZSIsIl9yZW5kZXJQYWdlQ2h1bmsiLCJvcGVyYXRvckxpc3RDaHVuayIsImFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlIiwic3RyZWFtUmVhZGVyIiwiZGVsYXkiLCJjdXJDYWNoZUtleSIsImN1ckludGVudFN0YXRlIiwiTG9vcGJhY2tQb3J0IiwibGlzdGVuZXJzIiwiZGVmZXJyZWQiLCJybUFib3J0IiwiYWJvcnRlZCIsIm9uQWJvcnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidGVybWluYXRlIiwiZmFrZVdvcmtlcklkIiwiaXNXb3JrZXJEaXNhYmxlZCIsIndvcmtlclBvcnRzIiwiX2lzU2FtZU9yaWdpbiIsIm90aGVyVXJsIiwiYmFzZSIsIm90aGVyIiwiX2NyZWF0ZUNETldyYXBwZXIiLCJ3cmFwcGVyIiwiY3JlYXRlT2JqZWN0VVJMIiwiX3BvcnQiLCJfd2ViV29ya2VyIiwiX21lc3NhZ2VIYW5kbGVyIiwiX2luaXRpYWxpemVGcm9tUG9ydCIsIl9pbml0aWFsaXplIiwibWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyIiwiX3NldHVwRmFrZVdvcmtlciIsInRlcm1pbmF0ZUVhcmx5Iiwic2VuZFRlc3QiLCJ0ZXN0T2JqIiwiX3NldHVwRmFrZVdvcmtlckdsb2JhbCIsIldvcmtlck1lc3NhZ2VIYW5kbGVyIiwid29ya2VySGFuZGxlciIsInNldHVwIiwiY2FjaGVkUG9ydCIsInBkZmpzV29ya2VyIiwibG9hZGVyIiwibWV0aG9kUHJvbWlzZXMiLCJwYWdlQ2FjaGUiLCJwYWdlUHJvbWlzZXMiLCJwYWdlUmVmQ2FjaGUiLCJwYXNzd29yZENhcGFiaWxpdHkiLCJmYWN0b3J5IiwiZm9udExvYWRlciIsIl9wYXJhbXMiLCJkZXN0cm95Q2FwYWJpbGl0eSIsIl9uZXR3b3JrU3RyZWFtIiwiX2Z1bGxSZWFkZXIiLCJfbGFzdFByb2dyZXNzIiwic2V0dXBNZXNzYWdlSGFuZGxlciIsImNhY2hlU2ltcGxlTWV0aG9kIiwiY2FjaGVkUHJvbWlzZSIsImlzT3BMaXN0IiwibW9kaWZpZWRJZHNIYXNoIiwiY2FjaGVLZXlCdWYiLCJwYWdlIiwidGVybWluYXRlZCIsInNpbmsiLCJyZWFkeVJlYXNvbiIsIl9udW1QYWdlcyIsImh0bWxGb3JYZmEiLCJ1cGRhdGVQYXNzd29yZCIsImVyciIsImV4cG9ydGVkRGF0YSIsImV4cG9ydGVkRXJyb3IiLCJmb250QWRkZWQiLCJpbWFnZVJlZiIsInBhZ2VQcm94eSIsImRhdGFMZW4iLCJyZWZTdHIiLCJyZXN1bHRzIiwibWV0YWRhdGEiLCJjbGVhbnVwU3VjY2Vzc2Z1bCIsIklOSVRJQUxfREFUQSIsImVuc3VyZU9iaiIsIml0ZXJhdG9yIiwiUmVuZGVyVGFzayIsIm9uQ29udGludWUiLCJmb3JtIiwickFGIiwiY2FudmFzSW5Vc2UiLCJXZWFrU2V0Iiwib3BlcmF0b3JMaXN0SWR4IiwicnVubmluZyIsImdyYXBoaWNzUmVhZHlDYWxsYmFjayIsImdyYXBoaWNzUmVhZHkiLCJfdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsbGVkIiwiX2NhbmNlbEJvdW5kIiwiX2NvbnRpbnVlQm91bmQiLCJfY29udGludWUiLCJfc2NoZWR1bGVOZXh0Qm91bmQiLCJfc2NoZWR1bGVOZXh0IiwiX25leHRCb3VuZCIsIl9uZXh0IiwiX2NhbnZhcyIsIlN0ZXBwZXJNYW5hZ2VyIiwiaW5pdCIsImdldE5leHRCcmVha1BvaW50IiwiZ2Z4IiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJ1cGRhdGVPcGVyYXRvckxpc3QiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtYWtlQ29sb3JDb21wIiwic2NhbGVBbmRDbGFtcCIsIkNvbG9yQ29udmVydGVycyIsIkNNWUtfRyIsIkdfQ01ZSyIsIkdfUkdCIiwiR19yZ2IiLCJHX0hUTUwiLCJHIiwiUkdCX0ciLCJSR0JfcmdiIiwiUkdCX0hUTUwiLCJUX0hUTUwiLCJUX3JnYiIsIkNNWUtfUkdCIiwiQ01ZS19yZ2IiLCJDTVlLX0hUTUwiLCJjb21wb25lbnRzIiwiUkdCX0NNWUsiLCJCYXNlU1ZHRmFjdG9yeSIsInNraXBEaW1lbnNpb25zIiwiX2NyZWF0ZVNWRyIsInNldHVwU3RvcmFnZSIsImh0bWwiLCJzdG9yZWREYXRhIiwieGZhT24iLCJ4ZmFPZmYiLCJjaGVja2VkIiwib3B0aW9uIiwic2VsZWN0ZWQiLCJzZWxlY3RlZEluZGV4Iiwic2V0QXR0cmlidXRlcyIsImxpbmtTZXJ2aWNlIiwiaXNIVE1MQW5jaG9yRWxlbWVudCIsIkhUTUxBbmNob3JFbGVtZW50IiwiYWRkTGlua0F0dHJpYnV0ZXMiLCJuZXdXaW5kb3ciLCJkYXRhSWQiLCJyb290IiwieGZhSHRtbCIsInJvb3RIdG1sIiwiaXNOb3RGb3JSaWNoVGV4dCIsInJvb3REaXYiLCJjcmVhdGVUZXh0Tm9kZSIsInN0YWNrIiwiY2hpbGRIdG1sIiwieG1sbnMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaGlkZGVuIiwiREVGQVVMVF9UQUJfSU5ERVgiLCJhbm5vdGF0aW9uX2xheWVyX0RFRkFVTFRfRk9OVF9TSVpFIiwiR2V0RWxlbWVudHNCeU5hbWVTZXQiLCJnZXRSZWN0RGltcyIsIkFubm90YXRpb25FbGVtZW50RmFjdG9yeSIsImFubm90YXRpb25UeXBlIiwiTGlua0Fubm90YXRpb25FbGVtZW50IiwiVGV4dEFubm90YXRpb25FbGVtZW50IiwiZmllbGRUeXBlIiwiVGV4dFdpZGdldEFubm90YXRpb25FbGVtZW50IiwicmFkaW9CdXR0b24iLCJSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50IiwiY2hlY2tCb3giLCJDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50IiwiUHVzaEJ1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50IiwiQ2hvaWNlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJTaWduYXR1cmVXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsIldpZGdldEFubm90YXRpb25FbGVtZW50IiwiUG9wdXBBbm5vdGF0aW9uRWxlbWVudCIsIkZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQiLCJMaW5lQW5ub3RhdGlvbkVsZW1lbnQiLCJTcXVhcmVBbm5vdGF0aW9uRWxlbWVudCIsIkNpcmNsZUFubm90YXRpb25FbGVtZW50IiwiUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudCIsIkNhcmV0QW5ub3RhdGlvbkVsZW1lbnQiLCJJbmtBbm5vdGF0aW9uRWxlbWVudCIsIlBvbHlnb25Bbm5vdGF0aW9uRWxlbWVudCIsIkhpZ2hsaWdodEFubm90YXRpb25FbGVtZW50IiwiVW5kZXJsaW5lQW5ub3RhdGlvbkVsZW1lbnQiLCJTcXVpZ2dseUFubm90YXRpb25FbGVtZW50IiwiU3RyaWtlT3V0QW5ub3RhdGlvbkVsZW1lbnQiLCJTdGFtcEFubm90YXRpb25FbGVtZW50IiwiRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uRWxlbWVudCIsIkFubm90YXRpb25FbGVtZW50IiwidXBkYXRlcyIsImhhc0JvcmRlciIsInBvcHVwRWxlbWVudCIsImlzUmVuZGVyYWJsZSIsImlnbm9yZUJvcmRlciIsImNyZWF0ZVF1YWRyaWxhdGVyYWxzIiwiZG93bmxvYWRNYW5hZ2VyIiwiaW1hZ2VSZXNvdXJjZXNQYXRoIiwicmVuZGVyRm9ybXMiLCJzdmdGYWN0b3J5IiwiZW5hYmxlU2NyaXB0aW5nIiwiX2ZpZWxkT2JqZWN0cyIsImZpZWxkT2JqZWN0cyIsIl9jcmVhdGVDb250YWluZXIiLCJfY3JlYXRlUXVhZHJpbGF0ZXJhbHMiLCJfaGFzUG9wdXBEYXRhIiwidGl0bGVPYmoiLCJjb250ZW50c09iaiIsInJpY2hUZXh0IiwiX2lzRWRpdGFibGUiLCJpc0VkaXRhYmxlIiwiaGFzUG9wdXBEYXRhIiwidXBkYXRlRWRpdGVkIiwic2V0UmVjdEVkaXRlZCIsInBvcHVwIiwicmVzZXRFZGl0ZWQiLCJjdXJyZW50UmVjdCIsInNldFJvdGF0aW9uIiwiYWx0ZXJuYXRpdmVUZXh0IiwidGl0bGUiLCJub1JvdGF0ZSIsImJvcmRlclN0eWxlIiwiYm9yZGVyV2lkdGgiLCJob3Jpem9udGFsUmFkaXVzIiwiaG9yaXpvbnRhbENvcm5lclJhZGl1cyIsInZlcnRpY2FsUmFkaXVzIiwidmVydGljYWxDb3JuZXJSYWRpdXMiLCJyYWRpdXMiLCJib3JkZXJSYWRpdXMiLCJib3JkZXJCb3R0b21TdHlsZSIsImJvcmRlckNvbG9yIiwiZWxlbWVudFdpZHRoIiwiZWxlbWVudEhlaWdodCIsIl9jb21tb25BY3Rpb25zIiwic2V0Q29sb3IiLCJqc05hbWUiLCJzdHlsZU5hbWUiLCJkZXRhaWwiLCJjb2xvclR5cGUiLCJjb2xvckFycmF5IiwiZGlzcGxheSIsIm5vVmlldyIsIm5vUHJpbnQiLCJ1c2VyTmFtZSIsInJlYWRvbmx5IiwicmVxdWlyZWQiLCJfc2V0UmVxdWlyZWQiLCJ0ZXh0Q29sb3IiLCJfZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94IiwiYWN0aW9ucyIsImpzRXZlbnQiLCJjb21tb25BY3Rpb25zIiwiX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTIiwiZXZlbnRQcm94eSIsInF1YWRQb2ludHMiLCJyZWN0QmxYIiwicmVjdEJsWSIsInJlY3RUclgiLCJyZWN0VHJZIiwidHJYIiwidHJZIiwiYmxYIiwiYmxZIiwic3ZnQnVmZmVyIiwiY2xpcFBhdGgiLCJyZWN0V2lkdGgiLCJyZWN0SGVpZ2h0IiwiYmFja2dyb3VuZEltYWdlIiwiX2NyZWF0ZVBvcHVwIiwibW9kaWZpY2F0aW9uRGF0ZSIsInBhcmVudFJlY3QiLCJlbGVtZW50cyIsIl9nZXRFbGVtZW50c0J5TmFtZSIsInNraXBJZCIsImZpZWxkcyIsImZpZWxkT2JqIiwiZXhwb3J0VmFsdWVzIiwiZXhwb3J0VmFsdWUiLCJkb21FbGVtZW50IiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJtYXliZVNob3ciLCJmb3JjZUhpZGUiLCJnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwIiwiYWRkSGlnaGxpZ2h0QXJlYSIsInRyaWdnZXJzIiwiX2VkaXRPbkRvdWJsZUNsaWNrIiwiYW5ub3RhdGlvbkVkaXRvclR5cGUiLCJpc1Rvb2x0aXBPbmx5IiwibGluayIsImlzQm91bmQiLCJfYmluZE5hbWVkQWN0aW9uIiwiYXR0YWNobWVudCIsImJpbmRBdHRhY2htZW50IiwiYXR0YWNobWVudERlc3QiLCJiaW5kU2V0T0NHU3RhdGUiLCJfYmluZExpbmsiLCJBY3Rpb24iLCJfYmluZEpTQWN0aW9uIiwicmVzZXRGb3JtIiwiX2JpbmRSZXNldEZvcm1BY3Rpb24iLCJzZXRJbnRlcm5hbExpbmsiLCJkZXN0aW5hdGlvbiIsImdldERlc3RpbmF0aW9uSGFzaCIsIm9uY2xpY2siLCJnb1RvRGVzdGluYXRpb24iLCJnZXRBbmNob3JVcmwiLCJleGVjdXRlTmFtZWRBY3Rpb24iLCJkZXNjcmlwdGlvbiIsIm9wZW5PckRvd25sb2FkRGF0YSIsImV4ZWN1dGVTZXRPQ0dTdGF0ZSIsIm90aGVyQ2xpY2tBY3Rpb24iLCJyZXNldEZvcm1GaWVsZHMiLCJyZWZzIiwicmVzZXRGb3JtUmVmcyIsImluY2x1ZGUiLCJhbGxGaWVsZHMiLCJmaWVsZElkcyIsImZpZWxkTmFtZSIsImZpZWxkIiwiYWxsSWRzIiwiZGlzcGF0Y2hFdmVudCIsIkV2ZW50Iiwic2hvd0VsZW1lbnRBbmRIaWRlQ2FudmFzIiwicHJldmlvdXNTaWJsaW5nIiwiX2dldEtleU1vZGlmaWVyIiwiX3NldEV2ZW50TGlzdGVuZXIiLCJlbGVtZW50RGF0YSIsImJhc2VOYW1lIiwiZXZlbnROYW1lIiwidmFsdWVHZXR0ZXIiLCJtb2RpZmllciIsImZvY3VzZWQiLCJfc2V0RXZlbnRMaXN0ZW5lcnMiLCJnZXR0ZXIiLCJCbHVyIiwiRm9jdXMiLCJfc2V0QmFja2dyb3VuZENvbG9yIiwiX3NldFRleHRTdHlsZSIsIlRFWFRfQUxJR05NRU5UIiwiZm9udENvbG9yIiwiZGVmYXVsdEFwcGVhcmFuY2VEYXRhIiwiY29tcHV0ZWRGb250U2l6ZSIsInJvdW5kVG9PbmVEZWNpbWFsIiwibXVsdGlMaW5lIiwibnVtYmVyT2ZMaW5lcyIsInRleHRBbGlnbm1lbnQiLCJ0ZXh0QWxpZ24iLCJpc1JlcXVpcmVkIiwiaGFzQXBwZWFyYW5jZSIsImZpZWxkVmFsdWUiLCJzZXRQcm9wZXJ0eU9uU2libGluZ3MiLCJrZXlJblN0b3JhZ2UiLCJtYXhMZW4iLCJjaGFyTGltaXQiLCJmaWVsZEZvcm1hdHRlZFZhbHVlcyIsImZvcm1hdHRlZFZhbHVlIiwiY29tYiIsInVzZXJWYWx1ZSIsImxhc3RDb21taXR0ZWRWYWx1ZSIsImNvbW1pdEtleSIsImRvTm90U2Nyb2xsIiwib3ZlcmZsb3dZIiwib3ZlcmZsb3dYIiwicmVhZE9ubHkiLCJtYXhMZW5ndGgiLCJkZWZhdWx0RmllbGRWYWx1ZSIsImJsdXJMaXN0ZW5lciIsInNjcm9sbExlZnQiLCJzZWxSYW5nZSIsInNldFNlbGVjdGlvblJhbmdlIiwid2lsbENvbW1pdCIsInNlbFN0YXJ0Iiwic2VsZWN0aW9uU3RhcnQiLCJzZWxFbmQiLCJzZWxlY3Rpb25FbmQiLCJfYmx1ckxpc3RlbmVyIiwiS2V5c3Ryb2tlIiwiaW5wdXRUeXBlIiwiY2hhbmdlIiwiZmllbGRXaWR0aCIsImNvbWJXaWR0aCIsImxldHRlclNwYWNpbmciLCJ2ZXJ0aWNhbEFsaWduIiwiY2hlY2tib3giLCJjdXJDaGVja2VkIiwiYnV0dG9uVmFsdWUiLCJyYWRpbyIsInBkZkJ1dHRvblZhbHVlIiwibGlua0VsZW1lbnQiLCJzZWxlY3RFbGVtZW50IiwiYWRkQW5FbXB0eUVudHJ5IiwiY29tYm8iLCJtdWx0aVNlbGVjdCIsIm11bHRpcGxlIiwib3B0aW9uRWxlbWVudCIsImRpc3BsYXlWYWx1ZSIsInJlbW92ZUVtcHR5RW50cnkiLCJub25lT3B0aW9uRWxlbWVudCIsImlzRXhwb3J0Iiwic2VsZWN0ZWRWYWx1ZXMiLCJnZXRJdGVtcyIsIm11bHRpcGxlU2VsZWN0aW9uIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJzZWxlY3RDaGlsZCIsImluZGljZXMiLCJlZGl0YWJsZSIsImNoYW5nZUV4Iiwia2V5RG93biIsIlBvcHVwRWxlbWVudCIsImVsZW1lbnRJZHMiLCJhcmlhSGFzUG9wdXAiLCJib3VuZEtleURvd24iLCJib3VuZEhpZGUiLCJib3VuZFNob3ciLCJib3VuZFRvZ2dsZSIsImRhdGVPYmoiLCJwaW5uZWQiLCJ3YXNWaXNpYmxlIiwidHJpZ2dlciIsImZsYXRNYXAiLCJiYXNlQ29sb3IiLCJvdXRsaW5lQ29sb3IiLCJCQUNLR1JPVU5EX0VOTElHSFQiLCJoZWFkZXIiLCJ2YWx1ZU9mIiwiY29udGVudHMiLCJfZm9ybWF0Q29udGVudHMiLCJtYWtlUG9wdXBDb250ZW50IiwicG9wdXBMaW5lcyIsInBvcHVwQ29udGVudCIsImxpbmVBdHRyaWJ1dGVzIiwibGluZSIsImxpbmVzIiwic2V0UG9zaXRpb24iLCJ1c2VQYXJlbnRSZWN0Iiwibm9ybWFsaXplZFJlY3QiLCJIT1JJWk9OVEFMX1NQQUNFX0FGVEVSX0FOTk9UQVRJT04iLCJwb3B1cExlZnQiLCJwb3B1cFRvcCIsInRleHRQb3NpdGlvbiIsImxpbmVTcGFuIiwibGluZUNvb3JkaW5hdGVzIiwic3F1YXJlIiwiY2lyY2xlIiwicG9seWxpbmUiLCJjb250YWluZXJDbGFzc05hbWUiLCJzdmdFbGVtZW50TmFtZSIsInZlcnRpY2VzIiwicG9seWxpbmVzR3JvdXBFbGVtZW50IiwicG9seWxpbmVzIiwiaXQiLCJpbmtMaXN0cyIsInRoaWNrbmVzcyIsImRvd25sb2FkIiwiYWNjZXNzaWJpbGl0eU1hbmFnZXIiLCJlZGl0YWJsZUFubm90YXRpb25zIiwic3RydWN0VHJlZUxheWVyIiwiYW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciIsIl9hbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyIiwiaGFzRWRpdGFibGVBbm5vdGF0aW9ucyIsImFwcGVuZEVsZW1lbnQiLCJjb250ZW50RWxlbWVudCIsImFubm90YXRpb25JZCIsImFyaWFBdHRyaWJ1dGVzIiwiZ2V0QXJpYUF0dHJpYnV0ZXMiLCJtb3ZlRWxlbWVudEluRE9NIiwiYW5ub3RhdGlvbnMiLCJwb3B1cFRvRWxlbWVudHMiLCJlbGVtZW50UGFyYW1zIiwibm9IVE1MIiwiaXNQb3B1cEFubm90YXRpb24iLCJyZW5kZXJlZCIsInNldEFubm90YXRpb25DYW52YXNNYXAiLCJyZXBsYWNlV2l0aCIsImFmdGVyIiwiZ2V0RWRpdGFibGVBbm5vdGF0aW9ucyIsImdldEVkaXRhYmxlQW5ub3RhdGlvbiIsIkVPTF9QQVRURVJOIiwiRnJlZVRleHRFZGl0b3IiLCJlZGl0b3JEaXZJZCIsImVkaXRNb2RlQUMiLCJfZnJlZVRleHREZWZhdWx0Q29udGVudCIsIl9pbnRlcm5hbFBhZGRpbmciLCJfZGVmYXVsdENvbG9yIiwiX2RlZmF1bHRGb250U2l6ZSIsIl90cmFuc2xhdGVFbXB0eSIsIl9lZGl0b3JUeXBlIiwidXBkYXRlRm9udFNpemUiLCJzZXRGb250c2l6ZSIsImVkaXRvckRpdiIsInNldEVkaXRvckRpbWVuc2lvbnMiLCJzYXZlZEZvbnRzaXplIiwiY29sIiwic2F2ZWRDb2xvciIsIm92ZXJsYXlEaXYiLCJjb250ZW50RWRpdGFibGUiLCJlZGl0b3JEaXZLZXlkb3duIiwiZWRpdG9yRGl2Rm9jdXMiLCJlZGl0b3JEaXZCbHVyIiwiZWRpdG9yRGl2SW5wdXQiLCJlZGl0b3JEaXZQYXN0ZSIsImlubmVyVGV4dCIsImV4dHJhY3RUZXh0IiwicHJldkNoaWxkIiwiY2hpbGROb2RlcyIsImdldE5vZGVDb250ZW50Iiwic2F2ZWREaXNwbGF5Iiwic2F2ZWRWaXNpYmlsaXR5Iiwic2F2ZWRUZXh0IiwibmV3VGV4dCIsInRyaW1FbmQiLCJzZXRUZXh0Iiwic2V0Q29udGVudCIsImRibGNsaWNrIiwiYmFzZVgiLCJiYXNlWSIsInBvc1giLCJwb3NZIiwibm9kZVZhbHVlIiwiZGVzZXJpYWxpemVDb250ZW50IiwiZGVsZXRlRnJvbURvY3VtZW50IiwiaW5zZXJ0Tm9kZSIsImNvbGxhcHNlVG9TdGFydCIsInN0YXJ0Q29udGFpbmVyIiwic3RhcnRPZmZzZXQiLCJidWZmZXJCZWZvcmUiLCJidWZmZXJBZnRlciIsIm5ld1JhbmdlIiwiUmFuZ2UiLCJiZWZvcmVMZW5ndGgiLCJyZWR1Y2UiLCJhY2MiLCJzZXRTdGFydCIsInNldEVuZCIsInJlbW92ZUFsbFJhbmdlcyIsImFkZFJhbmdlIiwicmVwbGFjZUNoaWxkcmVuIiwic2VyaWFsaXplQ29udGVudCIsInBhZGRpbmciLCJzdHJ1Y3RUcmVlUGFyZW50SWQiLCJoYXNFbGVtZW50Q2hhbmdlZCIsIk91dGxpbmUiLCJQUkVDSVNJT04iLCJ0b1NWR1BhdGgiLCJfcm90YXRpb24iLCJfcmVzY2FsZSIsIkZsb2F0MzJBcnJheSIsIl9yZXNjYWxlQW5kU3dhcCIsIl90cmFuc2xhdGUiLCJzdmdSb3VuZCIsIl9ub3JtYWxpemVQb2ludCIsIl9ub3JtYWxpemVQYWdlUG9pbnQiLCJjcmVhdGVCZXppZXJQb2ludHMiLCJGcmVlRHJhd091dGxpbmVyIiwiaW5uZXJNYXJnaW4iLCJsYXN0IiwibWluX2Rpc3QiLCJzY2FsZUZhY3RvciIsIk1JTl9ESVNUIiwiTUlOX0RJRkYiLCJNSU4iLCJnZXRMYXN0Q29vcmRzIiwibGFzdFRvcCIsImxhc3RCb3R0b20iLCJkaWZmWCIsImRpZmZZIiwiZGlmZkQiLCJuWCIsIm5ZIiwidGhYIiwidGhZIiwidG9TVkdQYXRoVHdvUG9pbnRzIiwidG9TVkdQYXRoRW5kIiwidG9TVkdQYXRoU3RhcnQiLCJsYXN0VG9wWCIsImxhc3RUb3BZIiwibGFzdEJvdHRvbVgiLCJsYXN0Qm90dG9tWSIsIm5ld0ZyZWVEcmF3T3V0bGluZSIsIm91dGxpbmUiLCJGcmVlRHJhd091dGxpbmUiLCJnZXRPdXRsaW5lcyIsImdldE91dGxpbmVUd29Qb2ludHMiLCJOIiwiZ2V0T3V0bGluZUVuZCIsImdldE91dGxpbmVTdGFydCIsImxhc3RQb2ludCIsImNvbXB1dGVNaW5NYXgiLCJsYXN0UG9pbnRYIiwibGFzdFBvaW50WSIsImx0ckNhbGxiYWNrIiwibmV3T3V0bGluZXIiLCJnZXROZXdPdXRsaW5lIiwib3V0bGluZXIiLCJIaWdobGlnaHRPdXRsaW5lciIsInZlcnRpY2FsRWRnZXMiLCJpbnRlcnZhbHMiLCJOVU1CRVJfT0ZfRElHSVRTIiwiRVBTSUxPTiIsInNoaWZ0ZWRNaW5YIiwic2hpZnRlZE1pblkiLCJsYXN0RWRnZSIsImVkZ2UiLCJzb3J0Iiwib3V0bGluZVZlcnRpY2FsRWRnZXMiLCJicmVha0VkZ2UiLCJlZGdlcyIsImFsbEVkZ2VzIiwiZWRnZTEiLCJlZGdlMiIsIm91dGxpbmVzIiwiSGlnaGxpZ2h0T3V0bGluZSIsImJpbmFyeVNlYXJjaCIsIm1pZGRsZSIsInk0IiwicG9seWdvbiIsInByZXZYIiwicHJldlkiLCJjbGFzc05hbWVzRm9yT3V0bGluaW5nIiwiRnJlZUhpZ2hsaWdodE91dGxpbmVyIiwiRnJlZUhpZ2hsaWdodE91dGxpbmUiLCJidXR0b25Td2F0Y2giLCJkZWZhdWx0Q29sb3IiLCJkcm9wZG93biIsImRyb3Bkb3duV2FzRnJvbUtleWJvYXJkIiwiaXNNYWluQ29sb3JQaWNrZXIiLCJvcGVuRHJvcGRvd25BQyIsImwxMG5Db2xvciIsIl9oaWRlRHJvcGRvd25Gcm9tS2V5Ym9hcmQiLCJfY29sb3JTZWxlY3RGcm9tS2V5Ym9hcmQiLCJfbW92ZVRvTmV4dCIsIl9tb3ZlVG9QcmV2aW91cyIsIl9tb3ZlVG9CZWdpbm5pbmciLCJfbW92ZVRvRW5kIiwiYmx1ZSIsImdyZWVuIiwicGluayIsInJlZCIsInllbGxvdyIsIm9wZW5Ecm9wZG93biIsInN3YXRjaCIsInJlbmRlck1haW5Ecm9wZG93biIsImdldERyb3Bkb3duUm9vdCIsInJvbGUiLCJjb2xvclNlbGVjdCIsImlzRHJvcGRvd25WaXNpYmxlIiwibmV4dFNpYmxpbmciLCJIaWdobGlnaHRFZGl0b3IiLCJjbGlwUGF0aElkIiwiZm9jdXNPdXRsaW5lcyIsImhpZ2hsaWdodERpdiIsImhpZ2hsaWdodE91dGxpbmVzIiwiaXNGcmVlSGlnaGxpZ2h0Iiwib3V0bGluZUlkIiwiX2RlZmF1bHRPcGFjaXR5IiwiX2RlZmF1bHRUaGlja25lc3MiLCJfZnJlZUhpZ2hsaWdodElkIiwiX2ZyZWVIaWdobGlnaHQiLCJfZnJlZUhpZ2hsaWdodENsaXBJZCIsIl9tb3ZlQ2FyZXQiLCJoaWdobGlnaHRJZCIsImNyZWF0ZUZyZWVPdXRsaW5lcyIsImFkZFRvRHJhd0xheWVyIiwiY3JlYXRlT3V0bGluZXMiLCJudW1iZXJPZkNvbG9ycyIsIm91dGxpbmVyRm9yT3V0bGluZSIsImV4dHJhVGhpY2tuZXNzIiwiZHJhd0xheWVyIiwiZmluYWxpemVEcmF3Iiwicm9vdENsYXNzIiwiaGlnaGxpZ2h0T3V0bGluZSIsImZyZWUiLCJ1cGRhdGVQcm9wZXJ0aWVzIiwicm90YXRlQmJveCIsInVwZGF0ZVRoaWNrbmVzcyIsInNldENvbG9yQW5kT3BhY2l0eSIsIm9wYSIsInNhdmVkT3BhY2l0eSIsInNhdmVkVGhpY2tuZXNzIiwic2V0VGhpY2tuZXNzIiwidGgiLCJjaGFuZ2VUaGlja25lc3MiLCJnZXRSb3RhdGlvbiIsImFkZFVuZG9hYmxlRWRpdG9yIiwiY2xlYW5EcmF3TGF5ZXIiLCJtdXN0QmVTZWxlY3RlZCIsImRyYXciLCJwb2ludGVyb3ZlciIsImhvdmVyZWQiLCJwb2ludGVybGVhdmUiLCJzZXRDYXJldCIsInNlcmlhbGl6ZUJveGVzIiwic2VyaWFsaXplT3V0bGluZXMiLCJzdGFydEhpZ2hsaWdodGluZyIsImVuZEhpZ2hsaWdodCIsImhpZ2hsaWdodE1vdmUiLCJyYXdXaWR0aCIsIkRyYXdpbmdPcHRpb25zIiwic3ZnUHJvcGVydGllcyIsInVwZGF0ZVByb3BlcnR5IiwidXBkYXRlU1ZHUHJvcGVydHkiLCJ0b1NWR1Byb3BlcnRpZXMiLCJ1cGRhdGVBbGwiLCJEcmF3aW5nRWRpdG9yIiwiZHJhd091dGxpbmVzIiwibXVzdEJlQ29tbWl0dGVkIiwiX2N1cnJlbnREcmF3SWQiLCJfY3VycmVudFBhcmVudCIsImN1cnJlbnREcmF3IiwiY3VycmVudERyYXdpbmdBQyIsImN1cnJlbnREcmF3aW5nT3B0aW9ucyIsImN1cnJlbnRQb2ludGVySWQiLCJjdXJyZW50UG9pbnRlclR5cGUiLCJjdXJyZW50UG9pbnRlcklkcyIsImN1cnJlbnRNb3ZlVGltZXN0YW1wIiwiX0lOTkVSX01BUkdJTiIsIl9kcmF3SWQiLCJjcmVhdGVEcmF3T3V0bGluZXMiLCJkcmF3SWQiLCJkcmF3aW5nT3B0aW9ucyIsIl9kcmF3aW5nT3B0aW9ucyIsImRlZmF1bHRQcm9wZXJ0aWVzIiwiY3JlYXRlRHJhd2luZyIsInVwZGF0ZUJib3giLCJfbWVyZ2VTVkdQcm9wZXJ0aWVzIiwiZGVmYXVsdFNWR1Byb3BlcnRpZXMiLCJwMUtleXMiLCJnZXREZWZhdWx0RHJhd2luZ09wdGlvbnMiLCJfb3B0aW9ucyIsInR5cGVzTWFwIiwic3VwcG9ydE11bHRpcGxlRHJhd2luZ3MiLCJwcm9wZXJ0eU5hbWUiLCJfZGVmYXVsdERyYXdpbmdPcHRpb25zIiwiX3VwZGF0ZVByb3BlcnR5Iiwic2F2ZWRWYWx1ZSIsInNldHRlciIsImdldFBhdGhSZXNpemluZ1NWR1Byb3BlcnRpZXMiLCJjb252ZXJ0VG9EcmF3U3BhY2UiLCJyb3RhdGVCb3giLCJnZXRQYXRoUmVzaXplZFNWR1Byb3BlcnRpZXMiLCJnZXRQYXRoVHJhbnNsYXRlZFNWR1Byb3BlcnRpZXMiLCJtb3ZpbmciLCJ1cGRhdGVQYXJlbnQiLCJjb252ZXJ0VG9QYXJlbnRTcGFjZSIsInBXIiwicEgiLCJ1cGRhdGVSb3RhdGlvbiIsInVwZGF0ZVBhcmVudERpbWVuc2lvbnMiLCJvblNjYWxlQ2hhbmdpbmdXaGVuRHJhd2luZyIsImRyYXdEaXYiLCJjcmVhdGVEcmF3ZXJJbnN0YW5jZSIsIl94IiwiX3kiLCJfcGFyZW50V2lkdGgiLCJfcGFyZW50SGVpZ2h0Iiwic3RhcnREcmF3aW5nIiwiX2lzTFRSIiwiX2VuZERyYXciLCJpc0NhbmNlbGxhYmxlIiwicmVtb3ZlTGFzdEVsZW1lbnQiLCJfZHJhd01vdmUiLCJ0aW1lU3RhbXAiLCJzdGFydE5ldyIsIl9jbGVhbnVwIiwibGFzdEVsZW1lbnQiLCJnZXRMYXN0RWxlbWVudCIsInNldExhc3RFbGVtZW50IiwiaXNBYm9ydGVkIiwiY3JlYXRlRHJhd2luZ09wdGlvbnMiLCJfZGF0YSIsImRlc2VyaWFsaXplRHJhdyIsIl9wYWdlWCIsIl9wYWdlWSIsIl9wYWdlV2lkdGgiLCJfcGFnZUhlaWdodCIsIl9pbm5lcldpZHRoIiwic2VyaWFsaXplRHJhdyIsIklua0RyYXdPdXRsaW5lciIsImxhc3RTVkdQYXRoIiwibGFzdEluZGV4IiwiRmxvYXQ2NEFycmF5IiwiSW5rRHJhd091dGxpbmUiLCJub3JtYWxpemVQb2ludCIsImZpcnN0WCIsImZpcnN0WSIsInNlY29uZFgiLCJzZWNvbmRZIiwiYzF4IiwiYzF5IiwiYzJ4IiwiYzJ5IiwiY3VycmVudFJvdGF0aW9uIiwiY29tcHV0ZUJib3giLCJzZXJpYWxpemVkTGluZXMiLCJzZXJpYWxpemVkUG9pbnRzIiwiZ2V0QkJveFdpdGhOb01hcmdpbiIsInJlc2NhbGVGbiIsIm5ld0xpbmVzIiwiZ2V0TWFyZ2luQ29tcG9uZW50cyIsIm1hcmdpbiIsIm1hcmdpblgiLCJtYXJnaW5ZIiwib2xkTWFyZ2luWCIsIm9sZE1hcmdpblkiLCJuZXdNYXJnaW5YIiwibmV3TWFyZ2luWSIsImRpZmZNYXJnaW5YIiwiZGlmZk1hcmdpblkiLCJyb3RhdGlvblRyYW5zZm9ybSIsInMxeCIsInMxeSIsInMyeCIsInMyeSIsIm5ld1BhcmVudFdpZHRoIiwibmV3UGFyZW50SGVpZ2h0IiwiSW5rRHJhd2luZ09wdGlvbnMiLCJ2aWV3ZXJQYXJhbWV0ZXJzIiwiSW5rRWRpdG9yIiwiU3RhbXBFZGl0b3IiLCJiaXRtYXBJZCIsImJpdG1hcFByb21pc2UiLCJiaXRtYXBVcmwiLCJiaXRtYXBGaWxlIiwiYml0bWFwRmlsZU5hbWUiLCJyZXNpemVUaW1lb3V0SWQiLCJoYXNCZWVuQWRkZWRJblVuZG9TdGFjayIsInN1cHBvcnRlZFR5cGVzIiwic3VwcG9ydGVkVHlwZXNTdHIiLCJwYXN0ZUVkaXRvciIsImdldEFzRmlsZSIsImhhc0FsdFRleHRTdGF0cyIsImhhc05vQWx0VGV4dCIsImdldEJpdG1hcEZldGNoZWQiLCJmcm9tSWQiLCJnZXRCaXRtYXBEb25lIiwiYWx0X3RleHRfbW9kYWwiLCJhbHRfdGV4dF90eXBlIiwibWxHdWVzc0FsdFRleHQiLCJ1cGRhdGVBbHRUZXh0RGF0YSIsImlzRW5hYmxlZEZvciIsImNvcHlDYW52YXMiLCJndWVzcyIsImNoYW5uZWxzIiwiYWx0IiwiZ2V0Qml0bWFwIiwiYWNjZXB0IiwiZmlsZXMiLCJjbGljayIsImRyYXdCaXRtYXAiLCJNQVhfUkFUSU8iLCJtYXhEYXRhRGltZW5zaW9uIiwibWF4UHJldmlld0RpbWVuc2lvbiIsImJpdG1hcFdpZHRoIiwiYml0bWFwSGVpZ2h0Iiwib3V0cHV0U2NhbGUiLCJzY2FsZWRXaWR0aCIsInNjYWxlZEhlaWdodCIsInNjYWxlQml0bWFwIiwiYm94RGltIiwiYm94RGltV2lkdGgiLCJib3hEaW1IZWlnaHQiLCJwYXR0ZXJuQ3R4IiwiZGF0YVdpZHRoIiwiZGF0YUhlaWdodCIsIm9mZnNjcmVlbkN0eCIsInByZXZXaWR0aCIsInByZXZIZWlnaHQiLCJzZXJpYWxpemVCaXRtYXAiLCJ0b1VybCIsInRvRGF0YVVSTCIsInN0cnVjdFBhcmVudCIsIl9zdHJ1Y3RUcmVlIiwiY2hhbmdlcyIsImlzU2FtZSIsImlzU2FtZUFsdFRleHQiLCJzdGFtcHMiLCJhcmVhIiwicHJldkRhdGEiLCJpc1NhbWVQYWdlSW5kZXgiLCJhbGxvd0NsaWNrIiwiYW5ub3RhdGlvbkxheWVyIiwiY2xpY2tBQyIsImVkaXRvckZvY3VzVGltZW91dElkIiwiaGFkUG9pbnRlckRvd24iLCJpc0Rpc2FibGluZyIsImlzRW5hYmxpbmciLCJkcmF3aW5nQUMiLCJmb2N1c2VkRWxlbWVudCIsInRleHRTZWxlY3Rpb25BQyIsIl9pbml0aWFsaXplZCIsImlzSW52aXNpYmxlIiwiZGlzYWJsZVRleHRTZWxlY3Rpb24iLCJ0b2dnbGVBbm5vdGF0aW9uTGF5ZXJQb2ludGVyRXZlbnRzIiwiZW5hYmxlVGV4dFNlbGVjdGlvbiIsImFubm90YXRpb25FbGVtZW50SWRzIiwiZWRpdGFibGVzIiwiY2hhbmdlZEFubm90YXRpb25zIiwicmVzZXRBbm5vdGF0aW9ucyIsImN1cnJlbnRBY3RpdmUiLCJ0ZXh0TGF5ZXJQb2ludGVyRG93biIsImF0dGFjaCIsImRldGFjaCIsInJlbW92ZVBvaW50ZXJJblRleHRMYXllciIsImN1cnJlbnRFZGl0b3JUeXBlIiwiY3JlYXRlTmV3RWRpdG9yIiwiZ2V0Q2VudGVyUG9pbnQiLCJzdGFydERyYXdpbmdTZXNzaW9uIiwicGF1c2UiLCJvbGRSb3RhdGlvbiIsIm1hcHBpbmciLCJ0b1VwZGF0ZSIsIl9zdmdGYWN0b3J5Iiwic2V0Qm94IiwiY3JlYXRlU1ZHIiwiY3JlYXRlQ2xpcFBhdGgiLCJwYXRoSWQiLCJjbGlwUGF0aFVzZSIsImlzUGF0aFVwZGF0YWJsZSIsImhhc0NsaXAiLCJ1c2UiLCJtdXN0UmVtb3ZlU2VsZkludGVyc2VjdGlvbnMiLCJtYXNrSWQiLCJ1c2UxIiwidXNlMiIsImNsb25lTm9kZSIsImVsZW1lbnRPcklkIiwicGF0aEVsZW1lbnQiLCJwZGZqc1ZlcnNpb24iLCJwZGZqc0J1aWxkIiwicGRmanNUZXN0aW5nVXRpbHMiLCJfX3dlYnBhY2tfZXhwb3J0c19fQWJvcnRFeGNlcHRpb24iLCJfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbkVkaXRvckxheWVyIiwiX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlIiwiX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25FZGl0b3JUeXBlIiwiX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25FZGl0b3JVSU1hbmFnZXIiLCJfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbkxheWVyIiwiX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25Nb2RlIiwiX193ZWJwYWNrX2V4cG9ydHNfX0NvbG9yUGlja2VyIiwiX193ZWJwYWNrX2V4cG9ydHNfX0RPTVNWR0ZhY3RvcnkiLCJfX3dlYnBhY2tfZXhwb3J0c19fRHJhd0xheWVyIiwiX193ZWJwYWNrX2V4cG9ydHNfX0ZlYXR1cmVUZXN0IiwiX193ZWJwYWNrX2V4cG9ydHNfX0dsb2JhbFdvcmtlck9wdGlvbnMiLCJfX3dlYnBhY2tfZXhwb3J0c19fSW1hZ2VLaW5kIiwiX193ZWJwYWNrX2V4cG9ydHNfX0ludmFsaWRQREZFeGNlcHRpb24iLCJfX3dlYnBhY2tfZXhwb3J0c19fTWlzc2luZ1BERkV4Y2VwdGlvbiIsIl9fd2VicGFja19leHBvcnRzX19PUFMiLCJfX3dlYnBhY2tfZXhwb3J0c19fT3V0cHV0U2NhbGUiLCJfX3dlYnBhY2tfZXhwb3J0c19fUERGRGF0YVJhbmdlVHJhbnNwb3J0IiwiX193ZWJwYWNrX2V4cG9ydHNfX1BERkRhdGVTdHJpbmciLCJfX3dlYnBhY2tfZXhwb3J0c19fUERGV29ya2VyIiwiX193ZWJwYWNrX2V4cG9ydHNfX1Bhc3N3b3JkUmVzcG9uc2VzIiwiX193ZWJwYWNrX2V4cG9ydHNfX1Blcm1pc3Npb25GbGFnIiwiX193ZWJwYWNrX2V4cG9ydHNfX1BpeGVsc1BlckluY2giLCJfX3dlYnBhY2tfZXhwb3J0c19fUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uIiwiX193ZWJwYWNrX2V4cG9ydHNfX1RleHRMYXllciIsIl9fd2VicGFja19leHBvcnRzX19Ub3VjaE1hbmFnZXIiLCJfX3dlYnBhY2tfZXhwb3J0c19fVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uIiwiX193ZWJwYWNrX2V4cG9ydHNfX1V0aWwiLCJfX3dlYnBhY2tfZXhwb3J0c19fVmVyYm9zaXR5TGV2ZWwiLCJfX3dlYnBhY2tfZXhwb3J0c19fWGZhTGF5ZXIiLCJfX3dlYnBhY2tfZXhwb3J0c19fYnVpbGQiLCJfX3dlYnBhY2tfZXhwb3J0c19fY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCIsIl9fd2VicGFja19leHBvcnRzX19mZXRjaERhdGEiLCJfX3dlYnBhY2tfZXhwb3J0c19fZ2V0RG9jdW1lbnQiLCJfX3dlYnBhY2tfZXhwb3J0c19fZ2V0RmlsZW5hbWVGcm9tVXJsIiwiX193ZWJwYWNrX2V4cG9ydHNfX2dldFBkZkZpbGVuYW1lRnJvbVVybCIsIl9fd2VicGFja19leHBvcnRzX19nZXRYZmFQYWdlVmlld3BvcnQiLCJfX3dlYnBhY2tfZXhwb3J0c19faXNEYXRhU2NoZW1lIiwiX193ZWJwYWNrX2V4cG9ydHNfX2lzUGRmRmlsZSIsIl9fd2VicGFja19leHBvcnRzX19ub0NvbnRleHRNZW51IiwiX193ZWJwYWNrX2V4cG9ydHNfX25vcm1hbGl6ZVVuaWNvZGUiLCJfX3dlYnBhY2tfZXhwb3J0c19fc2V0TGF5ZXJEaW1lbnNpb25zIiwiX193ZWJwYWNrX2V4cG9ydHNfX3NoYWRvdyIsIl9fd2VicGFja19leHBvcnRzX19zdG9wRXZlbnQiLCJfX3dlYnBhY2tfZXhwb3J0c19fdmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pdfjs-dist/build/pdf.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/pdfjs-dist/package.json":
/*!**********************************************!*\
  !*** ./node_modules/pdfjs-dist/package.json ***!
  \**********************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"pdfjs-dist","version":"4.10.38","main":"build/pdf.mjs","types":"types/src/pdf.d.ts","description":"Generic build of Mozilla\'s PDF.js library.","keywords":["Mozilla","pdf","pdf.js"],"homepage":"https://mozilla.github.io/pdf.js/","bugs":"https://github.com/mozilla/pdf.js/issues","license":"Apache-2.0","optionalDependencies":{"@napi-rs/canvas":"^0.1.65"},"browser":{"canvas":false,"fs":false,"http":false,"https":false,"url":false},"repository":{"type":"git","url":"git+https://github.com/mozilla/pdf.js.git"},"engines":{"node":">=20"},"scripts":{}}');

/***/ })

};
;